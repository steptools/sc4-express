(*
 $Id$
 ISO TC184/SC4/WG3 N1224 - ISO/CD-TS 10303-1292 Ap239 product definition information - EXPRESS MIM Long form
*)
SCHEMA ap239_product_definition_information_mim_lf;

  CONSTANT
  dummy_gri   : geometric_representation_item := representation_item('') 
                   || geometric_representation_item();
  dummy_tri   : topological_representation_item := representation_item('') 
                   || topological_representation_item();
  schema_name : STRING := 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF';
  END_CONSTANT;

  TYPE action_items = SELECT
    (ascribable_state);
  END_TYPE; -- action_items

  TYPE action_method_items = SELECT
    (action_method_relationship,
     state_type_relationship,
     state_type);
  END_TYPE; -- action_method_items

  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     exact,
     behind);
  END_TYPE; -- ahead_or_behind

  TYPE aliasable_item = SELECT
    (interface_connector_as_planned,
     product_definition,
     product_definition_formation,
     product_as_realized,
     organizational_project,
     product_as_planned,
     requirement_assignment,
     organization,
     interface_connector_design,
     product_definition_formation_relationship,
     product_definition_relationship,
     product,
     document_file,
     requirement_source,
     approval_status,
     event_occurrence,
     interface_connector_as_realized,
     certification,
     security_classification);
  END_TYPE; -- aliasable_item

  TYPE amount_of_substance_measure = REAL;
  END_TYPE; -- amount_of_substance_measure

  TYPE ap239_dm_approval_item = SELECT
    (applied_document_reference,
     applied_document_usage_constraint_assignment);
  END_TYPE; -- ap239_dm_approval_item

  TYPE ap239_dm_attribute_classification_item = SELECT
    (descriptive_representation_item,
     document_relationship,
     document_type,
     document_usage_role,
     envelope,
     envelope_relationship,
     identification_role,
     information_right,
     information_usage_right,
     measure_representation_item,
     message_relationship,
     object_role,
     product_definition_relationship,
     representation,
     representation_item,
     structured_message,
     usage_association);
  END_TYPE; -- ap239_dm_attribute_classification_item

  TYPE ap239_dm_attribute_language_item = SELECT
    (multi_language_attribute_assignment,
     envelope,
     envelope_relationship,
     information_right,
     information_usage_right,
     message_relationship,
     structured_message);
  END_TYPE; -- ap239_dm_attribute_language_item

  TYPE ap239_dm_classification_item = SELECT
    (applied_document_reference,
     applied_document_usage_constraint_assignment,
     applied_external_identification_assignment,
     applied_usage_right,
     descriptive_representation_item,
     document_file,
     document_relationship,
     envelope,
     envelope_relationship,
     information_right,
     information_usage_right,
     measure_representation_item,
     message_relationship,
     product,
     product_definition,
     product_definition_formation,
     product_definition_relationship,
     representation,
     structured_message,
     usage_association);
  END_TYPE; -- ap239_dm_classification_item

  TYPE ap239_dm_contract_item = SELECT
    (product,
     structured_message);
  END_TYPE; -- ap239_dm_contract_item

  TYPE ap239_dm_date_and_time_item = SELECT
    (applied_document_reference,
     applied_document_usage_constraint_assignment,
     applied_usage_right,
     product);
  END_TYPE; -- ap239_dm_date_and_time_item

  TYPE ap239_dm_date_item = SELECT
    (applied_document_reference,
     applied_document_usage_constraint_assignment,
     applied_usage_right,
     product);
  END_TYPE; -- ap239_dm_date_item

  TYPE ap239_dm_document_reference_item = SELECT
    (applied_identification_assignment,
     certification,
     contract,
     information_right,
     information_usage_right,
     organization,
     person);
  END_TYPE; -- ap239_dm_document_reference_item

  TYPE ap239_dm_ir_usage_item = SELECT
    (applied_certification_assignment,
     certification,
     document_file,
     document_relationship,
     product,
     product_definition,
     product_definition_formation,
     product_definition_relationship,
     structured_message);
  END_TYPE; -- ap239_dm_ir_usage_item

  TYPE ap239_dm_multi_language_attribute_item = SELECT
    (envelope,
     envelope_relationship,
     information_right,
     information_usage_right,
     message_relationship,
     structured_message);
  END_TYPE; -- ap239_dm_multi_language_attribute_item

  TYPE ap239_dm_organization_item = SELECT
    (applied_document_reference,
     applied_document_usage_constraint_assignment);
  END_TYPE; -- ap239_dm_organization_item

  TYPE ap239_dm_person_and_organization_item = SELECT
    (applied_document_reference,
     applied_document_usage_constraint_assignment);
  END_TYPE; -- ap239_dm_person_and_organization_item

  TYPE ap239_dm_security_classification_item = SELECT
    (applied_document_reference,
     applied_document_usage_constraint_assignment);
  END_TYPE; -- ap239_dm_security_classification_item

  TYPE ap239_dm_state_of_item = SELECT
    (applied_external_identification_assignment,
     document_file,
     product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_dm_state_of_item

  TYPE ap239_dm_state_type_of_item = SELECT
    (applied_external_identification_assignment,
     document_file,
     product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_dm_state_type_of_item

  TYPE ap239_mri_aliasable_item = SELECT
    (approval_status,
     certification,
     event_occurrence,
     organization,
     organizational_project,
     security_classification);
  END_TYPE; -- ap239_mri_aliasable_item

  TYPE ap239_mri_approval_item = SELECT
    (applied_contract_assignment,
     applied_event_occurrence_assignment,
     applied_identification_assignment,
     applied_organizational_project_assignment,
     event_occurrence,
     organizational_project);
  END_TYPE; -- ap239_mri_approval_item

  TYPE ap239_mri_attribute_classification_item = SELECT
    (approval,
     approval_relationship,
     approval_role,
     approval_status,
     certification,
     certification_type,
     contract_type,
     date_role,
     date_time_role,
     event_occurrence_context_role,
     event_occurrence_relationship,
     group,
     identification_role,
     name_attribute,
     object_role,
     organization_relationship,
     organization_role,
     organizational_address,
     organizational_project_relationship,
     organizational_project_role,
     person_and_organization_address,
     person_and_organization_role,
     security_classification_level,
     state_type_relationship,
     state_observed_relationship,
     state_type,
     applied_state_type_assignment,
     state_observed,
     applied_state_assignment);
  END_TYPE; -- ap239_mri_attribute_classification_item

  TYPE ap239_mri_attribute_language_item = SELECT
    (multi_language_attribute_assignment,
     event_occurrence);
  END_TYPE; -- ap239_mri_attribute_language_item

  TYPE ap239_mri_certification_item = SELECT
    (organizational_project);
  END_TYPE; -- ap239_mri_certification_item

  TYPE ap239_mri_classification_item = SELECT
    (address,
     applied_approval_assignment,
     applied_certification_assignment,
     applied_contract_assignment,
     applied_date_and_time_assignment,
     applied_date_assignment,
     applied_event_occurrence_assignment,
     applied_identification_assignment,
     applied_organization_assignment,
     applied_organizational_project_assignment,
     applied_person_and_organization_assignment,
     applied_security_classification_assignment,
     approval,
     approval_person_organization,
     approval_relationship,
     approval_status,
     calendar_date,
     certification,
     contract,
     date_and_time,
     event_occurrence,
     event_occurrence_relationship,
     language,
     multi_language_attribute_assignment,
     organization,
     organization_relationship,
     organizational_address,
     organizational_project,
     organizational_project_relationship,
     person_and_organization,
     person_and_organization_address,
     security_classification);
  END_TYPE; -- ap239_mri_classification_item

  TYPE ap239_mri_date_and_time_item = SELECT
    (applied_certification_assignment,
     applied_contract_assignment,
     applied_identification_assignment,
     organizational_address,
     person_and_organization_address);
  END_TYPE; -- ap239_mri_date_and_time_item

  TYPE ap239_mri_date_item = SELECT
    (applied_certification_assignment,
     applied_contract_assignment,
     applied_identification_assignment,
     organizational_address,
     person_and_organization_address);
  END_TYPE; -- ap239_mri_date_item

  TYPE ap239_mri_event_occurrence_item = SELECT
    (certification,
     organizational_project);
  END_TYPE; -- ap239_mri_event_occurrence_item

  TYPE ap239_mri_identification_item = SELECT
    (approval_status,
     certification,
     event_occurrence,
     organization,
     organizational_project,
     security_classification);
  END_TYPE; -- ap239_mri_identification_item

  TYPE ap239_mri_multi_language_attribute_item = SELECT
    (event_occurrence);
  END_TYPE; -- ap239_mri_multi_language_attribute_item

  TYPE ap239_mri_organization_item = SELECT
    (applied_certification_assignment,
     applied_contract_assignment,
     applied_event_occurrence_assignment,
     applied_organizational_project_assignment,
     certification,
     event_occurrence,
     organizational_project);
  END_TYPE; -- ap239_mri_organization_item

  TYPE ap239_mri_person_and_organization_item = SELECT
    (applied_certification_assignment,
     applied_contract_assignment,
     applied_event_occurrence_assignment,
     applied_organizational_project_assignment,
     certification,
     event_occurrence,
     organizational_project);
  END_TYPE; -- ap239_mri_person_and_organization_item

  TYPE ap239_padi_aliasable_item = SELECT
    (interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     product,
     product_as_planned,
     product_as_realized,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_padi_aliasable_item

  TYPE ap239_padi_approval_item = SELECT
    (interface_connection,
     interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     interface_connector_design_to_planned,
     interface_connector_design_to_realized,
     interface_connector_planned_to_realized,
     product,
     product_as_planned,
     product_as_realized,
     product_concept,
     product_definition,
     product_definition_formation,
     product_design_to_individual,
     product_planned_to_realized);
  END_TYPE; -- ap239_padi_approval_item

  TYPE ap239_padi_attribute_classification_item = SELECT
    (application_context,
     application_context_element,
     product_category,
     product_concept,
     product_concept_context,
     product_definition,
     product_definition_context,
     product_definition_formation_relationship,
     product_definition_relationship);
  END_TYPE; -- ap239_padi_attribute_classification_item

  TYPE ap239_padi_attribute_language_item = SELECT
    (multi_language_attribute_assignment,
     connector_on,
     product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_padi_attribute_language_item

  TYPE ap239_padi_certification_item = SELECT
    (interface_connection,
     product,
     product_as_planned,
     product_as_realized,
     product_definition_formation,
     product_definition_formation_relationship);
  END_TYPE; -- ap239_padi_certification_item

  TYPE ap239_padi_classification_item = SELECT
    (interface_connection,
     interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     interface_connector_design_to_planned,
     interface_connector_design_to_realized,
     interface_connector_planned_to_realized,
     interface_definition_for,
     product,
     product_as_planned,
     product_as_realized,
     product_category,
     product_concept,
     product_definition,
     product_definition_context,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     product_design_to_individual,
     product_planned_to_realized,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- ap239_padi_classification_item

  TYPE ap239_padi_condition_action_method_items = SELECT
    (action_method_relationship,
     applied_approval_assignment,
     applied_certification_assignment,
     applied_classification_assignment,
     applied_contract_assignment,
     applied_date_and_time_assignment,
     applied_date_assignment,
     applied_document_reference,
     applied_document_usage_constraint_assignment,
     applied_identification_assignment,
     applied_organization_assignment,
     applied_person_and_organization_assignment,
     calendar_date,
     date_and_time,
     product,
     product_as_individual,
     product_definition,
     product_definition_formation,
     product_related_product_category,
     property_definition);
  END_TYPE; -- ap239_padi_condition_action_method_items

  TYPE ap239_padi_condition_evaluation_action_items = SELECT
    (applied_approval_assignment,
     applied_certification_assignment,
     applied_classification_assignment,
     applied_contract_assignment,
     applied_date_and_time_assignment,
     applied_date_assignment,
     applied_document_reference,
     applied_document_usage_constraint_assignment,
     applied_identification_assignment,
     applied_organization_assignment,
     applied_person_and_organization_assignment,
     calendar_date,
     date_and_time,
     product,
     product_as_individual,
     product_definition,
     product_definition_formation,
     product_related_product_category,
     property_definition);
  END_TYPE; -- ap239_padi_condition_evaluation_action_items

  TYPE ap239_padi_contract_item = SELECT
    (interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     organizational_project,
     product,
     product_as_planned,
     product_as_realized,
     product_definition_formation);
  END_TYPE; -- ap239_padi_contract_item

  TYPE ap239_padi_date_and_time_item = SELECT
    (applied_organizational_project_assignment,
     interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design_to_planned,
     interface_connector_design_to_realized,
     interface_connector_planned_to_realized,
     product,
     product_as_planned,
     product_as_realized,
     product_concept,
     product_definition,
     product_definition_formation,
     product_design_to_individual,
     product_planned_to_realized);
  END_TYPE; -- ap239_padi_date_and_time_item

  TYPE ap239_padi_date_item = SELECT
    (applied_organizational_project_assignment,
     interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design_to_planned,
     interface_connector_design_to_realized,
     interface_connector_planned_to_realized,
     product,
     product_as_planned,
     product_as_realized,
     product_concept,
     product_definition,
     product_definition_formation,
     product_design_to_individual,
     product_planned_to_realized);
  END_TYPE; -- ap239_padi_date_item

  TYPE ap239_padi_document_reference_item = SELECT
    (interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     interface_connector_design_to_planned,
     interface_connector_design_to_realized,
     interface_connector_planned_to_realized,
     organizational_project,
     product,
     product_as_planned,
     product_as_realized,
     product_concept,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_design_to_individual,
     product_planned_to_realized);
  END_TYPE; -- ap239_padi_document_reference_item

  TYPE ap239_padi_identification_item = SELECT
    (interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     product,
     product_as_planned,
     product_as_realized,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_padi_identification_item

  TYPE ap239_padi_ir_usage_item = SELECT
    (applied_security_classification_assignment,
     interface_connection,
     interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     product,
     product_as_planned,
     product_as_realized,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     requirement_assignment,
     security_classification);
  END_TYPE; -- ap239_padi_ir_usage_item

  TYPE ap239_padi_multi_language_attribute_item = SELECT
    (connector_on,
     product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_padi_multi_language_attribute_item

  TYPE ap239_padi_organization_item = SELECT
    (applied_identification_assignment,
     interface_connector_as_planned,
     interface_connector_as_realized,
     product,
     product_as_planned,
     product_as_realized,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_padi_organization_item

  TYPE ap239_padi_person_and_organization_item = SELECT
    (applied_identification_assignment,
     interface_connector_as_planned,
     interface_connector_as_realized,
     product,
     product_as_planned,
     product_as_realized,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_padi_person_and_organization_item

  TYPE ap239_padi_project_item = SELECT
    (product_concept);
  END_TYPE; -- ap239_padi_project_item

  TYPE ap239_padi_requirement_assigned_item = SELECT
    (organizational_project,
     product,
     product_as_planned,
     product_as_realized,
     product_definition_formation);
  END_TYPE; -- ap239_padi_requirement_assigned_item

  TYPE ap239_padi_requirement_source_item = SELECT
    (product_as_individual,
     product_definition_formation);
  END_TYPE; -- ap239_padi_requirement_source_item

  TYPE ap239_padi_security_classification_item = SELECT
    (interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     product_as_planned,
     product_as_realized,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_padi_security_classification_item

  TYPE ap239_padi_state_of_item = SELECT
    (certification,
     connector_on,
     contract,
     interface_connection,
     interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     organization,
     organizational_project,
     person_and_organization,
     product,
     product_as_planned,
     product_as_realized,
     product_definition,
     product_definition_formation,
     security_classification);
  END_TYPE; -- ap239_padi_state_of_item

  TYPE ap239_padi_state_type_of_item = SELECT
    (certification,
     connector_on,
     contract,
     interface_connection,
     interface_connector_as_planned,
     interface_connector_as_realized,
     interface_connector_design,
     organization,
     organizational_project,
     person_and_organization,
     product,
     product_as_planned,
     product_as_realized,
     product_category,
     product_definition,
     product_definition_formation,
     security_classification);
  END_TYPE; -- ap239_padi_state_type_of_item

  TYPE ap239_prdi_aliasable_item = SELECT
    (product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_prdi_aliasable_item

  TYPE ap239_prdi_approval_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     in_zone,
     product,
     product_definition,
     product_definition_formation,
     product_definition_group_assignment,
     product_in_slot,
     selected_item_assignment,
     slot_as_planned,
     slot_as_realized,
     slot_design,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_on_product,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_approval_item

  TYPE ap239_prdi_attribute_classification_item = SELECT
    (alternate_product_relationship,
     breakdown_context,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product_definition_group_assignment);
  END_TYPE; -- ap239_prdi_attribute_classification_item

  TYPE ap239_prdi_certification_item = SELECT
    (product);
  END_TYPE; -- ap239_prdi_certification_item

  TYPE ap239_prdi_classification_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage_substitute,
     breakdown_context,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition_formation,
     product_definition_group_assignment,
     selected_item,
     selected_item_assignment,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_classification_item

  TYPE ap239_prdi_contract_item = SELECT
    (product,
     product_definition_formation);
  END_TYPE; -- ap239_prdi_contract_item

  TYPE ap239_prdi_date_and_time_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition,
     product_definition_formation,
     product_definition_group_assignment,
     selected_item,
     selected_item_assignment,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_date_and_time_item

  TYPE ap239_prdi_date_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition,
     product_definition_formation,
     product_definition_group_assignment,
     selected_item,
     selected_item_assignment,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_date_item

  TYPE ap239_prdi_document_reference_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition_formation,
     product_definition_group_assignment,
     selected_item,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_document_reference_item

  TYPE ap239_prdi_effectivity_item = SELECT
    (alternate_product_relationship,
     applied_certification_assignment,
     applied_contract_assignment,
     applied_document_reference,
     applied_document_usage_constraint_assignment,
     applied_external_identification_assignment,
     applied_identification_assignment,
     applied_organizational_project_assignment,
     applied_security_classification_assignment,
     applied_usage_right,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     document_relationship,
     document_type,
     interface_connection,
     interface_connector_design_to_planned,
     interface_connector_design_to_realized,
     interface_connector_planned_to_realized,
     make_from_usage_option,
     organizational_address,
     person_and_organization_address,
     product,
     product_as_individual,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_group_assignment,
     product_definition_relationship,
     product_design_to_individual,
     product_in_slot,
     product_planned_to_realized,
     property_definition,
     requirement_assignment,
     requirement_source,
     selected_item_assignment,
     slot_as_planned,
     slot_as_realized,
     slot_design,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_on_product,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_effectivity_item

  TYPE ap239_prdi_identification_item = SELECT
    (product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- ap239_prdi_identification_item

  TYPE ap239_prdi_ir_usage_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition,
     product_definition_formation,
     product_definition_group_assignment,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_on_product);
  END_TYPE; -- ap239_prdi_ir_usage_item

  TYPE ap239_prdi_multi_language_attribute_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_as_individual,
     product_definition,
     product_definition_formation,
     product_definition_group_assignment,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_on_product,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_multi_language_attribute_item

  TYPE ap239_prdi_organization_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition_formation,
     product_definition_group_assignment,
     selected_item,
     selected_item_assignment);
  END_TYPE; -- ap239_prdi_organization_item

  TYPE ap239_prdi_person_and_organization_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition_formation,
     product_definition_group_assignment,
     selected_item,
     selected_item_assignment);
  END_TYPE; -- ap239_prdi_person_and_organization_item

  TYPE ap239_prdi_project_item = SELECT
    (product);
  END_TYPE; -- ap239_prdi_project_item

  TYPE ap239_prdi_requirement_assigned_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition_formation,
     product_definition_group_assignment,
     product_in_slot);
  END_TYPE; -- ap239_prdi_requirement_assigned_item

  TYPE ap239_prdi_security_classification_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition,
     product_definition_formation,
     product_definition_group_assignment,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_on_product,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_security_classification_item

  TYPE ap239_prdi_selected_item_context_items = SELECT
    (contract,
     organizational_project,
     product,
     product_concept);
  END_TYPE; -- ap239_prdi_selected_item_context_items

  TYPE ap239_prdi_selected_item_select = SELECT
    (product,
     product_definition_formation);
  END_TYPE; -- ap239_prdi_selected_item_select

  TYPE ap239_prdi_state_of_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition,
     product_definition_formation,
     product_definition_group_assignment,
     product_in_slot,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_on_product,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_state_of_item

  TYPE ap239_prdi_state_type_of_item = SELECT
    (alternate_product_relationship,
     assembly_component_usage,
     assembly_component_usage_substitute,
     breakdown_element_group_assignment,
     breakdown_element_usage,
     product,
     product_definition,
     product_definition_formation,
     product_definition_group_assignment,
     product_in_slot,
     slot_design_to_planned,
     slot_design_to_realized,
     slot_on_product,
     slot_planned_to_realized);
  END_TYPE; -- ap239_prdi_state_type_of_item

  TYPE ap239_props_approval_item = SELECT
    (general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship);
  END_TYPE; -- ap239_props_approval_item

  TYPE ap239_props_attribute_classification_item = SELECT
    (general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship,
     property_definition_representation,
     representation,
     representation_context,
     representation_item);
  END_TYPE; -- ap239_props_attribute_classification_item

  TYPE ap239_props_attribute_language_item = SELECT
    (multi_language_attribute_assignment,
     general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship,
     representation_item);
  END_TYPE; -- ap239_props_attribute_language_item

  TYPE ap239_props_classification_item = SELECT
    (general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship,
     property_definition_representation,
     representation,
     representation_context,
     representation_item);
  END_TYPE; -- ap239_props_classification_item

  TYPE ap239_props_date_and_time_item = SELECT
    (general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship,
     representation);
  END_TYPE; -- ap239_props_date_and_time_item

  TYPE ap239_props_date_item = SELECT
    (general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship,
     representation);
  END_TYPE; -- ap239_props_date_item

  TYPE ap239_props_identification_item = SELECT
    (general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship);
  END_TYPE; -- ap239_props_identification_item

  TYPE ap239_props_multi_language_attribute_item = SELECT
    (general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship,
     representation_item);
  END_TYPE; -- ap239_props_multi_language_attribute_item

  TYPE ap239_props_organization_item = SELECT
    (general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship,
     representation);
  END_TYPE; -- ap239_props_organization_item

  TYPE ap239_props_person_and_organization_item = SELECT
    (general_property,
     general_property_relationship,
     property_definition,
     property_definition_relationship,
     representation);
  END_TYPE; -- ap239_props_person_and_organization_item

  TYPE approval_item = SELECT
    (product_definition_formation,
     interface_connection,
     applied_action_method_assignment,
     alternate_product_relationship,
     interface_connector_as_planned,
     product_definition_group_assignment,
     breakdown_element_usage,
     general_property,
     applied_contract_assignment,
     product_design_to_individual,
     interface_connector_planned_to_realized,
     applied_identification_assignment,
     slot_design_to_realized,
     organizational_project,
     assembly_component_usage,
     interface_connector_design_to_planned,
     action,
     action_method,
     slot_planned_to_realized,
     applied_event_occurrence_assignment,
     product_definition,
     envelope,
     slot_design_to_planned,
     property_definition,
     applied_document_usage_constraint_assignment,
     slot_as_planned,
     applied_organizational_project_assignment,
     general_property_relationship,
     slot_as_realized,
     certification,
     breakdown_element_group_assignment,
     slot_design,
     interface_connector_design_to_realized,
     applied_document_reference,
     slot_on_product,
     applied_action_assignment,
     product_in_slot,
     event_occurrence,
     interface_connector_design,
     product_as_planned,
     product_as_realized,
     interface_connector_as_realized,
     product,
     property_definition_relationship,
     structured_message,
     product_concept,
     in_zone,
     selected_item_assignment,
     product_planned_to_realized,
     contract);
  END_TYPE; -- approval_item

  TYPE area_measure = REAL;
  END_TYPE; -- area_measure

  TYPE attribute_classification_item = SELECT
    (message_relationship,
     approval_status,
     measure_representation_item,
     breakdown_element_usage,
     product_definition_relationship,
     product_concept_context,
     group,
     organizational_address,
     descriptive_representation_item,
     representation,
     organization_relationship,
     organization_role,
     date_role,
     object_role,
     product_definition_group_assignment,
     breakdown_context,
     information_usage_right,
     approval_relationship,
     application_context_element,
     security_classification_level,
     approval,
     product_definition,
     document_type,
     property_definition_representation,
     general_property,
     document_relationship,
     product_concept,
     name_attribute,
     certification_type,
     representation_context,
     property_definition_relationship,
     product_category,
     identification_role,
     information_right,
     property_definition,
     envelope_relationship,
     breakdown_element_group_assignment,
     alternate_product_relationship,
     product_definition_context,
     date_time_role,
     general_property_relationship,
     application_context,
     event_occurrence_relationship,
     approval_role,
     product_definition_formation_relationship,
     person_and_organization_role,
     contract_type,
     structured_message,
     organizational_project_relationship,
     person_and_organization_address,
     event_occurrence_context_role,
     representation_item,
     organizational_project_role,
     document_usage_role,
     certification,
     envelope,
     usage_association);
  END_TYPE; -- attribute_classification_item

  TYPE attribute_language_item = SELECT
    (multi_language_attribute_assignment,
     property_definition_relationship,
     date_role,
     general_property_relationship,
     identification_role,
     envelope,
     organization_relationship,
     event_occurrence,
     organizational_project_role,
     information_usage_right,
     contract,
     approval_relationship,
     connector_on,
     organizational_project_relationship,
     envelope_relationship,
     general_property,
     information_right,
     product,
     person_and_organization,
     certification,
     structured_message,
     approval,
     approval_status,
     representation_item,
     property_definition,
     date_time_role,
     message_relationship,
     product_definition,
     organizational_project,
     product_definition_formation,
     certification_type);
  END_TYPE; -- attribute_language_item

  TYPE attribute_type = SELECT
    (label,
     text);
  END_TYPE; -- attribute_type

  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE; -- axis2_placement

  TYPE b_spline_curve_form = ENUMERATION OF
    (polyline_form,
     circular_arc,
     elliptic_arc,
     parabolic_arc,
     hyperbolic_arc,
     unspecified);
  END_TYPE; -- b_spline_curve_form

  TYPE b_spline_surface_form = ENUMERATION OF
    (plane_surf,
     cylindrical_surf,
     conical_surf,
     spherical_surf,
     toroidal_surf,
     surf_of_revolution,
     ruled_surf,
     generalised_cone,
     quadric_surf,
     surf_of_linear_extrusion,
     unspecified);
  END_TYPE; -- b_spline_surface_form

  TYPE boolean_operand = SELECT
    (solid_model,
     half_space_solid,
     csg_primitive,
     boolean_result,
     half_space_2d);
  END_TYPE; -- boolean_operand

  TYPE boolean_operator = ENUMERATION OF
    (union,
     intersection,
     difference);
  END_TYPE; -- boolean_operator

  TYPE celsius_temperature_measure = REAL;
  END_TYPE; -- celsius_temperature_measure

  TYPE certification_item = SELECT
    (organizational_project,
     product,
     product_as_realized,
     product_definition_formation,
     interface_connection,
     product_as_planned,
     product_definition_formation_relationship);
  END_TYPE; -- certification_item

  TYPE characterized_action_definition = SELECT
    (action,
     action_method,
     action_method_relationship,
     action_relationship);
  END_TYPE; -- characterized_action_definition

  TYPE characterized_definition = SELECT
    (characterized_object,
     characterized_product_definition,
     shape_definition);
  END_TYPE; -- characterized_definition

  TYPE characterized_material_property = SELECT
    (material_property_representation,
     product_material_composition_relationship);
  END_TYPE; -- characterized_material_property

  TYPE characterized_product_definition = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE; -- characterized_product_definition

  TYPE characterized_resource_definition = SELECT
    (action_resource,
     action_resource_relationship,
     action_resource_requirement,
     action_resource_requirement_relationship);
  END_TYPE; -- characterized_resource_definition

  TYPE classification_item = SELECT
    (approval_status,
     selected_item_assignment,
     approval_person_organization,
     requirement_source,
     product_definition_relationship,
     product,
     interface_connector_design_to_realized,
     contract,
     applied_usage_right,
     date_and_time,
     general_property,
     requirement_assignment,
     representation_context,
     approval,
     interface_connector_design_to_planned,
     interface_connector_as_realized,
     security_classification,
     applied_action_method_assignment,
     breakdown_element_usage,
     event_occurrence,
     document_file,
     usage_association,
     product_as_planned,
     applied_document_reference,
     person_and_organization,
     descriptive_representation_item,
     organizational_project,
     product_definition_group_assignment,
     applied_certification_assignment,
     applied_organizational_project_assignment,
     product_definition,
     person_and_organization_address,
     information_usage_right,
     applied_state_assignment,
     applied_document_usage_constraint_assignment,
     assembly_component_usage_substitute,
     representation,
     property_definition_relationship,
     message_relationship,
     slot_planned_to_realized,
     multi_language_attribute_assignment,
     state_observed,
     slot_design_to_planned,
     action,
     property_definition,
     product_definition_context,
     interface_connection,
     product_definition_formation,
     product_design_to_individual,
     applied_date_assignment,
     organization_relationship,
     interface_connector_as_planned,
     organizational_address,
     calendar_date,
     applied_organization_assignment,
     organizational_project_relationship,
     product_definition_formation_relationship,
     applied_date_and_time_assignment,
     document_relationship,
     representation_item,
     applied_external_identification_assignment,
     approval_relationship,
     information_right,
     alternate_product_relationship,
     product_planned_to_realized,
     action_method_relationship,
     applied_action_assignment,
     applied_identification_assignment,
     action_method,
     interface_definition_for,
     general_property_relationship,
     applied_approval_assignment,
     event_occurrence_relationship,
     interface_connector_planned_to_realized,
     applied_state_type_assignment,
     state_type_relationship,
     product_concept,
     property_definition_representation,
     interface_connector_design,
     breakdown_element_group_assignment,
     applied_security_classification_assignment,
     certification,
     group,
     organization,
     applied_person_and_organization_assignment,
     envelope_relationship,
     envelope,
     applied_contract_assignment,
     state_type,
     address,
     measure_representation_item,
     applied_event_occurrence_assignment,
     selected_item,
     state_observed_relationship,
     product_category,
     language,
     product_as_realized,
     breakdown_context,
     slot_design_to_realized,
     structured_message);
  END_TYPE; -- classification_item

  TYPE compound_item_definition = SELECT
    (list_representation_item,
     set_representation_item);
  END_TYPE; -- compound_item_definition

  TYPE condition_action_method_items = SELECT
    (action_method_relationship,
     applied_date_and_time_assignment,
     applied_approval_assignment,
     product_definition_formation,
     applied_document_reference,
     applied_date_assignment,
     product,
     applied_organization_assignment,
     applied_person_and_organization_assignment,
     date_and_time,
     calendar_date,
     applied_contract_assignment,
     applied_certification_assignment,
     applied_document_usage_constraint_assignment,
     product_definition,
     applied_identification_assignment,
     property_definition,
     applied_classification_assignment,
     product_related_product_category,
     product_as_individual);
  END_TYPE; -- condition_action_method_items

  TYPE condition_approval_item = SELECT
    (action_method,
     applied_action_method_assignment);
  END_TYPE; -- condition_approval_item

  TYPE condition_classification_item = SELECT
    (action_method,
     action_method_relationship,
     applied_action_method_assignment);
  END_TYPE; -- condition_classification_item

  TYPE condition_date_and_time_item = SELECT
    (action_method,
     applied_action_method_assignment);
  END_TYPE; -- condition_date_and_time_item

  TYPE condition_date_item = SELECT
    (action_method,
     applied_action_method_assignment);
  END_TYPE; -- condition_date_item

  TYPE condition_evaluation_action_items = SELECT
    (applied_classification_assignment,
     applied_organization_assignment,
     calendar_date,
     applied_approval_assignment,
     applied_contract_assignment,
     property_definition,
     applied_certification_assignment,
     applied_document_usage_constraint_assignment,
     product,
     product_as_individual,
     applied_date_and_time_assignment,
     product_related_product_category,
     applied_document_reference,
     product_definition,
     date_and_time,
     product_definition_formation,
     applied_date_assignment,
     applied_identification_assignment,
     applied_person_and_organization_assignment);
  END_TYPE; -- condition_evaluation_action_items

  TYPE condition_evaluation_approval_item = SELECT
    (action,
     applied_action_assignment);
  END_TYPE; -- condition_evaluation_approval_item

  TYPE condition_evaluation_classification_item = SELECT
    (action,
     applied_action_assignment,
     group);
  END_TYPE; -- condition_evaluation_classification_item

  TYPE condition_evaluation_date_and_time_item = SELECT
    (action,
     applied_action_assignment);
  END_TYPE; -- condition_evaluation_date_and_time_item

  TYPE condition_evaluation_date_item = SELECT
    (action,
     applied_action_assignment);
  END_TYPE; -- condition_evaluation_date_item

  TYPE condition_evaluation_groupable_item = SELECT
    (applied_action_assignment,
     applied_action_method_assignment);
  END_TYPE; -- condition_evaluation_groupable_item

  TYPE condition_evaluation_identification_item = SELECT
    (action);
  END_TYPE; -- condition_evaluation_identification_item

  TYPE condition_evaluation_name_item = SELECT
    (applied_action_assignment);
  END_TYPE; -- condition_evaluation_name_item

  TYPE condition_evaluation_organization_item = SELECT
    (action,
     applied_action_assignment);
  END_TYPE; -- condition_evaluation_organization_item

  TYPE condition_evaluation_person_and_organization_item = SELECT
    (action,
     applied_action_assignment);
  END_TYPE; -- condition_evaluation_person_and_organization_item

  TYPE condition_identification_item = SELECT
    (action_method);
  END_TYPE; -- condition_identification_item

  TYPE condition_name_item = SELECT
    (applied_action_method_assignment);
  END_TYPE; -- condition_name_item

  TYPE condition_organization_item = SELECT
    (action_method,
     applied_action_method_assignment);
  END_TYPE; -- condition_organization_item

  TYPE condition_person_and_organization_item = SELECT
    (action_method,
     applied_action_method_assignment);
  END_TYPE; -- condition_person_and_organization_item

  TYPE configuration_design_item = SELECT
    (product_definition,
     product_definition_formation);
  END_TYPE; -- configuration_design_item

  TYPE contents_item = SELECT
    (representation);
  END_TYPE; -- contents_item

  TYPE context_dependent_measure = REAL;
  END_TYPE; -- context_dependent_measure

  TYPE contract_item = SELECT
    (product_definition_formation,
     product,
     interface_connector_as_planned,
     information_usage_right,
     requirement_source,
     product_as_realized,
     interface_connector_as_realized,
     product_definition_relationship,
     product_definition,
     organizational_project,
     product_definition_formation_relationship,
     interface_connector_design,
     structured_message,
     requirement_assignment,
     product_as_planned);
  END_TYPE; -- contract_item

  TYPE count_measure = NUMBER;
  END_TYPE; -- count_measure

  TYPE csg_primitive = SELECT
    (sphere,
     ellipsoid,
     block,
     right_angular_wedge,
     faceted_primitive,
     rectangular_pyramid,
     torus,
     right_circular_cone,
     eccentric_cone,
     right_circular_cylinder,
     cyclide_segment_solid,
     primitive_2d);
  END_TYPE; -- csg_primitive

  TYPE csg_select = SELECT
    (boolean_result,
     csg_primitive);
  END_TYPE; -- csg_select

  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE; -- curve_on_surface

  TYPE date_and_time_item = SELECT
    (selected_item,
     structured_message,
     product_planned_to_realized,
     applied_security_classification_assignment,
     action,
     interface_connector_planned_to_realized,
     envelope,
     contract,
     general_property,
     applied_person_and_organization_assignment,
     applied_contract_assignment,
     product_design_to_individual,
     representation,
     product_as_realized,
     event_occurrence,
     interface_connector_as_realized,
     general_property_relationship,
     product,
     security_classification,
     interface_connector_design_to_realized,
     interface_connector_design_to_planned,
     applied_organization_assignment,
     organizational_address,
     organizational_project,
     applied_action_assignment,
     slot_planned_to_realized,
     certification,
     assembly_component_usage_substitute,
     selected_item_assignment,
     breakdown_element_group_assignment,
     slot_design_to_planned,
     applied_document_reference,
     property_definition_relationship,
     product_as_planned,
     breakdown_element_usage,
     product_definition_formation,
     applied_organizational_project_assignment,
     interface_connector_as_planned,
     product_definition_group_assignment,
     assembly_component_usage,
     applied_certification_assignment,
     approval_person_organization,
     product_concept,
     applied_document_usage_constraint_assignment,
     person_and_organization_address,
     slot_design_to_realized,
     applied_action_method_assignment,
     product_definition,
     applied_usage_right,
     action_method,
     property_definition,
     applied_identification_assignment,
     alternate_product_relationship);
  END_TYPE; -- date_and_time_item

  TYPE date_and_time_item_approval = SELECT
    (approval_person_organization);
  END_TYPE; -- date_and_time_item_approval

  TYPE date_item = SELECT
    (organizational_address,
     product_as_planned,
     action,
     product,
     representation,
     applied_action_assignment,
     applied_document_usage_constraint_assignment,
     product_definition,
     envelope,
     contract,
     interface_connector_as_planned,
     applied_usage_right,
     product_definition_group_assignment,
     product_planned_to_realized,
     alternate_product_relationship,
     slot_design_to_planned,
     approval_person_organization,
     applied_identification_assignment,
     applied_security_classification_assignment,
     interface_connector_as_realized,
     breakdown_element_group_assignment,
     assembly_component_usage,
     organizational_project,
     property_definition,
     applied_certification_assignment,
     person_and_organization_address,
     applied_person_and_organization_assignment,
     slot_design_to_realized,
     product_definition_formation,
     product_as_realized,
     assembly_component_usage_substitute,
     applied_organizational_project_assignment,
     slot_planned_to_realized,
     applied_organization_assignment,
     applied_document_reference,
     selected_item,
     property_definition_relationship,
     event_occurrence,
     general_property_relationship,
     action_method,
     certification,
     product_concept,
     structured_message,
     interface_connector_design_to_planned,
     general_property,
     applied_action_method_assignment,
     interface_connector_design_to_realized,
     interface_connector_planned_to_realized,
     breakdown_element_usage,
     security_classification,
     selected_item_assignment,
     applied_contract_assignment,
     product_design_to_individual);
  END_TYPE; -- date_item

  TYPE date_item_approval = SELECT
    (approval_person_organization);
  END_TYPE; -- date_item_approval

  TYPE date_time_or_event_occurrence = SELECT
    (date_time_select,
     event_occurrence);
  END_TYPE; -- date_time_or_event_occurrence

  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 31));
  END_TYPE; -- day_in_month_number

  TYPE day_in_week_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 7));
  END_TYPE; -- day_in_week_number

  TYPE day_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 366));
  END_TYPE; -- day_in_year_number

  TYPE derived_property_select = SELECT
    (property_definition,
     action_property,
     resource_property);
  END_TYPE; -- derived_property_select

  TYPE description_attribute_select = SELECT
    (action_request_solution,
     application_context,
     approval_role,
     configuration_design,
     date_role,
     date_time_role,
     context_dependent_shape_representation,
     effectivity,
     external_source,
     organization_role,
     person_and_organization_role,
     person_and_organization,
     person_role,
     property_definition_representation,
     representation,
     time_role);
  END_TYPE; -- description_attribute_select

  TYPE descriptive_measure = STRING;
  END_TYPE; -- descriptive_measure

  TYPE dimension_count = INTEGER;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- dimension_count

  TYPE dm_aliasable_item = SELECT
    (document_file,
     product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- dm_aliasable_item

  TYPE dm_approval_item = SELECT
    (contract,
     certification,
     product_definition,
     product_definition_formation,
     product_definition_relationship);
  END_TYPE; -- dm_approval_item

  TYPE dm_attribute_language_item = SELECT
    (date_time_role,
     date_role,
     certification,
     person_and_organization,
     organizational_project_relationship,
     organization_relationship,
     organizational_project,
     approval,
     contract,
     multi_language_attribute_assignment,
     approval_status,
     identification_role,
     organizational_project_role,
     certification_type,
     approval_relationship,
     applied_document_reference,
     applied_document_usage_constraint_assignment,
     applied_external_identification_assignment,
     document_relationship,
     document_usage_role,
     external_source,
     object_role,
     product,
     product_category,
     product_definition,
     product_definition_formation,
     product_definition_relationship);
  END_TYPE; -- dm_attribute_language_item

  TYPE dm_contract_item = SELECT
    (product_definition_formation);
  END_TYPE; -- dm_contract_item

  TYPE dm_date_and_time_item = SELECT
    (contract,
     certification,
     applied_security_classification_assignment,
     security_classification,
     applied_person_and_organization_assignment,
     applied_organization_assignment,
     document_file,
     product_definition,
     product_definition_formation,
     product_definition_relationship);
  END_TYPE; -- dm_date_and_time_item

  TYPE dm_date_item = SELECT
    (applied_security_classification_assignment,
     contract,
     certification,
     applied_organization_assignment,
     security_classification,
     applied_person_and_organization_assignment,
     document_file,
     product_definition,
     product_definition_formation,
     product_definition_relationship);
  END_TYPE; -- dm_date_item

  TYPE dm_identification_item = SELECT
    (organization,
     security_classification_level,
     contract,
     document_file,
     product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- dm_identification_item

  TYPE dm_multi_language_attribute_item = SELECT
    (organizational_project_role,
     date_time_role,
     approval,
     contract,
     organizational_project,
     certification_type,
     identification_role,
     organizational_project_relationship,
     approval_status,
     person_and_organization,
     organization_relationship,
     approval_relationship,
     date_role,
     certification,
     applied_document_reference,
     applied_document_usage_constraint_assignment,
     applied_external_identification_assignment,
     document_relationship,
     document_usage_role,
     external_source,
     object_role,
     product,
     product_category,
     product_definition,
     product_definition_formation,
     product_definition_relationship);
  END_TYPE; -- dm_multi_language_attribute_item

  TYPE dm_organization_item = SELECT
    (contract,
     applied_identification_assignment,
     applied_security_classification_assignment,
     document_file,
     product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- dm_organization_item

  TYPE dm_person_and_organization_item = SELECT
    (contract,
     applied_identification_assignment,
     applied_security_classification_assignment,
     document_file,
     product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- dm_person_and_organization_item

  TYPE dm_security_classification_item = SELECT
    (document_file,
     product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- dm_security_classification_item

  TYPE document_location_select = SELECT
    (product_definition);
  END_TYPE; -- document_location_select

  TYPE document_reference_item = SELECT
    (interface_connector_design,
     interface_connector_as_realized,
     certification,
     product_definition_formation_relationship,
     breakdown_element_group_assignment,
     interface_connector_design_to_planned,
     product_as_realized,
     assembly_component_usage,
     product_definition_formation,
     interface_connector_as_planned,
     information_right,
     product_definition,
     product_design_to_individual,
     interface_connector_design_to_realized,
     information_usage_right,
     interface_connector_planned_to_realized,
     alternate_product_relationship,
     product_planned_to_realized,
     assembly_component_usage_substitute,
     slot_design_to_planned,
     contract,
     breakdown_element_usage,
     organizational_project,
     product,
     slot_design_to_realized,
     product_as_planned,
     product_concept,
     slot_planned_to_realized,
     product_definition_group_assignment,
     person,
     applied_identification_assignment,
     organization,
     selected_item);
  END_TYPE; -- document_reference_item

  TYPE effectivity_item = SELECT
    (slot_as_realized,
     applied_identification_assignment,
     document_type,
     product_as_individual,
     requirement_assignment,
     applied_security_classification_assignment,
     interface_connector_design_to_planned,
     applied_certification_assignment,
     slot_design_to_realized,
     product,
     applied_external_identification_assignment,
     applied_usage_right,
     product_definition,
     product_definition_relationship,
     interface_connector_design_to_realized,
     assembly_component_usage,
     product_definition_formation_relationship,
     requirement_source,
     product_definition_group_assignment,
     assembly_component_usage_substitute,
     property_definition,
     slot_as_planned,
     breakdown_element_group_assignment,
     organizational_address,
     product_design_to_individual,
     interface_connector_planned_to_realized,
     product_planned_to_realized,
     alternate_product_relationship,
     interface_connection,
     make_from_usage_option,
     slot_design_to_planned,
     applied_document_reference,
     selected_item_assignment,
     slot_on_product,
     breakdown_element_usage,
     applied_document_usage_constraint_assignment,
     slot_design,
     applied_contract_assignment,
     product_definition_formation,
     slot_planned_to_realized,
     product_in_slot,
     person_and_organization_address,
     applied_organizational_project_assignment,
     document_relationship);
  END_TYPE; -- effectivity_item

  TYPE electric_current_measure = REAL;
  END_TYPE; -- electric_current_measure

  TYPE envelope_approval = SELECT
    (envelope);
  END_TYPE; -- envelope_approval

  TYPE envelope_date = SELECT
    (envelope);
  END_TYPE; -- envelope_date

  TYPE envelope_date_and_time = SELECT
    (envelope);
  END_TYPE; -- envelope_date_and_time

  TYPE envelope_organization_item = SELECT
    (envelope);
  END_TYPE; -- envelope_organization_item

  TYPE envelope_person_organization_item = SELECT
    (envelope);
  END_TYPE; -- envelope_person_organization_item

  TYPE event_occurrence_date_and_time_item = SELECT
    (event_occurrence);
  END_TYPE; -- event_occurrence_date_and_time_item

  TYPE event_occurrence_date_item = SELECT
    (event_occurrence);
  END_TYPE; -- event_occurrence_date_item

  TYPE event_occurrence_item = SELECT
    (organizational_project,
     certification);
  END_TYPE; -- event_occurrence_item

  TYPE extent_enumeration = ENUMERATION OF
    (invalid,
     zero,
     finite_non_zero,
     infinite);
  END_TYPE; -- extent_enumeration

  TYPE external_class_name_item = SELECT
    (external_class_library);
  END_TYPE; -- external_class_name_item

  TYPE external_identification_item = SELECT
    (document_file,
     product_definition);
  END_TYPE; -- external_identification_item

  TYPE file_identification_item = SELECT
    (document_file);
  END_TYPE; -- file_identification_item

  TYPE file_location_select = SELECT
    (document_file);
  END_TYPE; -- file_location_select

  TYPE file_version_item = SELECT
    (document_file);
  END_TYPE; -- file_version_item

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE; -- founded_item_select

  TYPE geometric_set_select = SELECT
    (point,
     curve,
     surface);
  END_TYPE; -- geometric_set_select

  TYPE groupable_item = SELECT
    (applied_action_method_assignment,
     representation,
     applied_action_assignment);
  WHERE
    wr1: (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.GROUP' IN 
             TYPEOF(SELF)));
  END_TYPE; -- groupable_item

  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 24));
  END_TYPE; -- hour_in_day

  TYPE id_attribute_select = SELECT
    (action,
     address,
     product_category,
     property_definition,
     shape_aspect,
     shape_aspect_relationship,
     application_context,
     group,
     organizational_project,
     representation);
  END_TYPE; -- id_attribute_select

  TYPE identification_item = SELECT
    (organizational_project,
     certification,
     state_type,
     product_definition,
     contract,
     product_definition_formation,
     property_definition_relationship,
     product,
     general_property,
     approval_status,
     organization,
     interface_connector_as_realized,
     security_classification_level,
     general_property_relationship,
     product_as_individual,
     property_definition,
     state_type_relationship,
     interface_connector_as_planned,
     security_classification,
     product_as_planned,
     shape_representation,
     product_as_realized,
     event_occurrence,
     interface_connector_design,
     document_file,
     action,
     action_method);
  END_TYPE; -- identification_item

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE ir_approval_item = SELECT
    (contract,
     certification,
     applied_usage_right,
     information_usage_right);
  END_TYPE; -- ir_approval_item

  TYPE ir_contract_item = SELECT
    (information_usage_right);
  END_TYPE; -- ir_contract_item

  TYPE ir_date_and_time_item = SELECT
    (contract,
     certification,
     applied_security_classification_assignment,
     security_classification,
     applied_person_and_organization_assignment,
     applied_organization_assignment,
     information_usage_right);
  END_TYPE; -- ir_date_and_time_item

  TYPE ir_date_item = SELECT
    (applied_security_classification_assignment,
     contract,
     certification,
     applied_organization_assignment,
     security_classification,
     applied_person_and_organization_assignment,
     information_usage_right);
  END_TYPE; -- ir_date_item

  TYPE ir_identification_item = SELECT
    (organization,
     security_classification_level,
     contract,
     information_right,
     information_usage_right);
  END_TYPE; -- ir_identification_item

  TYPE ir_organization_item = SELECT
    (contract,
     applied_identification_assignment,
     applied_security_classification_assignment,
     information_usage_right);
  END_TYPE; -- ir_organization_item

  TYPE ir_person_and_organization_item = SELECT
    (contract,
     applied_identification_assignment,
     applied_security_classification_assignment,
     information_usage_right);
  END_TYPE; -- ir_person_and_organization_item

  TYPE ir_usage_item = SELECT
    (applied_certification_assignment,
     slot_design_to_planned,
     slot_on_product,
     interface_connection,
     slot_design_to_realized,
     product_definition,
     product_definition_relationship,
     product,
     product_definition_formation,
     document_file,
     product_as_planned,
     alternate_product_relationship,
     requirement_assignment,
     product_as_realized,
     breakdown_element_group_assignment,
     structured_message,
     document_relationship,
     product_definition_group_assignment,
     certification,
     assembly_component_usage,
     interface_connector_as_planned,
     interface_connector_as_realized,
     security_classification,
     product_definition_formation_relationship,
     interface_connector_design,
     applied_security_classification_assignment,
     breakdown_element_usage,
     assembly_component_usage_substitute);
  END_TYPE; -- ir_usage_item

  TYPE knot_type = ENUMERATION OF
    (uniform_knots,
     quasi_uniform_knots,
     piecewise_bezier_knots,
     unspecified);
  END_TYPE; -- knot_type

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE length_measure = REAL;
  END_TYPE; -- length_measure

  TYPE list_of_reversible_topology_item = LIST OF reversible_topology_item;
  END_TYPE; -- list_of_reversible_topology_item

  TYPE list_of_two_representation_items = list_representation_item;
  WHERE
    wr1: (HIINDEX(SELF) = 2);
  END_TYPE; -- list_of_two_representation_items

  TYPE list_representation_item = LIST [1:?] OF representation_item;
  END_TYPE; -- list_representation_item

  TYPE luminous_intensity_measure = REAL;
  END_TYPE; -- luminous_intensity_measure

  TYPE mass_measure = REAL;
  END_TYPE; -- mass_measure

  TYPE measure_value = SELECT
    (length_measure,
     mass_measure,
     time_measure,
     electric_current_measure,
     thermodynamic_temperature_measure,
     celsius_temperature_measure,
     amount_of_substance_measure,
     luminous_intensity_measure,
     plane_angle_measure,
     solid_angle_measure,
     area_measure,
     volume_measure,
     ratio_measure,
     parameter_value,
     numeric_measure,
     context_dependent_measure,
     descriptive_measure,
     positive_length_measure,
     positive_plane_angle_measure,
     positive_ratio_measure,
     count_measure);
  END_TYPE; -- measure_value

  TYPE message = STRING;
  END_TYPE; -- message

  TYPE message_approval = SELECT
    (structured_message);
  END_TYPE; -- message_approval

  TYPE message_date = SELECT
    (structured_message);
  END_TYPE; -- message_date

  TYPE message_date_time = SELECT
    (structured_message);
  END_TYPE; -- message_date_time

  TYPE message_having_contents = SELECT
    (structured_message);
  END_TYPE; -- message_having_contents

  TYPE message_organization = SELECT
    (structured_message);
  END_TYPE; -- message_organization

  TYPE message_person_and_organization = SELECT
    (structured_message);
  END_TYPE; -- message_person_and_organization

  TYPE message_security_classification = SELECT
    (structured_message);
  END_TYPE; -- message_security_classification

  TYPE message_state = SELECT
    (structured_message);
  END_TYPE; -- message_state

  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 59));
  END_TYPE; -- minute_in_hour

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 12));
  END_TYPE; -- month_in_year_number

  TYPE mri_approval_item = SELECT
    (certification,
     contract,
     product_definition_relationship,
     product_definition_formation,
     information_usage_right,
     requirement_source,
     product_definition,
     product,
     requirement_assignment,
     applied_usage_right,
     product_definition_formation_relationship);
  END_TYPE; -- mri_approval_item

  TYPE mri_attribute_language_item = SELECT
    (multi_language_attribute_assignment,
     approval,
     approval_relationship,
     approval_status,
     certification,
     certification_type,
     contract,
     date_role,
     date_time_role,
     identification_role,
     organization_relationship,
     organizational_project,
     organizational_project_relationship,
     organizational_project_role,
     person_and_organization,
     applied_external_identification_assignment,
     external_source,
     product_definition_relationship,
     product,
     state_observed,
     requirement_source,
     applied_document_usage_constraint_assignment,
     product_definition,
     applied_document_reference,
     document_relationship,
     object_role,
     state_observed_relationship,
     state_type,
     product_definition_formation,
     product_category,
     state_type_relationship,
     document_usage_role,
     requirement_assignment,
     product_definition_formation_relationship);
  END_TYPE; -- mri_attribute_language_item

  TYPE mri_date_and_time_item = SELECT
    (applied_organization_assignment,
     applied_person_and_organization_assignment,
     applied_security_classification_assignment,
     certification,
     contract,
     security_classification,
     state_type_relationship,
     requirement_source,
     product_definition_relationship,
     applied_state_type_assignment,
     product_definition_formation,
     product_definition,
     requirement_assignment,
     state_type,
     ascribable_state,
     product_definition_formation_relationship,
     applied_state_assignment,
     state_observed_relationship,
     state_observed,
     information_usage_right,
     product,
     document_file);
  END_TYPE; -- mri_date_and_time_item

  TYPE mri_date_item = SELECT
    (applied_organization_assignment,
     applied_person_and_organization_assignment,
     applied_security_classification_assignment,
     certification,
     contract,
     security_classification,
     document_file,
     product_definition_formation_relationship,
     product_definition_formation,
     state_observed_relationship,
     applied_state_type_assignment,
     applied_state_assignment,
     product_definition,
     ascribable_state,
     requirement_assignment,
     information_usage_right,
     state_type,
     product,
     product_definition_relationship,
     requirement_source,
     state_observed,
     state_type_relationship);
  END_TYPE; -- mri_date_item

  TYPE mri_identification_item = SELECT
    (contract,
     organization,
     security_classification_level,
     product,
     requirement_assignment,
     product_definition_formation,
     state_observed,
     information_right,
     document_file,
     state_type,
     product_definition_relationship,
     state_type_relationship,
     state_observed_relationship,
     product_definition,
     requirement_source,
     information_usage_right,
     product_definition_formation_relationship);
  END_TYPE; -- mri_identification_item

  TYPE mri_multi_language_attribute_item = SELECT
    (approval,
     approval_relationship,
     approval_status,
     certification,
     certification_type,
     contract,
     date_role,
     date_time_role,
     identification_role,
     organization_relationship,
     organizational_project,
     organizational_project_relationship,
     organizational_project_role,
     person_and_organization,
     applied_external_identification_assignment,
     product_definition_formation,
     product_category,
     object_role,
     product_definition_relationship,
     state_observed,
     state_observed_relationship,
     applied_document_usage_constraint_assignment,
     requirement_source,
     applied_document_reference,
     product_definition,
     product,
     state_type,
     requirement_assignment,
     state_type_relationship,
     external_source,
     document_usage_role,
     document_relationship,
     product_definition_formation_relationship);
  END_TYPE; -- mri_multi_language_attribute_item

  TYPE mri_organization_item = SELECT
    (applied_identification_assignment,
     applied_security_classification_assignment,
     contract,
     applied_state_type_assignment,
     state_type,
     requirement_assignment,
     state_observed_relationship,
     product_definition_formation,
     requirement_source,
     product_definition,
     information_usage_right,
     state_type_relationship,
     product,
     product_definition_formation_relationship,
     ascribable_state,
     product_definition_relationship,
     state_observed,
     document_file,
     applied_state_assignment);
  END_TYPE; -- mri_organization_item

  TYPE mri_person_and_organization_item = SELECT
    (applied_identification_assignment,
     applied_security_classification_assignment,
     contract,
     ascribable_state,
     product,
     product_definition_formation,
     state_type,
     product_definition_formation_relationship,
     state_observed_relationship,
     product_definition_relationship,
     applied_state_assignment,
     state_type_relationship,
     document_file,
     requirement_source,
     state_observed,
     product_definition,
     applied_state_type_assignment,
     requirement_assignment,
     information_usage_right);
  END_TYPE; -- mri_person_and_organization_item

  TYPE multi_language_attribute_item = SELECT
    (product_definition_formation,
     breakdown_element_usage,
     connector_on,
     product_definition,
     approval,
     assembly_component_usage,
     information_right,
     contract,
     message_relationship,
     approval_status,
     product_as_individual,
     representation_item,
     date_role,
     person_and_organization,
     product,
     slot_planned_to_realized,
     general_property,
     product_definition_group_assignment,
     event_occurrence,
     organization_relationship,
     alternate_product_relationship,
     organizational_project_role,
     general_property_relationship,
     slot_design_to_realized,
     organizational_project,
     certification_type,
     property_definition_relationship,
     property_definition,
     date_time_role,
     envelope,
     information_usage_right,
     slot_on_product,
     assembly_component_usage_substitute,
     structured_message,
     breakdown_element_group_assignment,
     certification,
     envelope_relationship,
     approval_relationship,
     identification_role,
     organizational_project_relationship,
     slot_design_to_planned);
  END_TYPE; -- multi_language_attribute_item

  TYPE name_attribute_select = SELECT
    (action_request_solution,
     address,
     configuration_design,
     context_dependent_shape_representation,
     derived_unit,
     effectivity,
     person_and_organization,
     product_definition,
     product_definition_substitute,
     property_definition_representation);
  END_TYPE; -- name_attribute_select

  TYPE name_item = SELECT
    (applied_action_assignment,
     external_class_library,
     applied_action_method_assignment);
  END_TYPE; -- name_item

  TYPE numeric_measure = NUMBER;
  END_TYPE; -- numeric_measure

  TYPE organization_item = SELECT
    (applied_security_classification_assignment,
     applied_action_method_assignment,
     representation,
     action_method,
     breakdown_element_group_assignment,
     contract,
     product_definition_group_assignment,
     selected_item,
     applied_identification_assignment,
     action,
     structured_message,
     product,
     general_property_relationship,
     product_definition_formation,
     applied_organizational_project_assignment,
     selected_item_assignment,
     property_definition,
     applied_document_usage_constraint_assignment,
     property_definition_relationship,
     organizational_project,
     assembly_component_usage,
     breakdown_element_usage,
     applied_contract_assignment,
     envelope,
     interface_connector_as_planned,
     applied_event_occurrence_assignment,
     product_as_planned,
     alternate_product_relationship,
     general_property,
     event_occurrence,
     product_definition,
     applied_certification_assignment,
     applied_action_assignment,
     interface_connector_as_realized,
     product_as_realized,
     assembly_component_usage_substitute,
     certification,
     applied_document_reference);
  END_TYPE; -- organization_item

  TYPE parameter_value = REAL;
  END_TYPE; -- parameter_value

  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE; -- pcurve_or_surface

  TYPE person_and_organization_item = SELECT
    (certification,
     applied_organizational_project_assignment,
     product_definition_group_assignment,
     product_as_planned,
     product,
     product_definition,
     applied_event_occurrence_assignment,
     breakdown_element_usage,
     applied_document_usage_constraint_assignment,
     applied_identification_assignment,
     alternate_product_relationship,
     product_definition_formation,
     selected_item_assignment,
     applied_certification_assignment,
     envelope,
     applied_security_classification_assignment,
     property_definition_relationship,
     event_occurrence,
     representation,
     contract,
     structured_message,
     product_as_realized,
     applied_contract_assignment,
     breakdown_element_group_assignment,
     organizational_project,
     assembly_component_usage_substitute,
     property_definition,
     applied_document_reference,
     applied_action_assignment,
     applied_action_method_assignment,
     assembly_component_usage,
     action_method,
     general_property,
     interface_connector_as_planned,
     interface_connector_as_realized,
     action,
     selected_item,
     general_property_relationship);
  END_TYPE; -- person_and_organization_item

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE plane_angle_measure = REAL;
  END_TYPE; -- plane_angle_measure

  TYPE positive_length_measure = length_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_length_measure

  TYPE positive_plane_angle_measure = plane_angle_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_plane_angle_measure

  TYPE positive_ratio_measure = ratio_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_ratio_measure

  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (curve_3d,
     pcurve_s1,
     pcurve_s2);
  END_TYPE; -- preferred_surface_curve_representation

  TYPE product_as_individual_identification_item = SELECT
    (product_as_individual);
  END_TYPE; -- product_as_individual_identification_item

  TYPE product_definition_or_breakdown_element_usage = SELECT
    (breakdown_element_usage,
     product_definition);
  END_TYPE; -- product_definition_or_breakdown_element_usage

  TYPE product_definition_or_product_definition_relationship = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE; -- product_definition_or_product_definition_relationship

  TYPE product_or_formation_or_definition = SELECT
    (product,
     product_definition_formation,
     product_definition);
  END_TYPE; -- product_or_formation_or_definition

  TYPE project_as_date_and_time_item = SELECT
    (organizational_project);
  END_TYPE; -- project_as_date_and_time_item

  TYPE project_as_date_item = SELECT
    (organizational_project);
  END_TYPE; -- project_as_date_item

  TYPE project_item = SELECT
    (product,
     product_concept);
  END_TYPE; -- project_item

  TYPE property_or_shape_select = SELECT
    (property_definition,
     shape_definition);
  END_TYPE; -- property_or_shape_select

  TYPE ratio_measure = REAL;
  END_TYPE; -- ratio_measure

  TYPE representation_identification_item = SELECT
    (shape_representation);
  END_TYPE; -- representation_identification_item

  TYPE representation_version_item = SELECT
    (shape_representation);
  END_TYPE; -- representation_version_item

  TYPE represented_definition = SELECT
    (general_property,
     property_definition,
     property_definition_relationship,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- represented_definition

  TYPE requirement_assigned_item = SELECT
    (breakdown_element_group_assignment,
     product,
     product_definition_formation,
     alternate_product_relationship,
     breakdown_element_usage,
     assembly_component_usage,
     organizational_project,
     product_as_realized,
     assembly_component_usage_substitute,
     product_in_slot,
     product_as_planned,
     product_definition_group_assignment);
  END_TYPE; -- requirement_assigned_item

  TYPE requirement_identification_and_version_aliasable_item = SELECT
    (product,
     product_definition_formation);
  END_TYPE; -- requirement_identification_and_version_aliasable_item

  TYPE requirement_identification_and_version_mri_identification_item =
              SELECT
    (organization,
     security_classification_level,
     contract,
     product,
     product_definition_formation);
  END_TYPE; -- requirement_identification_and_version_mri_identification_item

  TYPE requirement_source_item = SELECT
    (product_definition_formation,
     product_as_individual);
  END_TYPE; -- requirement_source_item

  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE; -- reversible_topology

  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE; -- reversible_topology_item

  TYPE rm_aliasable_item = SELECT
    (product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_aliasable_item

  TYPE rm_contract_item = SELECT
    (product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_contract_item

  TYPE rm_mri_approval_item = SELECT
    (contract,
     certification,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_mri_approval_item

  TYPE rm_mri_attribute_language_item = SELECT
    (date_time_role,
     date_role,
     certification,
     person_and_organization,
     organizational_project_relationship,
     organization_relationship,
     organizational_project,
     approval,
     contract,
     multi_language_attribute_assignment,
     approval_status,
     identification_role,
     organizational_project_role,
     certification_type,
     approval_relationship,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_mri_attribute_language_item

  TYPE rm_mri_date_and_time_item = SELECT
    (contract,
     certification,
     applied_security_classification_assignment,
     security_classification,
     applied_person_and_organization_assignment,
     applied_organization_assignment,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_mri_date_and_time_item

  TYPE rm_mri_date_item = SELECT
    (applied_security_classification_assignment,
     contract,
     certification,
     applied_organization_assignment,
     security_classification,
     applied_person_and_organization_assignment,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_mri_date_item

  TYPE rm_mri_identification_item = SELECT
    (organization,
     security_classification_level,
     contract,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_mri_identification_item

  TYPE rm_mri_multi_language_attribute_item = SELECT
    (organizational_project_role,
     date_time_role,
     approval,
     contract,
     organizational_project,
     certification_type,
     identification_role,
     organizational_project_relationship,
     approval_status,
     person_and_organization,
     organization_relationship,
     approval_relationship,
     date_role,
     certification,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_mri_multi_language_attribute_item

  TYPE rm_mri_organization_item = SELECT
    (contract,
     applied_identification_assignment,
     applied_security_classification_assignment,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_mri_organization_item

  TYPE rm_mri_person_and_organization_item = SELECT
    (contract,
     applied_identification_assignment,
     applied_security_classification_assignment,
     product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_mri_person_and_organization_item

  TYPE rm_security_classification_item = SELECT
    (product,
     product_definition,
     product_definition_formation,
     product_definition_formation_relationship,
     product_definition_relationship,
     requirement_assignment,
     requirement_source);
  END_TYPE; -- rm_security_classification_item

  TYPE role_select = SELECT
    (action_assignment,
     action_request_assignment,
     approval_assignment,
     approval_date_time,
     certification_assignment,
     contract_assignment,
     document_reference,
     effectivity_assignment,
     external_referent_assignment,
     group_assignment,
     name_assignment,
     security_classification_assignment);
  END_TYPE; -- role_select

  TYPE second_in_minute = REAL;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 60));
  END_TYPE; -- second_in_minute

  TYPE security_classification_item = SELECT
    (interface_connector_as_realized,
     structured_message,
     slot_on_product,
     requirement_assignment,
     product_definition_formation,
     product_definition_relationship,
     product,
     applied_document_usage_constraint_assignment,
     requirement_source,
     alternate_product_relationship,
     product_definition,
     interface_connector_as_planned,
     slot_design_to_planned,
     breakdown_element_group_assignment,
     product_definition_group_assignment,
     applied_document_reference,
     breakdown_element_usage,
     slot_planned_to_realized,
     document_file,
     product_definition_formation_relationship,
     product_as_planned,
     interface_connector_design,
     slot_design_to_realized,
     assembly_component_usage,
     product_as_realized,
     assembly_component_usage_substitute);
  END_TYPE; -- security_classification_item

  TYPE selected_item_context_items = SELECT
    (organizational_project,
     contract,
     product,
     product_concept);
  END_TYPE; -- selected_item_context_items

  TYPE selected_item_select = SELECT
    (product,
     product_definition_formation);
  END_TYPE; -- selected_item_select

  TYPE set_of_reversible_topology_item = SET OF reversible_topology_item;
  END_TYPE; -- set_of_reversible_topology_item

  TYPE set_representation_item = SET [1:?] OF representation_item;
  END_TYPE; -- set_representation_item

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- shape_definition

  TYPE shell = SELECT
    (vertex_shell,
     wire_shell,
     open_shell,
     closed_shell);
  END_TYPE; -- shell

  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE; -- si_prefix

  TYPE si_unit_name = ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE; -- si_unit_name

  TYPE solid_angle_measure = REAL;
  END_TYPE; -- solid_angle_measure

  TYPE source = ENUMERATION OF
    (made,
     bought,
     not_known);
  END_TYPE; -- source

  TYPE source_item = SELECT
    (identifier,
     message);
  END_TYPE; -- source_item

  TYPE spr_document_reference_item = SELECT
    (product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- spr_document_reference_item

  TYPE spr_organization_item = SELECT
    (product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- spr_organization_item

  TYPE spr_person_and_organization_item = SELECT
    (product,
     product_definition,
     product_definition_formation);
  END_TYPE; -- spr_person_and_organization_item

  TYPE state_definition_classification_item = SELECT
    (applied_state_type_assignment,
     state_type,
     state_type_relationship);
  END_TYPE; -- state_definition_classification_item

  TYPE state_definition_identification_item = SELECT
    (state_type,
     state_type_relationship);
  END_TYPE; -- state_definition_identification_item

  TYPE state_observed_classification_item = SELECT
    (applied_state_assignment,
     state_observed,
     state_observed_relationship);
  END_TYPE; -- state_observed_classification_item

  TYPE state_of_item = SELECT
    (product_as_realized,
     person_and_organization,
     contract,
     product_as_planned,
     interface_connection,
     product_definition,
     interface_connector_as_planned,
     slot_planned_to_realized,
     product_in_slot,
     interface_connector_design,
     product,
     slot_design_to_planned,
     product_definition_formation,
     certification,
     alternate_product_relationship,
     breakdown_element_group_assignment,
     organization,
     assembly_component_usage_substitute,
     interface_connector_as_realized,
     structured_message,
     organizational_project,
     breakdown_element_usage,
     applied_external_identification_assignment,
     security_classification,
     product_definition_group_assignment,
     connector_on,
     slot_on_product,
     document_file,
     slot_design_to_realized,
     assembly_component_usage);
  END_TYPE; -- state_of_item

  TYPE state_type_of_item = SELECT
    (product,
     product_as_realized,
     slot_on_product,
     product_definition,
     slot_design_to_planned,
     security_classification,
     breakdown_element_usage,
     slot_planned_to_realized,
     contract,
     interface_connector_as_planned,
     document_file,
     breakdown_element_group_assignment,
     person_and_organization,
     product_category,
     product_definition_formation,
     slot_design_to_realized,
     product_as_planned,
     organizational_project,
     connector_on,
     product_definition_group_assignment,
     interface_connection,
     alternate_product_relationship,
     interface_connector_design,
     applied_external_identification_assignment,
     assembly_component_usage_substitute,
     interface_connector_as_realized,
     product_in_slot,
     organization,
     certification,
     assembly_component_usage);
  END_TYPE; -- state_type_of_item

  TYPE statechar_action_items = SELECT
    (ascribable_state);
  END_TYPE; -- statechar_action_items

  TYPE statechar_action_method_items = SELECT
    (state_type,
     state_type_relationship);
  END_TYPE; -- statechar_action_method_items

  TYPE statechar_ap239_mri_attribute_classification_item = SELECT
    (approval,
     identification_role,
     contract_type,
     date_role,
     security_classification_level,
     person_and_organization_address,
     event_occurrence_relationship,
     organization_relationship,
     name_attribute,
     person_and_organization_role,
     event_occurrence_context_role,
     object_role,
     organizational_address,
     group,
     certification_type,
     organizational_project_role,
     approval_status,
     certification,
     date_time_role,
     organization_role,
     approval_relationship,
     approval_role,
     organizational_project_relationship,
     applied_state_assignment,
     applied_state_type_assignment,
     state_observed,
     state_observed_relationship,
     state_type,
     state_type_relationship);
  END_TYPE; -- statechar_ap239_mri_attribute_classification_item

  TYPE statechar_mri_attribute_language_item = SELECT
    (date_time_role,
     date_role,
     certification,
     person_and_organization,
     organizational_project_relationship,
     organization_relationship,
     organizational_project,
     approval,
     contract,
     multi_language_attribute_assignment,
     approval_status,
     identification_role,
     organizational_project_role,
     certification_type,
     approval_relationship,
     state_observed,
     state_observed_relationship,
     state_type,
     state_type_relationship);
  END_TYPE; -- statechar_mri_attribute_language_item

  TYPE statechar_mri_date_and_time_item = SELECT
    (contract,
     certification,
     applied_security_classification_assignment,
     security_classification,
     applied_person_and_organization_assignment,
     applied_organization_assignment,
     applied_state_assignment,
     applied_state_type_assignment,
     ascribable_state,
     state_observed,
     state_observed_relationship,
     state_type,
     state_type_relationship);
  END_TYPE; -- statechar_mri_date_and_time_item

  TYPE statechar_mri_date_item = SELECT
    (applied_security_classification_assignment,
     contract,
     certification,
     applied_organization_assignment,
     security_classification,
     applied_person_and_organization_assignment,
     applied_state_assignment,
     applied_state_type_assignment,
     ascribable_state,
     state_observed,
     state_observed_relationship,
     state_type,
     state_type_relationship);
  END_TYPE; -- statechar_mri_date_item

  TYPE statechar_mri_identification_item = SELECT
    (organization,
     security_classification_level,
     contract,
     state_observed,
     state_observed_relationship,
     state_type,
     state_type_relationship);
  END_TYPE; -- statechar_mri_identification_item

  TYPE statechar_mri_multi_language_attribute_item = SELECT
    (organizational_project_role,
     date_time_role,
     approval,
     contract,
     organizational_project,
     certification_type,
     identification_role,
     organizational_project_relationship,
     approval_status,
     person_and_organization,
     organization_relationship,
     approval_relationship,
     date_role,
     certification,
     state_observed,
     state_observed_relationship,
     state_type,
     state_type_relationship);
  END_TYPE; -- statechar_mri_multi_language_attribute_item

  TYPE statechar_mri_organization_item = SELECT
    (contract,
     applied_identification_assignment,
     applied_security_classification_assignment,
     applied_state_assignment,
     applied_state_type_assignment,
     ascribable_state,
     state_observed,
     state_observed_relationship,
     state_type,
     state_type_relationship);
  END_TYPE; -- statechar_mri_organization_item

  TYPE statechar_mri_person_and_organization_item = SELECT
    (contract,
     applied_identification_assignment,
     applied_security_classification_assignment,
     applied_state_assignment,
     applied_state_type_assignment,
     ascribable_state,
     state_observed,
     state_observed_relationship,
     state_type,
     state_type_relationship);
  END_TYPE; -- statechar_mri_person_and_organization_item

  TYPE supported_item = SELECT
    (action_directive,
     action,
     action_method);
  END_TYPE; -- supported_item

  TYPE surface_boundary = SELECT
    (boundary_curve,
     degenerate_pcurve);
  END_TYPE; -- surface_boundary

  TYPE surface_model = SELECT
    (shell_based_surface_model,
     face_based_surface_model);
  END_TYPE; -- surface_model

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE; -- thermodynamic_temperature_measure

  TYPE time_measure = REAL;
  END_TYPE; -- time_measure

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE; -- transformation

  TYPE transition_code = ENUMERATION OF
    (discontinuous,
     continuous,
     cont_same_gradient,
     cont_same_gradient_same_curvature);
  END_TYPE; -- transition_code

  TYPE trimming_preference = ENUMERATION OF
    (cartesian,
     parameter,
     unspecified);
  END_TYPE; -- trimming_preference

  TYPE trimming_select = SELECT
    (cartesian_point,
     parameter_value);
  END_TYPE; -- trimming_select

  TYPE unit = SELECT
    (named_unit,
     derived_unit);
  END_TYPE; -- unit

  TYPE value_qualifier = SELECT
    (precision_qualifier,
     type_qualifier,
     uncertainty_qualifier);
  END_TYPE; -- value_qualifier

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE; -- vector_or_direction

  TYPE versionable_item = SELECT
    (shape_representation,
     document_file);
  END_TYPE; -- versionable_item

  TYPE volume_measure = REAL;
  END_TYPE; -- volume_measure

  TYPE week_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 53));
  END_TYPE; -- week_in_year_number

  TYPE wireframe_model = SELECT
    (shell_based_wireframe_model,
     edge_based_wireframe_model);
  END_TYPE; -- wireframe_model

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY action;
      name          : label;
      description   : OPTIONAL text;
      chosen_method : action_method;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) 
               <= 1);
  END_ENTITY; -- action

  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
      assigned_action : action;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- action_assignment

  ENTITY action_directive;
      name        : label;
      description : OPTIONAL text;
      analysis    : text;
      comment     : text;
      requests    : SET [1:?] OF versioned_action_request;
  END_ENTITY; -- action_directive

  ENTITY action_method;
      name        : label;
      description : OPTIONAL text;
      consequence : text;
      purpose     : text;
  END_ENTITY; -- action_method

  ENTITY action_method_assignment
    ABSTRACT SUPERTYPE;
      assigned_action_method : action_method;
      role                   : action_method_role;
  END_ENTITY; -- action_method_assignment

  ENTITY action_method_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_method : action_method;
      related_method  : action_method;
  END_ENTITY; -- action_method_relationship

  ENTITY action_method_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- action_method_role

  ENTITY action_property;
      name        : label;
      description : text;
      definition  : characterized_action_definition;
  END_ENTITY; -- action_property

  ENTITY action_property_relationship;
      name                     : label;
      description              : text;
      relating_action_property : action_property;
      related_action_property  : action_property;
    WHERE
      wr1: (relating_action_property :<>: related_action_property);
  END_ENTITY; -- action_property_relationship

  ENTITY action_property_representation;
      name           : label;
      description    : text;
      property       : action_property;
      representation : representation;
  END_ENTITY; -- action_property_representation

  ENTITY action_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_action : action;
      related_action  : action;
  END_ENTITY; -- action_relationship

  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- action_request_assignment

  ENTITY action_request_solution;
      method  : action_method;
      request : versioned_action_request;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) 
               <= 1);
  END_ENTITY; -- action_request_solution

  ENTITY action_request_status;
      status           : label;
      assigned_request : versioned_action_request;
  END_ENTITY; -- action_request_status

  ENTITY action_resource;
      name        : label;
      description : OPTIONAL text;
      usage       : SET [1:?] OF supported_item;
      kind        : action_resource_type;
  END_ENTITY; -- action_resource

  ENTITY action_resource_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_resource : action_resource;
      related_resource  : action_resource;
  END_ENTITY; -- action_resource_relationship

  ENTITY action_resource_requirement;
      name        : label;
      description : text;
      kind        : resource_requirement_type;
      operations  : SET [1:?] OF characterized_action_definition;
  END_ENTITY; -- action_resource_requirement

  ENTITY action_resource_requirement_relationship;
      name                                 : label;
      description                          : text;
      relating_action_resource_requirement : action_resource_requirement;
      related_action_resource_requirement  : action_resource_requirement;
    WHERE
      wr1: (relating_action_resource_requirement :<>: 
               related_action_resource_requirement);
  END_ENTITY; -- action_resource_requirement_relationship

  ENTITY action_resource_type;
      name : label;
  END_ENTITY; -- action_resource_type

  ENTITY action_status;
      status          : label;
      assigned_action : executed_action;
  END_ENTITY; -- action_status

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    DERIVE
      name : label := get_name_value(SELF);
      url  : identifier := get_id_value(SELF);
    WHERE
      wr1: (EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number));
  END_ENTITY; -- address

  ENTITY alternate_product_relationship;
      name       : label;
      definition : OPTIONAL text;
      alternate  : product;
      base       : product;
      basis      : text;
    UNIQUE
      ur1 : alternate, base;
    WHERE
      wr1: (alternate :<>: base);
  END_ENTITY; -- alternate_product_relationship

  ENTITY amount_of_substance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- amount_of_substance_measure_with_unit

  ENTITY amount_of_substance_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 1) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- amount_of_substance_unit

  ENTITY application_context;
      application : label;
    DERIVE
      description : text := get_description_value(SELF);
      id          : identifier := get_id_value(SELF);
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) 
               <= 1);
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (library_context,product_concept_context,
        product_context,product_definition_context));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY application_context_relationship;
      name             : label;
      description      : OPTIONAL text;
      relating_context : application_context;
      related_context  : application_context;
  END_ENTITY; -- application_context_relationship

  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY; -- application_protocol_definition

  ENTITY applied_action_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF action_items;
  END_ENTITY; -- applied_action_assignment

  ENTITY applied_action_method_assignment
    SUBTYPE OF (action_method_assignment);
      items : SET [1:?] OF action_method_items;
  END_ENTITY; -- applied_action_method_assignment

  ENTITY applied_approval_assignment
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
  END_ENTITY; -- applied_approval_assignment

  ENTITY applied_attribute_classification_assignment
    SUBTYPE OF (attribute_classification_assignment);
      SELF\attribute_classification_assignment.assigned_class : class;
      items                                                   : SET [1:?]
                                                                    OF attribute_classification_item;
  END_ENTITY; -- applied_attribute_classification_assignment

  ENTITY applied_certification_assignment
    SUBTYPE OF (certification_assignment);
      items : SET [1:?] OF certification_item;
  END_ENTITY; -- applied_certification_assignment

  ENTITY applied_classification_assignment
    SUBTYPE OF (classification_assignment);
      items : SET [1:?] OF classification_item;
  END_ENTITY; -- applied_classification_assignment

  ENTITY applied_connector_on_product_definition
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : connector_on;
      items                                : SET [1:1] OF
                                                 product_definition;
  END_ENTITY; -- applied_connector_on_product_definition

  ENTITY applied_connector_on_product_definition_relationship
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : connector_on;
      items                                : SET [1:1] OF product_definition_relationship;
  END_ENTITY; -- applied_connector_on_product_definition_relationship

  ENTITY applied_contract_assignment
    SUBTYPE OF (contract_assignment);
      items : SET [1:?] OF contract_item;
  END_ENTITY; -- applied_contract_assignment

  ENTITY applied_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_item;
  END_ENTITY; -- applied_date_and_time_assignment

  ENTITY applied_date_assignment
    SUBTYPE OF (date_assignment);
      items : SET [1:?] OF date_item;
  END_ENTITY; -- applied_date_assignment

  ENTITY applied_document_reference
    SUBTYPE OF (document_reference);
      items : SET [1:?] OF document_reference_item;
  END_ENTITY; -- applied_document_reference

  ENTITY applied_document_usage_constraint_assignment
    SUBTYPE OF (document_usage_constraint_assignment);
      items : SET [1:?] OF document_reference_item;
  END_ENTITY; -- applied_document_usage_constraint_assignment

  ENTITY applied_effectivity_assignment
    SUBTYPE OF (effectivity_assignment);
      items : SET [1:?] OF effectivity_item;
  END_ENTITY; -- applied_effectivity_assignment

  ENTITY applied_event_occurrence_assignment
    SUBTYPE OF (event_occurrence_assignment);
      items : SET [1:?] OF event_occurrence_item;
  END_ENTITY; -- applied_event_occurrence_assignment

  ENTITY applied_external_identification_assignment
    SUBTYPE OF (external_identification_assignment);
      items : SET [1:?] OF external_identification_item;
  END_ENTITY; -- applied_external_identification_assignment

  ENTITY applied_group_assignment
    SUBTYPE OF (group_assignment);
      items : SET [1:?] OF groupable_item;
  END_ENTITY; -- applied_group_assignment

  ENTITY applied_identification_assignment
    SUBTYPE OF (identification_assignment);
      items : SET [1:?] OF identification_item;
  END_ENTITY; -- applied_identification_assignment

  ENTITY applied_name_assignment
    SUBTYPE OF (name_assignment);
      item : name_item;
  END_ENTITY; -- applied_name_assignment

  ENTITY applied_organization_assignment
    SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_item;
  END_ENTITY; -- applied_organization_assignment

  ENTITY applied_organizational_project_assignment
    SUBTYPE OF (organizational_project_assignment);
      items : SET [1:?] OF project_item;
  END_ENTITY; -- applied_organizational_project_assignment

  ENTITY applied_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_item;
  END_ENTITY; -- applied_person_and_organization_assignment

  ENTITY applied_security_classification_assignment
    SUBTYPE OF (security_classification_assignment);
      items : SET [1:?] OF security_classification_item;
  END_ENTITY; -- applied_security_classification_assignment

  ENTITY applied_state_assignment;
      assigned_state : state_observed;
      item_set       : SET [1:?] OF state_of_item;
      role           : state_role;
  END_ENTITY; -- applied_state_assignment

  ENTITY applied_state_type_assignment;
      assigned_state_type : state_type;
      item_set            : SET [1:?] OF state_type_of_item;
      role                : state_type_role;
  END_ENTITY; -- applied_state_type_assignment

  ENTITY applied_usage_right
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF ir_usage_item;
  END_ENTITY; -- applied_usage_right

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_approval : approval;
      related_approval  : approval;
  END_ENTITY; -- approval_relationship

  ENTITY approval_role;
      role : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.AREA_UNIT' IN 
               TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- area_measure_with_unit

  ENTITY area_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 2) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- area_unit

  ENTITY ascribable_state;
      name             : STRING;
      description      : OPTIONAL STRING;
      pertaining_state : state_type;
      ascribed_state   : state_observed;
  END_ENTITY; -- ascribable_state

  ENTITY ascribable_state_relationship;
      name                      : STRING;
      description               : OPTIONAL STRING;
      relating_ascribable_state : ascribable_state;
      related_ascribable_state  : ascribable_state;
  END_ENTITY; -- ascribable_state_relationship

  ENTITY assembly_component_usage
    SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
        specified_higher_usage_occurrence,promissory_usage_occurrence))
    SUBTYPE OF (product_definition_usage);
      reference_designator : OPTIONAL identifier;
  END_ENTITY; -- assembly_component_usage

  ENTITY assembly_component_usage_substitute;
      name       : label;
      definition : OPTIONAL text;
      base       : assembly_component_usage;
      substitute : assembly_component_usage;
    UNIQUE
      ur1 : base, substitute;
    WHERE
      wr1: (base.relating_product_definition :=: substitute.
               relating_product_definition);
      wr2: (base :<>: substitute);
  END_ENTITY; -- assembly_component_usage_substitute

  ENTITY assembly_component_usage_substitute_with_ranking
    SUBTYPE OF (assembly_component_usage_substitute);
      ranking           : INTEGER;
      ranking_rationale : text;
  END_ENTITY; -- assembly_component_usage_substitute_with_ranking

  ENTITY assigned_requirement
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : requirement_assignment;
      items                                : SET [1:1] OF
                                                 product_definition;
  END_ENTITY; -- assigned_requirement

  ENTITY attribute_classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_class : group;
      attribute_name : label;
      role           : classification_role;
  END_ENTITY; -- attribute_classification_assignment

  ENTITY attribute_language_assignment
    SUBTYPE OF (attribute_classification_assignment);
      SELF\attribute_classification_assignment.assigned_class : language;
      items                                                   : SET [1:?]
                                                                    OF attribute_language_item;
    WHERE
      wr1: (SELF\attribute_classification_assignment.role.name IN [
               'primary','translated']);
      wr2: (SELF\attribute_classification_assignment.attribute_name <> '');
  END_ENTITY; -- attribute_language_assignment

  ENTITY attribute_value_assignment
    ABSTRACT SUPERTYPE;
      attribute_name  : label;
      attribute_value : attribute_type;
      role            : attribute_value_role;
  END_ENTITY; -- attribute_value_assignment

  ENTITY attribute_value_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- attribute_value_role

  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- axis1_placement

  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- axis2_placement_2d

  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: (SELF\placement.location.dim = 3);
      wr2: ((NOT EXISTS(axis)) OR (axis.dim = 3));
      wr3: ((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3));
      wr4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0));
  END_ENTITY; -- axis2_placement_3d

  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (uniform_curve,b_spline_curve_with_knots,
        quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve)
    SUBTYPE OF (bounded_curve);
      degree              : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form          : b_spline_curve_form;
      closed_curve        : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(
                                         control_points_list) - 1;
      control_points                : ARRAY [0:
                                         upper_index_on_control_points] OF
                                          cartesian_point := list_to_array(
                                         control_points_list,0,
                                         upper_index_on_control_points);
    WHERE
      wr1: (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.UNIFORM_CURVE' 
               IN TYPEOF(SELF)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.QUASI_UNIFORM_CURVE' 
               IN TYPEOF(SELF)) OR (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.BEZIER_CURVE' 
               IN TYPEOF(SELF)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' 
               IN TYPEOF(SELF)));
  END_ENTITY; -- b_spline_curve

  ENTITY b_spline_curve_with_knots
    SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots               : LIST [2:?] OF parameter_value;
      knot_spec           : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      wr1: constraints_param_b_spline(degree,upper_index_on_knots,
               upper_index_on_control_points,knot_multiplicities,knots);
      wr2: (SIZEOF(knot_multiplicities) = upper_index_on_knots);
  END_ENTITY; -- b_spline_curve_with_knots

  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,uniform_surface,
        quasi_uniform_surface,bezier_surface) ANDOR 
        rational_b_spline_surface)
    SUBTYPE OF (bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                           cartesian_point := make_array_of_array(
                          control_points_list,0,u_upper,0,v_upper);
    WHERE
      wr1: (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.UNIFORM_SURFACE' 
               IN TYPEOF(SELF)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.QUASI_UNIFORM_SURFACE' 
               IN TYPEOF(SELF)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.BEZIER_SURFACE' 
               IN TYPEOF(SELF)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' 
               IN TYPEOF(SELF)));
  END_ENTITY; -- b_spline_surface

  ENTITY b_spline_surface_with_knots
    SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
               v_knots);
      wr3: (SIZEOF(u_multiplicities) = knot_u_upper);
      wr4: (SIZEOF(v_multiplicities) = knot_v_upper);
  END_ENTITY; -- b_spline_surface_with_knots

  ENTITY b_spline_volume
    SUPERTYPE OF (ONEOF (b_spline_volume_with_knots,uniform_volume,
        quasi_uniform_volume,bezier_volume) ANDOR rational_b_spline_volume)
    SUBTYPE OF (volume);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      w_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF
                                cartesian_point;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      w_upper        : INTEGER := SIZEOF(control_points_list[1][1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF ARRAY [0:
                          w_upper] OF cartesian_point := 
                          make_array_of_array_of_array(control_points_list,
                          0,u_upper,0,v_upper,0,w_upper);
    WHERE
      wr1: (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.BEZIER_VOLUME' 
               IN TYPEOF(SELF)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.UNIFORM_VOLUME' 
               IN TYPEOF(SELF)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.QUASI_UNIFORM_VOLUME' 
               IN TYPEOF(SELF)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.B_SPLINE_VOLUME_WITH_KNOTS' 
               IN TYPEOF(SELF)));
  END_ENTITY; -- b_spline_volume

  ENTITY b_spline_volume_with_knots
    SUBTYPE OF (b_spline_volume);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      w_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      w_knots          : LIST [2:?] OF parameter_value;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
      knot_w_upper : INTEGER := SIZEOF(w_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_volume.u_degree,
               knot_u_upper,SELF\b_spline_volume.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_volume.v_degree,
               knot_v_upper,SELF\b_spline_volume.v_upper,v_multiplicities,
               v_knots);
      wr3: constraints_param_b_spline(SELF\b_spline_volume.w_degree,
               knot_w_upper,SELF\b_spline_volume.w_upper,w_multiplicities,
               w_knots);
      wr4: (SIZEOF(u_multiplicities) = knot_u_upper);
      wr5: (SIZEOF(v_multiplicities) = knot_v_upper);
      wr6: (SIZEOF(w_multiplicities) = knot_w_upper);
  END_ENTITY; -- b_spline_volume_with_knots

  ENTITY bezier_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- bezier_curve

  ENTITY bezier_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- bezier_surface

  ENTITY bezier_volume
    SUBTYPE OF (b_spline_volume);
  END_ENTITY; -- bezier_volume

  ENTITY block
    SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
  END_ENTITY; -- block

  ENTITY block_volume
    SUBTYPE OF (volume);
      position : axis2_placement_3d;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
  END_ENTITY; -- block_volume

  ENTITY boolean_result
    SUBTYPE OF (geometric_representation_item);
      operator       : boolean_operator;
      first_operand  : boolean_operand;
      second_operand : boolean_operand;
  END_ENTITY; -- boolean_result

  ENTITY boundary_curve
    SUBTYPE OF (composite_curve_on_surface);
    WHERE
      wr1: SELF\composite_curve.closed_curve;
  END_ENTITY; -- boundary_curve

  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (polyline,b_spline_curve,trimmed_curve,
        bounded_pcurve,bounded_surface_curve,composite_curve))
    SUBTYPE OF (curve);
  END_ENTITY; -- bounded_curve

  ENTITY bounded_pcurve
    SUBTYPE OF (pcurve, bounded_curve);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.BOUNDED_CURVE' IN
                TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
  END_ENTITY; -- bounded_pcurve

  ENTITY bounded_surface
    SUPERTYPE OF (ONEOF (b_spline_surface,rectangular_trimmed_surface,
        curve_bounded_surface,rectangular_composite_surface))
    SUBTYPE OF (surface);
  END_ENTITY; -- bounded_surface

  ENTITY bounded_surface_curve
    SUBTYPE OF (surface_curve, bounded_curve);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.BOUNDED_CURVE' IN
                TYPEOF(SELF\surface_curve.curve_3d));
  END_ENTITY; -- bounded_surface_curve

  ENTITY box_domain
    SUBTYPE OF (founded_item);
      corner  : cartesian_point;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
      zlength : positive_length_measure;
    WHERE
      wr1: (SIZEOF(QUERY ( item <* USEDIN(SELF,'') | (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.BOXED_HALF_SPACE' 
               IN TYPEOF(item))) )) = 0);
  END_ENTITY; -- box_domain

  ENTITY boxed_half_space
    SUBTYPE OF (half_space_solid);
      enclosure : box_domain;
  END_ENTITY; -- boxed_half_space

  ENTITY breakdown_context
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- breakdown_context

  ENTITY breakdown_element_group_assignment
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : product_definition_element_relationship;
      items                                : SET [1:1] OF product_definition_or_breakdown_element_usage;
  END_ENTITY; -- breakdown_element_group_assignment

  ENTITY breakdown_element_realization
    SUBTYPE OF (product_definition_element_relationship);
  END_ENTITY; -- breakdown_element_realization

  ENTITY breakdown_element_usage
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- breakdown_element_usage

  ENTITY breakdown_of
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- breakdown_of

  ENTITY brep_2d
    SUBTYPE OF (solid_model);
      extent : face;
    WHERE
      wr1: (SIZEOF([
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.FACE_SURFACE',
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SUBFACE',
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_FACE'] 
               * TYPEOF(SELF.extent)) = 0);
      wr2: (SIZEOF(QUERY ( bnds <* extent.bounds | (NOT (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EDGE_LOOP' IN 
               TYPEOF(bnds.bound))) )) = 0);
      wr3: (SIZEOF(QUERY ( bnds <* extent.bounds | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.FACE_OUTER_BOUND' 
               IN TYPEOF(bnds)) )) = 1);
      wr4: (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* extent.bounds | (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EDGE_LOOP' IN 
               TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds
               .bound\path.edge_list | (NOT ((
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EDGE_CURVE' IN 
               TYPEOF(oe.edge_element)) AND (oe.edge_element\
               geometric_representation_item.dim = 2))) )) = 0)) )) = 0);
  END_ENTITY; -- brep_2d

  ENTITY brep_with_voids
    SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
  END_ENTITY; -- brep_with_voids

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY cartesian_point
    SUPERTYPE OF (ONEOF (cylindrical_point,polar_point,spherical_point))
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY; -- cartesian_point

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d,
        cartesian_transformation_operator_3d))
    SUBTYPE OF (geometric_representation_item, 
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: (scl > 0);
  END_ENTITY; -- cartesian_transformation_operator

  ENTITY cartesian_transformation_operator_2d
    SUBTYPE OF (cartesian_transformation_operator);
    DERIVE
      u : LIST [2:2] OF direction := base_axis(2,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,?);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- cartesian_transformation_operator_2d

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- cartesian_transformation_operator_3d

  ENTITY celsius_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- celsius_temperature_measure_with_unit

  ENTITY certification;
      name    : label;
      purpose : text;
      kind    : certification_type;
  END_ENTITY; -- certification

  ENTITY certification_assignment
    ABSTRACT SUPERTYPE;
      assigned_certification : certification;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- certification_assignment

  ENTITY certification_type;
      description : label;
  END_ENTITY; -- certification_type

  ENTITY characterized_object;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- characterized_object

  ENTITY characterized_object_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_object : characterized_object;
      related_object  : characterized_object;
  END_ENTITY; -- characterized_object_relationship

  ENTITY circle
    SUBTYPE OF (conic);
      radius : positive_length_measure;
  END_ENTITY; -- circle

  ENTITY circular_area
    SUBTYPE OF (primitive_2d);
      centre : cartesian_point;
      radius : positive_length_measure;
  END_ENTITY; -- circular_area

  ENTITY circular_involute
    SUBTYPE OF (curve);
      position    : axis2_placement;
      base_radius : positive_length_measure;
  END_ENTITY; -- circular_involute

  ENTITY class
    SUPERTYPE OF (ONEOF (class_by_extension,class_by_intension))
    SUBTYPE OF (group);
  END_ENTITY; -- class

  ENTITY class_by_extension
    SUBTYPE OF (class);
  END_ENTITY; -- class_by_extension

  ENTITY class_by_intension
    SUBTYPE OF (class);
  END_ENTITY; -- class_by_intension

  ENTITY classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_class : group;
      role           : classification_role;
  END_ENTITY; -- classification_assignment

  ENTITY classification_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- classification_role

  ENTITY closed_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- closed_shell

  ENTITY clothoid
    SUBTYPE OF (curve);
      position          : axis2_placement;
      clothoid_constant : length_measure;
  END_ENTITY; -- clothoid

  ENTITY complement;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      set_1       : class;
      set_2       : class;
      universe    : class;
  END_ENTITY; -- complement

  ENTITY composite_curve
    SUBTYPE OF (bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments   : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> 
                        discontinuous;
    WHERE
      wr1: (((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | (
               temp.transition = discontinuous) )) = 1)) OR (closed_curve 
               AND (SIZEOF(QUERY ( temp <* segments | (temp.transition = 
               discontinuous) )) = 0)));
  END_ENTITY; -- composite_curve

  ENTITY composite_curve_on_surface
    SUPERTYPE OF (boundary_curve)
    SUBTYPE OF (composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (SIZEOF(basis_surface) > 0);
      wr2: constraints_composite_curve_on_surface(SELF);
  END_ENTITY; -- composite_curve_on_surface

  ENTITY composite_curve_segment
    SUBTYPE OF (founded_item);
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.BOUNDED_CURVE' IN
                TYPEOF(parent_curve));
  END_ENTITY; -- composite_curve_segment

  ENTITY compound_representation_item
    SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
  END_ENTITY; -- compound_representation_item

  ENTITY concept_feature_operator;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- concept_feature_operator

  ENTITY concept_feature_relationship;
      name                             : label;
      description                      : OPTIONAL text;
      relating_product_concept_feature : product_concept_feature;
      related_product_concept_feature  : product_concept_feature;
  END_ENTITY; -- concept_feature_relationship

  ENTITY concept_feature_relationship_with_condition
    SUBTYPE OF (concept_feature_relationship);
      conditional_operator : concept_feature_operator;
  END_ENTITY; -- concept_feature_relationship_with_condition

  ENTITY conditional_concept_feature
    SUBTYPE OF (product_concept_feature);
      condition : concept_feature_relationship_with_condition;
  END_ENTITY; -- conditional_concept_feature

  ENTITY configurable_item
    SUBTYPE OF (configuration_item);
      item_concept_feature : SET [1:?] OF
                                 product_concept_feature_association;
  END_ENTITY; -- configurable_item

  ENTITY configuration_design;
      configuration : configuration_item;
      design        : configuration_design_item;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    UNIQUE
      ur1 : configuration, design;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) 
               <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- configuration_design

  ENTITY configuration_effectivity
    SUBTYPE OF (product_definition_effectivity);
      configuration : configuration_design;
    UNIQUE
      ur1 : configuration, usage, id;
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_USAGE' 
               IN TYPEOF(SELF\product_definition_effectivity.usage));
  END_ENTITY; -- configuration_effectivity

  ENTITY configuration_item;
      id           : identifier;
      name         : label;
      description  : OPTIONAL text;
      item_concept : product_concept;
      purpose      : OPTIONAL label;
  END_ENTITY; -- configuration_item

  ENTITY configuration_item_relationship;
      name                        : label;
      description                 : OPTIONAL text;
      relating_configuration_item : configuration_item;
      related_configuration_item  : configuration_item;
  END_ENTITY; -- configuration_item_relationship

  ENTITY conic
    SUPERTYPE OF (ONEOF (circle,ellipse,hyperbola,parabola))
    SUBTYPE OF (curve);
      position : axis2_placement;
  END_ENTITY; -- conic

  ENTITY conical_surface
    SUBTYPE OF (elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: (radius >= 0);
  END_ENTITY; -- conical_surface

  ENTITY connected_edge_set
    SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
  END_ENTITY; -- connected_edge_set

  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (closed_shell,open_shell))
    SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY; -- connected_face_set

  ENTITY connected_face_sub_set
    SUBTYPE OF (connected_face_set);
      parent_face_set : connected_face_set;
  END_ENTITY; -- connected_face_sub_set

  ENTITY connector_on
    SUBTYPE OF (group);
  END_ENTITY; -- connector_on

  ENTITY containing_message
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : message_contents_group;
      items                                : SET [1:1] OF
                                                 message_having_contents;
    DERIVE
      containing_message : SET [1:1] OF message_having_contents := SELF\
                              containing_message.items;
  END_ENTITY; -- containing_message

  ENTITY context_dependent_shape_representation;
      representation_relation      : shape_representation_relationship;
      represented_product_relation : product_definition_shape;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' 
               IN TYPEOF(SELF.represented_product_relation.definition));
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
      wr3: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) 
               <= 1);
  END_ENTITY; -- context_dependent_shape_representation

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
      name : label;
  END_ENTITY; -- context_dependent_unit

  ENTITY contract;
      name    : label;
      purpose : text;
      kind    : contract_type;
  END_ENTITY; -- contract

  ENTITY contract_assignment
    ABSTRACT SUPERTYPE;
      assigned_contract : contract;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- contract_assignment

  ENTITY contract_relationship;
      id                : identifier;
      name              : label;
      description       : OPTIONAL text;
      relating_contract : contract;
      related_contract  : contract;
  END_ENTITY; -- contract_relationship

  ENTITY contract_type;
      description : label;
  END_ENTITY; -- contract_type

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY; -- conversion_based_unit

  ENTITY convex_hexahedron
    SUBTYPE OF (faceted_primitive);
    WHERE
      wr1 : (SIZEOF(points) = 8);
      wr2 : (above_plane(points[1],points[2],points[3],points[4]) = 0);
      wr3 : (above_plane(points[5],points[8],points[7],points[6]) = 0);
      wr4 : (above_plane(points[1],points[4],points[8],points[5]) = 0);
      wr5 : (above_plane(points[4],points[3],points[7],points[8]) = 0);
      wr6 : (above_plane(points[3],points[2],points[6],points[7]) = 0);
      wr7 : (above_plane(points[1],points[5],points[6],points[2]) = 0);
      wr8 : same_side([points[1],points[2],points[3]],[points[5],points[6],
                points[7],points[8]]);
      wr9 : same_side([points[1],points[4],points[8]],[points[3],points[7],
                points[6],points[2]]);
      wr10: same_side([points[1],points[2],points[5]],[points[3],points[7],
                points[8],points[4]]);
      wr11: same_side([points[5],points[6],points[7]],[points[1],points[2],
                points[3],points[4]]);
      wr12: same_side([points[3],points[7],points[6]],[points[1],points[4],
                points[8],points[5]]);
      wr13: same_side([points[3],points[7],points[8]],[points[1],points[5],
                points[6],points[2]]);
  END_ENTITY; -- convex_hexahedron

  ENTITY coordinated_universal_time_offset;
      hour_offset   : INTEGER;
      minute_offset : OPTIONAL INTEGER;
      sense         : ahead_or_behind;
    DERIVE
      actual_minute_offset : INTEGER := NVL(minute_offset,0);
    WHERE
      wr1: ((0 <= hour_offset) AND (hour_offset <= 24));
      wr2: ((0 <= actual_minute_offset) AND (actual_minute_offset <= 59));
      wr3: (NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (
               sense = exact)));
  END_ENTITY; -- coordinated_universal_time_offset

  ENTITY csg_solid
    SUBTYPE OF (solid_model);
      tree_root_expression : csg_select;
  END_ENTITY; -- csg_solid

  ENTITY curve
    SUPERTYPE OF (ONEOF (line,conic,clothoid,circular_involute,pcurve,
        surface_curve,offset_curve_2d,offset_curve_3d,curve_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- curve

  ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
      basis_surface  : surface;
      boundaries     : SET [1:?] OF boundary_curve;
      implicit_outer : BOOLEAN;
    WHERE
      wr1: ((NOT implicit_outer) OR (SIZEOF(QUERY ( temp <* boundaries | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.OUTER_BOUNDARY_CURVE' 
               IN TYPEOF(temp)) )) = 0));
      wr2: ((NOT implicit_outer) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.BOUNDED_SURFACE' 
               IN TYPEOF(basis_surface)));
      wr3: (SIZEOF(QUERY ( temp <* boundaries | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.OUTER_BOUNDARY_CURVE' 
               IN TYPEOF(temp)) )) <= 1);
      wr4: (SIZEOF(QUERY ( temp <* boundaries | (temp\
               composite_curve_on_surface.basis_surface[1] <> SELF.
               basis_surface) )) = 0);
  END_ENTITY; -- curve_bounded_surface

  ENTITY curve_replica
    SUBTYPE OF (curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_curve.dim);
      wr2: acyclic_curve_replica(SELF,parent_curve);
  END_ENTITY; -- curve_replica

  ENTITY cyclide_segment_solid
    SUBTYPE OF (geometric_representation_item);
      position    : axis2_placement_3d;
      radius1     : positive_length_measure;
      radius2     : positive_length_measure;
      cone_angle1 : plane_angle_measure;
      cone_angle2 : plane_angle_measure;
      turn_angle  : plane_angle_measure;
  END_ENTITY; -- cyclide_segment_solid

  ENTITY cylindrical_point
    SUBTYPE OF (cartesian_point);
      r     : length_measure;
      theta : plane_angle_measure;
      z     : length_measure;
    DERIVE
      SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [
                                            r * COS(theta),r * SIN(theta),z];
    WHERE
      wr1: (r >= 0);
  END_ENTITY; -- cylindrical_point

  ENTITY cylindrical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- cylindrical_surface

  ENTITY cylindrical_volume
    SUBTYPE OF (volume);
      position : axis2_placement_3d;
      radius   : positive_length_measure;
      height   : positive_length_measure;
  END_ENTITY; -- cylindrical_volume

  ENTITY data_environment;
      name        : label;
      description : text;
      elements    : SET [1:?] OF property_definition_representation;
  END_ENTITY; -- data_environment

  ENTITY data_environment_relationship;
      name                      : label;
      description               : text;
      relating_data_environment : data_environment;
      related_data_environment  : data_environment;
  END_ENTITY; -- data_environment_relationship

  ENTITY date
    SUPERTYPE OF (ONEOF (calendar_date,ordinal_date,
        week_of_year_and_day_date));
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY; -- date_and_time

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role                   : date_time_role;
  END_ENTITY; -- date_and_time_assignment

  ENTITY date_assignment
    ABSTRACT SUPERTYPE;
      assigned_date : date;
      role          : date_role;
  END_ENTITY; -- date_assignment

  ENTITY date_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- date_role

  ENTITY date_time_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- date_time_role

  ENTITY dated_effectivity
    SUBTYPE OF (effectivity);
      effectivity_end_date   : OPTIONAL date_time_or_event_occurrence;
      effectivity_start_date : date_time_or_event_occurrence;
  END_ENTITY; -- dated_effectivity

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
  END_ENTITY; -- definitional_representation

  ENTITY degenerate_pcurve
    SUBTYPE OF (point);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CURVE' IN TYPEOF(
               reference_to_curve\representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- degenerate_pcurve

  ENTITY degenerate_toroidal_surface
    SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
    WHERE
      wr1: (major_radius < minor_radius);
  END_ENTITY; -- degenerate_toroidal_surface

  ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: ((SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (
               elements[1].exponent <> 1)));
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) 
               <= 1);
  END_ENTITY; -- derived_unit

  ENTITY derived_unit_element;
      unit     : named_unit;
      exponent : REAL;
  END_ENTITY; -- derived_unit_element

  ENTITY description_attribute;
      attribute_value : text;
      described_item  : description_attribute_select;
  END_ENTITY; -- description_attribute

  ENTITY descriptive_representation_item
    SUBTYPE OF (representation_item);
      description : text;
  END_ENTITY; -- descriptive_representation_item

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY; -- dimensional_exponents

  ENTITY directed_action
    SUBTYPE OF (executed_action);
      directive : action_directive;
  END_ENTITY; -- directed_action

  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0);
  END_ENTITY; -- direction

  ENTITY document;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      kind        : document_type;
    INVERSE
      representation_types : SET OF document_representation_type FOR 
                                represented_document;
  END_ENTITY; -- document

  ENTITY document_file
    SUBTYPE OF (document, characterized_object);
    WHERE
      wr1: (SELF\characterized_object.name = '');
      wr2: (NOT EXISTS(SELF\characterized_object.description));
      wr3: (SIZEOF(QUERY ( drt <* SELF\document.representation_types | (
               drt.name IN ['digital','physical']) )) = 1);
  END_ENTITY; -- document_file

  ENTITY document_product_association;
      name              : label;
      description       : OPTIONAL text;
      relating_document : document;
      related_product   : product_or_formation_or_definition;
  END_ENTITY; -- document_product_association

  ENTITY document_product_equivalence
    SUBTYPE OF (document_product_association);
    WHERE
      wr1: (SELF\document_product_association.name = 'equivalence');
      wr2: ((NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT' IN
                TYPEOF(SELF\document_product_association.related_product))) 
               OR ((SELF\document_product_association.relating_document.
               kind.product_data_type = 'configuration controlled document') 
               AND (SIZEOF(QUERY ( prpc <* USEDIN(SELF\
               document_product_association.related_product,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                | (prpc.name = 'document') )) = 1)));
      wr3: ((NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_FORMATION' 
               IN TYPEOF(SELF.related_product))) OR ((SELF\
               document_product_association.relating_document.kind.
               product_data_type = 
               'configuration controlled document version') AND (SIZEOF(
               QUERY ( prpc <* USEDIN(SELF.related_product\
               product_definition_formation.of_product,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                | (prpc.name = 'document') )) = 1)));
      wr4: ((NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION' 
               IN TYPEOF(SELF.related_product))) OR ((SELF\
               document_product_association.relating_document.kind.
               product_data_type = 
               'configuration controlled document definition') AND (SIZEOF(
               QUERY ( prpc <* USEDIN(SELF\document_product_association.
               related_product\product_definition.formation.of_product,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
                | (prpc.name = 'document') )) = 1)));
  END_ENTITY; -- document_product_equivalence

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
      assigned_document : document;
      source            : label;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- document_reference

  ENTITY document_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_document : document;
      related_document  : document;
  END_ENTITY; -- document_relationship

  ENTITY document_representation_type;
      name                 : label;
      represented_document : document;
  END_ENTITY; -- document_representation_type

  ENTITY document_type;
      product_data_type : label;
  END_ENTITY; -- document_type

  ENTITY document_usage_constraint;
      source                : document;
      subject_element       : label;
      subject_element_value : text;
  END_ENTITY; -- document_usage_constraint

  ENTITY document_usage_constraint_assignment
    ABSTRACT SUPERTYPE;
      assigned_document_usage : document_usage_constraint;
      role                    : document_usage_role;
  END_ENTITY; -- document_usage_constraint_assignment

  ENTITY document_usage_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- document_usage_role

  ENTITY document_with_class
    SUBTYPE OF (document);
      class : identifier;
  END_ENTITY; -- document_with_class

  ENTITY double_toleranced_measure_item
    SUBTYPE OF (compound_representation_item);
      SELF\compound_representation_item.item_element : list_of_two_representation_items;
  END_ENTITY; -- double_toleranced_measure_item

  ENTITY dupin_cyclide_surface
    SUBTYPE OF (elementary_surface);
      generalised_major_radius : positive_length_measure;
      generalised_minor_radius : positive_length_measure;
      skewness                 : length_measure;
    WHERE
      wr1: (skewness >= 0);
  END_ENTITY; -- dupin_cyclide_surface

  ENTITY eccentric_cone
    SUBTYPE OF (geometric_representation_item);
      position    : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      height      : positive_length_measure;
      x_offset    : length_measure;
      y_offset    : length_measure;
      ratio       : REAL;
    WHERE
      wr1: (ratio >= 0);
  END_ENTITY; -- eccentric_cone

  ENTITY eccentric_conical_volume
    SUBTYPE OF (volume);
      position    : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      height      : positive_length_measure;
      x_offset    : length_measure;
      y_offset    : length_measure;
      ratio       : REAL;
    WHERE
      wr1: (ratio >= 0);
  END_ENTITY; -- eccentric_conical_volume

  ENTITY edge
    SUPERTYPE OF (ONEOF (edge_curve,oriented_edge,subedge))
    SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY; -- edge

  ENTITY edge_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
  END_ENTITY; -- edge_based_wireframe_model

  ENTITY edge_curve
    SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense    : BOOLEAN;
  END_ENTITY; -- edge_curve

  ENTITY edge_loop
    SUBTYPE OF (loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: (SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].
               edge_end);
  END_ENTITY; -- edge_loop

  ENTITY effectivity
    SUPERTYPE OF (ONEOF (serial_numbered_effectivity,dated_effectivity,
        lot_effectivity,time_interval_based_effectivity));
      id : identifier;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) 
               <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- effectivity

  ENTITY effectivity_assignment
    ABSTRACT SUPERTYPE;
      assigned_effectivity : effectivity;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- effectivity_assignment

  ENTITY effectivity_context_assignment
    ABSTRACT SUPERTYPE;
      assigned_effectivity_assignment : effectivity_assignment;
      role                            : effectivity_context_role;
  END_ENTITY; -- effectivity_context_assignment

  ENTITY effectivity_context_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- effectivity_context_role

  ENTITY effectivity_relationship;
      name                 : label;
      description          : OPTIONAL text;
      related_effectivity  : effectivity;
      relating_effectivity : effectivity;
  END_ENTITY; -- effectivity_relationship

  ENTITY electric_current_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ELECTRIC_CURRENT_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- electric_current_measure_with_unit

  ENTITY electric_current_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 1) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- electric_current_unit

  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (plane,cylindrical_surface,conical_surface,
        spherical_surface,toroidal_surface))
    SUBTYPE OF (surface);
      position : axis2_placement_3d;
  END_ENTITY; -- elementary_surface

  ENTITY ellipse
    SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY; -- ellipse

  ENTITY ellipsoid
    SUBTYPE OF (geometric_representation_item);
      position    : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      semi_axis_3 : positive_length_measure;
  END_ENTITY; -- ellipsoid

  ENTITY ellipsoid_volume
    SUBTYPE OF (volume);
      position    : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      semi_axis_3 : positive_length_measure;
  END_ENTITY; -- ellipsoid_volume

  ENTITY elliptic_area
    SUBTYPE OF (primitive_2d);
      position    : axis2_placement_2d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY; -- elliptic_area

  ENTITY envelope
    SUBTYPE OF (characterized_object, product);
  END_ENTITY; -- envelope

  ENTITY envelope_relationship
    SUBTYPE OF (product_relationship);
  END_ENTITY; -- envelope_relationship

  ENTITY evaluated_degenerate_pcurve
    SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
  END_ENTITY; -- evaluated_degenerate_pcurve

  ENTITY event_occurrence;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- event_occurrence

  ENTITY event_occurrence_assignment
    ABSTRACT SUPERTYPE;
      assigned_event_occurrence : event_occurrence;
      role                      : event_occurrence_role;
  END_ENTITY; -- event_occurrence_assignment

  ENTITY event_occurrence_context_assignment
    ABSTRACT SUPERTYPE;
      assigned_event_occurrence_assignment : event_occurrence_assignment;
      role                                 : event_occurrence_context_role;
  END_ENTITY; -- event_occurrence_context_assignment

  ENTITY event_occurrence_context_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- event_occurrence_context_role

  ENTITY event_occurrence_relationship;
      name           : label;
      description    : OPTIONAL text;
      relating_event : event_occurrence;
      related_event  : event_occurrence;
  END_ENTITY; -- event_occurrence_relationship

  ENTITY event_occurrence_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- event_occurrence_role

  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY; -- executed_action

  ENTITY expanded_uncertainty
    SUBTYPE OF (standard_uncertainty);
      coverage_factor : REAL;
  END_ENTITY; -- expanded_uncertainty

  ENTITY experience;
      id          : STRING;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- experience

  ENTITY experience_assignment
    ABSTRACT SUPERTYPE;
      id                  : STRING;
      name                : STRING;
      description         : OPTIONAL STRING;
      role                : OPTIONAL STRING;
      assigned_experience : experience;
  END_ENTITY; -- experience_assignment

  ENTITY experience_relationship;
      id                  : STRING;
      name                : STRING;
      description         : OPTIONAL STRING;
      relating_experience : experience;
      related_experience  : experience;
  END_ENTITY; -- experience_relationship

  ENTITY experience_type;
      id          : STRING;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- experience_type

  ENTITY experience_type_assignment
    ABSTRACT SUPERTYPE;
      id                       : STRING;
      name                     : STRING;
      description              : OPTIONAL STRING;
      role                     : OPTIONAL STRING;
      assigned_experience_type : experience_type;
  END_ENTITY; -- experience_type_assignment

  ENTITY experience_type_relationship;
      id                       : STRING;
      name                     : STRING;
      description              : OPTIONAL STRING;
      relating_experience_type : experience_type;
      related_experience_type  : experience_type;
  END_ENTITY; -- experience_type_relationship

  ENTITY external_class_library
    SUBTYPE OF (external_source);
  END_ENTITY; -- external_class_library

  ENTITY external_identification_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (identification_assignment);
      source : external_source;
  END_ENTITY; -- external_identification_assignment

  ENTITY external_referent_assignment
    ABSTRACT SUPERTYPE;
      assigned_name : label;
    DERIVE
      role : object_role := get_role(SELF);
    UNIQUE
      ur1 : assigned_name;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- external_referent_assignment

  ENTITY external_source;
      source_id : source_item;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- external_source

  ENTITY external_source_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_source : external_source;
      related_source  : external_source;
  END_ENTITY; -- external_source_relationship

  ENTITY externally_defined_class
    SUBTYPE OF (class, externally_defined_item);
  END_ENTITY; -- externally_defined_class

  ENTITY externally_defined_item;
      item_id : source_item;
      source  : external_source;
  END_ENTITY; -- externally_defined_item

  ENTITY externally_defined_item_relationship;
      name          : label;
      description   : OPTIONAL text;
      relating_item : externally_defined_item;
      related_item  : externally_defined_item;
  END_ENTITY; -- externally_defined_item_relationship

  ENTITY extruded_area_solid
    SUBTYPE OF (swept_area_solid);
      extruded_direction : direction;
      depth              : positive_length_measure;
    WHERE
      wr1: (dot_product(SELF\swept_area_solid.swept_area.basis_surface\
               elementary_surface.position.p[3],extruded_direction) <> 0);
  END_ENTITY; -- extruded_area_solid

  ENTITY extruded_face_solid
    SUBTYPE OF (swept_face_solid);
      extruded_direction : direction;
      depth              : positive_length_measure;
    WHERE
      wr1: (dot_product(SELF\swept_face_solid.swept_face.face_geometry\
               elementary_surface.position.p[3],extruded_direction) <> 0);
  END_ENTITY; -- extruded_face_solid

  ENTITY face
    SUPERTYPE OF (ONEOF (face_surface,subface,oriented_face))
    SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      wr1: (NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
      wr2: (SIZEOF(QUERY ( temp <* bounds | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.FACE_OUTER_BOUND' 
               IN TYPEOF(temp)) )) <= 1);
  END_ENTITY; -- face

  ENTITY face_based_surface_model
    SUBTYPE OF (geometric_representation_item);
      fbsm_faces : SET [1:?] OF connected_face_set;
  END_ENTITY; -- face_based_surface_model

  ENTITY face_bound
    SUBTYPE OF (topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY; -- face_bound

  ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
  END_ENTITY; -- face_outer_bound

  ENTITY face_surface
    SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense    : BOOLEAN;
    WHERE
      wr1: (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_SURFACE' 
               IN TYPEOF(face_geometry)));
  END_ENTITY; -- face_surface

  ENTITY faceted_brep
    SUBTYPE OF (manifold_solid_brep);
  END_ENTITY; -- faceted_brep

  ENTITY faceted_primitive
    SUPERTYPE OF (ONEOF (tetrahedron,convex_hexahedron))
    SUBTYPE OF (geometric_representation_item);
      points : LIST [4:?] OF UNIQUE cartesian_point;
    WHERE
      wr1: (points[1].dim = 3);
  END_ENTITY; -- faceted_primitive

  ENTITY fixed_reference_swept_surface
    SUBTYPE OF (swept_surface);
      directrix       : curve;
      fixed_reference : direction;
  END_ENTITY; -- fixed_reference_swept_surface

  ENTITY founded_item;
  END_ENTITY; -- founded_item

  ENTITY functional_breakdown_context
    SUBTYPE OF (breakdown_context);
  END_ENTITY; -- functional_breakdown_context

  ENTITY functional_element_usage
    SUBTYPE OF (breakdown_element_usage);
  END_ENTITY; -- functional_element_usage

  ENTITY functionally_defined_transformation;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- functionally_defined_transformation

  ENTITY general_property;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- general_property

  ENTITY general_property_association;
      name               : label;
      description        : OPTIONAL text;
      base_definition    : general_property;
      derived_definition : derived_property_select;
    WHERE
      wr1: (SIZEOF(USEDIN(derived_definition,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION')) 
               = 1);
      wr2: (derived_definition.name = base_definition.name);
  END_ENTITY; -- general_property_association

  ENTITY general_property_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_property : general_property;
      related_property  : general_property;
  END_ENTITY; -- general_property_relationship

  ENTITY geometric_curve_set
    SUBTYPE OF (geometric_set);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF\geometric_set.elements | (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE' IN 
               TYPEOF(temp)) )) = 0);
  END_ENTITY; -- geometric_curve_set

  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY; -- geometric_representation_context

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (point,direction,vector,placement,
        cartesian_transformation_operator,curve,surface,volume))
    SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: (SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (
               NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(using_rep.context_of_items))) )) = 0);
  END_ENTITY; -- geometric_representation_item

  ENTITY geometric_set
    SUPERTYPE OF (ONEOF (geometric_curve_set,geometric_set_replica))
    SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY; -- geometric_set

  ENTITY geometric_set_replica
    SUBTYPE OF (geometric_set);
      parent_set     : geometric_set;
      transformation : cartesian_transformation_operator;
    DERIVE
      SELF\geometric_set.elements : SET [1:?] OF geometric_set_select := 
                                       build_transformed_set(transformation,
                                       parent_set);
    WHERE
      wr1: acyclic_set_replica(SELF,parent_set);
  END_ENTITY; -- geometric_set_replica

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY; -- global_uncertainty_assigned_context

  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY; -- global_unit_assigned_context

  ENTITY group;
      name        : label;
      description : OPTIONAL text;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) 
               <= 1);
  END_ENTITY; -- group

  ENTITY group_assignment
    ABSTRACT SUPERTYPE;
      assigned_group : group;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- group_assignment

  ENTITY group_relationship;
      name           : label;
      description    : OPTIONAL text;
      relating_group : group;
      related_group  : group;
  END_ENTITY; -- group_relationship

  ENTITY half_space_2d
    SUBTYPE OF (geometric_representation_item);
      base_curve     : curve;
      agreement_flag : BOOLEAN;
  END_ENTITY; -- half_space_2d

  ENTITY half_space_solid
    SUBTYPE OF (geometric_representation_item);
      base_surface   : surface;
      agreement_flag : BOOLEAN;
  END_ENTITY; -- half_space_solid

  ENTITY hexahedron_volume
    SUBTYPE OF (volume);
      points : LIST [8:8] OF cartesian_point;
    WHERE
      wr1 : (above_plane(points[1],points[2],points[3],points[4]) = 0);
      wr2 : (above_plane(points[5],points[8],points[7],points[6]) = 0);
      wr3 : (above_plane(points[1],points[4],points[8],points[5]) = 0);
      wr4 : (above_plane(points[4],points[3],points[7],points[8]) = 0);
      wr5 : (above_plane(points[3],points[2],points[6],points[7]) = 0);
      wr6 : (above_plane(points[1],points[5],points[6],points[2]) = 0);
      wr7 : same_side([points[1],points[2],points[3]],[points[5],points[6],
                points[7],points[8]]);
      wr8 : same_side([points[1],points[4],points[8]],[points[3],points[7],
                points[6],points[2]]);
      wr9 : same_side([points[1],points[2],points[5]],[points[3],points[7],
                points[8],points[4]]);
      wr10: same_side([points[5],points[6],points[7]],[points[1],points[2],
                points[3],points[4]]);
      wr11: same_side([points[3],points[7],points[6]],[points[1],points[4],
                points[8],points[5]]);
      wr12: same_side([points[3],points[7],points[8]],[points[1],points[5],
                points[6],points[2]]);
      wr13: (points[1].dim = 3);
  END_ENTITY; -- hexahedron_volume

  ENTITY hybrid_breakdown_context
    SUBTYPE OF (breakdown_context);
  END_ENTITY; -- hybrid_breakdown_context

  ENTITY hybrid_element_usage
    SUBTYPE OF (breakdown_element_usage);
  END_ENTITY; -- hybrid_element_usage

  ENTITY hyperbola
    SUBTYPE OF (conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY; -- hyperbola

  ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
  END_ENTITY; -- id_attribute

  ENTITY identification_assignment
    ABSTRACT SUPERTYPE;
      assigned_id : identifier;
      role        : identification_role;
  END_ENTITY; -- identification_assignment

  ENTITY identification_assignment_relationship;
      name                               : label;
      description                        : OPTIONAL text;
      relating_identification_assignment : identification_assignment;
      related_identification_assignment  : identification_assignment;
  END_ENTITY; -- identification_assignment_relationship

  ENTITY identification_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- identification_role

  ENTITY in_zone
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- in_zone

  ENTITY information_right
    SUBTYPE OF (action_method);
  END_ENTITY; -- information_right

  ENTITY information_usage_right
    SUBTYPE OF (action_method);
  END_ENTITY; -- information_usage_right

  ENTITY interface_connection
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- interface_connection

  ENTITY interface_connector_as_planned
    SUBTYPE OF (product_definition_formation);
  END_ENTITY; -- interface_connector_as_planned

  ENTITY interface_connector_as_realized
    SUBTYPE OF (product_definition_formation);
  END_ENTITY; -- interface_connector_as_realized

  ENTITY interface_connector_design
    SUBTYPE OF (product_definition_formation);
  END_ENTITY; -- interface_connector_design

  ENTITY interface_connector_design_to_planned
    SUBTYPE OF (product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.related_product_definition_formation  : interface_connector_as_planned;
      SELF\product_definition_formation_relationship.relating_product_definition_formation : interface_connector_design;
    WHERE
      wr1: (SELF.relating_product_definition_formation.of_product :=: SELF
               .related_product_definition_formation.of_product);
  END_ENTITY; -- interface_connector_design_to_planned

  ENTITY interface_connector_design_to_realized
    SUBTYPE OF (product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.related_product_definition_formation  : interface_connector_as_realized;
      SELF\product_definition_formation_relationship.relating_product_definition_formation : interface_connector_design;
    WHERE
      wr1: (SELF.relating_product_definition_formation.of_product :=: SELF
               .related_product_definition_formation.of_product);
  END_ENTITY; -- interface_connector_design_to_realized

  ENTITY interface_connector_planned_to_realized
    SUBTYPE OF (product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.related_product_definition_formation  : interface_connector_as_realized;
      SELF\product_definition_formation_relationship.relating_product_definition_formation : interface_connector_as_planned;
    WHERE
      wr1: (SELF.relating_product_definition_formation.of_product :=: SELF
               .related_product_definition_formation.of_product);
  END_ENTITY; -- interface_connector_planned_to_realized

  ENTITY interface_definition_for
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- interface_definition_for

  ENTITY intersection;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      operand     : SET [2:?] OF class;
      resultant   : class;
  END_ENTITY; -- intersection

  ENTITY intersection_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               <> associated_surface(SELF\surface_curve.associated_geometry
               [2]));
  END_ENTITY; -- intersection_curve

  ENTITY item_defined_transformation;
      name             : label;
      description      : OPTIONAL text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
  END_ENTITY; -- item_defined_transformation

  ENTITY item_identified_representation_usage;
      name                : label;
      description         : OPTIONAL text;
      definition          : represented_definition;
      used_representation : representation;
      identified_item     : representation_item;
    WHERE
      wr1: (SELF.used_representation IN using_representations(SELF.
               identified_item));
  END_ENTITY; -- item_identified_representation_usage

  ENTITY language
    SUBTYPE OF (group);
    WHERE
      wr1: (SELF\group.name <> '');
  END_ENTITY; -- language

  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.LENGTH_UNIT' IN 
               TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- length_measure_with_unit

  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- length_unit

  ENTITY library_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (external_referent_assignment);
      frame_of_reference : library_context;
    UNIQUE
      ur1 : frame_of_reference;
  END_ENTITY; -- library_assignment

  ENTITY library_context
    SUBTYPE OF (application_context_element);
      library_reference : label;
  END_ENTITY; -- library_context

  ENTITY line
    SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      wr1: (dir.dim = pnt.dim);
  END_ENTITY; -- line

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY; -- local_time

  ENTITY location;
      id          : STRING;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- location

  ENTITY location_assignment
    ABSTRACT SUPERTYPE;
      id                : STRING;
      name              : STRING;
      description       : OPTIONAL STRING;
      role              : OPTIONAL STRING;
      assigned_location : location;
  END_ENTITY; -- location_assignment

  ENTITY location_relationship;
      id                : STRING;
      name              : STRING;
      description       : OPTIONAL STRING;
      relating_location : location;
      related_location  : location;
  END_ENTITY; -- location_relationship

  ENTITY location_representation_assignment
    ABSTRACT SUPERTYPE;
      id                   : STRING;
      name                 : STRING;
      description          : OPTIONAL STRING;
      role                 : OPTIONAL STRING;
      represented_location : location;
  END_ENTITY; -- location_representation_assignment

  ENTITY loop
    SUPERTYPE OF (ONEOF (vertex_loop,edge_loop,poly_loop))
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- loop

  ENTITY lot_effectivity
    SUBTYPE OF (effectivity);
      effectivity_lot_id   : identifier;
      effectivity_lot_size : measure_with_unit;
  END_ENTITY; -- lot_effectivity

  ENTITY luminous_intensity_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.LUMINOUS_INTENSITY_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- luminous_intensity_measure_with_unit

  ENTITY luminous_intensity_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 1));
  END_ENTITY; -- luminous_intensity_unit

  ENTITY make_from_usage_option
    SUBTYPE OF (product_definition_usage);
      ranking           : INTEGER;
      ranking_rationale : text;
      quantity          : measure_with_unit;
    WHERE
      wr1: ((NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (
               quantity.value_component > 0));
  END_ENTITY; -- make_from_usage_option

  ENTITY make_from_usage_option_group;
      members : SET [2:?] OF make_from_usage_option;
    WHERE
      wr1: (SIZEOF(QUERY ( example <* members | (example.
               related_product_definition :=: members[1].
               related_product_definition) )) = SIZEOF(members));
  END_ENTITY; -- make_from_usage_option_group

  ENTITY manifold_solid_brep
    SUBTYPE OF (solid_model);
      outer : closed_shell;
  END_ENTITY; -- manifold_solid_brep

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]);
  END_ENTITY; -- mapped_item

  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.MASS_UNIT' IN 
               TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- mass_measure_with_unit

  ENTITY mass_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 1) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- mass_unit

  ENTITY material_designation;
      name        : label;
      definitions : SET [1:?] OF characterized_definition;
  END_ENTITY; -- material_designation

  ENTITY material_designation_characterization;
      name        : label;
      description : text;
      designation : material_designation;
      property    : characterized_material_property;
  END_ENTITY; -- material_designation_characterization

  ENTITY material_property
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : name, definition;
    WHERE
      wr1: (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CHARACTERIZED_OBJECT' 
               IN TYPEOF(SELF\property_definition.definition)) OR (SIZEOF(
               bag_to_set(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) 
               - QUERY ( temp <* bag_to_set(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))
                | (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.' + 
               'MATERIAL_PROPERTY_REPRESENTATION') IN TYPEOF(temp)) )) = 0));
  END_ENTITY; -- material_property

  ENTITY material_property_representation
    SUBTYPE OF (property_definition_representation);
      dependent_environment : data_environment;
  END_ENTITY; -- material_property_representation

  ENTITY measure_qualification;
      name              : label;
      description       : text;
      qualified_measure : measure_with_unit;
      qualifiers        : SET [1:?] OF value_qualifier;
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* qualifiers | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRECISION_QUALIFIER' 
               IN TYPEOF(temp)) )) < 2);
  END_ENTITY; -- measure_qualification

  ENTITY measure_representation_item
    SUBTYPE OF (representation_item, measure_with_unit);
  END_ENTITY; -- measure_representation_item

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (length_measure_with_unit,mass_measure_with_unit,
        time_measure_with_unit,electric_current_measure_with_unit,
        thermodynamic_temperature_measure_with_unit,
        celsius_temperature_measure_with_unit,
        amount_of_substance_measure_with_unit,
        luminous_intensity_measure_with_unit,plane_angle_measure_with_unit,
        solid_angle_measure_with_unit,area_measure_with_unit,
        volume_measure_with_unit,ratio_measure_with_unit));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY; -- measure_with_unit

  ENTITY message_contents_assignment
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : message_contents_group;
      items                                : SET [1:?] OF contents_item;
  END_ENTITY; -- message_contents_assignment

  ENTITY message_contents_group
    SUBTYPE OF (group);
  END_ENTITY; -- message_contents_group

  ENTITY message_relationship
    SUBTYPE OF (product_relationship);
      SELF\product_relationship.related_product  : structured_message;
      SELF\product_relationship.relating_product : structured_message;
    DERIVE
      related_message  : structured_message := SELF\product_relationship.
                            related_product;
      relating_message : structured_message := SELF\product_relationship.
                            relating_product;
  END_ENTITY; -- message_relationship

  ENTITY multi_language_attribute_assignment
    SUBTYPE OF (attribute_value_assignment);
      items : SET [1:?] OF multi_language_attribute_item;
    DERIVE
      translation_language : language := language_indication[1]\
                                attribute_classification_assignment.
                                assigned_class;
    INVERSE
      language_indication : SET [1:1] OF attribute_language_assignment FOR 
                               items;
    WHERE
      wr1: (SELF\attribute_value_assignment.role.name = 
               'alternate language');
      wr2: (SIZEOF(QUERY ( ala <* language_indication | ((ala\
               attribute_classification_assignment.attribute_name = 
               'attribute_value') AND (ala\
               attribute_classification_assignment.role.name = 'translated')) )) 
               = 1);
      wr3: (SELF\attribute_value_assignment.attribute_name <> '');
      wr4: (SIZEOF(QUERY ( ci <* items | (SIZEOF(QUERY ( ata <* USEDIN(ci,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS')
                | ((ata\attribute_value_assignment.attribute_name = SELF\
               attribute_value_assignment.attribute_name) AND (ata.
               translation_language :=: translation_language)) )) > 1) )) =
                0);
      wr5: (SIZEOF(QUERY ( ci <* items | (SIZEOF(QUERY ( ata <* USEDIN(ci,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')
                | ((ata\attribute_classification_assignment.role.name = 
               'primary') AND (ata\attribute_classification_assignment.
               attribute_name = SELF\attribute_value_assignment.
               attribute_name) AND (ata\attribute_classification_assignment
               .assigned_class :=: translation_language)) )) > 0) )) = 0);
  END_ENTITY; -- multi_language_attribute_assignment

  ENTITY name_assignment
    ABSTRACT SUPERTYPE;
      assigned_name : label;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- name_assignment

  ENTITY name_attribute;
      attribute_value : label;
      named_item      : name_attribute_select;
  END_ENTITY; -- name_attribute

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (si_unit,conversion_based_unit,
        context_dependent_unit) ANDOR ONEOF (length_unit,mass_unit,
        time_unit,electric_current_unit,thermodynamic_temperature_unit,
        amount_of_substance_unit,luminous_intensity_unit,plane_angle_unit,
        solid_angle_unit,area_unit,volume_unit,ratio_unit));
      dimensions : dimensional_exponents;
  END_ENTITY; -- named_unit

  ENTITY next_assembly_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- next_assembly_usage_occurrence

  ENTITY object_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- object_role

  ENTITY offset_curve_2d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
    WHERE
      wr1: (basis_curve.dim = 2);
  END_ENTITY; -- offset_curve_2d

  ENTITY offset_curve_3d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
      ref_direction  : direction;
    WHERE
      wr1: ((basis_curve.dim = 3) AND (ref_direction.dim = 3));
  END_ENTITY; -- offset_curve_3d

  ENTITY offset_surface
    SUBTYPE OF (surface);
      basis_surface  : surface;
      distance       : length_measure;
      self_intersect : LOGICAL;
  END_ENTITY; -- offset_surface

  ENTITY open_path
    SUBTYPE OF (path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: (SELF\path.edge_list[1].edge_element.edge_start :<>: SELF\path.
               edge_list[ne].edge_element.edge_end);
  END_ENTITY; -- open_path

  ENTITY open_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- open_shell

  ENTITY ordinal_date
    SUBTYPE OF (date);
      day_component : day_in_year_number;
    WHERE
      wr1: (((NOT leap_year(SELF.year_component)) AND (1 <= day_component) 
               AND (day_component <= 365)) OR (leap_year(SELF.
               year_component) AND (1 <= day_component) AND (day_component 
               <= 366)));
  END_ENTITY; -- ordinal_date

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- organization

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role                  : organization_role;
  END_ENTITY; -- organization_assignment

  ENTITY organization_relationship;
      name                  : label;
      description           : OPTIONAL text;
      relating_organization : organization;
      related_organization  : organization;
  END_ENTITY; -- organization_relationship

  ENTITY organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- organization_role

  ENTITY organization_type;
      id          : STRING;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- organization_type

  ENTITY organization_type_assignment
    ABSTRACT SUPERTYPE;
      id                         : STRING;
      name                       : STRING;
      description                : OPTIONAL STRING;
      role                       : OPTIONAL STRING;
      assigned_organization_type : organization_type;
  END_ENTITY; -- organization_type_assignment

  ENTITY organization_type_relationship;
      id                         : STRING;
      name                       : STRING;
      description                : OPTIONAL STRING;
      relating_organization_type : organization_type;
      related_organization_type  : organization_type;
  END_ENTITY; -- organization_type_relationship

  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : OPTIONAL text;
  END_ENTITY; -- organizational_address

  ENTITY organizational_project;
      name                      : label;
      description               : OPTIONAL text;
      responsible_organizations : SET [1:?] OF organization;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) 
               <= 1);
  END_ENTITY; -- organizational_project

  ENTITY organizational_project_assignment
    ABSTRACT SUPERTYPE;
      assigned_organizational_project : organizational_project;
      role                            : organizational_project_role;
  END_ENTITY; -- organizational_project_assignment

  ENTITY organizational_project_relationship;
      name                            : label;
      description                     : OPTIONAL text;
      relating_organizational_project : organizational_project;
      related_organizational_project  : organizational_project;
  END_ENTITY; -- organizational_project_relationship

  ENTITY organizational_project_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- organizational_project_role

  ENTITY oriented_closed_shell
    SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation          : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             closed_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_CLOSED_SHELL' 
               IN TYPEOF(SELF.closed_shell_element)));
  END_ENTITY; -- oriented_closed_shell

  ENTITY oriented_edge
    SUBTYPE OF (edge);
      edge_element : edge;
      orientation  : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_start,SELF.
                                edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_end,SELF.
                                edge_element.edge_start);
    WHERE
      wr1: (NOT (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_EDGE' 
               IN TYPEOF(SELF.edge_element)));
  END_ENTITY; -- oriented_edge

  ENTITY oriented_face
    SUBTYPE OF (face);
      face_element : face;
      orientation  : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(
                            SELF.orientation,SELF.face_element.bounds);
    WHERE
      wr1: (NOT (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_FACE' 
               IN TYPEOF(SELF.face_element)));
  END_ENTITY; -- oriented_face

  ENTITY oriented_open_shell
    SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation        : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             open_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_OPEN_SHELL' 
               IN TYPEOF(SELF.open_shell_element)));
  END_ENTITY; -- oriented_open_shell

  ENTITY oriented_path
    SUBTYPE OF (path);
      path_element : path;
      orientation  : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := 
                               conditional_reverse(SELF.orientation,SELF.
                               path_element.edge_list);
    WHERE
      wr1: (NOT (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_PATH' 
               IN TYPEOF(SELF.path_element)));
  END_ENTITY; -- oriented_path

  ENTITY oriented_surface
    SUBTYPE OF (surface);
      orientation : BOOLEAN;
  END_ENTITY; -- oriented_surface

  ENTITY outer_boundary_curve
    SUBTYPE OF (boundary_curve);
  END_ENTITY; -- outer_boundary_curve

  ENTITY parabola
    SUBTYPE OF (conic);
      focal_dist : length_measure;
    WHERE
      wr1: (focal_dist <> 0);
  END_ENTITY; -- parabola

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY; -- parametric_representation_context

  ENTITY path
    SUPERTYPE OF (ONEOF (open_path,edge_loop,oriented_path))
    SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
    WHERE
      wr1: path_head_to_tail(SELF);
  END_ENTITY; -- path

  ENTITY pcurve
    SUBTYPE OF (curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CURVE' IN TYPEOF(
               reference_to_curve\representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- pcurve

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    WHERE
      wr1: (EXISTS(last_name) OR EXISTS(first_name));
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) 
               <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_address
    SUBTYPE OF (organizational_address, personal_address);
      SELF\personal_address.people              : SET [1:1] OF person;
      SELF\organizational_address.organizations : SET [1:1] OF
                                                      organization;
    WHERE
      wr1: (SIZEOF(QUERY ( pao <* USEDIN(SELF\personal_address.people[1],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON')
                | (pao.the_organization :=: SELF\organizational_address.
               organizations[1]) )) = 1);
  END_ENTITY; -- person_and_organization_address

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- person_and_organization_role

  ENTITY person_assignment
    ABSTRACT SUPERTYPE;
      assigned_person : person;
      role            : person_role;
  END_ENTITY; -- person_assignment

  ENTITY person_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- person_role

  ENTITY person_type;
      id          : STRING;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- person_type

  ENTITY person_type_assignment
    ABSTRACT SUPERTYPE;
      id                   : STRING;
      name                 : STRING;
      description          : OPTIONAL STRING;
      role                 : OPTIONAL STRING;
      assigned_person_type : person_type;
  END_ENTITY; -- person_type_assignment

  ENTITY person_type_definition;
      id          : STRING;
      name        : STRING;
      description : OPTIONAL STRING;
      formation   : person_type_definition_formation;
  END_ENTITY; -- person_type_definition

  ENTITY person_type_definition_assignment
    ABSTRACT SUPERTYPE;
      id                              : STRING;
      name                            : STRING;
      description                     : OPTIONAL STRING;
      role                            : OPTIONAL STRING;
      assigned_person_type_definition : person_type_definition;
  END_ENTITY; -- person_type_definition_assignment

  ENTITY person_type_definition_formation;
      id             : STRING;
      name           : STRING;
      description    : OPTIONAL STRING;
      of_person_type : person_type;
  END_ENTITY; -- person_type_definition_formation

  ENTITY person_type_definition_relationship;
      id                              : STRING;
      name                            : STRING;
      description                     : OPTIONAL STRING;
      relating_person_type_definition : person_type_definition;
      related_person_type_definition  : person_type_definition;
  END_ENTITY; -- person_type_definition_relationship

  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : OPTIONAL text;
  END_ENTITY; -- personal_address

  ENTITY physical_breakdown_context
    SUBTYPE OF (breakdown_context);
  END_ENTITY; -- physical_breakdown_context

  ENTITY physical_element_usage
    SUBTYPE OF (breakdown_element_usage);
  END_ENTITY; -- physical_element_usage

  ENTITY placement
    SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d,
        axis2_placement_3d))
    SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY; -- placement

  ENTITY plane
    SUBTYPE OF (elementary_surface);
  END_ENTITY; -- plane

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PLANE_ANGLE_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- plane_angle_measure_with_unit

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- plane_angle_unit

  ENTITY point
    SUPERTYPE OF (ONEOF (cartesian_point,point_on_curve,point_on_surface,
        point_in_volume,point_replica,degenerate_pcurve))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- point

  ENTITY point_in_volume
    SUBTYPE OF (point);
      basis_volume      : volume;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
      point_parameter_w : parameter_value;
  END_ENTITY; -- point_in_volume

  ENTITY point_on_curve
    SUBTYPE OF (point);
      basis_curve     : curve;
      point_parameter : parameter_value;
  END_ENTITY; -- point_on_curve

  ENTITY point_on_surface
    SUBTYPE OF (point);
      basis_surface     : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
  END_ENTITY; -- point_on_surface

  ENTITY point_replica
    SUBTYPE OF (point);
      parent_pt      : point;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_pt.dim);
      wr2: acyclic_point_replica(SELF,parent_pt);
  END_ENTITY; -- point_replica

  ENTITY polar_point
    SUBTYPE OF (cartesian_point);
      r     : length_measure;
      theta : plane_angle_measure;
    DERIVE
      SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [
                                            r * COS(theta),r * SIN(theta)];
    WHERE
      wr1: (r >= 0);
  END_ENTITY; -- polar_point

  ENTITY poly_loop
    SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY; -- poly_loop

  ENTITY polygonal_area
    SUBTYPE OF (primitive_2d);
      bounds : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY; -- polygonal_area

  ENTITY polyline
    SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY; -- polyline

  ENTITY position_in_organization;
      id          : STRING;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- position_in_organization

  ENTITY position_in_organization_assignment
    ABSTRACT SUPERTYPE;
      id                                : STRING;
      name                              : STRING;
      description                       : OPTIONAL STRING;
      role                              : OPTIONAL STRING;
      assigned_position_in_organization : position_in_organization;
  END_ENTITY; -- position_in_organization_assignment

  ENTITY position_in_organization_relationship;
      id                                : STRING;
      name                              : STRING;
      description                       : OPTIONAL STRING;
      relating_position_in_organization : position_in_organization;
      related_position_in_organization  : position_in_organization;
  END_ENTITY; -- position_in_organization_relationship

  ENTITY position_in_organization_type;
      id          : STRING;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- position_in_organization_type

  ENTITY position_in_organization_type_assignment
    ABSTRACT SUPERTYPE;
      id                                     : STRING;
      name                                   : STRING;
      description                            : OPTIONAL STRING;
      role                                   : OPTIONAL STRING;
      assigned_position_in_organization_type : position_in_organization_type;
  END_ENTITY; -- position_in_organization_type_assignment

  ENTITY power_set;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      base        : class;
      derived     : class;
  END_ENTITY; -- power_set

  ENTITY pre_defined_item;
      name : label;
  END_ENTITY; -- pre_defined_item

  ENTITY precision_qualifier;
      precision_value : INTEGER;
  END_ENTITY; -- precision_qualifier

  ENTITY primitive_2d
    SUPERTYPE OF (ONEOF (circular_area,elliptic_area,rectangular_area,
        polygonal_area))
    SUBTYPE OF (geometric_representation_item);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- primitive_2d

  ENTITY process_product_association;
      name            : label;
      description     : text;
      defined_product : characterized_product_definition;
      process         : product_definition_process;
  END_ENTITY; -- process_product_association

  ENTITY process_property_association;
      name              : label;
      description       : text;
      process           : property_process;
      property_or_shape : property_or_shape_select;
  END_ENTITY; -- process_property_association

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY; -- product

  ENTITY product_as_individual
    ABSTRACT SUPERTYPE OF (ONEOF (product_as_planned,product_as_realized))
    SUBTYPE OF (product_definition_formation);
  END_ENTITY; -- product_as_individual

  ENTITY product_as_planned
    SUBTYPE OF (product_as_individual);
  END_ENTITY; -- product_as_planned

  ENTITY product_as_realized
    SUBTYPE OF (product_as_individual);
  END_ENTITY; -- product_as_realized

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) 
               <= 1);
  END_ENTITY; -- product_category

  ENTITY product_category_relationship;
      name         : label;
      description  : OPTIONAL text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY; -- product_category_relationship

  ENTITY product_concept;
      id             : identifier;
      name           : label;
      description    : OPTIONAL text;
      market_context : product_concept_context;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- product_concept

  ENTITY product_concept_context
    SUBTYPE OF (application_context_element);
      market_segment_type : label;
  END_ENTITY; -- product_concept_context

  ENTITY product_concept_feature;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- product_concept_feature

  ENTITY product_concept_feature_association;
      name        : label;
      description : OPTIONAL text;
      concept     : product_concept;
      feature     : product_concept_feature;
  END_ENTITY; -- product_concept_feature_association

  ENTITY product_concept_relationship;
      name                     : label;
      description              : OPTIONAL text;
      relating_product_concept : product_concept;
      related_product_concept  : product_concept;
  END_ENTITY; -- product_concept_relationship

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition;
      id                 : identifier;
      description        : OPTIONAL text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) 
               <= 1);
  END_ENTITY; -- product_definition

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY; -- product_definition_context

  ENTITY product_definition_context_association;
      definition         : product_definition;
      frame_of_reference : product_definition_context;
      role               : product_definition_context_role;
  END_ENTITY; -- product_definition_context_association

  ENTITY product_definition_context_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- product_definition_context_role

  ENTITY product_definition_effectivity
    SUBTYPE OF (effectivity);
      usage : product_definition_relationship;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) 
               = 0);
  END_ENTITY; -- product_definition_effectivity

  ENTITY product_definition_element_relationship
    SUBTYPE OF (group);
  END_ENTITY; -- product_definition_element_relationship

  ENTITY product_definition_formation;
      id          : identifier;
      description : OPTIONAL text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_formation_relationship;
      id                                    : identifier;
      name                                  : label;
      description                           : OPTIONAL text;
      relating_product_definition_formation : product_definition_formation;
      related_product_definition_formation  : product_definition_formation;
  END_ENTITY; -- product_definition_formation_relationship

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
      make_or_buy : source;
  END_ENTITY; -- product_definition_formation_with_specified_source

  ENTITY product_definition_group_assignment
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : product_definition_element_relationship;
      items                                : SET [1:1] OF product_definition_or_product_definition_relationship;
  END_ENTITY; -- product_definition_group_assignment

  ENTITY product_definition_occurrence_relationship;
      name             : label;
      description      : OPTIONAL text;
      occurrence       : product_definition;
      occurrence_usage : assembly_component_usage;
    WHERE
      wr1: (occurrence_usage.relating_product_definition :<>: occurrence);
      wr2: (occurrence_usage.related_product_definition :<>: occurrence);
      wr3: (occurrence.formation :=: occurrence_usage.
               related_product_definition.formation);
  END_ENTITY; -- product_definition_occurrence_relationship

  ENTITY product_definition_process
    SUBTYPE OF (action);
      identification : identifier;
    INVERSE
      product_definitions : SET [1:?] OF process_product_association FOR 
                               process;
  END_ENTITY; -- product_definition_process

  ENTITY product_definition_relationship
    SUPERTYPE OF (ONEOF (breakdown_context,breakdown_element_usage,
        breakdown_of,in_zone,interface_connection,interface_definition_for,
        product_in_slot,slot_on_product));
      id                          : identifier;
      name                        : label;
      description                 : OPTIONAL text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY; -- product_definition_relationship

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : definition;
    WHERE
      wr1: (SIZEOF(['AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION','AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CHARACTERIZED_OBJECT'] 
               * TYPEOF(SELF\property_definition.definition)) > 0);
  END_ENTITY; -- product_definition_shape

  ENTITY product_definition_substitute;
      description           : OPTIONAL text;
      context_relationship  : product_definition_relationship;
      substitute_definition : product_definition;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: (context_relationship.related_product_definition :<>: 
               substitute_definition);
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) 
               <= 1);
  END_ENTITY; -- product_definition_substitute

  ENTITY product_definition_usage
    SUPERTYPE OF (ONEOF (make_from_usage_option,assembly_component_usage))
    SUBTYPE OF (product_definition_relationship);
    UNIQUE
      ur1 : id, relating_product_definition, related_product_definition;
    WHERE
      wr1: acyclic_product_definition_relationship(SELF,[SELF\
               product_definition_relationship.related_product_definition],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_USAGE');
  END_ENTITY; -- product_definition_usage

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
  END_ENTITY; -- product_definition_with_associated_documents

  ENTITY product_design_to_individual
    SUBTYPE OF (product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.related_product_definition_formation  : product_as_individual;
    DERIVE
      individual_product : product_as_individual := SELF\
                              product_definition_formation_relationship.
                              related_product_definition_formation;
      product_version    : product_definition_formation := SELF\
                              product_definition_formation_relationship.
                              relating_product_definition_formation;
  END_ENTITY; -- product_design_to_individual

  ENTITY product_in_slot
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- product_in_slot

  ENTITY product_material_composition_relationship
    SUBTYPE OF (product_definition_relationship);
      class                : label;
      constituent_amount   : SET [1:?] OF measure_with_unit;
      composition_basis    : label;
      determination_method : text;
  END_ENTITY; -- product_material_composition_relationship

  ENTITY product_planned_to_realized
    SUBTYPE OF (product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.relating_product_definition_formation : product_as_planned;
      SELF\product_definition_formation_relationship.related_product_definition_formation  : product_as_realized;
    DERIVE
      planned_product  : product_as_planned := SELF\
                            product_definition_formation_relationship.
                            relating_product_definition_formation;
      realized_product : product_as_realized := SELF\
                            product_definition_formation_relationship.
                            related_product_definition_formation;
  END_ENTITY; -- product_planned_to_realized

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY; -- product_related_product_category

  ENTITY product_relationship;
      id               : identifier;
      name             : label;
      description      : OPTIONAL text;
      relating_product : product;
      related_product  : product;
  END_ENTITY; -- product_relationship

  ENTITY promissory_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- promissory_usage_occurrence

  ENTITY proper_subset;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      subset      : class;
      superset    : class;
  END_ENTITY; -- proper_subset

  ENTITY property_definition;
      name        : label;
      description : OPTIONAL text;
      definition  : characterized_definition;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) 
               <= 1);
  END_ENTITY; -- property_definition

  ENTITY property_definition_relationship;
      name                         : label;
      description                  : text;
      relating_property_definition : property_definition;
      related_property_definition  : property_definition;
  END_ENTITY; -- property_definition_relationship

  ENTITY property_definition_representation;
      definition          : represented_definition;
      used_representation : representation;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) 
               <= 1);
  END_ENTITY; -- property_definition_representation

  ENTITY property_process
    SUBTYPE OF (action);
      identification : identifier;
    INVERSE
      properties : SET [1:?] OF process_property_association FOR process;
  END_ENTITY; -- property_process

  ENTITY pyramid_volume
    SUBTYPE OF (volume);
      position : axis2_placement_3d;
      xlength  : positive_length_measure;
      ylength  : positive_length_measure;
      height   : positive_length_measure;
  END_ENTITY; -- pyramid_volume

  ENTITY qualification_type;
      id          : STRING;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- qualification_type

  ENTITY qualification_type_assignment
    ABSTRACT SUPERTYPE;
      id                          : STRING;
      name                        : STRING;
      description                 : OPTIONAL STRING;
      role                        : OPTIONAL STRING;
      assigned_qualification_type : qualification_type;
  END_ENTITY; -- qualification_type_assignment

  ENTITY qualification_type_relationship;
      id                          : STRING;
      name                        : STRING;
      description                 : OPTIONAL STRING;
      relating_qualification_type : qualification_type;
      related_qualification_type  : qualification_type;
  END_ENTITY; -- qualification_type_relationship

  ENTITY qualified_representation_item
    SUBTYPE OF (representation_item);
      qualifiers : SET [1:?] OF value_qualifier;
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* qualifiers | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRECISION_QUALIFIER' 
               IN TYPEOF(temp)) )) < 2);
  END_ENTITY; -- qualified_representation_item

  ENTITY qualitative_uncertainty
    SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : text;
  END_ENTITY; -- qualitative_uncertainty

  ENTITY quantified_assembly_component_usage
    SUBTYPE OF (assembly_component_usage);
      quantity : measure_with_unit;
    WHERE
      wr1: ((NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (
               quantity.value_component > 0));
  END_ENTITY; -- quantified_assembly_component_usage

  ENTITY quasi_uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- quasi_uniform_curve

  ENTITY quasi_uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- quasi_uniform_surface

  ENTITY quasi_uniform_volume
    SUBTYPE OF (b_spline_volume);
  END_ENTITY; -- quasi_uniform_volume

  ENTITY ratio_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.RATIO_UNIT' IN 
               TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- ratio_measure_with_unit

  ENTITY ratio_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- ratio_unit

  ENTITY rational_b_spline_curve
    SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := 
                   list_to_array(weights_data,0,
                   upper_index_on_control_points);
    WHERE
      wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
               control_points_list));
      wr2: curve_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_curve

  ENTITY rational_b_spline_surface
    SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := 
                   make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      wr1: ((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_surface.control_points_list[1])));
      wr2: surface_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_surface

  ENTITY rational_b_spline_volume
    SUBTYPE OF (b_spline_volume);
      weights_data : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF ARRAY [0:w_upper]
                    OF REAL := make_array_of_array_of_array(weights_data,0,
                   u_upper,0,v_upper,0,w_upper);
    WHERE
      wr1: ((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_volume.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_volume.control_points_list[1])) AND (SIZEOF(
               weights_data[1][1]) = SIZEOF(SELF\b_spline_volume.
               control_points_list[1][1])));
      wr2: volume_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_volume

  ENTITY rectangle_domain
    SUBTYPE OF (founded_item);
      corner  : cartesian_point;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
    WHERE
      wr1: (SIZEOF(QUERY ( item <* USEDIN(SELF,'') | (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.RECTANGLED_HALF_SPACE' 
               IN TYPEOF(item))) )) = 0);
  END_ENTITY; -- rectangle_domain

  ENTITY rectangled_half_space
    SUBTYPE OF (half_space_2d);
      enclosure : rectangle_domain;
  END_ENTITY; -- rectangled_half_space

  ENTITY rectangular_area
    SUBTYPE OF (primitive_2d);
      position : axis2_placement_2d;
      x        : positive_length_measure;
      y        : positive_length_measure;
  END_ENTITY; -- rectangular_area

  ENTITY rectangular_composite_surface
    SUBTYPE OF (bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
    DERIVE
      n_u : INTEGER := SIZEOF(segments);
      n_v : INTEGER := SIZEOF(segments[1]);
    WHERE
      wr1: (SIZEOF(QUERY ( s <* segments | (n_v <> SIZEOF(s)) )) = 0);
      wr2: constraints_rectangular_composite_surface(SELF);
  END_ENTITY; -- rectangular_composite_surface

  ENTITY rectangular_pyramid
    SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      xlength  : positive_length_measure;
      ylength  : positive_length_measure;
      height   : positive_length_measure;
  END_ENTITY; -- rectangular_pyramid

  ENTITY rectangular_trimmed_surface
    SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      u1            : parameter_value;
      u2            : parameter_value;
      v1            : parameter_value;
      v2            : parameter_value;
      usense        : BOOLEAN;
      vsense        : BOOLEAN;
    WHERE
      wr1: (u1 <> u2);
      wr2: (v1 <> v2);
      wr3: ((('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ELEMENTARY_SURFACE' 
               IN TYPEOF(basis_surface)) AND (NOT (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PLANE' IN 
               TYPEOF(basis_surface)))) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE_OF_REVOLUTION' 
               IN TYPEOF(basis_surface)) OR (usense = (u2 > u1)));
      wr4: (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SPHERICAL_SURFACE' 
               IN TYPEOF(basis_surface)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.TOROIDAL_SURFACE' 
               IN TYPEOF(basis_surface)) OR (vsense = (v2 > v1)));
  END_ENTITY; -- rectangular_trimmed_surface

  ENTITY relative_event_occurrence
    SUBTYPE OF (event_occurrence);
      base_event : event_occurrence;
      offset     : time_measure_with_unit;
  END_ENTITY; -- relative_event_occurrence

  ENTITY reparametrised_composite_curve_segment
    SUBTYPE OF (composite_curve_segment);
      param_length : parameter_value;
    WHERE
      wr1: (param_length > 0);
  END_ENTITY; -- reparametrised_composite_curve_segment

  ENTITY replacement_relationship
    SUBTYPE OF (action_relationship);
    WHERE
      wr1: acyclic_action_relationship(SELF,[SELF\action_relationship.
               related_action],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.REPLACEMENT_RELATIONSHIP');
  END_ENTITY; -- replacement_relationship

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id          : identifier := get_id_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) 
               <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- representation

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR 
                                      context_of_items;
  END_ENTITY; -- representation_context

  ENTITY representation_item;
      name : label;
    WHERE
      wr1: (SIZEOF(using_representations(SELF)) > 0);
  END_ENTITY; -- representation_item

  ENTITY representation_item_relationship;
      name                         : label;
      description                  : OPTIONAL text;
      relating_representation_item : representation_item;
      related_representation_item  : representation_item;
  END_ENTITY; -- representation_item_relationship

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY; -- representation_map

  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY; -- representation_relationship

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      wr1: (SELF\representation_relationship.rep_1.context_of_items :<>: 
               SELF\representation_relationship.rep_2.context_of_items);
  END_ENTITY; -- representation_relationship_with_transformation

  ENTITY requirement_assigned_object
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : requirement_assignment;
      items                                : SET [1:1] OF
                                                 requirement_assigned_item;
  END_ENTITY; -- requirement_assigned_object

  ENTITY requirement_assignment
    SUBTYPE OF (characterized_object, group);
  END_ENTITY; -- requirement_assignment

  ENTITY requirement_for_action_resource
    SUBTYPE OF (action_resource_requirement);
      resources : SET [1:?] OF action_resource;
  END_ENTITY; -- requirement_for_action_resource

  ENTITY requirement_source
    SUBTYPE OF (group);
  END_ENTITY; -- requirement_source

  ENTITY resource_property;
      name        : label;
      description : text;
      resource    : characterized_resource_definition;
  END_ENTITY; -- resource_property

  ENTITY resource_property_relationship;
      name                       : label;
      description                : text;
      relating_resource_property : resource_property;
      related_resource_property  : resource_property;
    WHERE
      wr1: (relating_resource_property :<>: related_resource_property);
  END_ENTITY; -- resource_property_relationship

  ENTITY resource_property_representation;
      name           : label;
      description    : text;
      property       : resource_property;
      representation : representation;
  END_ENTITY; -- resource_property_representation

  ENTITY resource_requirement_type;
      name        : label;
      description : text;
  END_ENTITY; -- resource_requirement_type

  ENTITY resource_requirement_type_relationship;
      name                      : label;
      description               : text;
      relating_requirement_type : resource_requirement_type;
      related_requirement_type  : resource_requirement_type;
    WHERE
      wr1: (relating_requirement_type :<>: related_requirement_type);
  END_ENTITY; -- resource_requirement_type_relationship

  ENTITY revolved_area_solid
    SUBTYPE OF (swept_area_solid);
      axis  : axis1_placement;
      angle : plane_angle_measure;
    DERIVE
      axis_line : line := representation_item('') || 
                     geometric_representation_item() || curve() || line(
                     axis.location,representation_item('') || 
                     geometric_representation_item() || vector(axis.z,1));
  END_ENTITY; -- revolved_area_solid

  ENTITY revolved_face_solid
    SUBTYPE OF (swept_face_solid);
      axis  : axis1_placement;
      angle : plane_angle_measure;
    DERIVE
      axis_line : line := representation_item('') || 
                     geometric_representation_item() || curve() || line(
                     axis.location,representation_item('') || 
                     geometric_representation_item() || vector(axis.z,1));
  END_ENTITY; -- revolved_face_solid

  ENTITY right_angular_wedge
    SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
      ltx      : length_measure;
    WHERE
      wr1: ((0 <= ltx) AND (ltx < x));
  END_ENTITY; -- right_angular_wedge

  ENTITY right_circular_cone
    SUBTYPE OF (geometric_representation_item);
      position   : axis1_placement;
      height     : positive_length_measure;
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: (radius >= 0);
  END_ENTITY; -- right_circular_cone

  ENTITY right_circular_cylinder
    SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      height   : positive_length_measure;
      radius   : positive_length_measure;
  END_ENTITY; -- right_circular_cylinder

  ENTITY right_to_usage_association
    SUBTYPE OF (action_method_relationship);
      SELF\action_method_relationship.related_method  : information_right;
      SELF\action_method_relationship.relating_method : information_usage_right;
    DERIVE
      right_applied : information_right := SELF\action_method_relationship
                         .related_method;
      right_usage   : information_usage_right := SELF\
                         action_method_relationship.relating_method;
  END_ENTITY; -- right_to_usage_association

  ENTITY role_association;
      role           : object_role;
      item_with_role : role_select;
  END_ENTITY; -- role_association

  ENTITY same_membership;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      set_1       : class;
      set_2       : class;
  END_ENTITY; -- same_membership

  ENTITY seam_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               = associated_surface(SELF\surface_curve.associated_geometry[
               2]));
      wr3: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN 
               TYPEOF(SELF\surface_curve.associated_geometry[1]));
      wr4: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN 
               TYPEOF(SELF\surface_curve.associated_geometry[2]));
  END_ENTITY; -- seam_curve

  ENTITY seam_edge
    SUBTYPE OF (oriented_edge);
      pcurve_reference : pcurve;
    WHERE
      wr1: (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EDGE_CURVE' IN 
               TYPEOF(edge_element)) AND (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SEAM_CURVE' IN 
               TYPEOF(edge_element\edge_curve.edge_geometry)));
      wr2: (pcurve_reference IN edge_element\edge_curve.edge_geometry\
               surface_curve.associated_geometry);
  END_ENTITY; -- seam_edge

  ENTITY sectioned_spine
    SUBTYPE OF (geometric_curve_set);
      cross_sections : LIST [2:?] OF curve;
      spine_points   : LIST [2:?] OF point;
    WHERE
      wr1: (SIZEOF(SELF\geometric_set.elements) = 1);
      wr2: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CURVE' IN TYPEOF(
               SELF\geometric_set.elements[1]));
      wr3: (SIZEOF(cross_sections) = SIZEOF(spine_points));
      wr4: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- sectioned_spine

  ENTITY security_classification;
      name           : label;
      purpose        : text;
      security_level : security_classification_level;
  END_ENTITY; -- security_classification

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) 
               <= 1);
  END_ENTITY; -- security_classification_assignment

  ENTITY security_classification_level;
      name : label;
  END_ENTITY; -- security_classification_level

  ENTITY selected_item
    SUBTYPE OF (class);
  END_ENTITY; -- selected_item

  ENTITY selected_item_assignment;
      assigned_class : selected_item;
      item           : selected_item_select;
  END_ENTITY; -- selected_item_assignment

  ENTITY selected_items_assignment_in_context_group
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : selected_items_context_group;
      selected_item_assignment             : SET [1:1] OF
                                                 selected_item_assignment;
  END_ENTITY; -- selected_items_assignment_in_context_group

  ENTITY selected_items_context_group
    SUBTYPE OF (group);
  END_ENTITY; -- selected_items_context_group

  ENTITY selected_items_context_group_to_context
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : selected_items_context_group;
      item_context                         : SET [1:?] OF selected_item_context_items;
  END_ENTITY; -- selected_items_context_group_to_context

  ENTITY serial_numbered_effectivity
    SUBTYPE OF (effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id   : OPTIONAL identifier;
  END_ENTITY; -- serial_numbered_effectivity

  ENTITY shape_aspect;
      name                 : label;
      description          : OPTIONAL text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) 
               <= 1);
  END_ENTITY; -- shape_aspect

  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : OPTIONAL text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) 
               <= 1);
  END_ENTITY; -- shape_aspect_relationship

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_SHAPE' 
               IN TYPEOF(SELF.definition)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SHAPE_DEFINITION' 
               IN TYPEOF(SELF.definition.definition)));
      wr2: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SHAPE_REPRESENTATION' 
               IN TYPEOF(SELF.used_representation));
  END_ENTITY; -- shape_definition_representation

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- shape_representation

  ENTITY shape_representation_relationship
    SUBTYPE OF (representation_relationship);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SHAPE_REPRESENTATION' 
               IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(
               SELF\representation_relationship.rep_2)));
  END_ENTITY; -- shape_representation_relationship

  ENTITY shell_based_surface_model
    SUBTYPE OF (geometric_representation_item);
      sbsm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_surface_model(SELF);
  END_ENTITY; -- shell_based_surface_model

  ENTITY shell_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      sbwm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_wireframe_model(SELF);
  END_ENTITY; -- shell_based_wireframe_model

  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := 
                                      dimensions_for_si_unit(name);
  END_ENTITY; -- si_unit

  ENTITY slot_as_planned
    SUBTYPE OF (product_definition_formation);
  END_ENTITY; -- slot_as_planned

  ENTITY slot_as_realized
    SUBTYPE OF (product_definition_formation);
  END_ENTITY; -- slot_as_realized

  ENTITY slot_design
    SUBTYPE OF (product_definition_formation);
  END_ENTITY; -- slot_design

  ENTITY slot_design_to_planned
    SUBTYPE OF (product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.related_product_definition_formation  : slot_as_planned;
      SELF\product_definition_formation_relationship.relating_product_definition_formation : slot_design;
    WHERE
      wr1: (SELF.relating_product_definition_formation.of_product :=: SELF
               .related_product_definition_formation.of_product);
  END_ENTITY; -- slot_design_to_planned

  ENTITY slot_design_to_realized
    SUBTYPE OF (product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.related_product_definition_formation  : slot_as_realized;
      SELF\product_definition_formation_relationship.relating_product_definition_formation : slot_design;
    WHERE
      wr1: (SELF.relating_product_definition_formation.of_product :=: SELF
               .related_product_definition_formation.of_product);
  END_ENTITY; -- slot_design_to_realized

  ENTITY slot_on_product
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- slot_on_product

  ENTITY slot_planned_to_realized
    SUBTYPE OF (product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.related_product_definition_formation  : slot_as_realized;
      SELF\product_definition_formation_relationship.relating_product_definition_formation : slot_as_planned;
    WHERE
      wr1: (SELF.relating_product_definition_formation.of_product :=: SELF
               .related_product_definition_formation.of_product);
  END_ENTITY; -- slot_planned_to_realized

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SOLID_ANGLE_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- solid_angle_measure_with_unit

  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- solid_angle_unit

  ENTITY solid_model
    SUPERTYPE OF (ONEOF (csg_solid,manifold_solid_brep,swept_face_solid,
        swept_area_solid,swept_disk_solid,solid_replica,brep_2d,
        trimmed_volume))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- solid_model

  ENTITY solid_replica
    SUBTYPE OF (solid_model);
      parent_solid   : solid_model;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_solid_replica(SELF,parent_solid);
      wr2: (parent_solid\geometric_representation_item.dim = 3);
  END_ENTITY; -- solid_replica

  ENTITY source_for_requirement
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : requirement_source;
      items                                : SET [1:1] OF
                                                 requirement_source_item;
  END_ENTITY; -- source_for_requirement

  ENTITY sourced_requirement
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : requirement_source;
      items                                : SET [1:1] OF
                                                 product_definition;
  END_ENTITY; -- sourced_requirement

  ENTITY specified_higher_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
      upper_usage : assembly_component_usage;
      next_usage  : next_assembly_usage_occurrence;
    UNIQUE
      ur1 : upper_usage, next_usage;
    WHERE
      wr1: (SELF :<>: upper_usage);
      wr2: (SELF\product_definition_relationship.
               relating_product_definition :=: upper_usage.
               relating_product_definition);
      wr3: (SELF\product_definition_relationship.
               related_product_definition :=: next_usage.
               related_product_definition);
      wr4: ((upper_usage.related_product_definition :=: next_usage.
               relating_product_definition) OR (SIZEOF(QUERY ( pdr <* 
               USEDIN(upper_usage.related_product_definition,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | (pdr.relating_product_definition :=: next_usage.
               relating_product_definition) )) = 1));
      wr5: (SIZEOF(['AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE','AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE'] 
               * TYPEOF(upper_usage)) = 1);
  END_ENTITY; -- specified_higher_usage_occurrence

  ENTITY sphere
    SUBTYPE OF (geometric_representation_item);
      radius : positive_length_measure;
      centre : point;
  END_ENTITY; -- sphere

  ENTITY spherical_point
    SUBTYPE OF (cartesian_point);
      r     : length_measure;
      theta : plane_angle_measure;
      phi   : plane_angle_measure;
    DERIVE
      SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [
                                            r * SIN(theta) * COS(phi),r * 
                                            SIN(theta) * SIN(phi),r * COS(
                                            theta)];
    WHERE
      wr1: (r >= 0);
  END_ENTITY; -- spherical_point

  ENTITY spherical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- spherical_surface

  ENTITY spherical_volume
    SUBTYPE OF (volume);
      position : axis2_placement_3d;
      radius   : positive_length_measure;
  END_ENTITY; -- spherical_volume

  ENTITY standard_uncertainty
    SUPERTYPE OF (expanded_uncertainty)
    SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : REAL;
  END_ENTITY; -- standard_uncertainty

  ENTITY state_characterized_object
    SUBTYPE OF (characterized_object, state_type);
  END_ENTITY; -- state_characterized_object

  ENTITY state_observed;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- state_observed

  ENTITY state_observed_relationship;
      name                    : STRING;
      description             : OPTIONAL STRING;
      relating_state_observed : SET [1:?] OF state_observed;
      related_state_observed  : SET [1:?] OF state_observed;
      role                    : STRING;
  END_ENTITY; -- state_observed_relationship

  ENTITY state_predicted
    SUBTYPE OF (state_observed);
  END_ENTITY; -- state_predicted

  ENTITY state_relationship_characterized_object
    SUBTYPE OF (characterized_object, state_type_relationship);
  END_ENTITY; -- state_relationship_characterized_object

  ENTITY state_role;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- state_role

  ENTITY state_type;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- state_type

  ENTITY state_type_relationship;
      name                : STRING;
      description         : OPTIONAL STRING;
      relating_state_type : SET [1:?] OF state_type;
      related_state_type  : SET [1:?] OF state_type;
      role                : STRING;
  END_ENTITY; -- state_type_relationship

  ENTITY state_type_role;
      name        : STRING;
      description : OPTIONAL STRING;
  END_ENTITY; -- state_type_role

  ENTITY structured_message
    SUBTYPE OF (product);
  END_ENTITY; -- structured_message

  ENTITY subedge
    SUBTYPE OF (edge);
      parent_edge : edge;
  END_ENTITY; -- subedge

  ENTITY subface
    SUBTYPE OF (face);
      parent_face : face;
    WHERE
      wr1: (NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)) + 
               list_to_set(list_face_loops(parent_face))));
  END_ENTITY; -- subface

  ENTITY subset;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      subset      : class;
      superset    : class;
  END_ENTITY; -- subset

  ENTITY surface
    SUPERTYPE OF (ONEOF (elementary_surface,swept_surface,bounded_surface,
        offset_surface,surface_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- surface

  ENTITY surface_curve
    SUPERTYPE OF (ONEOF (intersection_curve,seam_curve) ANDOR 
        bounded_surface_curve)
    SUBTYPE OF (curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (curve_3d.dim = 3);
      wr2: (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN 
               TYPEOF(associated_geometry[1])) OR (master_representation <>
                pcurve_s1));
      wr3: (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN 
               TYPEOF(associated_geometry[2])) OR (master_representation <>
                pcurve_s2));
      wr4: (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN 
               TYPEOF(curve_3d)));
  END_ENTITY; -- surface_curve

  ENTITY surface_curve_swept_area_solid
    SUBTYPE OF (swept_area_solid);
      directrix         : curve;
      start_param       : REAL;
      end_param         : REAL;
      reference_surface : surface;
    WHERE
      wr1: ((NOT (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE_CURVE' 
               IN TYPEOF(directrix))) OR (reference_surface IN directrix\
               surface_curve.basis_surface));
  END_ENTITY; -- surface_curve_swept_area_solid

  ENTITY surface_curve_swept_face_solid
    SUBTYPE OF (swept_face_solid);
      directrix         : curve;
      start_param       : REAL;
      end_param         : REAL;
      reference_surface : surface;
    WHERE
      wr1: ((NOT (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE_CURVE' 
               IN TYPEOF(directrix))) OR (reference_surface IN directrix\
               surface_curve.basis_surface));
  END_ENTITY; -- surface_curve_swept_face_solid

  ENTITY surface_curve_swept_surface
    SUBTYPE OF (swept_surface);
      directrix         : curve;
      reference_surface : surface;
    WHERE
      wr1: ((NOT (
               'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE_CURVE' 
               IN TYPEOF(directrix))) OR (reference_surface IN directrix\
               surface_curve.basis_surface));
  END_ENTITY; -- surface_curve_swept_surface

  ENTITY surface_of_linear_extrusion
    SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
  END_ENTITY; -- surface_of_linear_extrusion

  ENTITY surface_of_revolution
    SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
    DERIVE
      axis_line : line := representation_item('') || 
                     geometric_representation_item() || curve() || line(
                     axis_position.location,representation_item('') || 
                     geometric_representation_item() || vector(
                     axis_position.z,1));
  END_ENTITY; -- surface_of_revolution

  ENTITY surface_patch
    SUBTYPE OF (founded_item);
      parent_surface : bounded_surface;
      u_transition   : transition_code;
      v_transition   : transition_code;
      u_sense        : BOOLEAN;
      v_sense        : BOOLEAN;
    INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR 
                          segments;
    WHERE
      wr1: (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CURVE_BOUNDED_SURFACE' 
               IN TYPEOF(parent_surface)));
  END_ENTITY; -- surface_patch

  ENTITY surface_replica
    SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_surface_replica(SELF,parent_surface);
  END_ENTITY; -- surface_replica

  ENTITY swept_area_solid
    SUPERTYPE OF (ONEOF (revolved_area_solid,extruded_area_solid,
        surface_curve_swept_area_solid))
    SUBTYPE OF (solid_model);
      swept_area : curve_bounded_surface;
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PLANE' IN TYPEOF(
               swept_area.basis_surface));
  END_ENTITY; -- swept_area_solid

  ENTITY swept_disk_solid
    SUBTYPE OF (solid_model);
      directrix    : curve;
      radius       : positive_length_measure;
      inner_radius : OPTIONAL positive_length_measure;
      start_param  : REAL;
      end_param    : REAL;
    WHERE
      wr1: (directrix.dim = 3);
      wr2: ((NOT EXISTS(inner_radius)) OR (radius > inner_radius));
  END_ENTITY; -- swept_disk_solid

  ENTITY swept_face_solid
    SUPERTYPE OF (ONEOF (extruded_face_solid,revolved_face_solid,
        surface_curve_swept_face_solid))
    SUBTYPE OF (solid_model);
      swept_face : face_surface;
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PLANE' IN TYPEOF(
               swept_face.face_geometry));
  END_ENTITY; -- swept_face_solid

  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,surface_of_revolution,
        surface_curve_swept_surface,fixed_reference_swept_surface))
    SUBTYPE OF (surface);
      swept_curve : curve;
  END_ENTITY; -- swept_surface

  ENTITY system_breakdown_context
    SUBTYPE OF (breakdown_context);
  END_ENTITY; -- system_breakdown_context

  ENTITY system_element_usage
    SUBTYPE OF (breakdown_element_usage);
  END_ENTITY; -- system_element_usage

  ENTITY tetrahedron
    SUBTYPE OF (faceted_primitive);
    WHERE
      wr1: (SIZEOF(points) = 4);
      wr2: (above_plane(points[1],points[2],points[3],points[4]) <> 0);
  END_ENTITY; -- tetrahedron

  ENTITY tetrahedron_volume
    SUBTYPE OF (volume);
      point_1 : cartesian_point;
      point_2 : cartesian_point;
      point_3 : cartesian_point;
      point_4 : cartesian_point;
    WHERE
      wr1: (point_1.dim = 3);
      wr2: (above_plane(point_1,point_2,point_3,point_4) <> 0);
  END_ENTITY; -- tetrahedron_volume

  ENTITY thermodynamic_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' 
               IN TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- thermodynamic_temperature_measure_with_unit

  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 1) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- thermodynamic_temperature_unit

  ENTITY time_assignment
    ABSTRACT SUPERTYPE;
      assigned_time : local_time;
      role          : time_role;
  END_ENTITY; -- time_assignment

  ENTITY time_interval;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- time_interval

  ENTITY time_interval_assignment
    ABSTRACT SUPERTYPE;
      assigned_time_interval : time_interval;
      role                   : time_interval_role;
  END_ENTITY; -- time_interval_assignment

  ENTITY time_interval_based_effectivity
    SUBTYPE OF (effectivity);
      effectivity_period : time_interval;
  END_ENTITY; -- time_interval_based_effectivity

  ENTITY time_interval_relationship;
      name                   : label;
      description            : OPTIONAL text;
      relating_time_interval : time_interval;
      related_time_interval  : time_interval;
  END_ENTITY; -- time_interval_relationship

  ENTITY time_interval_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- time_interval_role

  ENTITY time_interval_with_bounds
    SUBTYPE OF (time_interval);
      primary_bound   : OPTIONAL date_time_or_event_occurrence;
      secondary_bound : OPTIONAL date_time_or_event_occurrence;
      duration        : OPTIONAL time_measure_with_unit;
    WHERE
      wr1: (NOT (EXISTS(secondary_bound) AND EXISTS(duration)));
      wr2: (EXISTS(primary_bound) OR EXISTS(secondary_bound));
  END_ENTITY; -- time_interval_with_bounds

  ENTITY time_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.TIME_UNIT' IN 
               TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- time_measure_with_unit

  ENTITY time_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) 
               <= 1);
  END_ENTITY; -- time_role

  ENTITY time_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 1) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- time_unit

  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (vertex,edge,face_bound,face,vertex_shell,
        wire_shell,connected_edge_set,connected_face_set,loop ANDOR path))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- topological_representation_item

  ENTITY toroidal_surface
    SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY; -- toroidal_surface

  ENTITY toroidal_volume
    SUBTYPE OF (volume);
      position     : axis2_placement_3d;
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
    WHERE
      wr1: (minor_radius < major_radius);
  END_ENTITY; -- toroidal_volume

  ENTITY torus
    SUBTYPE OF (geometric_representation_item);
      position     : axis1_placement;
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
    WHERE
      wr1: (major_radius > minor_radius);
  END_ENTITY; -- torus

  ENTITY trimmed_curve
    SUBTYPE OF (bounded_curve);
      basis_curve           : curve;
      trim_1                : SET [1:2] OF trimming_select;
      trim_2                : SET [1:2] OF trimming_select;
      sense_agreement       : BOOLEAN;
      master_representation : trimming_preference;
    WHERE
      wr1: ((HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2])));
      wr2: ((HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2])));
  END_ENTITY; -- trimmed_curve

  ENTITY trimmed_volume
    SUBTYPE OF (solid_model);
      basis_volume : volume;
      u1           : parameter_value;
      u2           : parameter_value;
      v1           : parameter_value;
      v2           : parameter_value;
      w1           : parameter_value;
      w2           : parameter_value;
    WHERE
      wr1: (u1 <> u2);
      wr2: (v1 <> v2);
      wr3: (w1 <> w2);
  END_ENTITY; -- trimmed_volume

  ENTITY type_qualifier;
      name : label;
  END_ENTITY; -- type_qualifier

  ENTITY uncertainty_assigned_representation
    SUBTYPE OF (representation);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY; -- uncertainty_assigned_representation

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      wr1: valid_measure_value(SELF\measure_with_unit.value_component);
  END_ENTITY; -- uncertainty_measure_with_unit

  ENTITY uncertainty_qualifier
    SUPERTYPE OF (ONEOF (standard_uncertainty,qualitative_uncertainty));
      measure_name : label;
      description  : text;
  END_ENTITY; -- uncertainty_qualifier

  ENTITY uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- uniform_curve

  ENTITY uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- uniform_surface

  ENTITY uniform_volume
    SUBTYPE OF (b_spline_volume);
  END_ENTITY; -- uniform_volume

  ENTITY union;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      operand     : SET [2:?] OF class;
      resultant   : class;
  END_ENTITY; -- union

  ENTITY usage_association
    SUBTYPE OF (action_method_relationship);
      SELF\action_method_relationship.related_method  : information_usage_right;
      SELF\action_method_relationship.relating_method : information_usage_right;
    DERIVE
      related  : information_usage_right := SELF\
                    action_method_relationship.related_method;
      relating : information_usage_right := SELF\
                    action_method_relationship.relating_method;
  END_ENTITY; -- usage_association

  ENTITY value_range
    SUBTYPE OF (compound_representation_item);
    WHERE
      wr1: ((('value_with_unit_mim.' + 'SET_REPRESENTATION_ITEM') IN 
               TYPEOF(item_element)) AND value_range_wr1(item_element));
      wr2: value_range_wr2(item_element);
      wr3: value_range_wr3(item_element);
  END_ENTITY; -- value_range

  ENTITY value_representation_item
    SUBTYPE OF (representation_item);
      value_component : measure_value;
    WHERE
      wr1: (SIZEOF(QUERY ( rep <* using_representations(SELF) | (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT' 
               IN TYPEOF(rep.context_of_items))) )) = 0);
  END_ENTITY; -- value_representation_item

  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: (magnitude >= 0);
  END_ENTITY; -- vector

  ENTITY versioned_action_request;
      id          : identifier;
      version     : label;
      purpose     : text;
      description : OPTIONAL text;
  END_ENTITY; -- versioned_action_request

  ENTITY vertex
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- vertex

  ENTITY vertex_loop
    SUBTYPE OF (loop);
      loop_vertex : vertex;
  END_ENTITY; -- vertex_loop

  ENTITY vertex_point
    SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
  END_ENTITY; -- vertex_point

  ENTITY vertex_shell
    SUBTYPE OF (topological_representation_item);
      vertex_shell_extent : vertex_loop;
  END_ENTITY; -- vertex_shell

  ENTITY volume
    SUPERTYPE OF (ONEOF (block_volume,wedge_volume,spherical_volume,
        cylindrical_volume,eccentric_conical_volume,toroidal_volume,
        pyramid_volume,b_spline_volume,ellipsoid_volume,tetrahedron_volume,
        hexahedron_volume))
    SUBTYPE OF (geometric_representation_item);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- volume

  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VOLUME_UNIT' IN 
               TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- volume_measure_with_unit

  ENTITY volume_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 3) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- volume_unit

  ENTITY wedge_volume
    SUBTYPE OF (volume);
      position : axis2_placement_3d;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
      ltx      : length_measure;
    WHERE
      wr1: ((0 <= ltx) AND (ltx < x));
  END_ENTITY; -- wedge_volume

  ENTITY week_of_year_and_day_date
    SUBTYPE OF (date);
      week_component : week_in_year_number;
      day_component  : OPTIONAL day_in_week_number;
  END_ENTITY; -- week_of_year_and_day_date

  ENTITY wire_shell
    SUBTYPE OF (topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
    WHERE
      wr1: (NOT mixed_loop_type_set(wire_shell_extent));
  END_ENTITY; -- wire_shell

  ENTITY zone_breakdown_context
    SUBTYPE OF (breakdown_context);
  END_ENTITY; -- zone_breakdown_context

  ENTITY zone_element_usage
    SUBTYPE OF (breakdown_element_usage);
  END_ENTITY; -- zone_element_usage

  RULE aliases_are_valid FOR (applied_identification_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( aia <* applied_identification_assignment | (NOT 
             alias_assignment_is_valid(aia)) )) = 0);

  END_RULE; -- aliases_are_valid

  FUNCTION above_plane(
               p1, p2, p3, p4: cartesian_point
      ): REAL;

    LOCAL
      val  : REAL;
      mag  : REAL;
      dir4 : direction := dummy_gri || direction([1,0,0]);
      dir3 : direction := dummy_gri || direction([1,0,0]);
      dir2 : direction := dummy_gri || direction([1,0,0]);
    END_LOCAL;
    IF p1.dim <> 3 THEN
      RETURN(?);
    END_IF;
    REPEAT i := 1 TO 3 BY 1;
      dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
      dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
      dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
      mag := dir4.direction_ratios[i] * dir4.direction_ratios[i];
    END_REPEAT;
    mag := mag;
    val := mag * dot_product(dir4,cross_product(dir2,dir3).orientation);
    RETURN(val);

  END_FUNCTION; -- above_plane

  FUNCTION acyclic_action_method_relationship(
               relation: action_method_relationship;
               relatives: SET [1:?] OF action_method;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF action_method_relationship;
    END_LOCAL;
    IF relation.relating_method IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( am <* bag_to_set(USEDIN(relation.relating_method,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ACTION_METHOD_RELATIONSHIP.RELATED_METHOD'))
         | (specific_relation IN TYPEOF(am)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_action_method_relationship(x[i],relatives + relation.
          relating_method,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_action_method_relationship

  FUNCTION acyclic_action_relationship(
               relation: action_relationship;
               relatives: SET [1:?] OF action;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF action_relationship;
    END_LOCAL;
    IF relation.relating_action IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( actn <* bag_to_set(USEDIN(relation.relating_action,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ACTION_RELATIONSHIP.RELATED_ACTION'))
         | (specific_relation IN TYPEOF(actn)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_action_relationship(x[i],relatives + relation.
          relating_action,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_action_relationship

  FUNCTION acyclic_action_resource_relationship(
               relation: action_resource_relationship;
               relatives: SET [1:?] OF action_resource;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF action_resource_relationship;
    END_LOCAL;
    IF relation.relating_resource IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( ar <* bag_to_set(USEDIN(relation.relating_resource,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ACTION_RESOURCE_RELATIONSHIP.RELATED_RESOURCE'))
         | (specific_relation IN TYPEOF(ar)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_action_resource_relationship(x[i],relatives + 
          relation.relating_resource,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_action_resource_relationship

  FUNCTION acyclic_approval_relationship(
               relation: approval_relationship;
               relatives: SET [1:?] OF approval;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF approval_relationship;
    END_LOCAL;
    IF relation.relating_approval IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( app <* bag_to_set(USEDIN(relation.relating_approval,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.APPROVAL_RELATIONSHIP.RELATED_APPROVAL'))
         | (specific_relation IN TYPEOF(app)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_approval_relationship(x[i],relatives + relation.
          relating_approval,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_approval_relationship

  FUNCTION acyclic_characterized_object_relationship(
               relation: characterized_object_relationship;
               relatives: SET [1:?] OF characterized_object;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF characterized_object_relationship;
    END_LOCAL;
    IF relation.relating_object IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( ca <* bag_to_set(USEDIN(relation.relating_object,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CHARACTERIZED_OBJECT_RELATIONSHIP.RELATED_OBJECT'))
         | (specific_relation IN TYPEOF(ca)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_characterized_object_relationship(x[i],relatives + 
          relation.relating_object,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_characterized_object_relationship

  FUNCTION acyclic_contract_relationship(
               relation: contract_relationship;
               relatives: SET [1:?] OF contract;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF contract_relationship;
    END_LOCAL;
    IF relation.relating_contract IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( cont <* bag_to_set(USEDIN(relation.relating_contract,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CONTRACT_RELATIONSHIP.RELATED_CONTRACT'))
         | (specific_relation IN TYPEOF(cont)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_contract_relationship(x[i],relatives + relation.
          relating_contract,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_contract_relationship

  FUNCTION acyclic_curve_replica(
               rep: curve_replica;
               parent: curve
      ): BOOLEAN;
    IF NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CURVE_REPLICA' IN
         TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;

  END_FUNCTION; -- acyclic_curve_replica

  FUNCTION acyclic_document_relationship(
               relation: document_relationship;
               relatives: SET [1:?] OF document;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF document_relationship;
    END_LOCAL;
    IF relation.relating_document IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( doc <* bag_to_set(USEDIN(relation.relating_document,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT'))
         | (specific_relation IN TYPEOF(doc)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_document_relationship(x[i],relatives + relation.
          relating_document,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_document_relationship

  FUNCTION acyclic_effectivity_relationship(
               relation: effectivity_relationship;
               relatives: SET [1:?] OF effectivity;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF effectivity_relationship;
    END_LOCAL;
    IF relation.relating_effectivity IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( eff <* bag_to_set(USEDIN(relation.relating_effectivity,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EFFECTIVITY_RELATIONSHIP.RELATED_EFFECTIVITY'))
         | (specific_relation IN TYPEOF(eff)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_effectivity_relationship(x[i],relatives + relation.
          relating_effectivity,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_effectivity_relationship

  FUNCTION acyclic_event_occurrence_relationship(
               relation: event_occurrence_relationship;
               relatives: SET [1:?] OF event_occurrence;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF event_occurrence_relationship;
    END_LOCAL;
    IF relation.relating_event IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( evnt <* bag_to_set(USEDIN(relation.relating_event,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EVENT_OCCURRENCE_RELATIONSHIP.RELATED_EVENT'))
         | (specific_relation IN TYPEOF(evnt)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_event_occurrence_relationship(x[i],relatives + 
          relation.relating_event,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_event_occurrence_relationship

  FUNCTION acyclic_external_source_relationship(
               relation: external_source_relationship;
               relatives: SET [1:?] OF external_source;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF external_source_relationship;
    END_LOCAL;
    IF relation.relating_source IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( es <* bag_to_set(USEDIN(relation.relating_source,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EXTERNAL_SOURCE_RELATIONSHIP.RELATED_SOURCE'))
         | (specific_relation IN TYPEOF(es)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_external_source_relationship(x[i],relatives + 
          relation.relating_source,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_external_source_relationship

  FUNCTION acyclic_externally_defined_item_relationship(
               relation: externally_defined_item_relationship;
               relatives: SET [1:?] OF externally_defined_item;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF externally_defined_item_relationship;
    END_LOCAL;
    IF relation.relating_item IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( edi <* bag_to_set(USEDIN(relation.relating_item,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATED_ITEM'))
         | (specific_relation IN TYPEOF(edi)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_externally_defined_item_relationship(x[i],relatives +
           relation.relating_item,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_externally_defined_item_relationship

  FUNCTION acyclic_general_property_relationship(
               relation: general_property_relationship;
               relatives: SET [1:?] OF general_property;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF general_property_relationship;
    END_LOCAL;
    IF relation.relating_property IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( genp <* bag_to_set(USEDIN(relation.relating_property,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.GENERAL_PROPERTY_RELATIONSHIP.RELATED_PROPERTY'))
         | (specific_relation IN TYPEOF(genp)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_general_property_relationship(x[i],relatives + 
          relation.relating_property,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_general_property_relationship

  FUNCTION acyclic_group_relationship(
               relation: group_relationship;
               relatives: SET [1:?] OF group;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF group_relationship;
    END_LOCAL;
    IF relation.relating_group IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( grp <* bag_to_set(USEDIN(relation.relating_group,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.GROUP_RELATIONSHIP.RELATED_GROUP'))
         | (specific_relation IN TYPEOF(grp)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_group_relationship(x[i],relatives + relation.
          relating_group,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_group_relationship

  FUNCTION acyclic_identification_assignment_relationship(
               relation: identification_assignment_relationship;
               relatives: SET [1:?] OF identification_assignment;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF identification_assignment_relationship;
    END_LOCAL;
    IF relation.relating_identification_assignment IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( ia <* bag_to_set(USEDIN(relation.
        relating_identification_assignment,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.RELATED_IDENTIFICATION_ASSIGNMENT'))
         | (specific_relation IN TYPEOF(ia)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_identification_assignment_relationship(x[i],relatives 
          + relation.relating_identification_assignment,specific_relation)
           THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_identification_assignment_relationship

  FUNCTION acyclic_mapped_representation(
               parent_set: SET OF representation;
               children_set: SET OF representation_item
      ): BOOLEAN;

    LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | (
        'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.MAPPED_ITEM' IN 
        TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.REPRESENTATION_ITEM' 
            IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_mapped_representation

  FUNCTION acyclic_organization_relationship(
               relation: organization_relationship;
               relatives: SET [1:?] OF organization;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF organization_relationship;
    END_LOCAL;
    IF relation.relating_organization IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( org <* bag_to_set(USEDIN(relation.relating_organization,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORGANIZATION_RELATIONSHIP.RELATED_ORGANIZATION'))
         | (specific_relation IN TYPEOF(org)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_organization_relationship(x[i],relatives + relation.
          relating_organization,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_organization_relationship

  FUNCTION acyclic_organizational_project_relationship(
               relation: organizational_project_relationship;
               relatives: SET [1:?] OF organizational_project;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF organizational_project_relationship;
    END_LOCAL;
    IF relation.relating_organizational_project IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( op <* bag_to_set(USEDIN(relation.
        relating_organizational_project,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORGANIZATIONAL_PROJECT_RELATIONSHIP.RELATED_ORGANIZATIONAL_PROJECT'))
         | (specific_relation IN TYPEOF(op)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_organizational_project_relationship(x[i],relatives + 
          relation.relating_organizational_project,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_organizational_project_relationship

  FUNCTION acyclic_point_replica(
               rep: point_replica;
               parent: point
      ): BOOLEAN;
    IF NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.POINT_REPLICA' IN
         TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
    END_IF;

  END_FUNCTION; -- acyclic_point_replica

  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category
      ): BOOLEAN;

    LOCAL
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_category_relationship

  FUNCTION acyclic_product_definition_formation_relationship(
               relation: product_definition_formation_relationship;
               relatives: SET [1:?] OF product_definition_formation;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF product_definition_formation_relationship;
    END_LOCAL;
    IF relation.relating_product_definition_formation IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( pdf <* bag_to_set(USEDIN(relation.
        relating_product_definition_formation,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION_FORMATION'))
         | (specific_relation IN TYPEOF(pdf)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_definition_formation_relationship(x[i],
          relatives + relation.relating_product_definition_formation,
          specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_definition_formation_relationship

  FUNCTION acyclic_product_definition_relationship(
               relation: product_definition_relationship;
               relatives: SET [1:?] OF product_definition;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;
    IF relation.relating_product_definition IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( pd <* bag_to_set(USEDIN(relation.
        relating_product_definition,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))
         | (specific_relation IN TYPEOF(pd)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_definition_relationship(x[i],relatives + 
          relation.relating_product_definition,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_definition_relationship

  FUNCTION acyclic_product_relationship(
               relation: product_relationship;
               relatives: SET [1:?] OF product;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF product_relationship;
    END_LOCAL;
    IF relation.relating_product IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( prod <* bag_to_set(USEDIN(relation.relating_product,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_RELATIONSHIP.RELATED_PRODUCT'))
         | (specific_relation IN TYPEOF(prod)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_relationship(x[i],relatives + relation.
          relating_product,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_relationship

  FUNCTION acyclic_property_definition_relationship(
               relation: property_definition_relationship;
               relatives: SET [1:?] OF property_definition;
               specific_relation: STRING
      ): LOGICAL;

    LOCAL
      x : SET OF property_definition_relationship;
    END_LOCAL;
    IF relation.relating_property_definition IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( pd <* bag_to_set(USEDIN(relation.
        relating_property_definition,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION'))
         | (specific_relation IN TYPEOF(pd)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_property_definition_relationship(x[i],relatives + 
          relation.relating_property_definition,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_property_definition_relationship

  FUNCTION acyclic_set_replica(
               rep: geometric_set_replica;
               parent: geometric_set
      ): BOOLEAN;
    IF NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.GEOMETRIC_SET_REPLICA' 
        IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_set_replica(rep,parent\geometric_set_replica.
          parent_set));
    END_IF;

  END_FUNCTION; -- acyclic_set_replica

  FUNCTION acyclic_shape_aspect_relationship(
               relation: shape_aspect_relationship;
               relatives: SET [1:?] OF shape_aspect;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF shape_aspect_relationship;
    END_LOCAL;
    IF relation.relating_shape_aspect IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( sa <* bag_to_set(USEDIN(relation.relating_shape_aspect,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))
         | (specific_relation IN TYPEOF(sa)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_shape_aspect_relationship(x[i],relatives + relation.
          relating_shape_aspect,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_shape_aspect_relationship

  FUNCTION acyclic_solid_replica(
               rep: solid_replica;
               parent: solid_model
      ): BOOLEAN;
    IF NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SOLID_REPLICA' IN
         TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_solid_replica(rep,parent\solid_replica.parent_solid));
    END_IF;

  END_FUNCTION; -- acyclic_solid_replica

  FUNCTION acyclic_surface_replica(
               rep: surface_replica;
               parent: surface
      ): BOOLEAN;
    IF NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE_REPLICA' 
        IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_surface_replica(rep,parent\surface_replica.
          parent_surface));
    END_IF;

  END_FUNCTION; -- acyclic_surface_replica

  FUNCTION acyclic_time_interval_relationship(
               relation: time_interval_relationship;
               relatives: SET [1:?] OF time_interval;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF time_interval_relationship;
    END_LOCAL;
    IF relation.relating_time_interval IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( ti <* bag_to_set(USEDIN(relation.relating_time_interval,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.TIME_INTERVAL_RELATIONSHIP.RELATED_TIME_INTERVAL'))
         | (specific_relation IN TYPEOF(ti)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_time_interval_relationship(x[i],relatives + relation.
          relating_time_interval,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_time_interval_relationship

  FUNCTION alias_assignment_is_valid(
               aia: applied_identification_assignment
      ): BOOLEAN;

    LOCAL
      item : identification_item;
      role : identification_role;
    END_LOCAL;
    role := aia.role;
    IF role.name = 'alias' THEN
      REPEAT i := LOINDEX(aia.items) TO HIINDEX(aia.items) BY 1;
        item := aia.items[i];
        IF SIZEOF(['AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.' + 
            'ALIASABLE_ITEM'] * TYPEOF(item)) = 0 THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- alias_assignment_is_valid

  FUNCTION assembly_shape_is_defined(
               assy: next_assembly_usage_occurrence
      ): BOOLEAN;

    LOCAL
      srr_set  : SET OF shape_representation_relationship := [];
      sdr1_set : SET OF shape_definition_representation := [];
      pdr_set  : SET OF product_definition_relationship := [];
      prop_set : SET OF property_definition := [];
      pds_set  : SET OF product_definition_shape := [];
      sdr_set  : SET OF shape_definition_representation := [];
      pd_set   : SET OF property_definition := [];
    END_LOCAL;
    pd_set := bag_to_set(USEDIN(assy.related_product_definition,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
    pdr_set := QUERY ( pdr <* bag_to_set(USEDIN(assy.
        related_product_definition,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))
         | (SIZEOF(USEDIN(pdr,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION')) 
        > 0) );
    IF SIZEOF(pd_set) > 0 THEN
      REPEAT i := 1 TO HIINDEX(pd_set) BY 1;
        sdr_set := sdr_set + QUERY ( pdr <* USEDIN(pd_set[i],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')
             | ((schema_name + '.SHAPE_DEFINITION_REPRESENTATION') IN 
            TYPEOF(pdr)) );
      END_REPEAT;
    END_IF;
    IF SIZEOF(pdr_set) > 0 THEN
      REPEAT i := 1 TO HIINDEX(pdr_set) BY 1;
        prop_set := prop_set + bag_to_set(USEDIN(pdr_set[i],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
      END_REPEAT;
      IF SIZEOF(prop_set) > 0 THEN
        REPEAT i := 1 TO HIINDEX(prop_set) BY 1;
          sdr_set := sdr_set + QUERY ( pdr <* USEDIN(prop_set[i],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')
               | ((schema_name + '.SHAPE_DEFINITION_REPRESENTATION') IN 
              TYPEOF(pdr)) );
        END_REPEAT;
      END_IF;
    END_IF;
    IF SIZEOF(sdr_set) > 0 THEN
      REPEAT i := 1 TO HIINDEX(sdr_set) BY 1;
        srr_set := QUERY ( rr <* bag_to_set(USEDIN(sdr_set[i]\
            property_definition_representation.used_representation,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.REPRESENTATION_RELATIONSHIP.REP_2'))
             | ((schema_name + '.SHAPE_REPRESENTATION_RELATIONSHIP') IN 
            TYPEOF(rr)) );
        pd_set := bag_to_set(USEDIN(assy.relating_product_definition,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
        IF SIZEOF(pd_set) > 0 THEN
          REPEAT i := 1 TO HIINDEX(pd_set) BY 1;
            sdr1_set := sdr1_set + QUERY ( pdr <* USEDIN(pd_set[i],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')
                 | ((schema_name + '.SHAPE_DEFINITION_REPRESENTATION') IN 
                TYPEOF(pdr)) );
          END_REPEAT;
        END_IF;
        IF (SIZEOF(sdr_set) > 0) AND (SIZEOF(sdr1_set) > 0) THEN
          IF SIZEOF(srr_set) > 0 THEN
            REPEAT j := 1 TO HIINDEX(srr_set) BY 1;
              IF SIZEOF(QUERY ( pdr <* bag_to_set(USEDIN(srr_set[j]\
                  representation_relationship.rep_1,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                   | ((schema_name + '.SHAPE_DEFINITION_REPRESENTATION') IN
                   TYPEOF(pdr)) ) * sdr1_set) >= 1 THEN
                pds_set := QUERY ( x <* bag_to_set(USEDIN(assy,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION'))
                     | ((schema_name + '.PRODUCT_DEFINITION_SHAPE') IN 
                    TYPEOF(x)) );
                IF SIZEOF(pds_set) = 0 THEN
                  RETURN(FALSE);
                END_IF;
                REPEAT k := 1 TO HIINDEX(pds_set) BY 1;
                  IF SIZEOF(QUERY ( cdsr <* USEDIN(pds_set[k],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.REPRESENTED_PRODUCT_RELATION')
                       | (cdsr.representation_relation :=: srr_set[j]) )) >
                       0 THEN
                    RETURN(FALSE);
                  END_IF;
                END_REPEAT;
              END_IF;
            END_REPEAT;
          END_IF;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- assembly_shape_is_defined

  FUNCTION associated_surface(
               arg: pcurve_or_surface
      ): surface;

    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN TYPEOF(arg)
         THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);

  END_FUNCTION; -- associated_surface

  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;

    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

  END_FUNCTION; -- bag_to_set

  FUNCTION base_axis(
               dim: INTEGER;
               axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;

    LOCAL
      u      : LIST [2:3] OF direction;
      d1     : direction;
      d2     : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));
      d2 := first_proj_axis(d1,axis1);
      u := [d2,second_proj_axis(d1,d2,axis2),d1];
    ELSE
      IF EXISTS(axis1) THEN
        d1 := normalise(axis1);
        u := [d1,orthogonal_complement(d1)];
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          d1 := normalise(axis2);
          u := [orthogonal_complement(d1),d1];
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u := [dummy_gri || direction([1,0]),dummy_gri || direction([0,1])];
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

  END_FUNCTION; -- base_axis

  FUNCTION boolean_choose(
               b: BOOLEAN;
               choice1: GENERIC:item;
               choice2: GENERIC:item
      ): GENERIC:item;
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;

  END_FUNCTION; -- boolean_choose

  FUNCTION build_2axes(
               ref_direction: direction
      ): LIST [2:2] OF direction;

    LOCAL
      d : direction := NVL(normalise(ref_direction),dummy_gri || 
           direction([1,0]));
    END_LOCAL;
    RETURN([d,orthogonal_complement(d)]);

  END_FUNCTION; -- build_2axes

  FUNCTION build_axes(
               axis, ref_direction: direction
      ): LIST [3:3] OF direction;

    LOCAL
      d1 : direction;
      d2 : direction;
    END_LOCAL;
    d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    d2 := first_proj_axis(d1,ref_direction);
    RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);

  END_FUNCTION; -- build_axes

  FUNCTION build_transformed_set(
               tr: cartesian_transformation_operator;
               gset: geometric_set
      ): SET OF geometric_set_select;

    LOCAL
      s     : SET [1:?] OF geometric_set_select := gset.elements;
      trset : SET OF geometric_set_select := [];
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(s) BY 1;
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CURVE' IN TYPEOF(s[j])
           THEN
        trset := trset + (dummy_gri || curve() || curve_replica(s[j],tr));
      ELSE
        IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.POINT' IN TYPEOF(s
            [j]) THEN
          trset := trset + (dummy_gri || point() || point_replica(s[j],tr));
        ELSE
          IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE' IN 
              TYPEOF(s[j]) THEN
            trset := trset + (dummy_gri || surface() || surface_replica(s[
                j],tr || cartesian_transformation_operator_3d(?)));
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
    RETURN(trset);

  END_FUNCTION; -- build_transformed_set

  FUNCTION categories_of_product(
               obj: product
      ): SET OF STRING;

    LOCAL
      i                    : INTEGER;
      category_assignments : BAG OF product_category;
      categories           : SET OF STRING := [];
    END_LOCAL;
    category_assignments := USEDIN(obj,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
    REPEAT i := LOINDEX(category_assignments) TO HIINDEX(
        category_assignments) BY 1;
      categories := categories + category_assignments[i].name;
    END_REPEAT;
    RETURN(categories);

  END_FUNCTION; -- categories_of_product

  FUNCTION closed_shell_reversed(
               a_shell: closed_shell
      ): oriented_closed_shell;

    LOCAL
      the_reverse : oriented_closed_shell;
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_CLOSED_SHELL' 
        IN TYPEOF(a_shell) THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell\oriented_closed_shell.
          closed_shell_element,NOT a_shell\oriented_closed_shell.
          orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- closed_shell_reversed

  FUNCTION conditional_reverse(
               p: BOOLEAN;
               an_item: reversible_topology
      ): reversible_topology;
    IF p THEN
      RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;

  END_FUNCTION; -- conditional_reverse

  FUNCTION constraints_composite_curve_on_surface(
               c: composite_curve_on_surface
      ): BOOLEAN;

    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN 
          TYPEOF(c\composite_curve.segments[k].parent_curve))) AND (NOT (
          'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE_CURVE' IN 
          TYPEOF(c\composite_curve.segments[k].parent_curve))) AND (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' 
          IN TYPEOF(c\composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_composite_curve_on_surface

  FUNCTION constraints_geometry_shell_based_surface_model(
               m: shell_based_surface_model
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
      IF (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.OPEN_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))) AND (NOT (
          'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CLOSED_SHELL' IN 
          TYPEOF(m.sbsm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_geometry_shell_based_surface_model

  FUNCTION constraints_geometry_shell_based_wireframe_model(
               m: shell_based_wireframe_model
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
      IF (NOT ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.WIRE_SHELL' IN
           TYPEOF(m.sbwm_boundary[j]))) AND (NOT (
          'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VERTEX_SHELL' IN 
          TYPEOF(m.sbwm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

  FUNCTION constraints_param_b_spline(
               degree: INTEGER;
               up_knots: INTEGER;
               up_cp: INTEGER;
               knot_mult: LIST OF INTEGER;
               knots: LIST OF parameter_value
      ): BOOLEAN;

    LOCAL
      k      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (
        degree + up_cp + 2)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k < 1) OR (k > (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i < up_knots) AND (k > degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k > (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_param_b_spline

  FUNCTION constraints_rectangular_composite_surface(
               s: rectangular_composite_surface
      ): BOOLEAN;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF NOT ((
            'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.B_SPLINE_SURFACE' 
            IN TYPEOF(s.segments[i][j].parent_surface)) OR ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' 
            IN TYPEOF(s.segments[i][j].parent_surface))) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u - 1 BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF s.segments[i][j].u_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v - 1 BY 1;
        IF s.segments[i][j].v_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_rectangular_composite_surface

  FUNCTION cross_product(
               arg1, arg2: direction
      ): vector;

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      v1 := normalise(arg1).direction_ratios;
      v2 := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(v1
          [3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[1])]);
      mag := 0;
      REPEAT i := 1 TO 3 BY 1;
        mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        result := dummy_gri || vector(res,mag);
      ELSE
        result := dummy_gri || vector(arg1,0);
      END_IF;
      RETURN(result);
    END_IF;

  END_FUNCTION; -- cross_product

  FUNCTION curve_weights_positive(
               b: rational_b_spline_curve
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] <= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- curve_weights_positive

  FUNCTION default_b_spline_curve_weights(
               up_cp: INTEGER
      ): ARRAY [0:up_cp] OF REAL;
    RETURN([1,up_cp + 1]);

  END_FUNCTION; -- default_b_spline_curve_weights

  FUNCTION default_b_spline_knot_mult(
               degree: INTEGER;
               up_knots: INTEGER;
               uniform: knot_type
      ): LIST [2:?] OF INTEGER;

    LOCAL
      knot_mult : LIST [1:up_knots] OF INTEGER;
    END_LOCAL;
    IF uniform = uniform_knots THEN
      knot_mult := [1,up_knots];
    ELSE
      IF uniform = quasi_uniform_knots THEN
        knot_mult := [1,up_knots];
        knot_mult[1] := degree + 1;
        knot_mult[up_knots] := degree + 1;
      ELSE
        IF uniform = piecewise_bezier_knots THEN
          knot_mult := [degree,up_knots];
          knot_mult[1] := degree + 1;
          knot_mult[up_knots] := degree + 1;
        ELSE
          knot_mult := [0,up_knots];
        END_IF;
      END_IF;
    END_IF;
    RETURN(knot_mult);

  END_FUNCTION; -- default_b_spline_knot_mult

  FUNCTION default_b_spline_knots(
               degree: INTEGER;
               up_knots: INTEGER;
               uniform: knot_type
      ): LIST [2:?] OF parameter_value;

    LOCAL
      ishift : INTEGER := 1;
      knots  : LIST [1:up_knots] OF parameter_value := [0,up_knots];
    END_LOCAL;
    IF uniform = uniform_knots THEN
      ishift := degree + 1;
    END_IF;
    IF (uniform = uniform_knots) OR (uniform = quasi_uniform_knots) OR (
        uniform = piecewise_bezier_knots) THEN
      REPEAT i := 1 TO up_knots BY 1;
        knots[i] := i - ishift;
      END_REPEAT;
    END_IF;
    RETURN(knots);

  END_FUNCTION; -- default_b_spline_knots

  FUNCTION default_b_spline_surface_weights(
               u_upper: INTEGER;
               v_upper: INTEGER
      ): ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL;
    RETURN([[1,v_upper + 1]:u_upper + 1]);

  END_FUNCTION; -- default_b_spline_surface_weights

  FUNCTION derive_dimensional_exponents(
               x: unit
      ): dimensional_exponents;

    LOCAL
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DERIVED_UNIT' IN 
        TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- derive_dimensional_exponents

  FUNCTION dimension_of(
               item: geometric_representation_item
      ): dimension_count;

    LOCAL
      x   : SET OF representation;
      y   : representation_context;
      dim : dimension_count;
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CARTESIAN_POINT' IN 
        TYPEOF(item) THEN
      dim := SIZEOF(item\cartesian_point.coordinates);
      RETURN(dim);
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DIRECTION' IN TYPEOF(
        item) THEN
      dim := SIZEOF(item\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(item)
         THEN
      dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    x := using_representations(item);
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN(dim);

  END_FUNCTION; -- dimension_of

  FUNCTION dimensions_for_si_unit(
               n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      OTHERWISE     :         RETURN(?);
      END_CASE;

  END_FUNCTION; -- dimensions_for_si_unit

  FUNCTION dot_product(
               arg1, arg2: direction
      ): REAL;

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN
        scalar := ?;
      ELSE
        vec1 := normalise(arg1);
        vec2 := normalise(arg2);
        ndim := arg1.dim;
        scalar := 0;
        REPEAT i := 1 TO ndim BY 1;
          scalar := scalar + (vec1.direction_ratios[i] * vec2.
              direction_ratios[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(scalar);

  END_FUNCTION; -- dot_product

  FUNCTION edge_curve_pcurves(
               an_edge: edge_curve;
               the_surface_curves: SET OF surface_curve
      ): SET OF pcurve;

    LOCAL
      the_geometry : LIST [1:2] OF pcurve_or_surface;
      a_curve      : curve;
      result       : SET OF pcurve;
    END_LOCAL;
    a_curve := an_edge.edge_geometry;
    result := [];
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN TYPEOF(
        a_curve) THEN
      result := result + a_curve;
    ELSE
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE_CURVE' IN 
          TYPEOF(a_curve) THEN
        the_geometry := a_curve\surface_curve.associated_geometry;
        REPEAT k := 1 TO SIZEOF(the_geometry) BY 1;
          IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN 
              TYPEOF(the_geometry[k]) THEN
            result := result + the_geometry[k];
          END_IF;
        END_REPEAT;
      ELSE
        REPEAT j := 1 TO SIZEOF(the_surface_curves) BY 1;
          the_geometry := the_surface_curves[j].associated_geometry;
          IF the_surface_curves[j].curve_3d :=: a_curve THEN
            REPEAT k := 1 TO SIZEOF(the_geometry) BY 1;
              IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN 
                  TYPEOF(the_geometry[k]) THEN
                result := result + the_geometry[k];
              END_IF;
            END_REPEAT;
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- edge_curve_pcurves

  FUNCTION edge_reversed(
               an_edge: edge
      ): oriented_edge;

    LOCAL
      the_reverse : oriented_edge;
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_EDGE' IN 
        TYPEOF(an_edge) THEN
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge\oriented_edge.edge_element,NOT an_edge\
          oriented_edge.orientation);
    ELSE
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- edge_reversed

  FUNCTION face_bound_reversed(
               a_face_bound: face_bound
      ): face_bound;

    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.FACE_OUTER_BOUND' IN 
        TYPEOF(a_face_bound) THEN
      the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
          NOT a_face_bound\face_bound.orientation) || face_outer_bound();
    ELSE
      the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT 
          a_face_bound.orientation);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_bound_reversed

  FUNCTION face_reversed(
               a_face: face
      ): oriented_face;

    LOCAL
      the_reverse : oriented_face;
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_FACE' IN 
        TYPEOF(a_face) THEN
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face\oriented_face.face_element,NOT 
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_reversed

  FUNCTION first_proj_axis(
               z_axis, arg: direction
      ): direction;

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN
      RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF (z.direction_ratios <> [1,0,0]) AND (z.direction_ratios <> [-1,
            0,0]) THEN
          v := dummy_gri || direction([1,0,0]);
        ELSE
          v := dummy_gri || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim <> 3 THEN
          RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

  END_FUNCTION; -- first_proj_axis

  FUNCTION get_basis_surface(
               c: curve_on_surface
      ): SET [0:2] OF surface;

    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PCURVE' IN TYPEOF(c)
         THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SURFACE_CURVE' IN 
          TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' 
        IN TYPEOF(c) THEN
      n := SIZEOF(c\composite_curve.segments);
      surfs := get_basis_surface(c\composite_curve.segments[1].
          parent_curve);
      IF n > 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve.segments[i]
              .parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);

  END_FUNCTION; -- get_basis_surface

  FUNCTION get_description_value(
               obj: description_attribute_select
      ): text;

    LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM');
    END_LOCAL;
    IF SIZEOF(description_bag) = 1 THEN
      RETURN(description_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_description_value

  FUNCTION get_id_value(
               obj: id_attribute_select
      ): identifier;

    LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM');
    END_LOCAL;
    IF SIZEOF(id_bag) = 1 THEN
      RETURN(id_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_id_value

  FUNCTION get_name_value(
               obj: name_attribute_select
      ): label;

    LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM');
    END_LOCAL;
    IF SIZEOF(name_bag) = 1 THEN
      RETURN(name_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_name_value

  FUNCTION get_product_definitions(
               c_def_instance: product
      ): SET OF product_definition;

    LOCAL
      pdr_set : SET OF product_definition := [];
      pd_set  : SET OF product_definition_formation := [];
    END_LOCAL;
    pd_set := bag_to_set(USEDIN(c_def_instance,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
    IF SIZEOF(pd_set) < 1 THEN
      RETURN(pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set) BY 1;
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION.FORMATION'));
    END_REPEAT;
    RETURN(pdr_set);

  END_FUNCTION; -- get_product_definitions

  FUNCTION get_property_definition_representations(
               c_def_instance: characterized_definition
      ): SET OF property_definition_representation;

    LOCAL
      pdr_set : SET OF property_definition_representation := [];
      pd_set  : SET OF property_definition := [];
    END_LOCAL;
    pd_set := bag_to_set(USEDIN(c_def_instance,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
    IF SIZEOF(pd_set) < 1 THEN
      RETURN(pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set) BY 1;
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    END_REPEAT;
    RETURN(pdr_set);

  END_FUNCTION; -- get_property_definition_representations

  FUNCTION get_role(
               obj: role_select
      ): object_role;

    LOCAL
      role_bag : BAG OF role_association := USEDIN(obj,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE');
    END_LOCAL;
    IF SIZEOF(role_bag) = 1 THEN
      RETURN(role_bag[1].role);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_role

  FUNCTION get_shape_aspects(
               c_def_instance: characterized_definition
      ): SET OF shape_aspect;

    LOCAL
      pdr_set : SET OF shape_aspect := [];
      pd_set  : SET OF product_definition_shape := [];
    END_LOCAL;
    pd_set := bag_to_set(QUERY ( pd <* USEDIN(c_def_instance,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION')
         | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ));
    IF SIZEOF(pd_set) < 1 THEN
      RETURN(pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set) BY 1;
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SHAPE_ASPECT.OF_SHAPE'));
    END_REPEAT;
    RETURN(pdr_set);

  END_FUNCTION; -- get_shape_aspects

  FUNCTION initial_context_is_additional(
               pd: product_definition
      ): BOOLEAN;

    LOCAL
      initial_context      : product_definition_context;
      context_associations : SET OF product_definition_context_association;
    END_LOCAL;
    initial_context := pd.frame_of_reference;
    context_associations := QUERY ( pdca <* bag_to_set(USEDIN(pd,'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION'))
         | ((pdca.role.name = 'additional context') AND (pdca.
        frame_of_reference :=: initial_context)) );
    RETURN(SIZEOF(context_associations) > 0);

  END_FUNCTION; -- initial_context_is_additional

  FUNCTION item_in_context(
               item: representation_item;
               cntxt: representation_context
      ): BOOLEAN;

    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,
        'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.REPRESENTATION.ITEMS') 
        * cntxt.representations_in_context) > 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.REPRESENTATION_ITEM' 
          IN TYPEOF(z)) );
      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- item_in_context

  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- leap_year

  FUNCTION list_face_loops(
               f: face
      ): LIST OF loop;

    LOCAL
      loops : LIST OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);

  END_FUNCTION; -- list_face_loops

  FUNCTION list_loop_edges(
               l: loop
      ): LIST OF edge;

    LOCAL
      edges : LIST OF edge := [];
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EDGE_LOOP' IN TYPEOF(l)
         THEN
      REPEAT i := 1 TO SIZEOF(l\path.edge_list) BY 1;
        edges := edges + l\path.edge_list[i].edge_element;
      END_REPEAT;
    END_IF;
    RETURN(edges);

  END_FUNCTION; -- list_loop_edges

  FUNCTION list_of_topology_reversed(
               a_list: list_of_reversible_topology_item
      ): list_of_reversible_topology_item;

    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- list_of_topology_reversed

  FUNCTION list_shell_edges(
               s: shell
      ): LIST OF edge;

    LOCAL
      edges : LIST OF edge := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(list_shell_loops(s)) BY 1;
      edges := edges + list_loop_edges(list_shell_loops(s)[i]);
    END_REPEAT;
    RETURN(edges);

  END_FUNCTION; -- list_shell_edges

  FUNCTION list_shell_faces(
               s: shell
      ): LIST OF face;

    LOCAL
      faces : LIST OF face := [];
    END_LOCAL;
    IF ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CLOSED_SHELL' IN 
        TYPEOF(s)) OR (
        'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.OPEN_SHELL' IN TYPEOF(
        s)) THEN
      REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces) BY 1;
        faces := faces + s\connected_face_set.cfs_faces[i];
      END_REPEAT;
    END_IF;
    RETURN(faces);

  END_FUNCTION; -- list_shell_faces

  FUNCTION list_shell_loops(
               s: shell
      ): LIST OF loop;

    LOCAL
      loops : LIST OF loop := [];
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VERTEX_SHELL' IN 
        TYPEOF(s) THEN
      loops := loops + s.vertex_shell_extent;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.WIRE_SHELL' IN TYPEOF(
        s) THEN
      REPEAT i := 1 TO SIZEOF(s.wire_shell_extent) BY 1;
        loops := loops + s.wire_shell_extent[i];
      END_REPEAT;
    END_IF;
    IF ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.OPEN_SHELL' IN 
        TYPEOF(s)) OR (
        'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CLOSED_SHELL' IN 
        TYPEOF(s)) THEN
      REPEAT i := 1 TO SIZEOF(s.cfs_faces) BY 1;
        loops := loops + list_face_loops(s.cfs_faces[i]);
      END_REPEAT;
    END_IF;
    RETURN(loops);

  END_FUNCTION; -- list_shell_loops

  FUNCTION list_to_array(
               lis: LIST OF GENERIC:t;
               low: INTEGER;
               u: INTEGER
      ): ARRAY [low:u] OF GENERIC:t;

    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n <> ((u - low) + 1) THEN
      RETURN(?);
    ELSE
      res := [lis[1],n];
      REPEAT i := 2 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;

  END_FUNCTION; -- list_to_array

  FUNCTION list_to_set(
               l: LIST OF GENERIC:t
      ): SET OF GENERIC:t;

    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);

  END_FUNCTION; -- list_to_set

  FUNCTION local_relatives_of_product_definitions(
               definition_set: SET OF product_definition;
               total_definitions: SET OF product_definition;
               relation_subtype: STRING
      ): SET OF product_definition;

    LOCAL
      local_def   : SET OF product_definition := [];
      local_pdr   : SET OF product_definition_relationship := [];
      local_total : SET OF product_definition := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(definition_set) BY 1;
      local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i],
          relation_subtype + 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION'));
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(local_pdr) BY 1;
      local_def := local_def + local_pdr[i].related_product_definition;
    END_REPEAT;
    IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
      RETURN(local_def);
    ELSE
      local_total := total_definitions + local_def;
      RETURN(local_def + local_relatives_of_product_definitions(local_def 
          - total_definitions,local_total,relation_subtype));
    END_IF;

  END_FUNCTION; -- local_relatives_of_product_definitions

  FUNCTION local_relatives_of_shape_representations(
               shape_representation_set: SET OF shape_representation;
               total_reps: SET OF shape_representation
      ): SET OF shape_representation;

    LOCAL
      local_shape_rep : SET OF shape_representation := [];
      local_srr       : SET OF shape_representation_relationship := [];
      local_total     : SET OF shape_representation := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(shape_representation_set) BY 1;
      local_srr := local_srr + QUERY ( rr <* bag_to_set(USEDIN(
          shape_representation_set[i],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.REPRESENTATION_RELATIONSHIP.REP_1'))
           | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SHAPE_REPRESENTATION_RELATIONSHIP' 
          IN TYPEOF(rr)) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(local_srr) BY 1;
      IF ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.' + 
          'SHAPE_REPRESENTATION_RELATIONSHIP') IN TYPEOF(local_srr[i])
           THEN
        local_shape_rep := local_shape_rep + local_srr[i].rep_2;
      END_IF;
    END_REPEAT;
    IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
      RETURN(shape_representation_set);
    ELSE
      local_total := total_reps + local_shape_rep;
      RETURN(local_shape_rep + local_relatives_of_shape_representations(
          local_shape_rep - total_reps,local_total));
    END_IF;

  END_FUNCTION; -- local_relatives_of_shape_representations

  FUNCTION make_array_of_array(
               lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1: INTEGER;
               u1: INTEGER;
               low2: INTEGER;
               u2: INTEGER
      ): ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;

    LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN
      RETURN(?);
    END_IF;
    IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN
      RETURN(?);
    END_IF;
    res := [list_to_array(lis[1],low2,u2),(u1 - low1) + 1];
    REPEAT i := 2 TO HIINDEX(lis) BY 1;
      IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN
        RETURN(?);
      END_IF;
      res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    RETURN(res);

  END_FUNCTION; -- make_array_of_array

  FUNCTION make_array_of_array_of_array(
               lis: LIST [1:?] OF LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1: INTEGER;
               u1: INTEGER;
               low2: INTEGER;
               u2: INTEGER;
               low3: INTEGER;
               u3: INTEGER
      ): ARRAY [low1:u1] OF ARRAY [low2:u2] OF ARRAY [low3:u3] OF GENERIC
             :t;

    LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF ARRAY [low3:u3] OF
              GENERIC:t;
    END_LOCAL;
    IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN
      RETURN(?);
    END_IF;
    IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN
      RETURN(?);
    END_IF;
    res := [make_array_of_array(lis[1],low2,u2,low3,u3):(u1 - low1) + 1];
    REPEAT i := 2 TO HIINDEX(lis) BY 1;
      IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN
        RETURN(?);
      END_IF;
      res[(low1 + i) - 1] := make_array_of_array(lis[i],low2,u2,low3,u3);
    END_REPEAT;
    RETURN(res);

  END_FUNCTION; -- make_array_of_array_of_array

  FUNCTION mixed_loop_type_set(
               l: SET OF loop
      ): LOGICAL;

    LOCAL
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) <= 1 THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := 
        'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.POLY_LOOP' IN TYPEOF(l
        [1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.POLY_LOOP' IN 
          TYPEOF(l[i])) <> poly_loop_type THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);

  END_FUNCTION; -- mixed_loop_type_set

  FUNCTION msb_shells(
               brep: manifold_solid_brep
      ): SET [1:?] OF closed_shell;
    IF SIZEOF(QUERY ( msbtype <* TYPEOF(brep) | (msbtype LIKE 
        '*BREP_WITH_VOIDS') )) >= 1 THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;

  END_FUNCTION; -- msb_shells

  FUNCTION normalise(
               arg: vector_or_direction
      ): vector_or_direction;

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      result := ?;
    ELSE
      ndim := arg.dim;
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(
          arg) THEN
        v := dummy_gri || direction(arg.orientation.direction_ratios);
        IF arg.magnitude = 0 THEN
          RETURN(?);
        ELSE
          vec := dummy_gri || vector(v,1);
        END_IF;
      ELSE
        v := dummy_gri || direction(arg.direction_ratios);
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := mag;
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(
            arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- normalise

  FUNCTION open_shell_reversed(
               a_shell: open_shell
      ): oriented_open_shell;

    LOCAL
      the_reverse : oriented_open_shell;
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_OPEN_SHELL' 
        IN TYPEOF(a_shell) THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- open_shell_reversed

  FUNCTION orthogonal_complement(
               vec: direction
      ): direction;

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result := dummy_gri || direction([-vec.direction_ratios[2],vec.
          direction_ratios[1]]);
      RETURN(result);
    END_IF;

  END_FUNCTION; -- orthogonal_complement

  FUNCTION path_head_to_tail(
               a_path: path
      ): LOGICAL;

    LOCAL
      n : INTEGER;
      p : LOGICAL := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);

  END_FUNCTION; -- path_head_to_tail

  FUNCTION path_reversed(
               a_path: path
      ): oriented_path;

    LOCAL
      the_reverse : oriented_path;
    END_LOCAL;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ORIENTED_PATH' IN 
        TYPEOF(a_path) THEN
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path\oriented_path.path_element,
          NOT a_path\oriented_path.orientation);
    ELSE
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- path_reversed

  FUNCTION relatives_of_product_definitions(
               definition_set: SET OF product_definition;
               relation_subtype: STRING
      ): SET OF product_definition;
    RETURN(local_relatives_of_product_definitions(definition_set,
        definition_set,relation_subtype));

  END_FUNCTION; -- relatives_of_product_definitions

  FUNCTION relatives_of_shape_representations(
               shape_representation_set: SET OF shape_representation
      ): SET OF shape_representation;
    RETURN(local_relatives_of_shape_representations(
        shape_representation_set,shape_representation_set));

  END_FUNCTION; -- relatives_of_shape_representations

  FUNCTION same_side(
               plane_pts: LIST [3:3] OF cartesian_point;
               test_points: LIST [2:?] OF cartesian_point
      ): BOOLEAN;

    LOCAL
      n    : INTEGER;
      val2 : REAL;
      val1 : REAL;
    END_LOCAL;
    IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
      RETURN(?);
    END_IF;
    n := SIZEOF(test_points);
    val1 := above_plane(plane_pts[1],plane_pts[2],plane_pts[3],test_points
        [1]);
    REPEAT i := 2 TO n BY 1;
      val2 := above_plane(plane_pts[1],plane_pts[2],plane_pts[3],
          test_points[i]);
      IF (val1 * val2) <= 0 THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- same_side

  FUNCTION scalar_times_vector(
               scalar: REAL;
               vec: vector_or_direction
      ): vector;

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(
          vec) THEN
        v := dummy_gri || direction(vec.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v),mag);
    END_IF;
    RETURN(result);

  END_FUNCTION; -- scalar_times_vector

  FUNCTION second_proj_axis(
               z_axis, x_axis, arg: direction
      ): direction;

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := dummy_gri || direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

  END_FUNCTION; -- second_proj_axis

  FUNCTION set_of_topology_reversed(
               a_set: set_of_reversible_topology_item
      ): set_of_reversible_topology_item;

    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- set_of_topology_reversed

  FUNCTION shell_reversed(
               a_shell: shell
      ): shell;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.OPEN_SHELL' IN TYPEOF(
        a_shell) THEN
      RETURN(open_shell_reversed(a_shell));
    ELSE
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CLOSED_SHELL' IN 
          TYPEOF(a_shell) THEN
        RETURN(closed_shell_reversed(a_shell));
      ELSE
        RETURN(?);
      END_IF;
    END_IF;

  END_FUNCTION; -- shell_reversed

  FUNCTION surface_weights_positive(
               b: rational_b_spline_surface
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] <= 0 THEN
          result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- surface_weights_positive

  FUNCTION topology_reversed(
               an_item: reversible_topology
      ): reversible_topology;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.EDGE' IN TYPEOF(
        an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PATH' IN TYPEOF(
        an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.FACE_BOUND' IN TYPEOF(
        an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.FACE' IN TYPEOF(
        an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SHELL' IN TYPEOF(
        an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);

  END_FUNCTION; -- topology_reversed

  FUNCTION type_check_function(
               the_type: GENERIC;
               sub_names: SET OF STRING;
               criterion: INTEGER
      ): LOGICAL;
    IF (NOT EXISTS(the_type)) OR (NOT ((0 <= criterion) AND (criterion <= 
        3))) OR (SIZEOF(sub_names) = 0) THEN
      RETURN(UNKNOWN);
    ELSE
      CASE criterion OF
        0  :           RETURN(SIZEOF(sub_names * TYPEOF(the_type)) > 0);
        1  :           RETURN(SIZEOF(sub_names * TYPEOF(the_type)) = 0);
        2  :           RETURN(SIZEOF(sub_names * TYPEOF(the_type)) = 1);
        3  :           RETURN(SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
        END_CASE;
    END_IF;

  END_FUNCTION; -- type_check_function

  FUNCTION using_items(
               item: founded_item_select;
               checked_items: SET OF founded_item_select
      ): SET OF founded_item_select;

    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | ((
        'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.REPRESENTATION_ITEM' 
        IN TYPEOF(z)) OR (
        'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.FOUNDED_ITEM' IN 
        TYPEOF(z))) );
    IF SIZEOF(next_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);

  END_FUNCTION; -- using_items

  FUNCTION using_representations(
               item: founded_item_select
      ): SET OF representation;

    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,
        'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);

  END_FUNCTION; -- using_representations

  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    CASE date.month_component OF
      1 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      2 :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      3 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      4 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      5 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      6 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      7 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      8 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      9 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      10  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      11  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      12  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      END_CASE;
    RETURN(FALSE);

  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_measure_value(
               m: measure_value
      ): BOOLEAN;
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m > 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN
        RETURN(m > 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;

  END_FUNCTION; -- valid_measure_value

  FUNCTION valid_time(
               time: local_time
      ): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- valid_time

  FUNCTION valid_units(
               m: measure_with_unit
      ): BOOLEAN;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.LENGTH_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.MASS_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.TIME_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.ELECTRIC_CURRENT_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.LUMINOUS_INTENSITY_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.PLANE_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.SOLID_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.AREA_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VOLUME_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.RATIO_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.POSITIVE_LENGTH_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- valid_units

  FUNCTION value_range_wr1(
               agg: AGGREGATE OF representation_item
      ): BOOLEAN;
    IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY ( i1 <* agg | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF(i1)) )) = 2) OR (SIZEOF(QUERY ( i2 <* agg | ('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VALUE_REPRESENTATION_ITEM' 
        IN TYPEOF(i2)) )) = 2)) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- value_range_wr1

  FUNCTION value_range_wr2(
               agg: AGGREGATE OF representation_item
      ): BOOLEAN;
    IF (SIZEOF(QUERY ( i <* agg | (i.name = 'upper limit') )) = 1) AND (
        SIZEOF(QUERY ( i <* agg | (i.name = 'lower limit') )) = 1) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- value_range_wr2

  FUNCTION value_range_wr3(
               agg: AGGREGATE OF representation_item
      ): BOOLEAN;
    IF SIZEOF(QUERY ( i1 <* agg | (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF(i1)) AND (SIZEOF(QUERY ( i2 <* agg | (('AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF(i2)) AND (i1 :<>: i2) AND (i1\measure_with_unit.
        unit_component :=: i2\measure_with_unit.unit_component)) )) = 1)) )) 
        = 2 THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- value_range_wr3

  FUNCTION vector_difference(
               arg1, arg2: vector_or_direction
      ): vector;

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      RETURN(?);
    ELSE
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(
          arg1) THEN
        mag1 := arg1.magnitude;
        vec1 := arg1.orientation;
      ELSE
        mag1 := 1;
        vec1 := arg1;
      END_IF;
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(
          arg2) THEN
        mag2 := arg2.magnitude;
        vec2 := arg2.orientation;
      ELSE
        mag2 := 1;
        vec2 := arg2;
      END_IF;
      vec1 := normalise(vec1);
      vec2 := normalise(vec2);
      ndim := SIZEOF(vec1.direction_ratios);
      mag := 0;
      res := dummy_gri || direction(vec1.direction_ratios);
      REPEAT i := 1 TO ndim BY 1;
        res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
            mag2 * vec2.direction_ratios[i]);
        mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        result := dummy_gri || vector(res,mag);
      ELSE
        result := dummy_gri || vector(vec1,0);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- vector_difference

  FUNCTION vector_sum(
               arg1, arg2: vector_or_direction
      ): vector;

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      RETURN(?);
    ELSE
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(
          arg1) THEN
        mag1 := arg1.magnitude;
        vec1 := arg1.orientation;
      ELSE
        mag1 := 1;
        vec1 := arg1;
      END_IF;
      IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(
          arg2) THEN
        mag2 := arg2.magnitude;
        vec2 := arg2.orientation;
      ELSE
        mag2 := 1;
        vec2 := arg2;
      END_IF;
      vec1 := normalise(vec1);
      vec2 := normalise(vec2);
      ndim := SIZEOF(vec1.direction_ratios);
      mag := 0;
      res := dummy_gri || direction(vec1.direction_ratios);
      REPEAT i := 1 TO ndim BY 1;
        res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
            mag2 * vec2.direction_ratios[i]);
        mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        result := dummy_gri || vector(res,mag);
      ELSE
        result := dummy_gri || vector(vec1,0);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- vector_sum

  FUNCTION version_assignment_is_valid(
               aia: applied_identification_assignment
      ): BOOLEAN;

    LOCAL
      item : identification_item;
      role : identification_role;
    END_LOCAL;
    role := aia.role;
    IF role.name = 'version' THEN
      REPEAT i := LOINDEX(aia.items) TO HIINDEX(aia.items) BY 1;
        item := aia.items[i];
        IF SIZEOF(['AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.' + 
            'VERSIONABLE_ITEM'] * TYPEOF(item)) = 0 THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- version_assignment_is_valid

  FUNCTION vertex_point_pcurves(
               a_vertex: vertex_point;
               the_degenerates: SET OF evaluated_degenerate_pcurve
      ): SET OF degenerate_pcurve;

    LOCAL
      a_point : point;
      result  : SET OF degenerate_pcurve;
    END_LOCAL;
    a_point := a_vertex.vertex_geometry;
    result := [];
    IF 'AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.DEGENERATE_PCURVE' IN 
        TYPEOF(a_point) THEN
      result := result + a_point;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates) BY 1;
        IF the_degenerates[j].equivalent_point :=: a_point THEN
          result := result + the_degenerates[j];
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- vertex_point_pcurves

  FUNCTION volume_weights_positive(
               b: rational_b_spline_volume
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        REPEAT k := 0 TO b.w_upper BY 1;
          IF b.weights[i][j][k] <= 0 THEN
            result := FALSE;
            RETURN(result);
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- volume_weights_positive

END_SCHEMA; -- ap239_product_definition_information_mim_lf
