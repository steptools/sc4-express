(***********************************************************************
Title:  AIM long for form ISO/IS 10303-209
Author: Keith Hunten and Adnan Yucel
Date: 2001-06-01
N-number: ISO TC184/SC4/WG3 N972
***********************************************************************)

(* 
   File generated 5 September 2000
   Adnan Yucel, LM Aero
   817-777-0028
   
   Fedex bug: DIV replaced by / in FUNCTION number_of_terms.
   Manually corrected.
   
   13584-20 bug: corrected wr1 rule of comparison_expression.
   
   revised the derived attribute of surface_of_revolution per latest p42TC3.
*)

SCHEMA structural_analysis_design;

  CONSTANT
  dummy_gri : geometric_representation_item := representation_item('') || 
                 geometric_representation_item();
  dummy_tri : topological_representation_item := representation_item('') 
                 || topological_representation_item();
  END_CONSTANT;

  TYPE action_item = SELECT
    (product_definition,
     product_definition_formation,
     product_definition_relationship);
  END_TYPE; -- action_item

  TYPE action_request_item = SELECT
    (product_definition,
     product_definition_formation,
     product_definition_relationship);
  END_TYPE; -- action_request_item

  TYPE action_type = ENUMERATION OF
    (applied_loads,
     residual_loads);
  END_TYPE; -- action_type

  TYPE aggregated_angular_variable = ENUMERATION OF
    (total_applied_moment,
     application_defined_aggregated_angular_scalar_variable);
  END_TYPE; -- aggregated_angular_variable

  TYPE aggregated_scalar_variable = ENUMERATION OF
    (total_strain_energy,
     mass,
     volume);
  END_TYPE; -- aggregated_scalar_variable

  TYPE aggregated_tensor2_3d_variable = ENUMERATION OF
    (rotational_inertia);
  END_TYPE; -- aggregated_tensor2_3d_variable

  TYPE aggregated_vector_3d_variable = ENUMERATION OF
    (total_applied_force,
     centre_of_mass_offset);
  END_TYPE; -- aggregated_vector_3d_variable

  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     behind);
  END_TYPE; -- ahead_or_behind

  TYPE amount_of_substance_measure = REAL;
  END_TYPE; -- amount_of_substance_measure

  TYPE angular_value = context_dependent_measure;
  END_TYPE; -- angular_value

  TYPE anisotropic_symmetric_tensor2_2d = ARRAY [1:3] OF
                  context_dependent_measure;
  END_TYPE; -- anisotropic_symmetric_tensor2_2d

  TYPE anisotropic_symmetric_tensor2_3d = ARRAY [1:6] OF
                  context_dependent_measure;
  END_TYPE; -- anisotropic_symmetric_tensor2_3d

  TYPE anisotropic_symmetric_tensor4_2d = ARRAY [1:6] OF
                  context_dependent_measure;
  END_TYPE; -- anisotropic_symmetric_tensor4_2d

  TYPE anisotropic_symmetric_tensor4_3d = ARRAY [1:21] OF
                  context_dependent_measure;
  END_TYPE; -- anisotropic_symmetric_tensor4_3d

  TYPE application_defined_degree_of_freedom = STRING;
  END_TYPE; -- application_defined_degree_of_freedom

  TYPE application_defined_element_purpose = STRING;
  END_TYPE; -- application_defined_element_purpose

  TYPE application_defined_matrix_property_type = STRING;
  END_TYPE; -- application_defined_matrix_property_type

  TYPE application_defined_scalar_variable = STRING;
  END_TYPE; -- application_defined_scalar_variable

  TYPE application_defined_tensor2_2d_variable = STRING;
  END_TYPE; -- application_defined_tensor2_2d_variable

  TYPE application_defined_tensor2_3d_variable = STRING;
  END_TYPE; -- application_defined_tensor2_3d_variable

  TYPE application_defined_vector_2d_variable = STRING;
  END_TYPE; -- application_defined_vector_2d_variable

  TYPE application_defined_vector_3d_variable = STRING;
  END_TYPE; -- application_defined_vector_3d_variable

  TYPE approval_item = SELECT
    (action_directive,
     certification,
     configuration_item,
     configuration_effectivity,
     contract,
     control,
     fea_model,
     product_definition,
     product_definition_formation,
     result,
     retention,
     security_classification,
     versioned_action_request);
  END_TYPE; -- approval_item

  TYPE area_measure = REAL;
  END_TYPE; -- area_measure

  TYPE axi_or_plane = ENUMERATION OF
    (axisymmetric,
     planar);
  END_TYPE; -- axi_or_plane

  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE; -- axis2_placement

  TYPE b_spline_curve_form = ENUMERATION OF
    (polyline_form,
     circular_arc,
     elliptic_arc,
     parabolic_arc,
     hyperbolic_arc,
     unspecified);
  END_TYPE; -- b_spline_curve_form

  TYPE b_spline_surface_form = ENUMERATION OF
    (plane_surf,
     cylindrical_surf,
     conical_surf,
     spherical_surf,
     toroidal_surf,
     surf_of_revolution,
     ruled_surf,
     generalised_cone,
     quadric_surf,
     surf_of_linear_extrusion,
     unspecified);
  END_TYPE; -- b_spline_surface_form

  TYPE boolean_operand = SELECT
    (solid_model);
  END_TYPE; -- boolean_operand

  TYPE boundary_aggregated_variable = SELECT
    (aggregated_vector_3d_variable,
     application_defined_vector_3d_variable);
  END_TYPE; -- boundary_aggregated_variable

  TYPE boundary_curve_scalar_variable = ENUMERATION OF
    (normal_force_per_unit_length);
  END_TYPE; -- boundary_curve_scalar_variable

  TYPE boundary_curve_vector_3d_variable = ENUMERATION OF
    (applied_force_per_unit_length,
     applied_moment_per_unit_length);
  END_TYPE; -- boundary_curve_vector_3d_variable

  TYPE boundary_edge_variable = SELECT
    (boundary_curve_scalar_variable,
     boundary_curve_vector_3d_variable,
     application_defined_scalar_variable,
     application_defined_vector_3d_variable);
  END_TYPE; -- boundary_edge_variable

  TYPE boundary_surface_scalar_variable = ENUMERATION OF
    (pressure);
  END_TYPE; -- boundary_surface_scalar_variable

  TYPE boundary_surface_vector_3d_variable = ENUMERATION OF
    (applied_force_per_unit_area,
     applied_moment_per_unit_area);
  END_TYPE; -- boundary_surface_vector_3d_variable

  TYPE boundary_variable = SELECT
    (boundary_surface_scalar_variable,
     boundary_surface_vector_3d_variable,
     application_defined_scalar_variable,
     application_defined_vector_3d_variable);
  END_TYPE; -- boundary_variable

  TYPE certification_item = SELECT
    (product_definition_relationship);
  END_TYPE; -- certification_item

  TYPE characterized_definition = SELECT
    (characterized_object,
     characterized_product_definition,
     shape_definition);
  END_TYPE; -- characterized_definition

  TYPE characterized_material_property = SELECT
    (material_property_representation,
     product_material_composition_relationship);
  END_TYPE; -- characterized_material_property

  TYPE characterized_product_definition = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE; -- characterized_product_definition

  TYPE context_dependent_measure = REAL;
  END_TYPE; -- context_dependent_measure

  TYPE contract_item = SELECT
    (product_definition_formation);
  END_TYPE; -- contract_item

  TYPE coordinate_system_type = ENUMERATION OF
    (cartesian,
     cylindrical,
     spherical);
  END_TYPE; -- coordinate_system_type

  TYPE count_measure = NUMBER;
  END_TYPE; -- count_measure

  TYPE curve_2d_element_descriptor = SELECT
    (axisymmetric_curve_2d_element_descriptor,
     plane_curve_2d_element_descriptor);
  END_TYPE; -- curve_2d_element_descriptor

  TYPE curve_2d_element_output_reference = SELECT
    (curve_2d_element_representation,
     curve_2d_element_descriptor,
     curve_2d_element_group,
     curve_2d_substructure_element_reference,
     analysis_item_within_representation);
  END_TYPE; -- curve_2d_element_output_reference

  TYPE curve_2d_element_representation = SELECT
    (axisymmetric_curve_2d_element_representation,
     plane_curve_2d_element_representation);
  END_TYPE; -- curve_2d_element_representation

  TYPE curve_2d_state_coordinate_system = SELECT
    (fea_axis2_placement_3d,
     curve_2d_element_coordinate_system);
  END_TYPE; -- curve_2d_state_coordinate_system

  TYPE curve_3d_element_coordinate_system = SELECT
    (aligned_curve_3d_element_coordinate_system,
     parametric_curve_3d_element_coordinate_system);
  END_TYPE; -- curve_3d_element_coordinate_system

  TYPE curve_3d_element_length_integration = SELECT
    (element_integration_algebraic,
     curve_3d_element_length_integration_rule,
     curve_3d_element_length_integration_explicit);
  END_TYPE; -- curve_3d_element_length_integration

  TYPE curve_3d_element_output_reference = SELECT
    (curve_3d_element_representation,
     curve_3d_element_descriptor,
     curve_3d_element_group,
     curve_3d_substructure_element_reference,
     analysis_item_within_representation);
  END_TYPE; -- curve_3d_element_output_reference

  TYPE curve_3d_state_coordinate_system = SELECT
    (fea_axis2_placement_3d,
     curve_3d_element_coordinate_system);
  END_TYPE; -- curve_3d_state_coordinate_system

  TYPE curve_edge = ENUMERATION OF
    (element_edge);
  END_TYPE; -- curve_edge

  TYPE curve_element_end_coordinate_system = SELECT
    (fea_axis2_placement_3d,
     curve_3d_element_coordinate_system);
  END_TYPE; -- curve_element_end_coordinate_system

  TYPE curve_element_freedom = SELECT
    (enumerated_curve_element_freedom,
     application_defined_degree_of_freedom);
  END_TYPE; -- curve_element_freedom

  TYPE curve_element_purpose = SELECT
    (enumerated_curve_element_purpose,
     application_defined_element_purpose);
  END_TYPE; -- curve_element_purpose

  TYPE curve_element_variable = SELECT
    (volume_variable,
     curve_scalar_variable,
     curve_vector_2d_variable,
     application_defined_vector_2d_variable,
     curve_vector_3d_variable);
  END_TYPE; -- curve_element_variable

  TYPE curve_matrix_property_type = SELECT
    (enumerated_curve_matrix_property_type,
     application_defined_matrix_property_type);
  END_TYPE; -- curve_matrix_property_type

  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE; -- curve_on_surface

  TYPE curve_scalar_variable = ENUMERATION OF
    (curve_axial_force,
     curve_axial_strain,
     torque,
     curve_warping,
     bi_moment,
     twist);
  END_TYPE; -- curve_scalar_variable

  TYPE curve_vector_2d_variable = ENUMERATION OF
    (curve_shear_force,
     curve_bending_moment,
     curve_element_curvature,
     curve_thermal_gradient,
     reference_curve_thermal_gradient);
  END_TYPE; -- curve_vector_2d_variable

  TYPE curve_vector_3d_variable = ENUMERATION OF
    (applied_force_per_unit_length,
     applied_moment_per_unit_length);
  END_TYPE; -- curve_vector_3d_variable

  TYPE cylindrical_harmonic_number = INTEGER;
  WHERE
    wr1: (SELF >= 0);
  END_TYPE; -- cylindrical_harmonic_number

  TYPE date_item = SELECT
    (action_directive,
     approval_person_organization,
     certification,
     contract,
     product_definition,
     retention,
     security_classification,
     versioned_action_request);
  END_TYPE; -- date_item

  TYPE date_time_item = SELECT
    (action_directive,
     approval_person_organization,
     certification,
     contract,
     product_definition,
     retention,
     security_classification,
     versioned_action_request);
  END_TYPE; -- date_time_item

  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  END_TYPE; -- day_in_month_number

  TYPE day_in_week_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 7));
  END_TYPE; -- day_in_week_number

  TYPE day_in_year_number = INTEGER;
  END_TYPE; -- day_in_year_number

  TYPE degree_of_freedom = SELECT
    (enumerated_degree_of_freedom,
     application_defined_degree_of_freedom);
  END_TYPE; -- degree_of_freedom

  TYPE descriptive_measure = STRING;
  END_TYPE; -- descriptive_measure

  TYPE dimension_count = INTEGER;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- dimension_count

  TYPE dimensional_characteristic = SELECT
    (dimensional_size);
  END_TYPE; -- dimensional_characteristic

  TYPE directionally_explicit_element_coordinate_system = SELECT
    (directionally_explicit_element_coordinate_system_arbitrary,
     directionally_explicit_element_coordinate_system_aligned);
  END_TYPE; -- directionally_explicit_element_coordinate_system

  TYPE document_reference_item = SELECT
    (product_definition,
     shape_aspect);
  END_TYPE; -- document_reference_item

  TYPE electric_current_measure = REAL;
  END_TYPE; -- electric_current_measure

  TYPE element_2d_shape = ENUMERATION OF
    (quadrilateral,
     triangle);
  END_TYPE; -- element_2d_shape

  TYPE element_aspect = SELECT
    (element_volume,
     volume_3d_face,
     volume_2d_face,
     volume_3d_edge,
     volume_2d_edge,
     surface_3d_face,
     surface_2d_face,
     surface_3d_edge,
     surface_2d_edge,
     curve_edge);
  END_TYPE; -- element_aspect

  TYPE element_integration_algebraic = ENUMERATION OF
    (algebraic);
  END_TYPE; -- element_integration_algebraic

  TYPE element_or_element_group = SELECT
    (element_representation,
     element_group);
  END_TYPE; -- element_or_element_group

  TYPE element_order = ENUMERATION OF
    (linear,
     quadratic,
     cubic);
  END_TYPE; -- element_order

  TYPE element_volume = ENUMERATION OF
    (volume);
  END_TYPE; -- element_volume

  TYPE enumerated_curve_element_freedom = ENUMERATION OF
    (x_translation,
     y_translation,
     z_translation,
     x_rotation,
     y_rotation,
     z_rotation,
     warp,
     none);
  END_TYPE; -- enumerated_curve_element_freedom

  TYPE enumerated_curve_element_purpose = ENUMERATION OF
    (axial,
     y_y_bending,
     z_z_bending,
     torsion,
     x_y_shear,
     x_z_shear,
     warping);
  END_TYPE; -- enumerated_curve_element_purpose

  TYPE enumerated_curve_matrix_property_type = ENUMERATION OF
    (axial,
     y_y_bending,
     z_z_bending,
     torsion,
     x_y_shear,
     x_z_shear,
     warping,
     axial_mass,
     y_y_bending_mass,
     z_z_bending_mass,
     torsion_mass,
     x_y_shear_mass,
     x_z_shear_mass,
     warping_mass,
     mass);
  END_TYPE; -- enumerated_curve_matrix_property_type

  TYPE enumerated_degree_of_freedom = ENUMERATION OF
    (x_translation,
     y_translation,
     z_translation,
     x_rotation,
     y_rotation,
     z_rotation,
     warp);
  END_TYPE; -- enumerated_degree_of_freedom

  TYPE enumerated_matrix_property_type = ENUMERATION OF
    (stiffness,
     mass,
     damping);
  END_TYPE; -- enumerated_matrix_property_type

  TYPE enumerated_plane_2d_element_purpose = ENUMERATION OF
    (plane_stress,
     plane_strain);
  END_TYPE; -- enumerated_plane_2d_element_purpose

  TYPE enumerated_surface_element_purpose = ENUMERATION OF
    (membrane_direct,
     membrane_shear,
     bending_direct,
     bending_torsion,
     normal_to_plane_shear);
  END_TYPE; -- enumerated_surface_element_purpose

  TYPE enumerated_surface_matrix_property_type = ENUMERATION OF
    (membrane_direct,
     membrane_shear,
     bending_direct,
     bending_torsion,
     normal_to_plane_shear,
     membrane_direct_mass,
     membrane_shear_mass,
     bending_direct_mass,
     bending_torsion_mass,
     normal_to_plane_shear_mass,
     mass);
  END_TYPE; -- enumerated_surface_matrix_property_type

  TYPE enumerated_volume_element_purpose = ENUMERATION OF
    (stress_displacement);
  END_TYPE; -- enumerated_volume_element_purpose

  TYPE fea_column_normalised_monoclinic_symmetric_tensor4_3d = ARRAY [1:13]
              OF context_dependent_measure;
  END_TYPE; -- fea_column_normalised_monoclinic_symmetric_tensor4_3d

  TYPE fea_column_normalised_orthotropic_symmetric_tensor4_3d = ARRAY [1:9]
              OF context_dependent_measure;
  END_TYPE; -- fea_column_normalised_orthotropic_symmetric_tensor4_3d

  TYPE fea_iso_orthotropic_symmetric_tensor4_3d = ARRAY [1:3] OF
              context_dependent_measure;
  END_TYPE; -- fea_iso_orthotropic_symmetric_tensor4_3d

  TYPE fea_isotropic_symmetric_tensor4_3d = ARRAY [1:2] OF
              context_dependent_measure;
  END_TYPE; -- fea_isotropic_symmetric_tensor4_3d

  TYPE fea_transverse_isotropic_symmetric_tensor4_3d = ARRAY [1:5] OF
              context_dependent_measure;
  END_TYPE; -- fea_transverse_isotropic_symmetric_tensor4_3d

  TYPE field_value = SELECT
    (unspecified_value,
     scalar,
     tensor1_2d,
     tensor1_3d,
     anisotropic_symmetric_tensor2_2d,
     isotropic_symmetric_tensor2_3d,
     orthotropic_symmetric_tensor2_3d,
     anisotropic_symmetric_tensor2_3d);
  END_TYPE; -- field_value

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE; -- founded_item_select

  TYPE geometric_set_select = SELECT
    (point,
     curve,
     surface);
  END_TYPE; -- geometric_set_select

  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 24));
  END_TYPE; -- hour_in_day

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE integration_rule = ENUMERATION OF
    (gaussian,
     simpson);
  END_TYPE; -- integration_rule

  TYPE isotropic_symmetric_tensor2_3d = context_dependent_measure;
  END_TYPE; -- isotropic_symmetric_tensor2_3d

  TYPE knot_type = ENUMERATION OF
    (uniform_knots,
     unspecified,
     quasi_uniform_knots,
     piecewise_bezier_knots);
  END_TYPE; -- knot_type

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE length_measure = REAL;
  END_TYPE; -- length_measure

  TYPE list_of_reversible_topology_item = LIST [0:?] OF
              reversible_topology_item;
  END_TYPE; -- list_of_reversible_topology_item

  TYPE luminous_intensity_measure = REAL;
  END_TYPE; -- luminous_intensity_measure

  TYPE mass_measure = REAL;
  END_TYPE; -- mass_measure

  TYPE matrix_property_type = SELECT
    (enumerated_matrix_property_type,
     application_defined_matrix_property_type);
  END_TYPE; -- matrix_property_type

  TYPE matrix_symmetry = ENUMERATION OF
    (symmetric,
     diagonal);
  END_TYPE; -- matrix_symmetry

  TYPE measure_or_unspecified_value = SELECT
    (context_dependent_measure,
     unspecified_value);
  END_TYPE; -- measure_or_unspecified_value

  TYPE measure_value = SELECT
    (length_measure,
     mass_measure,
     time_measure,
     electric_current_measure,
     thermodynamic_temperature_measure,
     amount_of_substance_measure,
     luminous_intensity_measure,
     plane_angle_measure,
     solid_angle_measure,
     area_measure,
     volume_measure,
     ratio_measure,
     parameter_value,
     numeric_measure,
     context_dependent_measure,
     descriptive_measure,
     positive_length_measure,
     positive_plane_angle_measure,
     positive_ratio_measure,
     count_measure);
  END_TYPE; -- measure_value

  TYPE message_level = ENUMERATION OF
    (error,
     warning,
     note);
  END_TYPE; -- message_level

  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 59));
  END_TYPE; -- minute_in_hour

  TYPE model_or_control_element = SELECT
    (element_representation,
     constraint_element);
  END_TYPE; -- model_or_control_element

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 12));
  END_TYPE; -- month_in_year_number

  TYPE name_item = SELECT
    (expression_conversion_based_unit);
  END_TYPE; -- name_item

  TYPE node_or_node_group = SELECT
    (node_representation,
     node_group);
  END_TYPE; -- node_or_node_group

  TYPE node_output_reference = SELECT
    (node_representation,
     node_group,
     substructure_node_reference,
     analysis_item_within_representation);
  END_TYPE; -- node_output_reference

  TYPE numeric_measure = NUMBER;
  END_TYPE; -- numeric_measure

  TYPE organization_item = SELECT
    (action_directive,
     configuration_item,
     contract,
     product,
     product_definition,
     product_definition_formation,
     security_classification,
     versioned_action_request);
  END_TYPE; -- organization_item

  TYPE orthotropic_symmetric_tensor2_3d = ARRAY [1:3] OF
              context_dependent_measure;
  END_TYPE; -- orthotropic_symmetric_tensor2_3d

  TYPE parameter_value = REAL;
  END_TYPE; -- parameter_value

  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE; -- pcurve_or_surface

  TYPE person_organization_item = SELECT
    (action_directive,
     configuration_item,
     contract,
     product,
     product_definition,
     product_definition_formation,
     security_classification,
     versioned_action_request);
  END_TYPE; -- person_organization_item

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE plane_2d_element_purpose = SELECT
    (enumerated_plane_2d_element_purpose,
     application_defined_element_purpose);
  END_TYPE; -- plane_2d_element_purpose

  TYPE plane_angle_measure = REAL;
  END_TYPE; -- plane_angle_measure

  TYPE positive_length_measure = length_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_length_measure

  TYPE positive_plane_angle_measure = plane_angle_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_plane_angle_measure

  TYPE positive_ratio_measure = ratio_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_ratio_measure

  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (curve_3d,
     pcurve_s1,
     pcurve_s2);
  END_TYPE; -- preferred_surface_curve_representation

  TYPE ratio_measure = REAL;
  END_TYPE; -- ratio_measure

  TYPE retention_item = SELECT
    (control,
     document,
     material_property,
     product,
     product_definition,
     product_definition_formation,
     product_definition_relationship,
     representation,
     result);
  END_TYPE; -- retention_item

  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE; -- reversible_topology

  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE; -- reversible_topology_item

  TYPE scalar = context_dependent_measure;
  END_TYPE; -- scalar

  TYPE second_in_minute = REAL;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 60));
  END_TYPE; -- second_in_minute

  TYPE security_classification_item = SELECT
    (product_definition,
     product_definition_formation,
     product_definition_usage);
  END_TYPE; -- security_classification_item

  TYPE set_of_reversible_topology_item = SET [0:?] OF
              reversible_topology_item;
  END_TYPE; -- set_of_reversible_topology_item

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- shape_definition

  TYPE shape_function = ENUMERATION OF
    (lagrangian,
     serendipity,
     hermitian,
     unspecified);
  END_TYPE; -- shape_function

  TYPE shell = SELECT
    (vertex_shell,
     wire_shell,
     open_shell,
     closed_shell);
  END_TYPE; -- shell

  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE; -- si_prefix

  TYPE si_unit_name = ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE; -- si_unit_name

  TYPE solid_angle_measure = REAL;
  END_TYPE; -- solid_angle_measure

  TYPE source = ENUMERATION OF
    (made,
     bought,
     not_known);
  END_TYPE; -- source

  TYPE supported_item = SELECT
    (action_directive,
     action,
     action_method);
  END_TYPE; -- supported_item

  TYPE surface_2d_edge = INTEGER;
  WHERE
    wr1: ((SELF >= 1) AND (SELF <= 2));
  END_TYPE; -- surface_2d_edge

  TYPE surface_2d_element_coordinate_system = SELECT
    (aligned_surface_2d_element_coordinate_system,
     parametric_surface_2d_element_coordinate_system);
  END_TYPE; -- surface_2d_element_coordinate_system

  TYPE surface_2d_element_descriptor = SELECT
    (axisymmetric_surface_2d_element_descriptor,
     plane_surface_2d_element_descriptor);
  END_TYPE; -- surface_2d_element_descriptor

  TYPE surface_2d_element_length_integration = SELECT
    (element_integration_algebraic,
     surface_2d_element_length_integration_rule,
     surface_2d_element_length_integration_explicit);
  END_TYPE; -- surface_2d_element_length_integration

  TYPE surface_2d_element_output_reference = SELECT
    (surface_2d_element_representation,
     surface_2d_element_descriptor,
     surface_2d_element_group,
     surface_2d_substructure_element_reference,
     analysis_item_within_representation);
  END_TYPE; -- surface_2d_element_output_reference

  TYPE surface_2d_element_representation = SELECT
    (axisymmetric_surface_2d_element_representation,
     plane_surface_2d_element_representation);
  END_TYPE; -- surface_2d_element_representation

  TYPE surface_2d_face = INTEGER;
  WHERE
    wr1: ((SELF >= 1) AND (SELF <= 2));
  END_TYPE; -- surface_2d_face

  TYPE surface_2d_state_coordinate_system = SELECT
    (fea_axis2_placement_3d,
     surface_2d_element_coordinate_system);
  END_TYPE; -- surface_2d_state_coordinate_system

  TYPE surface_3d_edge = INTEGER;
  WHERE
    wr1: ((SELF >= 1) AND (SELF <= 4));
  END_TYPE; -- surface_3d_edge

  TYPE surface_3d_element_coordinate_system = SELECT
    (aligned_surface_3d_element_coordinate_system,
     parametric_surface_3d_element_coordinate_system,
     constant_surface_3d_element_coordinate_system);
  END_TYPE; -- surface_3d_element_coordinate_system

  TYPE surface_3d_element_field_integration = SELECT
    (element_integration_algebraic,
     surface_3d_element_field_integration_rule,
     surface_3d_element_field_integration_explicit);
  END_TYPE; -- surface_3d_element_field_integration

  TYPE surface_3d_element_output_reference = SELECT
    (surface_3d_element_representation,
     surface_3d_element_descriptor,
     surface_3d_element_group,
     surface_3d_substructure_element_reference,
     analysis_item_within_representation);
  END_TYPE; -- surface_3d_element_output_reference

  TYPE surface_3d_face = INTEGER;
  WHERE
    wr1: ((SELF >= 1) AND (SELF <= 2));
  END_TYPE; -- surface_3d_face

  TYPE surface_3d_state_coordinate_system = SELECT
    (fea_axis2_placement_3d,
     surface_3d_element_coordinate_system);
  END_TYPE; -- surface_3d_state_coordinate_system

  TYPE surface_element_purpose = SELECT
    (enumerated_surface_element_purpose,
     application_defined_element_purpose);
  END_TYPE; -- surface_element_purpose

  TYPE surface_element_variable = SELECT
    (volume_variable,
     surface_scalar_variable,
     surface_vector_2d_variable,
     surface_vector_3d_variable,
     surface_tensor2_2d_variable,
     application_defined_tensor2_2d_variable);
  END_TYPE; -- surface_element_variable

  TYPE surface_matrix_property_type = SELECT
    (enumerated_surface_matrix_property_type,
     application_defined_matrix_property_type);
  END_TYPE; -- surface_matrix_property_type

  TYPE surface_model = SELECT
    (shell_based_surface_model);
  END_TYPE; -- surface_model

  TYPE surface_scalar_variable = ENUMERATION OF
    (thickness,
     surface_thermal_gradient,
     reference_surface_thermal_gradient);
  END_TYPE; -- surface_scalar_variable

  TYPE surface_section_integration = SELECT
    (element_integration_algebraic,
     surface_section_integration_rule,
     surface_section_integration_explicit);
  END_TYPE; -- surface_section_integration

  TYPE surface_tensor2_2d_variable = ENUMERATION OF
    (surface_membrane_force,
     surface_membrane_strain,
     surface_bending_moment,
     surface_curvature);
  END_TYPE; -- surface_tensor2_2d_variable

  TYPE surface_vector_2d_variable = ENUMERATION OF
    (surface_out_of_plane_shear_force,
     surface_out_of_plane_shear_strain);
  END_TYPE; -- surface_vector_2d_variable

  TYPE surface_vector_3d_variable = ENUMERATION OF
    (applied_force_per_unit_area,
     applied_moment_per_unit_area);
  END_TYPE; -- surface_vector_3d_variable

  TYPE symmetric_tensor2_2d = SELECT
    (anisotropic_symmetric_tensor2_2d);
  END_TYPE; -- symmetric_tensor2_2d

  TYPE symmetric_tensor2_3d = SELECT
    (isotropic_symmetric_tensor2_3d,
     orthotropic_symmetric_tensor2_3d,
     anisotropic_symmetric_tensor2_3d);
  END_TYPE; -- symmetric_tensor2_3d

  TYPE symmetric_tensor4_2d = SELECT
    (anisotropic_symmetric_tensor4_2d);
  END_TYPE; -- symmetric_tensor4_2d

  TYPE symmetric_tensor4_3d = SELECT
    (anisotropic_symmetric_tensor4_3d,
     fea_isotropic_symmetric_tensor4_3d,
     fea_iso_orthotropic_symmetric_tensor4_3d,
     fea_transverse_isotropic_symmetric_tensor4_3d,
     fea_column_normalised_orthotropic_symmetric_tensor4_3d,
     fea_column_normalised_monoclinic_symmetric_tensor4_3d);
  END_TYPE; -- symmetric_tensor4_3d

  TYPE tensor1 = SELECT
    (tensor1_2d,
     tensor1_3d);
  END_TYPE; -- tensor1

  TYPE tensor1_2d = ARRAY [1:2] OF context_dependent_measure;
  END_TYPE; -- tensor1_2d

  TYPE tensor1_3d = ARRAY [1:3] OF context_dependent_measure;
  END_TYPE; -- tensor1_3d

  TYPE tensor_type = SELECT
    (scalar,
     angular_value,
     tensor1_2d,
     tensor1_3d,
     anisotropic_symmetric_tensor2_2d,
     isotropic_symmetric_tensor2_3d,
     orthotropic_symmetric_tensor2_3d,
     anisotropic_symmetric_tensor2_3d,
     anisotropic_symmetric_tensor4_2d,
     anisotropic_symmetric_tensor4_3d,
     fea_isotropic_symmetric_tensor4_3d,
     fea_iso_orthotropic_symmetric_tensor4_3d,
     fea_transverse_isotropic_symmetric_tensor4_3d,
     fea_column_normalised_orthotropic_symmetric_tensor4_3d,
     fea_column_normalised_monoclinic_symmetric_tensor4_3d);
  END_TYPE; -- tensor_type

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE; -- thermodynamic_temperature_measure

  TYPE time_measure = REAL;
  END_TYPE; -- time_measure

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE; -- transformation

  TYPE transition_code = ENUMERATION OF
    (discontinuous,
     continuous,
     cont_same_gradient,
     cont_same_gradient_same_curvature);
  END_TYPE; -- transition_code

  TYPE trimming_preference = ENUMERATION OF
    (cartesian,
     parameter,
     unspecified);
  END_TYPE; -- trimming_preference

  TYPE trimming_select = SELECT
    (cartesian_point,
     parameter_value);
  END_TYPE; -- trimming_select

  TYPE unit = SELECT
    (named_unit,
     derived_unit);
  END_TYPE; -- unit

  TYPE unspecified_value = ENUMERATION OF
    (unspecified);
  END_TYPE; -- unspecified_value

  TYPE value_qualifier = SELECT
    (precision_qualifier,
     type_qualifier,
     uncertainty_qualifier);
  END_TYPE; -- value_qualifier

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE; -- vector_or_direction

  TYPE volume_2d_edge = INTEGER;
  WHERE
    wr1: ((SELF >= 1) AND (SELF <= 4));
  END_TYPE; -- volume_2d_edge

  TYPE volume_2d_element_coordinate_system = SELECT
    (arbitrary_volume_2d_element_coordinate_system,
     parametric_volume_2d_element_coordinate_system);
  END_TYPE; -- volume_2d_element_coordinate_system

  TYPE volume_2d_element_descriptor = SELECT
    (axisymmetric_volume_2d_element_descriptor,
     plane_volume_2d_element_descriptor);
  END_TYPE; -- volume_2d_element_descriptor

  TYPE volume_2d_element_field_integration = SELECT
    (element_integration_algebraic,
     volume_2d_element_field_integration_rule,
     volume_2d_element_field_integration_explicit);
  END_TYPE; -- volume_2d_element_field_integration

  TYPE volume_2d_element_output_reference = SELECT
    (volume_2d_element_representation,
     volume_2d_element_descriptor,
     volume_2d_element_group,
     volume_2d_substructure_element_reference,
     analysis_item_within_representation);
  END_TYPE; -- volume_2d_element_output_reference

  TYPE volume_2d_element_representation = SELECT
    (axisymmetric_volume_2d_element_representation,
     plane_volume_2d_element_representation);
  END_TYPE; -- volume_2d_element_representation

  TYPE volume_2d_face = INTEGER;
  WHERE
    wr1: ((SELF >= 1) AND (SELF <= 4));
  END_TYPE; -- volume_2d_face

  TYPE volume_3d_edge = INTEGER;
  WHERE
    wr1: ((SELF >= 1) AND (SELF <= 12));
  END_TYPE; -- volume_3d_edge

  TYPE volume_3d_element_coordinate_system = SELECT
    (arbitrary_volume_3d_element_coordinate_system,
     parametric_volume_3d_element_coordinate_system);
  END_TYPE; -- volume_3d_element_coordinate_system

  TYPE volume_3d_element_field_integration = SELECT
    (element_integration_algebraic,
     volume_3d_element_field_integration_rule,
     volume_3d_element_field_integration_explicit);
  END_TYPE; -- volume_3d_element_field_integration

  TYPE volume_3d_element_output_reference = SELECT
    (volume_3d_element_representation,
     volume_3d_element_descriptor,
     volume_3d_element_group,
     volume_3d_substructure_element_reference,
     analysis_item_within_representation);
  END_TYPE; -- volume_3d_element_output_reference

  TYPE volume_3d_element_shape = ENUMERATION OF
    (hexahedron,
     wedge,
     tetrahedron,
     pyramid);
  END_TYPE; -- volume_3d_element_shape

  TYPE volume_3d_face = INTEGER;
  WHERE
    wr1: ((SELF >= 1) AND (SELF <= 6));
  END_TYPE; -- volume_3d_face

  TYPE volume_aggregated_variable = SELECT
    (aggregated_scalar_variable,
     aggregated_angular_variable,
     aggregated_vector_3d_variable,
     aggregated_tensor2_3d_variable,
     application_defined_scalar_variable,
     application_defined_vector_3d_variable,
     application_defined_tensor2_3d_variable);
  END_TYPE; -- volume_aggregated_variable

  TYPE volume_angular_variable = ENUMERATION OF
    (constant_angular_acceleration,
     application_defined_angular_scalar_variable);
  END_TYPE; -- volume_angular_variable

  TYPE volume_element_purpose = SELECT
    (enumerated_volume_element_purpose,
     application_defined_element_purpose);
  END_TYPE; -- volume_element_purpose

  TYPE volume_measure = REAL;
  END_TYPE; -- volume_measure

  TYPE volume_scalar_variable = ENUMERATION OF
    (temperature,
     moisture,
     reference_temperature,
     strain_energy_per_unit_volume);
  END_TYPE; -- volume_scalar_variable

  TYPE volume_tensor2_3d_variable = ENUMERATION OF
    (total_strain,
     stress);
  END_TYPE; -- volume_tensor2_3d_variable

  TYPE volume_variable = SELECT
    (volume_scalar_variable,
     volume_angular_variable,
     volume_vector_3d_variable,
     volume_tensor2_3d_variable,
     application_defined_scalar_variable,
     application_defined_vector_3d_variable,
     application_defined_tensor2_3d_variable);
  END_TYPE; -- volume_variable

  TYPE volume_vector_3d_variable = ENUMERATION OF
    (position,
     applied_force_per_unit_volume,
     applied_moment_per_unit_volume,
     displacement,
     infinitesimal_rotation,
     acceleration);
  END_TYPE; -- volume_vector_3d_variable

  TYPE week_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 53));
  END_TYPE; -- week_in_year_number

  TYPE wireframe_model = SELECT
    (shell_based_wireframe_model,
     edge_based_wireframe_model);
  END_TYPE; -- wireframe_model

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY action;
      name          : label;
      description   : text;
      chosen_method : action_method;
  END_ENTITY; -- action

  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
      assigned_action : action;
  END_ENTITY; -- action_assignment

  ENTITY action_directive;
      name        : label;
      description : text;
      analysis    : text;
      comment     : text;
      requests    : SET [1:?] OF versioned_action_request;
  END_ENTITY; -- action_directive

  ENTITY action_method;
      name        : label;
      description : text;
      consequence : text;
      purpose     : text;
  END_ENTITY; -- action_method

  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
  END_ENTITY; -- action_request_assignment

  ENTITY action_request_solution;
      method  : action_method;
      request : versioned_action_request;
  END_ENTITY; -- action_request_solution

  ENTITY action_request_status;
      status           : label;
      assigned_request : versioned_action_request;
  END_ENTITY; -- action_request_status

  ENTITY action_status;
      status          : label;
      assigned_action : executed_action;
  END_ENTITY; -- action_status

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    WHERE
      wr1: (EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number));
  END_ENTITY; -- address

  ENTITY advanced_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.MANIFOLD_SOLID_BREP',
               'STRUCTURAL_ANALYSIS_DESIGN.FACETED_BREP',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM',
               'STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
               = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.MANIFOLD_SOLID_BREP',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               > 0);
      wr3: (SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(
               it)) ) | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT 
               (SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
               NOT ('STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(
               fcs))) )) = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( msb <* QUERY ( it <* items | (
               'STRUCTURAL_ANALYSIS_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(
               it)) ) | ('STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_CLOSED_SHELL' 
               IN TYPEOF(msb\manifold_solid_brep.outer)) )) = 0);
      wr5: (SIZEOF(QUERY ( brv <* QUERY ( it <* items | (
               'STRUCTURAL_ANALYSIS_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | 
               csh\oriented_closed_shell.orientation )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | 
               (NOT ('STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0);
  END_ENTITY; -- advanced_brep_shape_representation

  ENTITY advanced_face
    SUBTYPE OF (face_surface);
    WHERE
      wr1 : (SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.ELEMENTARY_SURFACE',
                'STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_SURFACE',
                'STRUCTURAL_ANALYSIS_DESIGN.SWEPT_SURFACE'] * TYPEOF(
                face_geometry)) = 1);
      wr2 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_CURVE' 
                IN TYPEOF(oe\oriented_edge.edge_element))) )) = 0)) )) = 0);
      wr3 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.LINE',
                'STRUCTURAL_ANALYSIS_DESIGN.CONIC',
                'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE',
                'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_CURVE',
                'STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_CURVE'] * TYPEOF(oe.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0);
      wr4 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN TYPEOF(oe\edge
                .edge_start)) AND (
                'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(oe\
                edge.edge_start\vertex_point.vertex_geometry)) AND (
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN TYPEOF(oe\edge
                .edge_end)) AND (
                'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(oe\
                edge.edge_end\vertex_point.vertex_geometry)))) )) = 0)) )) 
                = 0);
      wr5 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | ('STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_PATH' IN TYPEOF(
                elp_fbnds.bound)) )) = 0);
      wr6 : ((NOT ('STRUCTURAL_ANALYSIS_DESIGN.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.LINE',
                'STRUCTURAL_ANALYSIS_DESIGN.CONIC',
                'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE',
                'STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_CURVE'] * TYPEOF(
                face_geometry\swept_surface.swept_curve)) = 1));
      wr7 : (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* bounds | (
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_LOOP' IN TYPEOF(bnds.
                bound)) ) | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND (
                'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry)))) )) = 0);
      wr8 : (SIZEOF(QUERY ( bnd <* bounds | (NOT (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP',
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_LOOP'] * TYPEOF(bnd.
                bound)) = 1)) )) = 0);
      wr9 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('STRUCTURAL_ANALYSIS_DESIGN.SURFACE_CURVE' IN
                 TYPEOF(oe\oriented_edge.edge_element\edge_curve.
                edge_geometry)) AND (NOT (SIZEOF(QUERY ( sc_ag <* oe.
                edge_element\edge_curve.edge_geometry\surface_curve.
                associated_geometry | (NOT (
                'STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(sc_ag))) )) =
                 0))) )) = 0)) )) = 0);
      wr10: (((NOT ('STRUCTURAL_ANALYSIS_DESIGN.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (NOT (
                'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE' IN TYPEOF(
                face_geometry\swept_surface.swept_curve))) OR (SIZEOF(
                face_geometry\swept_surface.swept_curve\polyline.points) >=
                 3)) AND (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* 
                bounds | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(
                bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound
                \path.edge_list | (('STRUCTURAL_ANALYSIS_DESIGN.POLYLINE' 
                IN TYPEOF(oe\oriented_edge.edge_element\edge_curve.
                edge_geometry)) AND (NOT (SIZEOF(oe\oriented_edge.
                edge_element\edge_curve.edge_geometry\polyline.points) >= 3))) )) 
                = 0)) )) = 0));
  END_ENTITY; -- advanced_face

  ENTITY aligned_axis_tolerance;
      model_ref : fea_model;
      tolerance : context_dependent_measure;
  END_ENTITY; -- aligned_axis_tolerance

  ENTITY aligned_curve_3d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      coordinate_system : fea_axis2_placement_3d;
  END_ENTITY; -- aligned_curve_3d_element_coordinate_system

  ENTITY aligned_surface_2d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      orientation : direction;
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- aligned_surface_2d_element_coordinate_system

  ENTITY aligned_surface_3d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      coordinate_system : fea_axis2_placement_3d;
  END_ENTITY; -- aligned_surface_3d_element_coordinate_system

  ENTITY alternate_product_relationship;
      name       : label;
      definition : text;
      alternate  : product;
      base       : product;
      basis      : text;
    UNIQUE
      ur1 : alternate, base;
    WHERE
      wr1: (alternate :<>: base);
  END_ENTITY; -- alternate_product_relationship

  ENTITY amount_of_substance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.AMOUNT_OF_SUBSTANCE_UNIT' IN 
               TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- amount_of_substance_measure_with_unit

  ENTITY amount_of_substance_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 1) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- amount_of_substance_unit

  ENTITY analysis_item_within_representation;
      name        : label;
      description : text;
      item        : representation_item;
      rep         : representation;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* using_representations(item) | (tmp :=: 
               rep) )) = 1);
  END_ENTITY; -- analysis_item_within_representation

  ENTITY analysis_message
    SUPERTYPE OF (ONEOF (whole_model_analysis_message,
        element_analysis_message,node_analysis_message,
        element_group_analysis_message))
    SUBTYPE OF (state_definition);
      level        : message_level;
      message_text : text;
  END_ENTITY; -- analysis_message

  ENTITY analysis_step
    SUPERTYPE OF (ONEOF (control_analysis_step,result_analysis_step));
      analysis_control : control;
  END_ENTITY; -- analysis_step

  ENTITY application_context;
      application : text;
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (product_context,product_definition_context,
        product_concept_context));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY; -- application_protocol_definition

  ENTITY applied_action_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF action_item;
  END_ENTITY; -- applied_action_assignment

  ENTITY applied_action_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF action_request_item;
  END_ENTITY; -- applied_action_request_assignment

  ENTITY applied_approval_assignment
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
  END_ENTITY; -- applied_approval_assignment

  ENTITY applied_certification_assignment
    SUBTYPE OF (certification_assignment);
      items : SET [1:?] OF certification_item;
  END_ENTITY; -- applied_certification_assignment

  ENTITY applied_contract_assignment
    SUBTYPE OF (contract_assignment);
      items : SET [1:?] OF contract_item;
  END_ENTITY; -- applied_contract_assignment

  ENTITY applied_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_time_item;
    WHERE
      wr1: applied_date_time_correlation(SELF);
  END_ENTITY; -- applied_date_and_time_assignment

  ENTITY applied_date_assignment
    SUBTYPE OF (date_assignment);
      items : SET [1:?] OF date_item;
    WHERE
      wr1: applied_date_correlation(SELF);
  END_ENTITY; -- applied_date_assignment

  ENTITY applied_document_reference
    SUBTYPE OF (document_reference);
      items : SET [1:?] OF document_reference_item;
  END_ENTITY; -- applied_document_reference

  ENTITY applied_name_assignment
    SUBTYPE OF (name_assignment);
      items : SET [1:?] OF name_item;
  END_ENTITY; -- applied_name_assignment

  ENTITY applied_organization_assignment
    SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_item;
    WHERE
      wr1: applied_organization_correlation(SELF);
  END_ENTITY; -- applied_organization_assignment

  ENTITY applied_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_organization_item;
    WHERE
      wr1: applied_person_and_organization_correlation(SELF);
  END_ENTITY; -- applied_person_and_organization_assignment

  ENTITY applied_security_classification_assignment
    SUBTYPE OF (security_classification_assignment);
      items : SET [1:?] OF security_classification_item;
  END_ENTITY; -- applied_security_classification_assignment

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_relationship;
      name              : label;
      description       : text;
      relating_approval : approval;
      related_approval  : approval;
  END_ENTITY; -- approval_relationship

  ENTITY approval_role;
      role : label;
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY arbitrary_volume_2d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      orientation : direction;
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- arbitrary_volume_2d_element_coordinate_system

  ENTITY arbitrary_volume_3d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      coordinate_system : fea_axis2_placement_3d;
  END_ENTITY; -- arbitrary_volume_3d_element_coordinate_system

  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.AREA_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- area_measure_with_unit

  ENTITY area_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 2) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- area_unit

  ENTITY assembly_component_usage
    SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
        specified_higher_usage_occurrence,promissory_usage_occurrence))
    SUBTYPE OF (product_definition_usage);
      reference_designator : OPTIONAL identifier;
  END_ENTITY; -- assembly_component_usage

  ENTITY assembly_component_usage_substitute;
      name       : label;
      definition : text;
      base       : assembly_component_usage;
      substitute : assembly_component_usage;
    UNIQUE
      ur1 : base, substitute;
    WHERE
      wr1: (base.relating_product_definition :=: substitute.
               relating_product_definition);
      wr2: (base :<>: substitute);
  END_ENTITY; -- assembly_component_usage_substitute

  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- axis1_placement

  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- axis2_placement_2d

  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: (SELF\placement.location.dim = 3);
      wr2: ((NOT EXISTS(axis)) OR (axis.dim = 3));
      wr3: ((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3));
      wr4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0));
  END_ENTITY; -- axis2_placement_3d

  ENTITY axisymmetric_2d_element_property;
      angle : plane_angle_measure;
  END_ENTITY; -- axisymmetric_2d_element_property

  ENTITY axisymmetric_curve_2d_element_descriptor
    SUBTYPE OF (element_descriptor);
      purpose : SET [1:?] OF SET [1:?] OF curve_element_purpose;
  END_ENTITY; -- axisymmetric_curve_2d_element_descriptor

  ENTITY axisymmetric_curve_2d_element_representation
    SUBTYPE OF (element_representation);
      model_ref          : fea_model_2d;
      element_descriptor : axisymmetric_curve_2d_element_descriptor;
      property           : curve_2d_element_property;
      angle_property     : axisymmetric_2d_element_property;
      material           : element_material;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: (model_ref.type_of_2d_analysis = axisymmetric);
      wr2: (SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'CURVE_2D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(item)) )) = 
               1);
      wr3: (SIZEOF(QUERY ( item1 <* material.properties | (SIZEOF(
               QUERY ( item2 <* item1\property_definition_representation.
               used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AREA_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION'] *
                TYPEOF(item2)) = 1) )) = 1) )) >= 1);
      wr4: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
      fu1: required_0d_nodes(SELF\element_representation.node_list);
  END_ENTITY; -- axisymmetric_curve_2d_element_representation

  ENTITY axisymmetric_surface_2d_element_descriptor
    SUBTYPE OF (element_descriptor);
      purpose : SET [1:?] OF SET [1:?] OF surface_element_purpose;
  END_ENTITY; -- axisymmetric_surface_2d_element_descriptor

  ENTITY axisymmetric_surface_2d_element_representation
    SUBTYPE OF (element_representation);
      model_ref          : fea_model_2d;
      element_descriptor : axisymmetric_surface_2d_element_descriptor;
      property           : surface_element_property;
      angle_property     : axisymmetric_2d_element_property;
      material           : element_material;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: (model_ref.type_of_2d_analysis = axisymmetric);
      wr2: ((SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM') IN 
               TYPEOF(item)) )) + SIZEOF(QUERY ( item <* SELF\
               representation.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) ))) = 1);
      wr3: (SIZEOF(QUERY ( item1 <* material.properties | (SIZEOF(
               QUERY ( item2 <* item1\property_definition_representation.
               used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AREA_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SHELL_MEMBRANE_STIFFNESS','STRUCTURAL_ANALYSIS_DESIGN.' 
               + 'FEA_SHELL_BENDING_STIFFNESS',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_SHELL_SHEAR_STIFFNESS'] 
               * TYPEOF(item2)) = 1) )) = 1) )) >= 1);
      wr4: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
      fu1: required_1d_nodes(SELF\element_representation.node_list,
               element_descriptor\element_descriptor.topology_order);
  END_ENTITY; -- axisymmetric_surface_2d_element_representation

  ENTITY axisymmetric_volume_2d_element_descriptor
    SUBTYPE OF (element_descriptor);
      purpose : SET [1:?] OF SET [1:?] OF volume_element_purpose;
      shape   : element_2d_shape;
  END_ENTITY; -- axisymmetric_volume_2d_element_descriptor

  ENTITY axisymmetric_volume_2d_element_representation
    SUBTYPE OF (element_representation);
      model_ref          : fea_model_2d;
      element_descriptor : axisymmetric_volume_2d_element_descriptor;
      angle_property     : axisymmetric_2d_element_property;
      material           : element_material;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: (model_ref.type_of_2d_analysis = axisymmetric);
      wr2: ((SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) )) + SIZEOF(QUERY ( item <* SELF\representation.items
                | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) ))) = 1);
      wr3: (SIZEOF(QUERY ( item1 <* material.properties | (SIZEOF(
               QUERY ( item2 <* item1\property_definition_representation.
               used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AREA_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION'] *
                TYPEOF(item2)) = 1) )) = 1) )) >= 1);
      wr4: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
      fu1: required_2d_nodes(SELF\element_representation.node_list,
               element_descriptor.shape,element_descriptor\
               element_descriptor.topology_order);
  END_ENTITY; -- axisymmetric_volume_2d_element_representation

  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (uniform_curve,b_spline_curve_with_knots,
        quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve)
    SUBTYPE OF (bounded_curve);
      degree              : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form          : b_spline_curve_form;
      closed_curve        : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(
                                         control_points_list) - 1;
      control_points                : ARRAY [0:
                                         upper_index_on_control_points] OF
                                          cartesian_point := list_to_array(
                                         control_points_list,0,
                                         upper_index_on_control_points);
    WHERE
      wr1: (('STRUCTURAL_ANALYSIS_DESIGN.UNIFORM_CURVE' IN TYPEOF(SELF)) 
               OR ('STRUCTURAL_ANALYSIS_DESIGN.QUASI_UNIFORM_CURVE' IN 
               TYPEOF(SELF)) OR ('STRUCTURAL_ANALYSIS_DESIGN.BEZIER_CURVE' 
               IN TYPEOF(SELF)) OR (
               'STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' IN 
               TYPEOF(SELF)));
  END_ENTITY; -- b_spline_curve

  ENTITY b_spline_curve_with_knots
    SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots               : LIST [2:?] OF parameter_value;
      knot_spec           : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      wr1: constraints_param_b_spline(degree,upper_index_on_knots,
               upper_index_on_control_points,knot_multiplicities,knots);
      wr2: (SIZEOF(knot_multiplicities) = upper_index_on_knots);
  END_ENTITY; -- b_spline_curve_with_knots

  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,uniform_surface,
        quasi_uniform_surface,bezier_surface) ANDOR 
        rational_b_spline_surface)
    SUBTYPE OF (bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                           cartesian_point := make_array_of_array(
                          control_points_list,0,u_upper,0,v_upper);
    WHERE
      wr1: (('STRUCTURAL_ANALYSIS_DESIGN.UNIFORM_SURFACE' IN TYPEOF(SELF)) 
               OR ('STRUCTURAL_ANALYSIS_DESIGN.QUASI_UNIFORM_SURFACE' IN 
               TYPEOF(SELF)) OR (
               'STRUCTURAL_ANALYSIS_DESIGN.BEZIER_SURFACE' IN TYPEOF(SELF)) 
               OR ('STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' 
               IN TYPEOF(SELF)));
  END_ENTITY; -- b_spline_surface

  ENTITY b_spline_surface_with_knots
    SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
               v_knots);
      wr3: (SIZEOF(u_multiplicities) = knot_u_upper);
      wr4: (SIZEOF(v_multiplicities) = knot_v_upper);
  END_ENTITY; -- b_spline_surface_with_knots

  ENTITY beveled_sheet_representation
    SUBTYPE OF (shape_representation);
  END_ENTITY; -- beveled_sheet_representation

  ENTITY bezier_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- bezier_curve

  ENTITY bezier_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- bezier_surface

  ENTITY binary_generic_expression
    ABSTRACT SUPERTYPE
    SUBTYPE OF (generic_expression);
      operands : LIST [2:2] OF generic_expression;
  END_ENTITY; -- binary_generic_expression

  ENTITY binary_numeric_expression
    ABSTRACT SUPERTYPE OF (ONEOF (minus_expression,div_expression))
    SUBTYPE OF (numeric_expression, binary_generic_expression);
      SELF\binary_generic_expression.operands : LIST [2:2] OF
                                                    numeric_expression;
  END_ENTITY; -- binary_numeric_expression

  ENTITY boolean_expression
    ABSTRACT SUPERTYPE OF (ONEOF (multiple_arity_boolean_expression,
        comparison_expression,interval_expression))
    SUBTYPE OF (expression);
  END_ENTITY; -- boolean_expression

  ENTITY boundary_curve
    SUBTYPE OF (composite_curve_on_surface);
    WHERE
      wr1: SELF\composite_curve.closed_curve;
  END_ENTITY; -- boundary_curve

  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (polyline,b_spline_curve,trimmed_curve,
        bounded_pcurve,bounded_surface_curve,composite_curve))
    SUBTYPE OF (curve);
  END_ENTITY; -- bounded_curve

  ENTITY bounded_pcurve
    SUBTYPE OF (pcurve, bounded_curve);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\
               pcurve.reference_to_curve.items[1]));
  END_ENTITY; -- bounded_pcurve

  ENTITY bounded_surface
    SUPERTYPE OF (ONEOF (b_spline_surface,rectangular_trimmed_surface,
        curve_bounded_surface,rectangular_composite_surface))
    SUBTYPE OF (surface);
  END_ENTITY; -- bounded_surface

  ENTITY bounded_surface_curve
    SUBTYPE OF (surface_curve, bounded_curve);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\
               surface_curve.curve_3d));
  END_ENTITY; -- bounded_surface_curve

  ENTITY brep_with_voids
    SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
  END_ENTITY; -- brep_with_voids

  ENTITY calculated_state
    SUBTYPE OF (state);
  END_ENTITY; -- calculated_state

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY cartesian_point
    SUPERTYPE OF (ONEOF (cylindrical_point,spherical_point))
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY; -- cartesian_point

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d,
        cartesian_transformation_operator_3d))
    SUBTYPE OF (geometric_representation_item, 
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: (scl > 0);
  END_ENTITY; -- cartesian_transformation_operator

  ENTITY cartesian_transformation_operator_2d
    SUBTYPE OF (cartesian_transformation_operator);
    DERIVE
      u : LIST [2:2] OF direction := base_axis(2,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,?);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- cartesian_transformation_operator_2d

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- cartesian_transformation_operator_3d

  ENTITY certification;
      name    : label;
      purpose : text;
      kind    : certification_type;
  END_ENTITY; -- certification

  ENTITY certification_assignment
    ABSTRACT SUPERTYPE;
      assigned_certification : certification;
  END_ENTITY; -- certification_assignment

  ENTITY certification_type;
      description : label;
  END_ENTITY; -- certification_type

  ENTITY characterized_object;
      name        : label;
      description : text;
  END_ENTITY; -- characterized_object

  ENTITY circle
    SUBTYPE OF (conic);
      radius : positive_length_measure;
  END_ENTITY; -- circle

  ENTITY closed_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- closed_shell

  ENTITY comparison_equal
    SUBTYPE OF (comparison_expression);
  END_ENTITY; -- comparison_equal

  ENTITY comparison_expression
    ABSTRACT SUPERTYPE OF (comparison_equal)
    SUBTYPE OF (boolean_expression, binary_generic_expression);
      SELF\binary_generic_expression.operands : LIST [2:2] OF expression;
    WHERE
      wr1:  ((('STRUCTURAL_ANALYSIS_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(
               SELF\binary_generic_expression.operands[1])) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(
               SELF\binary_generic_expression.operands[2]))) OR ((
               'STRUCTURAL_ANALYSIS_DESIGN.BOOLEAN_EXPRESSION' IN TYPEOF(
               SELF\binary_generic_expression.operands[1])) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.BOOLEAN_EXPRESSION' IN TYPEOF(
               SELF\binary_generic_expression.operands[2]))) OR ((
               'STRUCTURAL_ANALYSIS_DESIGN.STRING_EXPRESSION' IN TYPEOF(
               SELF\binary_generic_expression.operands[1])) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.STRING_EXPRESSION' IN TYPEOF(
               SELF\binary_generic_expression.operands[2]))));
  END_ENTITY; -- comparison_expression

  ENTITY composite_assembly_definition
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATING_PRODUCT_DEFINITION') | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'NEXT_ASSEMBLY_USAGE_OCCURRENCE') IN TYPEOF(pdr)) )) = 1);
  END_ENTITY; -- composite_assembly_definition

  ENTITY composite_assembly_sequence_definition
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATING_PRODUCT_DEFINITION') | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'NEXT_ASSEMBLY_USAGE_OCCURRENCE') IN TYPEOF(pdr)) )) > 0);
  END_ENTITY; -- composite_assembly_sequence_definition

  ENTITY composite_curve
    SUBTYPE OF (bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments   : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> 
                        discontinuous;
    WHERE
      wr1: (((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | (
               temp.transition = discontinuous) )) = 1)) OR (closed_curve 
               AND (SIZEOF(QUERY ( temp <* segments | (temp.transition = 
               discontinuous) )) = 0)));
  END_ENTITY; -- composite_curve

  ENTITY composite_curve_on_surface
    SUPERTYPE OF (boundary_curve)
    SUBTYPE OF (composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (SIZEOF(basis_surface) > 0);
      wr2: constraints_composite_curve_on_surface(SELF);
  END_ENTITY; -- composite_curve_on_surface

  ENTITY composite_curve_segment
    SUBTYPE OF (founded_item);
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.BOUNDED_CURVE' IN TYPEOF(
               parent_curve));
  END_ENTITY; -- composite_curve_segment

  ENTITY composite_sheet_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.' + 
               'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'MANIFOLD_SURFACE_SHAPE_REPRESENTATION'] * TYPEOF(SELF)) = 1);
  END_ENTITY; -- composite_sheet_representation

  ENTITY configuration_design;
      configuration : configuration_item;
      design        : product_definition_formation;
    UNIQUE
      ur1 : configuration, design;
  END_ENTITY; -- configuration_design

  ENTITY configuration_effectivity
    SUBTYPE OF (product_definition_effectivity);
      configuration : configuration_design;
    UNIQUE
      ur1 : configuration, usage, id;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.PRODUCT_DEFINITION_USAGE' IN 
               TYPEOF(SELF\product_definition_effectivity.usage));
  END_ENTITY; -- configuration_effectivity

  ENTITY configuration_item;
      id           : identifier;
      name         : label;
      description  : OPTIONAL text;
      item_concept : product_concept;
      purpose      : OPTIONAL label;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- configuration_item

  ENTITY conic
    SUPERTYPE OF (ONEOF (circle,ellipse,hyperbola,parabola))
    SUBTYPE OF (curve);
      position : axis2_placement;
  END_ENTITY; -- conic

  ENTITY conical_surface
    SUBTYPE OF (elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: (radius >= 0);
  END_ENTITY; -- conical_surface

  ENTITY connected_edge_set
    SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
  END_ENTITY; -- connected_edge_set

  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (closed_shell,open_shell))
    SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY; -- connected_face_set

  ENTITY constant_surface_3d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      axis  : INTEGER;
      angle : plane_angle_measure;
    WHERE
      wr1: ((axis >= 1) AND (axis <= 2));
  END_ENTITY; -- constant_surface_3d_element_coordinate_system

  ENTITY constraint_element
    SUPERTYPE OF (ONEOF (single_point_constraint_element,
        linear_constraint_equation_element,nodal_dof_reduction,
        point_constraint,curve_constraint,surface_constraint,
        solid_constraint));
      element_id : identifier;
      steps      : SET [1:?] OF control_analysis_step;
  END_ENTITY; -- constraint_element

  ENTITY context_dependent_shape_representation;
      representation_relation      : shape_representation_relationship;
      represented_product_relation : product_definition_shape;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' 
               IN TYPEOF(SELF.represented_product_relation.definition));
  END_ENTITY; -- context_dependent_shape_representation

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
      name : label;
  END_ENTITY; -- context_dependent_unit

  ENTITY contract;
      name    : label;
      purpose : text;
      kind    : contract_type;
  END_ENTITY; -- contract

  ENTITY contract_assignment
    ABSTRACT SUPERTYPE;
      assigned_contract : contract;
  END_ENTITY; -- contract_assignment

  ENTITY contract_type;
      description : label;
  END_ENTITY; -- contract_type

  ENTITY control;
      model_ref              : fea_model;
      control_id             : identifier;
      creating_software      : text;
      description            : text;
      user_defined_control   : SET [1:?] OF text;
      intended_analysis_code : SET [1:?] OF text;
    UNIQUE
      ur1 : model_ref, control_id;
  END_ENTITY; -- control

  ENTITY control_analysis_step
    SUPERTYPE OF (ONEOF (control_linear_static_analysis_step,
        control_linear_modes_and_frequencies_analysis_step))
    SUBTYPE OF (analysis_step);
      step_id       : identifier;
      sequence      : INTEGER;
      initial_state : state;
      description   : text;
    UNIQUE
      ur1 : analysis_control, sequence;
      ur2 : analysis_control, step_id;
  END_ENTITY; -- control_analysis_step

  ENTITY control_linear_modes_and_frequencies_analysis_step
    SUBTYPE OF (control_analysis_step);
      process         : control_linear_modes_and_frequencies_process;
      number_of_modes : count_measure;
      frequency_range : ARRAY [1:2] OF context_dependent_measure;
  END_ENTITY; -- control_linear_modes_and_frequencies_analysis_step

  ENTITY control_linear_modes_and_frequencies_process
    SUBTYPE OF (control_process);
      final_input_state : state;
  END_ENTITY; -- control_linear_modes_and_frequencies_process

  ENTITY control_linear_static_analysis_step
    SUBTYPE OF (control_analysis_step);
      process : control_linear_static_load_increment_process;
  END_ENTITY; -- control_linear_static_analysis_step

  ENTITY control_linear_static_analysis_step_with_harmonic
    SUBTYPE OF (control_linear_static_analysis_step);
      symmetry : cylindrical_symmetry_control;
  END_ENTITY; -- control_linear_static_analysis_step_with_harmonic

  ENTITY control_linear_static_load_increment_process
    SUBTYPE OF (control_process);
      final_input_state : state;
  END_ENTITY; -- control_linear_static_load_increment_process

  ENTITY control_process
    SUPERTYPE OF (ONEOF (control_linear_static_load_increment_process,
        control_linear_modes_and_frequencies_process));
      process_id  : identifier;
      description : text;
  END_ENTITY; -- control_process

  ENTITY control_result_relationship;
      control : control_analysis_step;
      result  : result_analysis_step;
  END_ENTITY; -- control_result_relationship

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY; -- conversion_based_unit

  ENTITY coordinated_universal_time_offset;
      hour_offset   : hour_in_day;
      minute_offset : OPTIONAL minute_in_hour;
      sense         : ahead_or_behind;
  END_ENTITY; -- coordinated_universal_time_offset

  ENTITY curve
    SUPERTYPE OF (ONEOF (line,conic,pcurve,surface_curve,offset_curve_2d,
        offset_curve_3d,curve_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- curve

  ENTITY curve_2d_element_basis;
      descriptor : curve_2d_element_descriptor;
      variable   : curve_element_variable;
  END_ENTITY; -- curve_2d_element_basis

  ENTITY curve_2d_element_constant_specified_variable_value
    SUBTYPE OF (curve_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : surface_element_variable;
      coordinate_system : OPTIONAL curve_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_2d_element_constant_specified_variable_value

  ENTITY curve_2d_element_constant_specified_volume_variable_value
    SUBTYPE OF (curve_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_variable;
      coordinate_system : OPTIONAL curve_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_2d_element_constant_specified_volume_variable_value

  ENTITY curve_2d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      orientation : direction;
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- curve_2d_element_coordinate_system

  ENTITY curve_2d_element_field_variable_definition
    SUPERTYPE OF (ONEOF (
        curve_2d_element_location_point_volume_variable_values,
        curve_2d_element_location_point_variable_values,
        curve_2d_whole_element_variable_value,
        curve_2d_element_constant_specified_variable_value,
        curve_2d_element_constant_specified_volume_variable_value))
    SUBTYPE OF (field_variable_element_definition);
      element : curve_2d_element_output_reference;
  END_ENTITY; -- curve_2d_element_field_variable_definition

  ENTITY curve_2d_element_group
    SUBTYPE OF (element_group);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* elements | ((NOT ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION') IN TYPEOF(
               item))) AND (NOT (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PLANE_CURVE_2D_ELEMENT_REPRESENTATION') IN TYPEOF(item)))) )) 
               = 0);
  END_ENTITY; -- curve_2d_element_group

  ENTITY curve_2d_element_integrated_matrix;
      descriptor              : curve_2d_element_descriptor;
      property_type           : curve_matrix_property_type;
      integration_description : text;
  END_ENTITY; -- curve_2d_element_integrated_matrix

  ENTITY curve_2d_element_integrated_matrix_with_definition
    SUBTYPE OF (curve_2d_element_integrated_matrix);
      integration_definition : curve_2d_element_integration;
  END_ENTITY; -- curve_2d_element_integrated_matrix_with_definition

  ENTITY curve_2d_element_integration;
      section : LIST [1:?] OF curve_section_element_location;
  END_ENTITY; -- curve_2d_element_integration

  ENTITY curve_2d_element_location_point_variable_values
    SUBTYPE OF (curve_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 curve_2d_element_value_and_location;
      variable             : curve_element_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- curve_2d_element_location_point_variable_values

  ENTITY curve_2d_element_location_point_volume_variable_values
    SUBTYPE OF (curve_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF curve_2d_element_value_and_volume_location;
      variable             : curve_element_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- curve_2d_element_location_point_volume_variable_values

  ENTITY curve_2d_element_property;
      property_id : identifier;
      description : text;
      section     : curve_element_section_definition;
  END_ENTITY; -- curve_2d_element_property

  ENTITY curve_2d_element_value_and_location;
      simple_value      : field_value;
      location          : curve_section_element_location;
      coordinate_system : OPTIONAL curve_2d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- curve_2d_element_value_and_location

  ENTITY curve_2d_element_value_and_volume_location;
      simple_value      : field_value;
      location          : curve_volume_element_location;
      coordinate_system : OPTIONAL curve_2d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- curve_2d_element_value_and_volume_location

  ENTITY curve_2d_node_field_aggregated_variable_values
    SUBTYPE OF (curve_2d_node_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL curve_2d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_2d_node_field_aggregated_variable_values

  ENTITY curve_2d_node_field_section_variable_values
    SUBTYPE OF (curve_2d_node_field_variable_definition);
      simple_value      : field_value;
      variable          : curve_element_variable;
      location          : curve_section_element_location;
      coordinate_system : OPTIONAL curve_2d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_2d_node_field_section_variable_values

  ENTITY curve_2d_node_field_variable_definition
    SUPERTYPE OF (ONEOF (curve_2d_node_field_section_variable_values,
        curve_2d_node_field_aggregated_variable_values))
    SUBTYPE OF (field_variable_node_definition);
  END_ENTITY; -- curve_2d_node_field_variable_definition

  ENTITY curve_2d_substructure_element_reference;
      substructure_element_ref : substructure_element_representation;
      element_ref              : curve_2d_element_representation;
  END_ENTITY; -- curve_2d_substructure_element_reference

  ENTITY curve_2d_whole_element_variable_value
    SUBTYPE OF (curve_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL curve_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_2d_whole_element_variable_value

  ENTITY curve_3d_element_basis;
      descriptor              : curve_3d_element_descriptor;
      variable                : curve_element_variable;
      variable_order          : element_order;
      variable_shape_function : shape_function;
      evaluation_points       : LIST [1:?] OF curve_element_location;
  END_ENTITY; -- curve_3d_element_basis

  ENTITY curve_3d_element_constant_specified_variable_value
    SUBTYPE OF (curve_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : curve_element_variable;
      coordinate_system : OPTIONAL curve_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_3d_element_constant_specified_variable_value

  ENTITY curve_3d_element_constant_specified_volume_variable_value
    SUBTYPE OF (curve_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_variable;
      coordinate_system : OPTIONAL curve_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_3d_element_constant_specified_volume_variable_value

  ENTITY curve_3d_element_descriptor
    SUBTYPE OF (element_descriptor);
      purpose : SET [1:?] OF SET [1:?] OF curve_element_purpose;
  END_ENTITY; -- curve_3d_element_descriptor

  ENTITY curve_3d_element_field_variable_definition
    SUPERTYPE OF (ONEOF (
        curve_3d_element_location_point_volume_variable_values,
        curve_3d_element_location_point_variable_values,
        curve_3d_whole_element_variable_value,
        curve_3d_element_constant_specified_variable_value,
        curve_3d_element_constant_specified_volume_variable_value,
        curve_3d_element_nodal_specified_variable_values))
    SUBTYPE OF (field_variable_element_definition);
      element : curve_3d_element_output_reference;
  END_ENTITY; -- curve_3d_element_field_variable_definition

  ENTITY curve_3d_element_group
    SUBTYPE OF (element_group);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* elements | (NOT ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'CURVE_3D_ELEMENT_REPRESENTATION') IN TYPEOF(item))) )) = 0);
  END_ENTITY; -- curve_3d_element_group

  ENTITY curve_3d_element_integrated_matrix;
      descriptor              : curve_3d_element_descriptor;
      property_type           : curve_matrix_property_type;
      integration_description : text;
  END_ENTITY; -- curve_3d_element_integrated_matrix

  ENTITY curve_3d_element_integrated_matrix_with_definition
    SUBTYPE OF (curve_3d_element_integrated_matrix);
      integration_definition : curve_3d_element_integration;
  END_ENTITY; -- curve_3d_element_integrated_matrix_with_definition

  ENTITY curve_3d_element_integration;
      element_length : curve_3d_element_length_integration;
      section        : curve_section_integration_explicit;
  END_ENTITY; -- curve_3d_element_integration

  ENTITY curve_3d_element_length_integration_explicit;
      integration_positions_and_weights : SET [1:?] OF curve_3d_element_position_weight;
  END_ENTITY; -- curve_3d_element_length_integration_explicit

  ENTITY curve_3d_element_length_integration_rule;
      integration_method : integration_rule;
      integration_order  : INTEGER;
  END_ENTITY; -- curve_3d_element_length_integration_rule

  ENTITY curve_3d_element_location_point_variable_values
    SUBTYPE OF (curve_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 curve_3d_element_value_and_location;
      variable             : curve_element_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- curve_3d_element_location_point_variable_values

  ENTITY curve_3d_element_location_point_volume_variable_values
    SUBTYPE OF (curve_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF curve_3d_element_value_and_volume_location;
      variable             : volume_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- curve_3d_element_location_point_volume_variable_values

  ENTITY curve_3d_element_nodal_specified_variable_values
    SUBTYPE OF (curve_3d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : curve_element_variable;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_3d_element_nodal_specified_variable_values

  ENTITY curve_3d_element_position_weight;
      integration_position : curve_volume_element_location;
      integration_weight   : context_dependent_measure;
  END_ENTITY; -- curve_3d_element_position_weight

  ENTITY curve_3d_element_property;
      property_id          : identifier;
      description          : text;
      interval_definitions : LIST [1:?] OF curve_element_interval;
      end_offsets          : ARRAY [1:2] OF curve_element_end_offset;
      end_releases         : ARRAY [1:2] OF curve_element_end_release;
  END_ENTITY; -- curve_3d_element_property

  ENTITY curve_3d_element_representation
    SUBTYPE OF (element_representation);
      model_ref          : fea_model_3d;
      element_descriptor : curve_3d_element_descriptor;
      property           : curve_3d_element_property;
      material           : element_material;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: ((SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PARAMETRIC_CURVE_3D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) )) + SIZEOF(QUERY ( item <* SELF\representation.items
                | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'ALIGNED_CURVE_3D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(item)) ))) 
               = 1);
      wr2: (SIZEOF(QUERY ( item1 <* material.properties | (SIZEOF(
               QUERY ( item2 <* item1\property_definition_representation.
               used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AREA_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION'] *
                TYPEOF(item2)) = 1) )) = 1) )) >= 1);
      wr3: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
      fu1: required_1d_nodes(SELF\element_representation.node_list,
               element_descriptor\element_descriptor.topology_order);
  END_ENTITY; -- curve_3d_element_representation

  ENTITY curve_3d_element_value_and_location;
      simple_value      : field_value;
      location          : curve_element_location;
      coordinate_system : OPTIONAL curve_3d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- curve_3d_element_value_and_location

  ENTITY curve_3d_element_value_and_volume_location;
      simple_value      : field_value;
      location          : curve_volume_element_location;
      coordinate_system : OPTIONAL curve_3d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- curve_3d_element_value_and_volume_location

  ENTITY curve_3d_node_field_aggregated_variable_values
    SUBTYPE OF (curve_3d_node_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL curve_3d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_3d_node_field_aggregated_variable_values

  ENTITY curve_3d_node_field_section_variable_values
    SUBTYPE OF (curve_3d_node_field_variable_definition);
      simple_value      : field_value;
      variable          : curve_element_variable;
      location          : curve_section_element_location;
      coordinate_system : OPTIONAL curve_3d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_3d_node_field_section_variable_values

  ENTITY curve_3d_node_field_variable_definition
    SUPERTYPE OF (ONEOF (curve_3d_node_field_section_variable_values,
        curve_3d_node_field_aggregated_variable_values))
    SUBTYPE OF (field_variable_node_definition);
  END_ENTITY; -- curve_3d_node_field_variable_definition

  ENTITY curve_3d_substructure_element_reference;
      substructure_element_ref : substructure_element_representation;
      element_ref              : curve_3d_element_representation;
  END_ENTITY; -- curve_3d_substructure_element_reference

  ENTITY curve_3d_whole_element_variable_value
    SUBTYPE OF (curve_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL curve_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- curve_3d_whole_element_variable_value

  ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
      basis_surface  : surface;
      boundaries     : SET [1:?] OF boundary_curve;
      implicit_outer : BOOLEAN;
    WHERE
      wr1: ((NOT implicit_outer) OR (SIZEOF(QUERY ( temp <* boundaries | (
               'STRUCTURAL_ANALYSIS_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(
               temp)) )) = 0));
      wr2: ((NOT implicit_outer) OR (
               'STRUCTURAL_ANALYSIS_DESIGN.BOUNDED_SURFACE' IN TYPEOF(
               basis_surface)));
      wr3: (SIZEOF(QUERY ( temp <* boundaries | (
               'STRUCTURAL_ANALYSIS_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(
               temp)) )) <= 1);
      wr4: (SIZEOF(QUERY ( temp <* boundaries | (temp\
               composite_curve_on_surface.basis_surface[1] <> SELF.
               basis_surface) )) = 0);
  END_ENTITY; -- curve_bounded_surface

  ENTITY curve_constraint
    SUBTYPE OF (constraint_element);
      required_curve            : analysis_item_within_representation;
      coordinate_system         : fea_axis2_placement_3d;
      freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
      description               : text;
    WHERE
      wr1: (('STRUCTURAL_ANALYSIS_DESIGN.CURVE' IN TYPEOF(required_curve.
               item)) OR ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_CURVE' IN 
               TYPEOF(required_curve.item)));
  END_ENTITY; -- curve_constraint

  ENTITY curve_element_end_offset;
      coordinate_system : curve_element_end_coordinate_system;
      offset_vector     : ARRAY [1:3] OF context_dependent_measure;
  END_ENTITY; -- curve_element_end_offset

  ENTITY curve_element_end_release;
      coordinate_system : curve_element_end_coordinate_system;
      releases          : LIST [1:?] OF curve_element_end_release_packet;
  END_ENTITY; -- curve_element_end_release

  ENTITY curve_element_end_release_packet;
      release_freedom   : curve_element_freedom;
      release_stiffness : context_dependent_measure;
  END_ENTITY; -- curve_element_end_release_packet

  ENTITY curve_element_interval
    SUPERTYPE OF (ONEOF (curve_element_interval_constant,
        curve_element_interval_linearly_varying));
      finish_position : curve_element_location;
      eu_angles       : euler_angles;
  END_ENTITY; -- curve_element_interval

  ENTITY curve_element_interval_constant
    SUBTYPE OF (curve_element_interval);
      section : curve_element_section_definition;
  END_ENTITY; -- curve_element_interval_constant

  ENTITY curve_element_interval_linearly_varying
    SUBTYPE OF (curve_element_interval);
      sections : ARRAY [1:2] OF curve_element_section_definition;
  END_ENTITY; -- curve_element_interval_linearly_varying

  ENTITY curve_element_location;
      coordinate : fea_parametric_point;
  END_ENTITY; -- curve_element_location

  ENTITY curve_element_section_definition
    SUPERTYPE OF (curve_element_section_derived_definitions);
      description   : text;
      section_angle : plane_angle_measure;
  END_ENTITY; -- curve_element_section_definition

  ENTITY curve_element_section_derived_definitions
    SUBTYPE OF (curve_element_section_definition);
      cross_sectional_area            : context_dependent_measure;
      shear_area                      : ARRAY [1:2] OF
                                            measure_or_unspecified_value;
      second_moment_of_area           : ARRAY [1:3] OF
                                            context_dependent_measure;
      torsional_constant              : context_dependent_measure;
      warping_constant                : measure_or_unspecified_value;
      location_of_centroid            : ARRAY [1:2] OF
                                            measure_or_unspecified_value;
      location_of_shear_centre        : ARRAY [1:2] OF
                                            measure_or_unspecified_value;
      location_of_non_structural_mass : ARRAY [1:2] OF
                                            measure_or_unspecified_value;
      non_structural_mass             : measure_or_unspecified_value;
      polar_moment                    : measure_or_unspecified_value;
  END_ENTITY; -- curve_element_section_derived_definitions

  ENTITY curve_freedom_action_definition
    SUBTYPE OF (curve_freedom_and_value_definition);
      action : action_type;
  END_ENTITY; -- curve_freedom_action_definition

  ENTITY curve_freedom_and_value_definition
    SUPERTYPE OF (ONEOF (curve_freedom_values,
        curve_freedom_action_definition))
    SUBTYPE OF (state_definition);
      required_curve     : analysis_item_within_representation;
      coordinate_system  : fea_axis2_placement_3d;
      degrees_of_freedom : freedoms_list;
      values             : LIST [1:?] OF measure_or_unspecified_value;
    WHERE
      wr1: (SIZEOF(degrees_of_freedom.freedoms) = SIZEOF(values));
      wr2: (('STRUCTURAL_ANALYSIS_DESIGN.CURVE' IN TYPEOF(required_curve.
               item)) OR ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_CURVE' IN 
               TYPEOF(required_curve.item)));
  END_ENTITY; -- curve_freedom_and_value_definition

  ENTITY curve_freedom_values
    SUBTYPE OF (curve_freedom_and_value_definition);
  END_ENTITY; -- curve_freedom_values

  ENTITY curve_replica
    SUBTYPE OF (curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_curve.dim);
      wr2: acyclic_curve_replica(SELF,parent_curve);
  END_ENTITY; -- curve_replica

  ENTITY curve_section_element_location;
      offsets : ARRAY [1:2] OF context_dependent_measure;
  END_ENTITY; -- curve_section_element_location

  ENTITY curve_section_integration_explicit;
      integration_positions : SET [1:?] OF curve_section_element_location;
  END_ENTITY; -- curve_section_integration_explicit

  ENTITY curve_volume_element_location;
      field_location   : curve_element_location;
      section_location : curve_section_element_location;
  END_ENTITY; -- curve_volume_element_location

  ENTITY cylindrical_point
    SUBTYPE OF (cartesian_point);
      r     : length_measure;
      theta : plane_angle_measure;
      z     : length_measure;
    DERIVE
      SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [
                                            r * COS(theta),r * SIN(theta),z];
    WHERE
      wr1: (r >= 0);
  END_ENTITY; -- cylindrical_point

  ENTITY cylindrical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- cylindrical_surface

  ENTITY cylindrical_symmetry_control
    SUBTYPE OF (symmetry_control);
      harmonic : cylindrical_harmonic_number;
      phase    : measure_or_unspecified_value;
  END_ENTITY; -- cylindrical_symmetry_control

  ENTITY data_environment;
      name        : label;
      description : text;
      elements    : SET [1:?] OF property_definition_representation;
  END_ENTITY; -- data_environment

  ENTITY data_environment_relationship;
      name                      : label;
      description               : text;
      relating_data_environment : data_environment;
      related_data_environment  : data_environment;
  END_ENTITY; -- data_environment_relationship

  ENTITY date
    SUPERTYPE OF (ONEOF (calendar_date,ordinal_date,
        week_of_year_and_day_date));
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY; -- date_and_time

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role                   : date_time_role;
  END_ENTITY; -- date_and_time_assignment

  ENTITY date_assignment
    ABSTRACT SUPERTYPE;
      assigned_date : date;
      role          : date_role;
  END_ENTITY; -- date_assignment

  ENTITY date_role;
      name : label;
  END_ENTITY; -- date_role

  ENTITY date_time_role;
      name : label;
  END_ENTITY; -- date_time_role

  ENTITY dated_effectivity
    SUBTYPE OF (effectivity);
      effectivity_start_date : date_and_time;
      effectivity_end_date   : OPTIONAL date_and_time;
  END_ENTITY; -- dated_effectivity

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
  END_ENTITY; -- definitional_representation

  ENTITY degenerate_pcurve
    SUBTYPE OF (point);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('STRUCTURAL_ANALYSIS_DESIGN.CURVE' IN TYPEOF(
               reference_to_curve\representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- degenerate_pcurve

  ENTITY degenerate_toroidal_surface
    SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
    WHERE
      wr1: (major_radius < minor_radius);
  END_ENTITY; -- degenerate_toroidal_surface

  ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
    WHERE
      wr1: ((SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (
               elements[1].exponent <> 1)));
  END_ENTITY; -- derived_unit

  ENTITY derived_unit_element;
      unit     : named_unit;
      exponent : REAL;
  END_ENTITY; -- derived_unit_element

  ENTITY descriptive_representation_item
    SUBTYPE OF (representation_item);
      description : text;
  END_ENTITY; -- descriptive_representation_item

  ENTITY design_make_from_relationship
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- design_make_from_relationship

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY; -- dimensional_exponents

  ENTITY dimensional_size;
      applies_to : shape_aspect;
      name       : label;
    WHERE
      wr1: (applies_to.product_definitional = TRUE);
  END_ENTITY; -- dimensional_size

  ENTITY directed_action
    SUBTYPE OF (executed_action);
      directive : action_directive;
  END_ENTITY; -- directed_action

  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0);
  END_ENTITY; -- direction

  ENTITY direction_node
    SUBTYPE OF (direction);
      node_1 : node_representation;
      node_2 : node_representation;
    DERIVE
      SELF\direction.direction_ratios : LIST [2:3] OF REAL := 
                                           build_direction_node(node_1,
                                           node_2);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* node_1\representation.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(item)) )) 
               = 1);
      wr2: (SIZEOF(QUERY ( item <* node_2\representation.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(item)) )) 
               = 1);
      wr3: (NOT ((direction_ratios[1] = 0) AND (direction_ratios[2] = 0) 
               AND (direction_ratios[3] = 0)));
  END_ENTITY; -- direction_node

  ENTITY directionally_explicit_element_coefficient;
      property_type : matrix_property_type;
      coefficient   : context_dependent_measure;
  END_ENTITY; -- directionally_explicit_element_coefficient

  ENTITY directionally_explicit_element_coordinate_system_aligned
    SUBTYPE OF (fea_representation_item);
      aligned_system : curve_3d_element_coordinate_system;
  END_ENTITY; -- directionally_explicit_element_coordinate_system_aligned

  ENTITY directionally_explicit_element_coordinate_system_arbitrary
    SUBTYPE OF (fea_representation_item);
      arbitrary_system : fea_axis2_placement_3d;
  END_ENTITY; -- directionally_explicit_element_coordinate_system_arbitrary

  ENTITY directionally_explicit_element_representation
    SUBTYPE OF (element_representation);
      model_ref            : fea_model;
      systems_and_freedoms : LIST [2:2] OF system_and_freedom;
      description          : text;
      coefficient          : directionally_explicit_element_coefficient;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      fu1: required_1d_nodes(SELF\element_representation.node_list,linear);
  END_ENTITY; -- directionally_explicit_element_representation

  ENTITY div_expression
    SUBTYPE OF (binary_numeric_expression);
  END_ENTITY; -- div_expression

  ENTITY document;
      id          : identifier;
      name        : label;
      description : text;
      kind        : document_type;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- document

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
      assigned_document : document;
      source            : label;
  END_ENTITY; -- document_reference

  ENTITY document_relationship;
      name              : label;
      description       : text;
      relating_document : document;
      related_document  : document;
  END_ENTITY; -- document_relationship

  ENTITY document_type;
      product_data_type : label;
  END_ENTITY; -- document_type

  ENTITY document_usage_constraint;
      source                : document;
      subject_element       : label;
      subject_element_value : text;
  END_ENTITY; -- document_usage_constraint

  ENTITY document_with_class
    SUBTYPE OF (document);
      class : identifier;
  END_ENTITY; -- document_with_class

  ENTITY draped_defined_transformation
    SUBTYPE OF (item_defined_transformation);
  END_ENTITY; -- draped_defined_transformation

  ENTITY dummy_node
    SUBTYPE OF (node_representation);
  END_ENTITY; -- dummy_node

  ENTITY edge
    SUPERTYPE OF (ONEOF (edge_curve,oriented_edge))
    SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY; -- edge

  ENTITY edge_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
  END_ENTITY; -- edge_based_wireframe_model

  ENTITY edge_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.EDGE_BASED_WIREFRAME_MODEL',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM',
               'STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
               = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.EDGE_BASED_WIREFRAME_MODEL',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               >= 1);
      wr3: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               'STRUCTURAL_ANALYSIS_DESIGN.EDGE_CURVE' IN TYPEOF(edges))) )) 
               = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( pline_edges <* QUERY ( edges <* eb.ces_edges | (
               'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE' IN TYPEOF(edges\
               edge_curve.edge_geometry)) ) | (NOT (SIZEOF(pline_edges\
               edge_curve.edge_geometry\polyline.points) > 2)) )) = 0)) )) 
               = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT ((
               'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN TYPEOF(edges.
               edge_start)) AND ('STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' 
               IN TYPEOF(edges.edge_end)))) )) = 0)) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT 
               valid_wireframe_edge_curve(edges\edge_curve.edge_geometry)) )) 
               = 0)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               valid_wireframe_vertex_point(edges.edge_start\vertex_point.
               vertex_geometry) AND valid_wireframe_vertex_point(edges.
               edge_end\vertex_point.vertex_geometry))) )) = 0)) )) = 0)) )) 
               = 0);
      wr8: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | 
               (NOT (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0);
      wr9: (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3);
  END_ENTITY; -- edge_based_wireframe_shape_representation

  ENTITY edge_curve
    SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense    : BOOLEAN;
  END_ENTITY; -- edge_curve

  ENTITY edge_loop
    SUBTYPE OF (loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: (SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].
               edge_end);
  END_ENTITY; -- edge_loop

  ENTITY effectivity
    SUPERTYPE OF (ONEOF (serial_numbered_effectivity,dated_effectivity,
        lot_effectivity));
      id : identifier;
  END_ENTITY; -- effectivity

  ENTITY element_analysis_message
    SUBTYPE OF (analysis_message);
      element : element_representation;
  END_ENTITY; -- element_analysis_message

  ENTITY element_definition
    SUBTYPE OF (shape_aspect);
  END_ENTITY; -- element_definition

  ENTITY element_descriptor
    SUPERTYPE OF (ONEOF (volume_3d_element_descriptor,
        axisymmetric_volume_2d_element_descriptor,
        plane_volume_2d_element_descriptor,surface_3d_element_descriptor,
        axisymmetric_surface_2d_element_descriptor,
        plane_surface_2d_element_descriptor,curve_3d_element_descriptor,
        axisymmetric_curve_2d_element_descriptor,
        plane_curve_2d_element_descriptor));
      topology_order : element_order;
      description    : text;
  END_ENTITY; -- element_descriptor

  ENTITY element_geometric_relationship;
      element_ref : element_or_element_group;
      item        : analysis_item_within_representation;
      aspect      : element_aspect;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN 
               TYPEOF(item.item));
      wr2: consistent_geometric_reference(aspect,item.item);
      wr3: consistent_element_or_group_reference(aspect,element_ref);
  END_ENTITY; -- element_geometric_relationship

  ENTITY element_group
    SUBTYPE OF (fea_group);
      elements : SET [1:?] OF element_representation;
  END_ENTITY; -- element_group

  ENTITY element_group_analysis_message
    SUBTYPE OF (analysis_message);
      group : element_group;
  END_ENTITY; -- element_group_analysis_message

  ENTITY element_material;
      material_id : identifier;
      description : text;
      properties  : SET [1:?] OF material_property_representation;
  END_ENTITY; -- element_material

  ENTITY element_nodal_freedom_actions
    SUBTYPE OF (state_definition);
      element      : model_or_control_element;
      nodal_action : LIST [1:?] OF element_nodal_freedom_terms;
  END_ENTITY; -- element_nodal_freedom_actions

  ENTITY element_nodal_freedom_terms;
      coordinate_system  : fea_axis2_placement_3d;
      degrees_of_freedom : freedoms_list;
      values             : LIST [1:?] OF measure_or_unspecified_value;
    WHERE
      wr1: (SIZEOF(degrees_of_freedom.freedoms) = SIZEOF(values));
  END_ENTITY; -- element_nodal_freedom_terms

  ENTITY element_representation
    SUPERTYPE OF (ONEOF (volume_3d_element_representation,
        axisymmetric_volume_2d_element_representation,
        plane_volume_2d_element_representation,
        surface_3d_element_representation,
        axisymmetric_surface_2d_element_representation,
        plane_surface_2d_element_representation,
        curve_3d_element_representation,
        axisymmetric_curve_2d_element_representation,
        plane_curve_2d_element_representation,point_element_representation,
        directionally_explicit_element_representation,
        explicit_element_representation,substructure_element_representation))
    SUBTYPE OF (representation);
      node_list : LIST [1:?] OF node_representation;
    WHERE
      wr1: (SIZEOF(QUERY ( item <* node_list | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'GEOMETRIC_NODE') IN TYPEOF(
               item)) )) = 0);
  END_ENTITY; -- element_representation

  ENTITY element_sequence;
      order_id    : identifier;
      control_ref : control;
      purpose     : text;
      elements    : LIST [1:?] OF model_or_control_element;
    UNIQUE
      ur1 : order_id, control_ref;
  END_ENTITY; -- element_sequence

  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (plane,cylindrical_surface,conical_surface,
        spherical_surface,toroidal_surface))
    SUBTYPE OF (surface);
      position : axis2_placement_3d;
  END_ENTITY; -- elementary_surface

  ENTITY ellipse
    SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY; -- ellipse

  ENTITY environment;
      syntactic_representation : generic_variable;
      semantics                : variable_semantics;
  END_ENTITY; -- environment

  ENTITY euler_angles;
      angles : ARRAY [1:3] OF plane_angle_measure;
  END_ENTITY; -- euler_angles

  ENTITY evaluated_degenerate_pcurve
    SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
  END_ENTITY; -- evaluated_degenerate_pcurve

  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY; -- executed_action

  ENTITY expanded_uncertainty
    SUBTYPE OF (standard_uncertainty);
      coverage_factor : REAL;
  END_ENTITY; -- expanded_uncertainty

  ENTITY explicit_element_matrix;
      property_type : matrix_property_type;
      symmetry      : matrix_symmetry;
      node_dof_list : LIST [1:?] OF LIST [1:?] OF degree_of_freedom;
      matrix_values : LIST [1:?] OF context_dependent_measure;
    WHERE
      wr1: (SIZEOF(matrix_values) = number_of_terms(node_dof_list,symmetry));
  END_ENTITY; -- explicit_element_matrix

  ENTITY explicit_element_representation
    SUBTYPE OF (element_representation);
      model_ref   : fea_model;
      description : text;
      matrix      : explicit_element_matrix;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: (SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AXIS2_PLACEMENT_3D') IN
                TYPEOF(item)) )) = 1);
      wr2: (SIZEOF(matrix.node_dof_list) = SIZEOF(SELF\
               element_representation.node_list));
  END_ENTITY; -- explicit_element_representation

  ENTITY expression
    ABSTRACT SUPERTYPE OF (ONEOF (numeric_expression,boolean_expression))
    SUBTYPE OF (generic_expression);
  END_ENTITY; -- expression

  ENTITY expression_conversion_based_unit
    SUBTYPE OF (named_unit, variable_semantics);
    INVERSE
      associated_variable_environment : environment FOR semantics;
  END_ENTITY; -- expression_conversion_based_unit

  ENTITY face
    SUPERTYPE OF (ONEOF (face_surface,oriented_face))
    SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      wr1: (NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
      wr2: (SIZEOF(QUERY ( temp <* bounds | (
               'STRUCTURAL_ANALYSIS_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(temp)) )) 
               <= 1);
  END_ENTITY; -- face

  ENTITY face_bound
    SUBTYPE OF (topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY; -- face_bound

  ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
  END_ENTITY; -- face_outer_bound

  ENTITY face_surface
    SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense    : BOOLEAN;
  END_ENTITY; -- face_surface

  ENTITY faceted_brep
    SUBTYPE OF (manifold_solid_brep);
  END_ENTITY; -- faceted_brep

  ENTITY faceted_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* items | (NOT (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.FACETED_BREP',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM',
               'STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
               = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.FACETED_BREP',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               > 0);
      wr3: (SIZEOF(QUERY ( fbrep <* QUERY ( it <* items | (
               'STRUCTURAL_ANALYSIS_DESIGN.FACETED_BREP' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( csh <* msb_shells(fbrep) | (NOT (
               SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
               NOT (('STRUCTURAL_ANALYSIS_DESIGN.FACE_SURFACE' IN TYPEOF(
               fcs)) AND ('STRUCTURAL_ANALYSIS_DESIGN.PLANE' IN TYPEOF(fcs\
               face_surface.face_geometry)) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(fcs\
               face_surface.face_geometry\elementary_surface.position.
               location)))) )) = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( fbrep <* QUERY ( it <* items | (
               'STRUCTURAL_ANALYSIS_DESIGN.FACETED_BREP' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( csh <* msb_shells(fbrep) | (NOT (
               SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
               NOT (SIZEOF(QUERY ( bnds <* fcs.bounds | (
               'STRUCTURAL_ANALYSIS_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(bnds)) )) 
               = 1)) )) = 0)) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( msb <* QUERY ( it <* items | (
               'STRUCTURAL_ANALYSIS_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(
               it)) ) | ('STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_CLOSED_SHELL' 
               IN TYPEOF(msb\manifold_solid_brep.outer)) )) = 0);
      wr6: (SIZEOF(QUERY ( brv <* QUERY ( it <* items | (
               'STRUCTURAL_ANALYSIS_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | 
               csh\oriented_closed_shell.orientation )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | 
               (NOT ('STRUCTURAL_ANALYSIS_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0);
  END_ENTITY; -- faceted_brep_shape_representation

  ENTITY fea_area_density
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constant : scalar;
  END_ENTITY; -- fea_area_density

  ENTITY fea_axis2_placement_2d
    SUBTYPE OF (axis2_placement_2d);
      system_type : coordinate_system_type;
      description : text;
  END_ENTITY; -- fea_axis2_placement_2d

  ENTITY fea_axis2_placement_3d
    SUBTYPE OF (axis2_placement_3d);
      system_type : coordinate_system_type;
      description : text;
  END_ENTITY; -- fea_axis2_placement_3d

  ENTITY fea_curve_section_geometric_relationship;
      section_ref : curve_element_section_definition;
      item        : analysis_item_within_representation;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN 
               TYPEOF(item.item));
  END_ENTITY; -- fea_curve_section_geometric_relationship

  ENTITY fea_group
    SUPERTYPE OF (ONEOF (element_group,node_group))
    SUBTYPE OF (group);
      model_ref : fea_model;
  END_ENTITY; -- fea_group

  ENTITY fea_group_relation
    SUBTYPE OF (group_relationship);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.FEA_GROUP' IN TYPEOF(SELF\
               group_relationship.relating_group));
      wr2: ('STRUCTURAL_ANALYSIS_DESIGN.FEA_GROUP' IN TYPEOF(SELF\
               group_relationship.related_group));
  END_ENTITY; -- fea_group_relation

  ENTITY fea_linear_elasticity
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constants : symmetric_tensor4_3d;
  END_ENTITY; -- fea_linear_elasticity

  ENTITY fea_mass_density
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constant : scalar;
  END_ENTITY; -- fea_mass_density

  ENTITY fea_material_property_geometric_relationship;
      material_ref : fea_material_property_representation;
      item         : analysis_item_within_representation;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN 
               TYPEOF(item.item));
  END_ENTITY; -- fea_material_property_geometric_relationship

  ENTITY fea_material_property_representation
    SUBTYPE OF (material_property_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* SELF\property_definition_representation
               .used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AREA_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SHELL_MEMBRANE_STIFFNESS','STRUCTURAL_ANALYSIS_DESIGN.' 
               + 'FEA_SHELL_BENDING_STIFFNESS',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_SHELL_SHEAR_STIFFNESS'] 
               * TYPEOF(item)) = 1) )) = 1);
      wr2: ('STRUCTURAL_ANALYSIS_DESIGN.MATERIAL_PROPERTY' IN TYPEOF(SELF\
               property_definition_representation.definition));
  END_ENTITY; -- fea_material_property_representation

  ENTITY fea_material_property_representation_item
    SUPERTYPE OF (ONEOF (fea_linear_elasticity,fea_mass_density,
        fea_area_density,
        fea_tangential_coefficient_of_linear_thermal_expansion,
        fea_secant_coefficient_of_linear_thermal_expansion,
        fea_moisture_absorption,fea_shell_membrane_stiffness,
        fea_shell_bending_stiffness,
        fea_shell_membrane_bending_coupling_stiffness,
        fea_shell_shear_stiffness))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- fea_material_property_representation_item

  ENTITY fea_model
    SUPERTYPE OF (ONEOF (fea_model_2d,fea_model_3d))
    SUBTYPE OF (representation);
      creating_software      : text;
      intended_analysis_code : SET [1:?] OF text;
      description            : text;
      analysis_type          : text;
    UNIQUE
      ur1 : name;
  END_ENTITY; -- fea_model

  ENTITY fea_model_2d
    SUBTYPE OF (fea_model);
      type_of_2d_analysis : axi_or_plane;
    WHERE
      wr1: (SELF\representation.context_of_items\
               geometric_representation_context.coordinate_space_dimension 
               = 2);
  END_ENTITY; -- fea_model_2d

  ENTITY fea_model_3d
    SUBTYPE OF (fea_model);
    WHERE
      wr1: (SELF\representation.context_of_items\
               geometric_representation_context.coordinate_space_dimension 
               = 3);
  END_ENTITY; -- fea_model_3d

  ENTITY fea_model_definition
    SUBTYPE OF (shape_aspect);
  END_ENTITY; -- fea_model_definition

  ENTITY fea_moisture_absorption
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constants : symmetric_tensor2_3d;
  END_ENTITY; -- fea_moisture_absorption

  ENTITY fea_parametric_point
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF parameter_value;
    WHERE
      wr1: valid_parametric_coordinate(coordinates);
      wr2: (SIZEOF(TYPEOF(SELF) * [
               'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT',
               'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_CURVE',
               'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_SURFACE',
               'STRUCTURAL_ANALYSIS_DESIGN.DEGENERATE_PCURVE',
               'STRUCTURAL_ANALYSIS_DESIGN.POINT_REPLICA',
               'STRUCTURAL_ANALYSIS_DESIGN.SPHERICAL_POINT',
               'STRUCTURAL_ANALYSIS_DESIGN.CYLINDRICAL_POINT']) = 0);
  END_ENTITY; -- fea_parametric_point

  ENTITY fea_representation_item
    SUPERTYPE OF (ONEOF (arbitrary_volume_3d_element_coordinate_system,
        parametric_volume_3d_element_coordinate_system,
        arbitrary_volume_2d_element_coordinate_system,
        parametric_volume_2d_element_coordinate_system,
        aligned_surface_3d_element_coordinate_system,
        parametric_surface_3d_element_coordinate_system,
        constant_surface_3d_element_coordinate_system,
        aligned_surface_2d_element_coordinate_system,
        parametric_surface_2d_element_coordinate_system,
        aligned_curve_3d_element_coordinate_system,
        parametric_curve_3d_element_coordinate_system,
        parametric_curve_3d_element_coordinate_direction,
        curve_2d_element_coordinate_system,
        directionally_explicit_element_coordinate_system_arbitrary,
        directionally_explicit_element_coordinate_system_aligned))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- fea_representation_item

  ENTITY fea_secant_coefficient_of_linear_thermal_expansion
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constants         : symmetric_tensor2_3d;
      reference_temperature : thermodynamic_temperature_measure;
  END_ENTITY; -- fea_secant_coefficient_of_linear_thermal_expansion

  ENTITY fea_shell_bending_stiffness
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constants : symmetric_tensor4_2d;
  END_ENTITY; -- fea_shell_bending_stiffness

  ENTITY fea_shell_membrane_bending_coupling_stiffness
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constants : symmetric_tensor4_2d;
  END_ENTITY; -- fea_shell_membrane_bending_coupling_stiffness

  ENTITY fea_shell_membrane_stiffness
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constants : symmetric_tensor4_2d;
  END_ENTITY; -- fea_shell_membrane_stiffness

  ENTITY fea_shell_shear_stiffness
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constants : symmetric_tensor2_2d;
  END_ENTITY; -- fea_shell_shear_stiffness

  ENTITY fea_surface_section_geometric_relationship;
      section_ref : surface_section;
      item        : analysis_item_within_representation;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN 
               TYPEOF(item.item));
  END_ENTITY; -- fea_surface_section_geometric_relationship

  ENTITY fea_tangential_coefficient_of_linear_thermal_expansion
    SUBTYPE OF (fea_material_property_representation_item);
      fea_constants : symmetric_tensor2_3d;
  END_ENTITY; -- fea_tangential_coefficient_of_linear_thermal_expansion

  ENTITY field_variable_definition
    SUPERTYPE OF (ONEOF (field_variable_element_definition,
        field_variable_element_group_value,field_variable_whole_model_value,
        field_variable_node_definition))
    SUBTYPE OF (state_definition);
  END_ENTITY; -- field_variable_definition

  ENTITY field_variable_element_definition
    SUPERTYPE OF (ONEOF (volume_3d_element_field_variable_definition,
        volume_2d_element_field_variable_definition,
        surface_3d_element_field_variable_definition,
        surface_2d_element_field_variable_definition,
        curve_3d_element_field_variable_definition,
        curve_2d_element_field_variable_definition))
    SUBTYPE OF (field_variable_definition);
  END_ENTITY; -- field_variable_element_definition

  ENTITY field_variable_element_group_value
    SUBTYPE OF (field_variable_definition);
      group             : element_group;
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL fea_axis2_placement_3d;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- field_variable_element_group_value

  ENTITY field_variable_node_definition
    SUPERTYPE OF (ONEOF (volume_3d_node_field_variable_definition,
        volume_2d_node_field_variable_definition,
        surface_3d_node_field_variable_definition,
        surface_2d_node_field_variable_definition,
        curve_3d_node_field_variable_definition,
        curve_2d_node_field_variable_definition))
    SUBTYPE OF (field_variable_definition);
      node  : node_output_reference;
      group : OPTIONAL element_group;
  END_ENTITY; -- field_variable_node_definition

  ENTITY field_variable_whole_model_value
    SUBTYPE OF (field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL fea_axis2_placement_3d;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- field_variable_whole_model_value

  ENTITY flat_pattern_ply_representation_relationship
    SUBTYPE OF (shape_representation_relationship);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.SHAPE_REPRESENTATION' IN (TYPEOF(
               SELF\representation_relationship.rep_1) * TYPEOF(SELF\
               representation_relationship.rep_2)));
      wr2: (SELF\representation_relationship.rep_1.context_of_items\
               geometric_representation_context.coordinate_space_dimension 
               = 3);
  END_ENTITY; -- flat_pattern_ply_representation_relationship

  ENTITY founded_item;
  END_ENTITY; -- founded_item

  ENTITY freedom_and_coefficient;
      freedom : degree_of_freedom;
      a       : measure_or_unspecified_value;
  END_ENTITY; -- freedom_and_coefficient

  ENTITY freedoms_list;
      freedoms : LIST [1:?] OF degree_of_freedom;
  END_ENTITY; -- freedoms_list

  ENTITY functionally_defined_transformation;
      name        : label;
      description : text;
  END_ENTITY; -- functionally_defined_transformation

  ENTITY generic_expression
    ABSTRACT SUPERTYPE OF (ONEOF (simple_generic_expression,
        unary_generic_expression,binary_generic_expression,
        multiple_arity_generic_expression));
    WHERE
      wr1: is_acyclic(SELF);
  END_ENTITY; -- generic_expression

  ENTITY generic_literal
    ABSTRACT SUPERTYPE
    SUBTYPE OF (simple_generic_expression);
  END_ENTITY; -- generic_literal

  ENTITY generic_variable
    ABSTRACT SUPERTYPE
    SUBTYPE OF (simple_generic_expression);
    INVERSE
      interpretation : environment FOR syntactic_representation;
  END_ENTITY; -- generic_variable

  ENTITY geometric_curve_set
    SUBTYPE OF (geometric_set);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF\geometric_set.elements | (
               'STRUCTURAL_ANALYSIS_DESIGN.SURFACE' IN TYPEOF(temp)) )) = 0);
  END_ENTITY; -- geometric_curve_set

  ENTITY geometric_node
    SUBTYPE OF (node_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* SELF\representation.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.POINT' IN TYPEOF(item)) )) = 1);
  END_ENTITY; -- geometric_node

  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY; -- geometric_representation_context

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (point,direction,vector,placement,
        cartesian_transformation_operator,curve,surface,edge_curve,
        face_surface,poly_loop,vertex_point,solid_model,
        shell_based_surface_model,shell_based_wireframe_model,
        edge_based_wireframe_model,geometric_set))
    SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: (SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (
               NOT ('STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(using_rep.context_of_items))) )) = 0);
  END_ENTITY; -- geometric_representation_item

  ENTITY geometric_set
    SUPERTYPE OF (geometric_curve_set)
    SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY; -- geometric_set

  ENTITY geometrically_bounded_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_SET',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM',
               'STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
               = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_SET',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               > 0);
      wr3: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | 
               (NOT ((('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) 
               AND (SIZEOF(QUERY ( mr_it <* mi\mapped_item.mapping_source.
               mapped_representation.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_SET' IN TYPEOF(mr_it)) )) 
               > 0))) )) = 0);
      wr4: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( pnt <* QUERY ( gsel <* gs\
               geometric_set.elements | ('STRUCTURAL_ANALYSIS_DESIGN.POINT' 
               IN TYPEOF(gsel)) ) | (NOT gbsf_check_point(pnt)) )) = 0)) )) 
               = 0);
      wr5: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( cv <* QUERY ( gsel <* gs\
               geometric_set.elements | ('STRUCTURAL_ANALYSIS_DESIGN.CURVE' 
               IN TYPEOF(gsel)) ) | (NOT gbsf_check_curve(cv)) )) = 0)) )) 
               = 0);
      wr6: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( sf <* QUERY ( gsel <* gs\
               geometric_set.elements | (
               'STRUCTURAL_ANALYSIS_DESIGN.SURFACE' IN TYPEOF(gsel)) ) | (
               NOT gbsf_check_surface(sf)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) )
                | (SIZEOF(QUERY ( gsel <* gs\geometric_set.elements | (
               'STRUCTURAL_ANALYSIS_DESIGN.SURFACE' IN TYPEOF(gsel)) )) > 0) )) 
               > 0);
  END_ENTITY; -- geometrically_bounded_surface_shape_representation

  ENTITY geometrically_bounded_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(TYPEOF(it) * [
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_CURVE_SET',
               'STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM']) = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(TYPEOF(it) * [
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_CURVE_SET',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM']) = 1) )) >= 1);
      wr3: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(
               it)) ) | (NOT (SIZEOF(QUERY ( crv <* QUERY ( elem <* gcs\
               geometric_set.elements | ('STRUCTURAL_ANALYSIS_DESIGN.CURVE' 
               IN TYPEOF(elem)) ) | (NOT 
               valid_geometrically_bounded_wf_curve(crv)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(
               it)) ) | (NOT (SIZEOF(QUERY ( pnts <* QUERY ( elem <* gcs\
               geometric_set.elements | ('STRUCTURAL_ANALYSIS_DESIGN.POINT' 
               IN TYPEOF(elem)) ) | (NOT 
               valid_geometrically_bounded_wf_point(pnts)) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(
               it)) ) | (NOT (SIZEOF(QUERY ( cnc <* QUERY ( elem <* gcs\
               geometric_set.elements | ('STRUCTURAL_ANALYSIS_DESIGN.CONIC' 
               IN TYPEOF(elem)) ) | (NOT (
               'STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(
               cnc\conic.position))) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(
               it)) ) | (NOT (SIZEOF(QUERY ( pline <* QUERY ( elem <* gcs\
               geometric_set.elements | (
               'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE' IN TYPEOF(elem)) ) | (
               NOT (SIZEOF(pline\polyline.points) > 2)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | 
               (NOT (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
               = 0);
  END_ENTITY; -- geometrically_bounded_wireframe_shape_representation

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY; -- global_uncertainty_assigned_context

  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY; -- global_unit_assigned_context

  ENTITY grounded_damper
    SUBTYPE OF (point_element_matrix);
      damping_coefficients : ARRAY [1:6] OF context_dependent_measure;
  END_ENTITY; -- grounded_damper

  ENTITY grounded_spring
    SUBTYPE OF (point_element_matrix);
      stiffness_coefficients : ARRAY [1:6] OF context_dependent_measure;
  END_ENTITY; -- grounded_spring

  ENTITY group;
      name        : label;
      description : text;
  END_ENTITY; -- group

  ENTITY group_relationship;
      name           : label;
      description    : text;
      relating_group : group;
      related_group  : group;
  END_ENTITY; -- group_relationship

  ENTITY hyperbola
    SUBTYPE OF (conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY; -- hyperbola

  ENTITY intersection_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               <> associated_surface(SELF\surface_curve.associated_geometry
               [2]));
  END_ENTITY; -- intersection_curve

  ENTITY interval_expression
    SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
    DERIVE
      interval_low  : generic_expression := SELF\
                         multiple_arity_generic_expression.operands[1];
      interval_item : generic_expression := SELF\
                         multiple_arity_generic_expression.operands[2];
      interval_high : generic_expression := SELF\
                         multiple_arity_generic_expression.operands[3];
    WHERE
      wr1: (('STRUCTURAL_ANALYSIS_DESIGN.EXPRESSION' IN TYPEOF(
               interval_low)) AND ('STRUCTURAL_ANALYSIS_DESIGN.EXPRESSION' 
               IN TYPEOF(interval_item)) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.EXPRESSION' IN TYPEOF(
               interval_high)));
      wr2: ((('STRUCTURAL_ANALYSIS_DESIGN.STRING_EXPRESSION' IN TYPEOF(
               SELF.interval_low)) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.STRING_EXPRESSION' IN TYPEOF(
               SELF.interval_high)) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.STRING_EXPRESSION' IN TYPEOF(
               SELF.interval_item))) OR ((
               'STRUCTURAL_ANALYSIS_DESIGN.STRING_EXPRESSION' IN TYPEOF(
               SELF.interval_low)) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(
               SELF.interval_item)) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.NUMERIC_EXPRESSION' IN TYPEOF(
               SELF.interval_high))));
  END_ENTITY; -- interval_expression

  ENTITY item_defined_transformation;
      name             : label;
      description      : text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
  END_ENTITY; -- item_defined_transformation

  ENTITY laid_defined_transformation
    SUBTYPE OF (item_defined_transformation);
  END_ENTITY; -- laid_defined_transformation

  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.LENGTH_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- length_measure_with_unit

  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- length_unit

  ENTITY line
    SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      wr1: (dir.dim = pnt.dim);
  END_ENTITY; -- line

  ENTITY linear_constraint_equation_element
    SUBTYPE OF (constraint_element);
      freedoms_and_coefficients : SET [1:?] OF linear_constraint_equation_nodal_term;
      description               : text;
  END_ENTITY; -- linear_constraint_equation_element

  ENTITY linear_constraint_equation_element_value
    SUBTYPE OF (state_definition);
      element : linear_constraint_equation_element;
      b       : measure_or_unspecified_value;
  END_ENTITY; -- linear_constraint_equation_element_value

  ENTITY linear_constraint_equation_nodal_term;
      node                         : node_representation;
      coordinate_system            : fea_axis2_placement_3d;
      freedom_and_coefficient_term : freedom_and_coefficient;
      dependent                    : LOGICAL;
  END_ENTITY; -- linear_constraint_equation_nodal_term

  ENTITY linearly_superimposed_state
    SUBTYPE OF (state);
    INVERSE
      components : SET [1:?] OF state_component FOR state;
  END_ENTITY; -- linearly_superimposed_state

  ENTITY literal_number
    ABSTRACT SUPERTYPE OF (real_literal)
    SUBTYPE OF (simple_numeric_expression, generic_literal);
      the_value : NUMBER;
  END_ENTITY; -- literal_number

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY; -- local_time

  ENTITY loop
    SUPERTYPE OF (ONEOF (vertex_loop,edge_loop,poly_loop))
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- loop

  ENTITY lot_effectivity
    SUBTYPE OF (effectivity);
      effectivity_lot_id   : identifier;
      effectivity_lot_size : measure_with_unit;
  END_ENTITY; -- lot_effectivity

  ENTITY make_from_usage_option
    SUBTYPE OF (product_definition_usage);
      ranking           : INTEGER;
      ranking_rationale : text;
      quantity          : measure_with_unit;
    WHERE
      wr1: (ranking > 0);
  END_ENTITY; -- make_from_usage_option

  ENTITY manifold_solid_brep
    SUBTYPE OF (solid_model);
      outer : closed_shell;
  END_ENTITY; -- manifold_solid_brep

  ENTITY manifold_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL',
                'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM',
                'STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(
                it)) = 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL',
                'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                > 0);
      wr3 : (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) )
                 | (NOT (('STRUCTURAL_ANALYSIS_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' 
                IN TYPEOF(mi\mapped_item.mapping_source.
                mapped_representation)) AND (SIZEOF(QUERY ( mr_it <* mi\
                mapped_item.mapping_source.mapped_representation.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(mr_it)) )) > 0))) )) = 0);
      wr4 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( sh <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.OPEN_SHELL',
                'STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_CLOSED_SHELL',
                'STRUCTURAL_ANALYSIS_DESIGN.CLOSED_SHELL'] * TYPEOF(sh)) = 
                1)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (
                'STRUCTURAL_ANALYSIS_DESIGN.FACE_SURFACE' IN TYPEOF(fa))) )) 
                = 0)) )) = 0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) 
                OR msf_surface_check(fa\face_surface.face_geometry))) )) = 
                0)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) 
                OR (SIZEOF(QUERY ( bnds <* fa.bounds | (NOT (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP',
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_LOOP'] * TYPEOF(bnds.
                bound)) = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) 
                OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds
                 | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.
                bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.
                edge_list | (NOT ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_CURVE' 
                IN TYPEOF(oe.edge_element))) )) = 0)) )) = 0))) )) = 0)) )) 
                = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) 
                OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds
                 | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.
                bound)) ) | (NOT (SIZEOF(QUERY ( oe_cv <* QUERY ( oe <* 
                elp_fbnds\path.edge_list | (
                'STRUCTURAL_ANALYSIS_DESIGN.EDGE_CURVE' IN TYPEOF(oe.
                edge_element)) ) | (NOT (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_CURVE',
                'STRUCTURAL_ANALYSIS_DESIGN.CONIC',
                'STRUCTURAL_ANALYSIS_DESIGN.CURVE_REPLICA',
                'STRUCTURAL_ANALYSIS_DESIGN.LINE',
                'STRUCTURAL_ANALYSIS_DESIGN.OFFSET_CURVE_3D',
                'STRUCTURAL_ANALYSIS_DESIGN.PCURVE',
                'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE',
                'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_CURVE'] * TYPEOF(oe_cv.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0))) )) = 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) 
                OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds
                 | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.
                bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.
                edge_list | (NOT msf_curve_check(oe.edge_element\edge_curve
                .edge_geometry)) )) = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 
                0);
      wr11: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) 
                OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds
                 | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.
                bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.
                edge_list | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_start)) AND (
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_end)))) )) = 0)) )) = 0))) )) = 0)) )) = 
                0)) )) = 0);
      wr12: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) 
                OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds
                 | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.
                bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.
                edge_list | (NOT ((SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT',
                'STRUCTURAL_ANALYSIS_DESIGN.DEGENERATE_PCURVE',
                'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_CURVE',
                'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_start\vertex_point.vertex_geometry)) = 1) 
                AND (SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT',
                'STRUCTURAL_ANALYSIS_DESIGN.DEGENERATE_PCURVE',
                'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_CURVE',
                'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_end\vertex_point.vertex_geometry)) = 1))) )) 
                = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr13: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) 
                OR (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds
                 | ('STRUCTURAL_ANALYSIS_DESIGN.VERTEX_LOOP' IN TYPEOF(bnds
                .bound)) ) | (NOT (
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\vertex_loop.loop_vertex))) )) = 0))) )) = 0)) )) 
                = 0)) )) = 0);
      wr14: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) 
                OR (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds
                 | ('STRUCTURAL_ANALYSIS_DESIGN.VERTEX_LOOP' IN TYPEOF(bnds
                .bound)) ) | (NOT (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT',
                'STRUCTURAL_ANALYSIS_DESIGN.DEGENERATE_PCURVE',
                'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_CURVE',
                'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_SURFACE'] * TYPEOF(
                vlp_fbnds\vertex_loop.loop_vertex\vertex_point.
                vertex_geometry)) = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
  END_ENTITY; -- manifold_surface_shape_representation

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]);
  END_ENTITY; -- mapped_item

  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.MASS_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- mass_measure_with_unit

  ENTITY mass_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 1) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- mass_unit

  ENTITY material_designation;
      name        : label;
      definitions : SET [1:?] OF characterized_definition;
  END_ENTITY; -- material_designation

  ENTITY material_designation_characterization;
      name        : label;
      description : text;
      designation : material_designation;
      property    : characterized_material_property;
  END_ENTITY; -- material_designation_characterization

  ENTITY material_property
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : name, definition;
    WHERE
      wr1: (('STRUCTURAL_ANALYSIS_DESIGN.CHARACTERIZED_OBJECT' IN TYPEOF(
               SELF\property_definition.definition)) OR (SIZEOF(bag_to_set(
               USEDIN(SELF,'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) - 
               QUERY ( temp <* bag_to_set(USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'MATERIAL_PROPERTY_REPRESENTATION') IN TYPEOF(temp)) )) = 0));
  END_ENTITY; -- material_property

  ENTITY material_property_representation
    SUBTYPE OF (property_definition_representation);
      dependent_environment : data_environment;
  END_ENTITY; -- material_property_representation

  ENTITY measure_qualification;
      name              : label;
      description       : text;
      qualified_measure : measure_with_unit;
      qualifiers        : SET [1:?] OF value_qualifier;
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* qualifiers | (
               'STRUCTURAL_ANALYSIS_DESIGN.PRECISION_QUALIFIER' IN TYPEOF(
               temp)) )) < 2);
  END_ENTITY; -- measure_qualification

  ENTITY measure_representation_item
    SUBTYPE OF (representation_item, measure_with_unit);
  END_ENTITY; -- measure_representation_item

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (length_measure_with_unit,mass_measure_with_unit,
        time_measure_with_unit,thermodynamic_temperature_measure_with_unit,
        amount_of_substance_measure_with_unit,plane_angle_measure_with_unit,
        solid_angle_measure_with_unit,area_measure_with_unit,
        volume_measure_with_unit));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY; -- measure_with_unit

  ENTITY minus_expression
    SUBTYPE OF (binary_numeric_expression);
  END_ENTITY; -- minus_expression

  ENTITY mult_expression
    SUBTYPE OF (multiple_arity_numeric_expression);
  END_ENTITY; -- mult_expression

  ENTITY multiple_arity_boolean_expression
    ABSTRACT SUPERTYPE
    SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
      SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF boolean_expression;
  END_ENTITY; -- multiple_arity_boolean_expression

  ENTITY multiple_arity_generic_expression
    ABSTRACT SUPERTYPE
    SUBTYPE OF (generic_expression);
      operands : LIST [2:?] OF generic_expression;
  END_ENTITY; -- multiple_arity_generic_expression

  ENTITY multiple_arity_numeric_expression
    ABSTRACT SUPERTYPE OF (ONEOF (plus_expression,mult_expression))
    SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
      SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF numeric_expression;
  END_ENTITY; -- multiple_arity_numeric_expression

  ENTITY name_assignment
    ABSTRACT SUPERTYPE;
      assigned_name : label;
  END_ENTITY; -- name_assignment

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (si_unit,conversion_based_unit,
        context_dependent_unit) ANDOR ONEOF (length_unit,mass_unit,
        time_unit,thermodynamic_temperature_unit,amount_of_substance_unit,
        plane_angle_unit,solid_angle_unit,area_unit,volume_unit,ratio_unit));
      dimensions : dimensional_exponents;
  END_ENTITY; -- named_unit

  ENTITY named_unit_variable
    SUBTYPE OF (named_unit, variable_semantics);
    INVERSE
      associated_variable_environment : environment FOR semantics;
  END_ENTITY; -- named_unit_variable

  ENTITY next_assembly_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- next_assembly_usage_occurrence

  ENTITY no_symmetry_control
    SUBTYPE OF (symmetry_control);
  END_ENTITY; -- no_symmetry_control

  ENTITY nodal_dof_reduction
    SUBTYPE OF (constraint_element);
      required_node     : node_output_reference;
      coordinate_system : fea_axis2_placement_3d;
      freedoms          : SET [1:?] OF degree_of_freedom;
      description       : text;
  END_ENTITY; -- nodal_dof_reduction

  ENTITY nodal_freedom_action_definition
    SUBTYPE OF (nodal_freedom_and_value_definition);
      action : action_type;
  END_ENTITY; -- nodal_freedom_action_definition

  ENTITY nodal_freedom_and_value_definition
    SUPERTYPE OF (ONEOF (nodal_freedom_values,
        nodal_freedom_action_definition))
    SUBTYPE OF (state_definition);
      node               : node_output_reference;
      coordinate_system  : fea_axis2_placement_3d;
      degrees_of_freedom : freedoms_list;
      values             : LIST [1:?] OF measure_or_unspecified_value;
    WHERE
      wr1: (SIZEOF(degrees_of_freedom.freedoms) = SIZEOF(values));
  END_ENTITY; -- nodal_freedom_and_value_definition

  ENTITY nodal_freedom_values
    SUBTYPE OF (nodal_freedom_and_value_definition);
  END_ENTITY; -- nodal_freedom_values

  ENTITY node
    SUPERTYPE OF (node_with_vector ANDOR 
        node_with_solution_coordinate_system)
    SUBTYPE OF (node_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* SELF\representation.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.POINT' IN TYPEOF(item)) )) = 1);
  END_ENTITY; -- node

  ENTITY node_analysis_message
    SUBTYPE OF (analysis_message);
      node : node_output_reference;
  END_ENTITY; -- node_analysis_message

  ENTITY node_definition
    SUBTYPE OF (shape_aspect);
  END_ENTITY; -- node_definition

  ENTITY node_geometric_relationship;
      node_ref : node_or_node_group;
      item     : analysis_item_within_representation;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.GEOMETRIC_REPRESENTATION_ITEM' IN 
               TYPEOF(item.item));
  END_ENTITY; -- node_geometric_relationship

  ENTITY node_group
    SUBTYPE OF (fea_group);
      nodes : SET [1:?] OF node_representation;
  END_ENTITY; -- node_group

  ENTITY node_representation
    SUPERTYPE OF (ONEOF (node,dummy_node,geometric_node))
    SUBTYPE OF (representation);
      model_ref : fea_model;
    UNIQUE
      ur1 : model_ref, name;
  END_ENTITY; -- node_representation

  ENTITY node_sequence;
      order_id    : identifier;
      control_ref : control;
      purpose     : text;
      nodes       : LIST [1:?] OF node_representation;
    UNIQUE
      ur1 : order_id, control_ref;
  END_ENTITY; -- node_sequence

  ENTITY node_set
    SUBTYPE OF (geometric_representation_item);
      nodes : SET [1:?] OF node_representation;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* nodes | (tmp\representation.
               context_of_items :<>: nodes[1]\representation.
               context_of_items) )) = 0);
  END_ENTITY; -- node_set

  ENTITY node_with_solution_coordinate_system
    SUBTYPE OF (node);
    WHERE
      wr1: (((SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AXIS2_PLACEMENT_3D') IN
                TYPEOF(item)) )) = 1) AND (SELF\representation.
               context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3)) OR ((SIZEOF(
               QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AXIS2_PLACEMENT_2D') IN
                TYPEOF(item)) )) = 1) AND (SELF\representation.
               context_of_items\geometric_representation_context.
               coordinate_space_dimension = 2)));
  END_ENTITY; -- node_with_solution_coordinate_system

  ENTITY node_with_vector
    SUBTYPE OF (node);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* SELF\representation.items | (
               'STRUCTURAL_ANALYSIS_DESIGN.DIRECTION' IN TYPEOF(item)) )) =
                1);
  END_ENTITY; -- node_with_vector

  ENTITY numeric_expression
    ABSTRACT SUPERTYPE OF (ONEOF (simple_numeric_expression,
        unary_numeric_expression,binary_numeric_expression,
        multiple_arity_numeric_expression))
    SUBTYPE OF (expression);
    DERIVE
      is_int       : BOOLEAN := is_int_expr(SELF);
      sql_mappable : BOOLEAN := is_sql_mappable(SELF);
  END_ENTITY; -- numeric_expression

  ENTITY numeric_variable
    SUPERTYPE OF (real_numeric_variable)
    SUBTYPE OF (simple_numeric_expression, variable);
    WHERE
      wr1: (('STRUCTURAL_ANALYSIS_DESIGN.INT_NUMERIC_VARIABLE' IN TYPEOF(
               SELF)) OR (
               'STRUCTURAL_ANALYSIS_DESIGN.REAL_NUMERIC_VARIABLE' IN 
               TYPEOF(SELF)));
  END_ENTITY; -- numeric_variable

  ENTITY offset_curve_2d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
    WHERE
      wr1: (basis_curve.dim = 2);
  END_ENTITY; -- offset_curve_2d

  ENTITY offset_curve_3d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
      ref_direction  : direction;
    WHERE
      wr1: ((basis_curve.dim = 3) AND (ref_direction.dim = 3));
  END_ENTITY; -- offset_curve_3d

  ENTITY offset_surface
    SUBTYPE OF (surface);
      basis_surface  : surface;
      distance       : length_measure;
      self_intersect : LOGICAL;
  END_ENTITY; -- offset_surface

  ENTITY open_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- open_shell

  ENTITY ordinal_date
    SUBTYPE OF (date);
      day_component : day_in_year_number;
    WHERE
      wr1: (((NOT leap_year(SELF.year_component)) AND (1 <= day_component) 
               AND (day_component <= 365)) OR (leap_year(SELF.
               year_component) AND (1 <= day_component) AND (day_component 
               <= 366)));
  END_ENTITY; -- ordinal_date

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : text;
  END_ENTITY; -- organization

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role                  : organization_role;
  END_ENTITY; -- organization_assignment

  ENTITY organization_relationship;
      name                  : label;
      description           : text;
      relating_organization : organization;
      related_organization  : organization;
  END_ENTITY; -- organization_relationship

  ENTITY organization_role;
      name : label;
  END_ENTITY; -- organization_role

  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : text;
  END_ENTITY; -- organizational_address

  ENTITY organizational_project;
      name                      : label;
      description               : text;
      responsible_organizations : SET [1:?] OF organization;
  END_ENTITY; -- organizational_project

  ENTITY oriented_closed_shell
    SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation          : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             closed_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_CLOSED_SHELL' IN 
               TYPEOF(SELF.closed_shell_element)));
  END_ENTITY; -- oriented_closed_shell

  ENTITY oriented_edge
    SUBTYPE OF (edge);
      edge_element : edge;
      orientation  : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_start,SELF.
                                edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_end,SELF.
                                edge_element.edge_start);
    WHERE
      wr1: (NOT ('STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_EDGE' IN TYPEOF(SELF
               .edge_element)));
  END_ENTITY; -- oriented_edge

  ENTITY oriented_face
    SUBTYPE OF (face);
      face_element : face;
      orientation  : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(
                            SELF.orientation,SELF.face_element.bounds);
    WHERE
      wr1: (NOT ('STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_FACE' IN TYPEOF(SELF
               .face_element)));
  END_ENTITY; -- oriented_face

  ENTITY oriented_open_shell
    SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation        : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             open_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_OPEN_SHELL' IN 
               TYPEOF(SELF.open_shell_element)));
  END_ENTITY; -- oriented_open_shell

  ENTITY oriented_path
    SUBTYPE OF (path);
      path_element : path;
      orientation  : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := 
                               conditional_reverse(SELF.orientation,SELF.
                               path_element.edge_list);
    WHERE
      wr1: (NOT ('STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_PATH' IN TYPEOF(SELF
               .path_element)));
  END_ENTITY; -- oriented_path

  ENTITY outer_boundary_curve
    SUBTYPE OF (boundary_curve);
  END_ENTITY; -- outer_boundary_curve

  ENTITY output_request_state
    SUBTYPE OF (state);
      steps : SET [1:?] OF control_analysis_step;
  END_ENTITY; -- output_request_state

  ENTITY parabola
    SUBTYPE OF (conic);
      focal_dist : length_measure;
    WHERE
      wr1: (focal_dist <> 0);
  END_ENTITY; -- parabola

  ENTITY parametric_curve_3d_element_coordinate_direction
    SUBTYPE OF (fea_representation_item);
      orientation : direction;
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- parametric_curve_3d_element_coordinate_direction

  ENTITY parametric_curve_3d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      direction : parametric_curve_3d_element_coordinate_direction;
  END_ENTITY; -- parametric_curve_3d_element_coordinate_system

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY; -- parametric_representation_context

  ENTITY parametric_surface_2d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
  END_ENTITY; -- parametric_surface_2d_element_coordinate_system

  ENTITY parametric_surface_3d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      axis  : INTEGER;
      angle : plane_angle_measure;
    WHERE
      wr1: ((axis >= 1) AND (axis <= 2));
  END_ENTITY; -- parametric_surface_3d_element_coordinate_system

  ENTITY parametric_volume_2d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      axis  : INTEGER;
      angle : plane_angle_measure;
    WHERE
      wr1: ((axis >= 1) AND (axis <= 2));
  END_ENTITY; -- parametric_volume_2d_element_coordinate_system

  ENTITY parametric_volume_3d_element_coordinate_system
    SUBTYPE OF (fea_representation_item);
      axis_1    : INTEGER;
      axis_2    : INTEGER;
      eu_angles : euler_angles;
    WHERE
      wr1: ((axis_1 >= 1) AND (axis_1 <= 3) AND (axis_2 >= 1) AND (axis_2 
               <= 3) AND (NOT (axis_1 = axis_2)));
  END_ENTITY; -- parametric_volume_3d_element_coordinate_system

  ENTITY path
    SUPERTYPE OF (ONEOF (edge_loop,oriented_path))
    SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
    WHERE
      wr1: path_head_to_tail(SELF);
  END_ENTITY; -- path

  ENTITY pcurve
    SUBTYPE OF (curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('STRUCTURAL_ANALYSIS_DESIGN.CURVE' IN TYPEOF(
               reference_to_curve\representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- pcurve

  ENTITY percentage_laminate_definition
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATING_PRODUCT_DEFINITION') | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'NEXT_ASSEMBLY_USAGE_OCCURRENCE') IN TYPEOF(pdr)) )) > 0);
  END_ENTITY; -- percentage_laminate_definition

  ENTITY percentage_ply_definition
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | ((
               'STRUCTURAL_ANALYSIS_DESIGN.PERCENTAGE_LAMINATE_DEFINITION' 
               IN TYPEOF(pdr.related_product_definition)) AND (pdr.name = 
               'makeup and properties')) )) = 0);
  END_ENTITY; -- percentage_ply_definition

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    UNIQUE
      ur1 : id;
    WHERE
      wr1: (EXISTS(last_name) OR EXISTS(first_name));
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
  END_ENTITY; -- person_and_organization_role

  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : text;
  END_ENTITY; -- personal_address

  ENTITY placement
    SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d,
        axis2_placement_3d))
    SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY; -- placement

  ENTITY plane
    SUBTYPE OF (elementary_surface);
  END_ENTITY; -- plane

  ENTITY plane_2d_element_property
    SUPERTYPE OF (simple_plane_2d_element_property);
      depth : context_dependent_measure;
  END_ENTITY; -- plane_2d_element_property

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- plane_angle_measure_with_unit

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- plane_angle_unit

  ENTITY plane_curve_2d_element_descriptor
    SUBTYPE OF (element_descriptor);
      purpose    : SET [1:?] OF SET [1:?] OF curve_element_purpose;
      assumption : plane_2d_element_purpose;
  END_ENTITY; -- plane_curve_2d_element_descriptor

  ENTITY plane_curve_2d_element_representation
    SUBTYPE OF (element_representation);
      model_ref          : fea_model_2d;
      element_descriptor : plane_curve_2d_element_descriptor;
      property           : curve_2d_element_property;
      depth_property     : plane_2d_element_property;
      material           : element_material;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: (model_ref.type_of_2d_analysis = planar);
      wr2: (SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'CURVE_2D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(item)) )) = 
               1);
      wr3: (SIZEOF(QUERY ( item1 <* material.properties | (SIZEOF(
               QUERY ( item2 <* item1\property_definition_representation.
               used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AREA_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION'] *
                TYPEOF(item2)) = 1) )) = 1) )) >= 1);
      wr4: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
      fu1: required_0d_nodes(SELF\element_representation.node_list);
  END_ENTITY; -- plane_curve_2d_element_representation

  ENTITY plane_surface_2d_element_descriptor
    SUBTYPE OF (element_descriptor);
      purpose    : SET [1:?] OF SET [1:?] OF surface_element_purpose;
      assumption : plane_2d_element_purpose;
  END_ENTITY; -- plane_surface_2d_element_descriptor

  ENTITY plane_surface_2d_element_representation
    SUBTYPE OF (element_representation);
      model_ref          : fea_model_2d;
      element_descriptor : plane_surface_2d_element_descriptor;
      property           : surface_element_property;
      depth_property     : plane_2d_element_property;
      material           : element_material;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: (model_ref.type_of_2d_analysis = planar);
      wr2: ((SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM') IN 
               TYPEOF(item)) )) + SIZEOF(QUERY ( item <* SELF\
               representation.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) ))) = 1);
      wr3: (SIZEOF(QUERY ( item1 <* material.properties | (SIZEOF(
               QUERY ( item2 <* item1\property_definition_representation.
               used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AREA_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SHELL_MEMBRANE_STIFFNESS','STRUCTURAL_ANALYSIS_DESIGN.' 
               + 'FEA_SHELL_BENDING_STIFFNESS',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_SHELL_SHEAR_STIFFNESS'] 
               * TYPEOF(item2)) = 1) )) = 1) )) >= 1);
      wr4: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
      fu1: required_1d_nodes(SELF\element_representation.node_list,
               element_descriptor\element_descriptor.topology_order);
  END_ENTITY; -- plane_surface_2d_element_representation

  ENTITY plane_volume_2d_element_descriptor
    SUBTYPE OF (element_descriptor);
      purpose    : SET [1:?] OF SET [1:?] OF volume_element_purpose;
      shape      : element_2d_shape;
      assumption : plane_2d_element_purpose;
  END_ENTITY; -- plane_volume_2d_element_descriptor

  ENTITY plane_volume_2d_element_representation
    SUBTYPE OF (element_representation);
      model_ref          : fea_model_2d;
      element_descriptor : plane_volume_2d_element_descriptor;
      depth_property     : plane_2d_element_property;
      material           : element_material;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: (model_ref.type_of_2d_analysis = planar);
      wr2: ((SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) )) + SIZEOF(QUERY ( item <* SELF\representation.items
                | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) ))) = 1);
      wr3: (SIZEOF(QUERY ( item1 <* material.properties | (SIZEOF(
               QUERY ( item2 <* item1\property_definition_representation.
               used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AREA_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION'] *
                TYPEOF(item2)) = 1) )) = 1) )) >= 1);
      wr4: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
      fu1: required_2d_nodes(SELF\element_representation.node_list,
               element_descriptor.shape,element_descriptor\
               element_descriptor.topology_order);
  END_ENTITY; -- plane_volume_2d_element_representation

  ENTITY plus_expression
    SUBTYPE OF (multiple_arity_numeric_expression);
  END_ENTITY; -- plus_expression

  ENTITY ply_laminate_definition
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATING_PRODUCT_DEFINITION') | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'NEXT_ASSEMBLY_USAGE_OCCURRENCE') IN TYPEOF(pdr)) )) = 1);
  END_ENTITY; -- ply_laminate_definition

  ENTITY ply_laminate_sequence_definition
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATING_PRODUCT_DEFINITION') | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'NEXT_ASSEMBLY_USAGE_OCCURRENCE') IN TYPEOF(pdr)) )) > 0);
  END_ENTITY; -- ply_laminate_sequence_definition

  ENTITY point
    SUPERTYPE OF (ONEOF (cartesian_point,point_on_curve,point_on_surface,
        point_replica,degenerate_pcurve))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- point

  ENTITY point_and_vector
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(SELF\representation.items) = 3);
      wr2: (('STRUCTURAL_ANALYSIS_DESIGN.POINT' IN TYPEOF(SELF\
               representation.items[1])) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.DIRECTION' IN TYPEOF(SELF\
               representation.items[2])) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.DIRECTION' IN TYPEOF(SELF\
               representation.items[3])));
  END_ENTITY; -- point_and_vector

  ENTITY point_constraint
    SUBTYPE OF (constraint_element);
      required_point            : analysis_item_within_representation;
      coordinate_system         : fea_axis2_placement_3d;
      freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
      description               : text;
    WHERE
      wr1: (('STRUCTURAL_ANALYSIS_DESIGN.POINT' IN TYPEOF(required_point.
               item)) OR ('STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN 
               TYPEOF(required_point.item)));
  END_ENTITY; -- point_constraint

  ENTITY point_element_matrix
    SUPERTYPE OF (ONEOF (stationary_mass,grounded_spring,grounded_damper));
  END_ENTITY; -- point_element_matrix

  ENTITY point_element_representation
    SUBTYPE OF (element_representation);
      model_ref   : fea_model;
      description : text;
      matrix_set  : SET [1:?] OF point_element_matrix;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: (SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AXIS2_PLACEMENT_3D') IN
                TYPEOF(item)) )) = 1);
      fu1: required_0d_nodes(SELF\element_representation.node_list);
  END_ENTITY; -- point_element_representation

  ENTITY point_freedom_action_definition
    SUBTYPE OF (point_freedom_and_value_definition);
      action : action_type;
  END_ENTITY; -- point_freedom_action_definition

  ENTITY point_freedom_and_value_definition
    SUPERTYPE OF (ONEOF (point_freedom_values,
        point_freedom_action_definition))
    SUBTYPE OF (state_definition);
      required_point     : analysis_item_within_representation;
      coordinate_system  : fea_axis2_placement_3d;
      degrees_of_freedom : freedoms_list;
      values             : LIST [1:?] OF measure_or_unspecified_value;
    WHERE
      wr1: (SIZEOF(degrees_of_freedom.freedoms) = SIZEOF(values));
      wr2: (('STRUCTURAL_ANALYSIS_DESIGN.POINT' IN TYPEOF(required_point.
               item)) OR ('STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN 
               TYPEOF(required_point.item)));
  END_ENTITY; -- point_freedom_and_value_definition

  ENTITY point_freedom_values
    SUBTYPE OF (point_freedom_and_value_definition);
  END_ENTITY; -- point_freedom_values

  ENTITY point_on_curve
    SUBTYPE OF (point);
      basis_curve     : curve;
      point_parameter : parameter_value;
  END_ENTITY; -- point_on_curve

  ENTITY point_on_surface
    SUBTYPE OF (point);
      basis_surface     : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
  END_ENTITY; -- point_on_surface

  ENTITY point_path
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'REPRESENTATION_RELATIONSHIP.REP_1')) = 1);
  END_ENTITY; -- point_path

  ENTITY point_replica
    SUBTYPE OF (point);
      parent_pt      : point;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_pt.dim);
      wr2: acyclic_point_replica(SELF,parent_pt);
  END_ENTITY; -- point_replica

  ENTITY point_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF\representation.items | (NOT (SIZEOF(
               ['STRUCTURAL_ANALYSIS_DESIGN.NODE_SET',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AXIS2_PLACEMENT_3D'] * 
               TYPEOF(it)) = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF\representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.NODE_SET',
               'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               >= 1);
  END_ENTITY; -- point_representation

  ENTITY poly_loop
    SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY; -- poly_loop

  ENTITY polyline
    SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY; -- polyline

  ENTITY precision_qualifier;
      precision_value : INTEGER;
  END_ENTITY; -- precision_qualifier

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : text;
      frame_of_reference : SET [1:?] OF product_context;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- product

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- product_category

  ENTITY product_category_relationship;
      name         : label;
      description  : text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY; -- product_category_relationship

  ENTITY product_concept;
      id             : identifier;
      name           : label;
      description    : text;
      market_context : product_concept_context;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- product_concept

  ENTITY product_concept_context
    SUBTYPE OF (application_context_element);
      market_segment_type : label;
  END_ENTITY; -- product_concept_context

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition;
      id                 : identifier;
      description        : text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
  END_ENTITY; -- product_definition

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY; -- product_definition_context

  ENTITY product_definition_effectivity
    SUBTYPE OF (effectivity);
      usage : product_definition_relationship;
    UNIQUE
      ur1 : usage, id;
  END_ENTITY; -- product_definition_effectivity

  ENTITY product_definition_formation;
      id          : identifier;
      description : text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_formation_relationship;
      id                                    : identifier;
      name                                  : label;
      description                           : text;
      relating_product_definition_formation : product_definition_formation;
      related_product_definition_formation  : product_definition_formation;
  END_ENTITY; -- product_definition_formation_relationship

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
      make_or_buy : source;
  END_ENTITY; -- product_definition_formation_with_specified_source

  ENTITY product_definition_relationship;
      id                          : identifier;
      name                        : label;
      description                 : text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY; -- product_definition_relationship

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : definition;
    WHERE
      wr1: (NOT ('STRUCTURAL_ANALYSIS_DESIGN.SHAPE_DEFINITION' IN TYPEOF(
               SELF\property_definition.definition)));
  END_ENTITY; -- product_definition_shape

  ENTITY product_definition_usage
    SUPERTYPE OF (ONEOF (make_from_usage_option,assembly_component_usage))
    SUBTYPE OF (product_definition_relationship);
    UNIQUE
      ur1 : id, relating_product_definition, related_product_definition;
    WHERE
      wr1: acyclic_product_definition_relationship(SELF,[SELF\
               product_definition_relationship.related_product_definition],
               'STRUCTURAL_ANALYSIS_DESIGN.PRODUCT_DEFINITION_USAGE');
  END_ENTITY; -- product_definition_usage

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
  END_ENTITY; -- product_definition_with_associated_documents

  ENTITY product_material_composition_relationship
    SUBTYPE OF (product_definition_relationship);
      class                : label;
      constituent_amount   : SET [1:?] OF measure_with_unit;
      composition_basis    : label;
      determination_method : text;
  END_ENTITY; -- product_material_composition_relationship

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY; -- product_related_product_category

  ENTITY promissory_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- promissory_usage_occurrence

  ENTITY property_definition;
      name        : label;
      description : text;
      definition  : characterized_definition;
  END_ENTITY; -- property_definition

  ENTITY property_definition_representation;
      definition          : property_definition;
      used_representation : representation;
  END_ENTITY; -- property_definition_representation

  ENTITY qualified_representation_item
    SUBTYPE OF (representation_item);
      qualifiers : SET [1:?] OF value_qualifier;
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* qualifiers | (
               'STRUCTURAL_ANALYSIS_DESIGN.PRECISION_QUALIFIER' IN TYPEOF(
               temp)) )) < 2);
  END_ENTITY; -- qualified_representation_item

  ENTITY qualitative_uncertainty
    SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : text;
  END_ENTITY; -- qualitative_uncertainty

  ENTITY quantified_assembly_component_usage
    SUBTYPE OF (assembly_component_usage);
      quantity : measure_with_unit;
  END_ENTITY; -- quantified_assembly_component_usage

  ENTITY quasi_uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- quasi_uniform_curve

  ENTITY quasi_uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- quasi_uniform_surface

  ENTITY ratio_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- ratio_unit

  ENTITY rational_b_spline_curve
    SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := 
                   list_to_array(weights_data,0,
                   upper_index_on_control_points);
    WHERE
      wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
               control_points_list));
      wr2: curve_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_curve

  ENTITY rational_b_spline_surface
    SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := 
                   make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      wr1: ((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_surface.control_points_list[1])));
      wr2: surface_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_surface

  ENTITY real_literal
    SUBTYPE OF (literal_number);
      SELF\literal_number.the_value : REAL;
  END_ENTITY; -- real_literal

  ENTITY real_numeric_variable
    SUBTYPE OF (numeric_variable);
  END_ENTITY; -- real_numeric_variable

  ENTITY rectangular_composite_surface
    SUBTYPE OF (bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
    DERIVE
      n_u : INTEGER := SIZEOF(segments);
      n_v : INTEGER := SIZEOF(segments[1]);
    WHERE
      wr1: ([] = QUERY ( s <* segments | (n_v <> SIZEOF(s)) ));
      wr2: constraints_rectangular_composite_surface(SELF);
  END_ENTITY; -- rectangular_composite_surface

  ENTITY rectangular_trimmed_surface
    SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      u1            : parameter_value;
      u2            : parameter_value;
      v1            : parameter_value;
      v2            : parameter_value;
      usense        : BOOLEAN;
      vsense        : BOOLEAN;
    WHERE
      wr1: (u1 <> u2);
      wr2: (v1 <> v2);
      wr3: ((('STRUCTURAL_ANALYSIS_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(
               basis_surface)) AND (NOT ('STRUCTURAL_ANALYSIS_DESIGN.PLANE' 
               IN TYPEOF(basis_surface)))) OR (
               'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_OF_REVOLUTION' IN 
               TYPEOF(basis_surface)) OR (usense = (u2 > u1)));
      wr4: (('STRUCTURAL_ANALYSIS_DESIGN.SPHERICAL_SURFACE' IN TYPEOF(
               basis_surface)) OR (
               'STRUCTURAL_ANALYSIS_DESIGN.TOROIDAL_SURFACE' IN TYPEOF(
               basis_surface)) OR (vsense = (v2 > v1)));
  END_ENTITY; -- rectangular_trimmed_surface

  ENTITY reparametrised_composite_curve_segment
    SUBTYPE OF (composite_curve_segment);
      param_length : parameter_value;
    WHERE
      wr1: (param_length > 0);
  END_ENTITY; -- reparametrised_composite_curve_segment

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
  END_ENTITY; -- representation

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR 
                                      context_of_items;
  END_ENTITY; -- representation_context

  ENTITY representation_item;
      name : label;
    WHERE
      wr1: (SIZEOF(using_representations(SELF)) > 0);
  END_ENTITY; -- representation_item

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY; -- representation_map

  ENTITY representation_relationship;
      name        : label;
      description : text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY; -- representation_relationship

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      wr1: (SELF\representation_relationship.rep_1.context_of_items :<>: 
               SELF\representation_relationship.rep_2.context_of_items);
  END_ENTITY; -- representation_relationship_with_transformation

  ENTITY result;
      result_id         : identifier;
      creating_software : text;
      description       : text;
  END_ENTITY; -- result

  ENTITY result_analysis_step
    SUPERTYPE OF (ONEOF (result_linear_static_analysis_sub_step,
        result_linear_modes_and_frequencies_analysis_sub_step))
    SUBTYPE OF (analysis_step);
      analysis_result : result;
    UNIQUE
      ur1 : analysis_control, analysis_result;
  END_ENTITY; -- result_analysis_step

  ENTITY result_linear_modes_and_frequencies_analysis_sub_step
    SUBTYPE OF (result_analysis_step);
      states : SET [1:?] OF calculated_state;
  END_ENTITY; -- result_linear_modes_and_frequencies_analysis_sub_step

  ENTITY result_linear_static_analysis_sub_step
    SUBTYPE OF (result_analysis_step);
      state : calculated_state;
  END_ENTITY; -- result_linear_static_analysis_sub_step

  ENTITY retention
    SUBTYPE OF (action);
    WHERE
      wr1: (SIZEOF(QUERY ( aa <* USEDIN(SELF,'STRUCTURAL_ANALYSIS_DESIGN.' 
               + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION') | (
               'STRUCTURAL_ANALYSIS_DESIGN.RETENTION_ASSIGNMENT' IN TYPEOF(
               aa)) )) > 0);
      wr2: ((SIZEOF(QUERY ( ada <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'APPLIED_DATE_ASSIGNMENT.ITEMS') | (ada.role.name = 
               'start date') )) + SIZEOF(QUERY ( adata <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') | (adata.role.name 
               = 'start date') ))) = 1);
      wr3: ((SIZEOF(QUERY ( ada <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'APPLIED_DATE_ASSIGNMENT.ITEMS') | (ada.role.name = 
               'earliest end date') )) + SIZEOF(QUERY ( adata <* USEDIN(
               SELF,'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') | (adata.role.name 
               = 'earliest end date') ))) = 1);
      wr4: ((SIZEOF(QUERY ( ada <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'APPLIED_DATE_ASSIGNMENT.ITEMS') | (ada.role.name = 
               'latest end date') )) + SIZEOF(QUERY ( adata <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') | (adata.role.name 
               = 'latest end date') ))) = 1);
  END_ENTITY; -- retention

  ENTITY retention_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF retention_item;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.RETENTION' IN TYPEOF(SELF.
               assigned_action));
  END_ENTITY; -- retention_assignment

  ENTITY seam_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               = associated_surface(SELF\surface_curve.associated_geometry[
               2]));
      wr3: ('STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(SELF\
               surface_curve.associated_geometry[1]));
      wr4: ('STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(SELF\
               surface_curve.associated_geometry[2]));
  END_ENTITY; -- seam_curve

  ENTITY security_classification;
      name           : label;
      purpose        : text;
      security_level : security_classification_level;
  END_ENTITY; -- security_classification

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
  END_ENTITY; -- security_classification_assignment

  ENTITY security_classification_level;
      name : label;
  END_ENTITY; -- security_classification_level

  ENTITY serial_numbered_effectivity
    SUBTYPE OF (effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id   : OPTIONAL identifier;
  END_ENTITY; -- serial_numbered_effectivity

  ENTITY shape_aspect;
      name                 : label;
      description          : text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
  END_ENTITY; -- shape_aspect

  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
  END_ENTITY; -- shape_aspect_relationship

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: (('STRUCTURAL_ANALYSIS_DESIGN.SHAPE_DEFINITION' IN TYPEOF(SELF.
               definition.definition)) OR (
               'STRUCTURAL_ANALYSIS_DESIGN.PRODUCT_DEFINITION_SHAPE' IN 
               TYPEOF(SELF.definition)));
      wr2: ('STRUCTURAL_ANALYSIS_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(
               SELF.used_representation));
  END_ENTITY; -- shape_definition_representation

  ENTITY shape_dimension_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF.items | (NOT (
               'STRUCTURAL_ANALYSIS_DESIGN.MEASURE_REPRESENTATION_ITEM' IN 
               TYPEOF(temp))) )) = 0);
      wr2: (SIZEOF(SELF.items) <= 2);
      wr3: (SIZEOF(QUERY ( pos_mri <* QUERY ( real_mri <* SELF.items | (
               'REAL' IN TYPEOF(real_mri\measure_with_unit.value_component)) )
                | (NOT (pos_mri\measure_with_unit.value_component > 0)) )) 
               = 0);
  END_ENTITY; -- shape_dimension_representation

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- shape_representation

  ENTITY shape_representation_relationship
    SUBTYPE OF (representation_relationship);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.SHAPE_REPRESENTATION' IN (TYPEOF(
               SELF\representation_relationship.rep_1) + TYPEOF(SELF\
               representation_relationship.rep_2)));
  END_ENTITY; -- shape_representation_relationship

  ENTITY shell_based_surface_model
    SUBTYPE OF (geometric_representation_item);
      sbsm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_surface_model(SELF);
  END_ENTITY; -- shell_based_surface_model

  ENTITY shell_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      sbwm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_wireframe_model(SELF);
  END_ENTITY; -- shell_based_wireframe_model

  ENTITY shell_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL',
                'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM',
                'STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(
                it)) = 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL',
                'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                >= 1);
      wr3 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'STRUCTURAL_ANALYSIS_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | 
                (NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_CURVE' 
                IN TYPEOF(el.edge_element))) )) = 0)) )) = 0)) )) = 0)) )) 
                = 0);
      wr4 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'STRUCTURAL_ANALYSIS_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | 
                (NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( pline_el <* 
                QUERY ( el <* eloop\path.edge_list | (
                'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE' IN TYPEOF(el.
                edge_element\edge_curve.edge_geometry)) ) | (NOT (SIZEOF(
                pline_el.edge_element\edge_curve.edge_geometry\polyline.
                points) > 2)) )) = 0)) )) = 0)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'STRUCTURAL_ANALYSIS_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | 
                (NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT valid_wireframe_edge_curve(el.edge_element
                \edge_curve.edge_geometry)) )) = 0)) )) = 0)) )) = 0)) )) =
                 0);
      wr6 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'STRUCTURAL_ANALYSIS_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | 
                (NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT ((
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN TYPEOF(el.
                edge_element.edge_start)) AND (
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN TYPEOF(el.
                edge_element.edge_end)))) )) = 0)) )) = 0)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'STRUCTURAL_ANALYSIS_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | 
                (NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('STRUCTURAL_ANALYSIS_DESIGN.EDGE_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT (valid_wireframe_vertex_point(el.
                edge_element.edge_start\vertex_point.vertex_geometry) AND 
                valid_wireframe_vertex_point(el.edge_element.edge_end\
                vertex_point.vertex_geometry))) )) = 0)) )) = 0)) )) = 0)) )) 
                = 0);
      wr8 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'STRUCTURAL_ANALYSIS_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | 
                (NOT (SIZEOF(QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | (
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_LOOP' IN TYPEOF(wsb)) )
                 | (NOT ('STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN 
                TYPEOF(vloop\vertex_loop.loop_vertex))) )) = 0)) )) = 0)) )) 
                = 0);
      wr9 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'STRUCTURAL_ANALYSIS_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | 
                (NOT (SIZEOF(QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | (
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_LOOP' IN TYPEOF(wsb)) )
                 | (NOT valid_wireframe_vertex_point(vloop\vertex_loop.
                loop_vertex\vertex_point.vertex_geometry)) )) = 0)) )) = 0)) )) 
                = 0);
      wr10: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)) )
                 | (NOT ('STRUCTURAL_ANALYSIS_DESIGN.VERTEX_POINT' IN 
                TYPEOF(vs\vertex_shell.vertex_shell_extent.loop_vertex))) )) 
                = 0)) )) = 0);
      wr11: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)) )
                 | (NOT valid_wireframe_vertex_point(vs\vertex_shell.
                vertex_shell_extent.loop_vertex\vertex_point.
                vertex_geometry)) )) = 0)) )) = 0);
      wr12: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) )
                 | (NOT (('STRUCTURAL_ANALYSIS_DESIGN.' + 
                'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
                mapped_item.mapping_source.mapped_representation))) )) = 0);
      wr13: (SELF.context_of_items\geometric_representation_context.
                coordinate_space_dimension = 3);
  END_ENTITY; -- shell_based_wireframe_shape_representation

  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := 
                                      dimensions_for_si_unit(SELF.name);
  END_ENTITY; -- si_unit

  ENTITY simple_generic_expression
    ABSTRACT SUPERTYPE OF (ONEOF (generic_literal,generic_variable))
    SUBTYPE OF (generic_expression);
  END_ENTITY; -- simple_generic_expression

  ENTITY simple_numeric_expression
    ABSTRACT SUPERTYPE OF (ONEOF (literal_number,numeric_variable))
    SUBTYPE OF (numeric_expression, simple_generic_expression);
  END_ENTITY; -- simple_numeric_expression

  ENTITY simple_plane_2d_element_property
    SUBTYPE OF (plane_2d_element_property);
  END_ENTITY; -- simple_plane_2d_element_property

  ENTITY single_point_constraint_element
    SUBTYPE OF (constraint_element);
      required_node       : node_output_reference;
      coordinate_system   : fea_axis2_placement_3d;
      freedoms_and_values : SET [1:?] OF freedom_and_coefficient;
      description         : text;
  END_ENTITY; -- single_point_constraint_element

  ENTITY single_point_constraint_element_values
    SUBTYPE OF (state_definition);
      element            : single_point_constraint_element;
      degrees_of_freedom : freedoms_list;
      b                  : LIST [1:?] OF measure_or_unspecified_value;
    WHERE
      wr1: (SIZEOF(degrees_of_freedom.freedoms) = SIZEOF(b));
  END_ENTITY; -- single_point_constraint_element_values

  ENTITY smeared_material_definition
    SUBTYPE OF (product_definition);
  END_ENTITY; -- smeared_material_definition

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- solid_angle_measure_with_unit

  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- solid_angle_unit

  ENTITY solid_constraint
    SUBTYPE OF (constraint_element);
      required_solid            : analysis_item_within_representation;
      coordinate_system         : fea_axis2_placement_3d;
      freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
      description               : text;
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.SOLID_MODEL' IN TYPEOF(
               required_solid.item));
  END_ENTITY; -- solid_constraint

  ENTITY solid_freedom_action_definition
    SUBTYPE OF (solid_freedom_and_value_definition);
      action : action_type;
  END_ENTITY; -- solid_freedom_action_definition

  ENTITY solid_freedom_and_value_definition
    SUPERTYPE OF (ONEOF (solid_freedom_values,
        solid_freedom_action_definition))
    SUBTYPE OF (state_definition);
      required_solid     : analysis_item_within_representation;
      coordinate_system  : fea_axis2_placement_3d;
      degrees_of_freedom : freedoms_list;
      values             : LIST [1:?] OF measure_or_unspecified_value;
    WHERE
      wr1: (SIZEOF(degrees_of_freedom.freedoms) = SIZEOF(values));
      wr2: ('STRUCTURAL_ANALYSIS_DESIGN.SOLID_MODEL' IN TYPEOF(
               required_solid.item));
  END_ENTITY; -- solid_freedom_and_value_definition

  ENTITY solid_freedom_values
    SUBTYPE OF (solid_freedom_and_value_definition);
  END_ENTITY; -- solid_freedom_values

  ENTITY solid_model
    SUPERTYPE OF (manifold_solid_brep)
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- solid_model

  ENTITY specified_higher_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
      upper_usage : assembly_component_usage;
      next_usage  : next_assembly_usage_occurrence;
    UNIQUE
      ur1 : upper_usage, next_usage;
    WHERE
      wr1: (SELF :<>: upper_usage);
      wr2: (SELF\product_definition_relationship.
               relating_product_definition :=: upper_usage.
               relating_product_definition);
      wr3: (SELF\product_definition_relationship.
               related_product_definition :=: next_usage.
               related_product_definition);
      wr4: (upper_usage.related_product_definition :=: next_usage.
               relating_product_definition);
      wr5: (NOT ('STRUCTURAL_ANALYSIS_DESIGN.PROMISSORY_USAGE_OCCURRENCE' 
               IN TYPEOF(upper_usage)));
  END_ENTITY; -- specified_higher_usage_occurrence

  ENTITY specified_state
    SUBTYPE OF (state);
  END_ENTITY; -- specified_state

  ENTITY spherical_point
    SUBTYPE OF (cartesian_point);
      r     : length_measure;
      theta : plane_angle_measure;
      phi   : plane_angle_measure;
    DERIVE
      SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [
                                            r * SIN(theta) * COS(phi),r * 
                                            SIN(theta) * SIN(phi),r * COS(
                                            theta)];
    WHERE
      wr1: (r >= 0);
  END_ENTITY; -- spherical_point

  ENTITY spherical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- spherical_surface

  ENTITY standard_uncertainty
    SUPERTYPE OF (expanded_uncertainty)
    SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : REAL;
  END_ENTITY; -- standard_uncertainty

  ENTITY state
    SUPERTYPE OF (ONEOF (specified_state,calculated_state,
        linearly_superimposed_state,output_request_state));
      state_id    : identifier;
      description : text;
  END_ENTITY; -- state

  ENTITY state_component
    SUBTYPE OF (state);
      state  : linearly_superimposed_state;
      factor : context_dependent_measure;
  END_ENTITY; -- state_component

  ENTITY state_definition
    SUPERTYPE OF (ONEOF (field_variable_definition,
        nodal_freedom_and_value_definition,element_nodal_freedom_actions,
        point_freedom_and_value_definition,
        curve_freedom_and_value_definition,
        surface_freedom_and_value_definition,
        solid_freedom_and_value_definition,
        linear_constraint_equation_element_value,
        single_point_constraint_element_values,analysis_message));
      defined_state : state;
  END_ENTITY; -- state_definition

  ENTITY state_relationship;
      name           : label;
      description    : text;
      relating_state : state;
      related_state  : state;
  END_ENTITY; -- state_relationship

  ENTITY state_with_harmonic
    SUBTYPE OF (state);
      symmetry : cylindrical_symmetry_control;
  END_ENTITY; -- state_with_harmonic

  ENTITY stationary_mass
    SUBTYPE OF (point_element_matrix);
      mass               : ARRAY [1:3] OF context_dependent_measure;
      moments_of_inertia : symmetric_tensor2_3d;
      coordinate_system  : fea_axis2_placement_3d;
      offset_vector      : ARRAY [1:3] OF context_dependent_measure;
  END_ENTITY; -- stationary_mass

  ENTITY structural_response_property
    SUBTYPE OF (property_definition);
  END_ENTITY; -- structural_response_property

  ENTITY structural_response_property_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.STRUCTURAL_RESPONSE_PROPERTY' IN 
               TYPEOF(SELF\property_definition_representation.definition));
      wr2: ((('STRUCTURAL_ANALYSIS_DESIGN.FEA_MODEL' IN TYPEOF(SELF\
               property_definition_representation.used_representation)) AND
                ('STRUCTURAL_ANALYSIS_DESIGN.FEA_MODEL_DEFINITION' IN 
               TYPEOF(SELF\property_definition_representation.definition.
               definition))) OR ((
               'STRUCTURAL_ANALYSIS_DESIGN.ELEMENT_REPRESENTATION' IN 
               TYPEOF(SELF\property_definition_representation.
               used_representation)) AND (
               'STRUCTURAL_ANALYSIS_DESIGN.ELEMENT_DEFINITION' IN TYPEOF(
               SELF\property_definition_representation.definition.
               definition))) OR ((
               'STRUCTURAL_ANALYSIS_DESIGN.NODE_REPRESENTATION' IN TYPEOF(
               SELF\property_definition_representation.used_representation)) 
               AND ('STRUCTURAL_ANALYSIS_DESIGN.NODE_DEFINITION' IN TYPEOF(
               SELF\property_definition_representation.definition.
               definition))));
  END_ENTITY; -- structural_response_property_definition_representation

  ENTITY substructure_element_representation
    SUBTYPE OF (element_representation);
      model_ref              : fea_model;
      substructure_model_ref : fea_model;
    UNIQUE
      ur1 : model_ref, name;
  END_ENTITY; -- substructure_element_representation

  ENTITY substructure_node_reference;
      substructure_element_ref : substructure_element_representation;
      node_ref                 : node_representation;
  END_ENTITY; -- substructure_node_reference

  ENTITY substructure_node_relationship
    SUBTYPE OF (representation_relationship);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.NODE_REPRESENTATION' IN TYPEOF(
               SELF\representation_relationship.rep_1));
      wr2: ('STRUCTURAL_ANALYSIS_DESIGN.NODE_REPRESENTATION' IN TYPEOF(
               SELF\representation_relationship.rep_2));
  END_ENTITY; -- substructure_node_relationship

  ENTITY supplied_part_relationship
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- supplied_part_relationship

  ENTITY surface
    SUPERTYPE OF (ONEOF (elementary_surface,swept_surface,bounded_surface,
        offset_surface,surface_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- surface

  ENTITY surface_2d_element_basis;
      descriptor              : surface_2d_element_descriptor;
      variable                : surface_element_variable;
      variable_order          : element_order;
      variable_shape_function : shape_function;
      evaluation_points       : LIST [1:?] OF surface_element_location;
  END_ENTITY; -- surface_2d_element_basis

  ENTITY surface_2d_element_boundary_constant_specified_surface_variable_value
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_variable;
      element_face      : surface_2d_face;
      coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_constant_specified_surface_variable_value

  ENTITY surface_2d_element_boundary_constant_specified_variable_value
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_face      : surface_2d_face;
      coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_constant_specified_variable_value

  ENTITY surface_2d_element_boundary_edge_constant_specified_surface_variable_value
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_edge_variable;
      element_edge      : surface_2d_edge;
      coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_edge_constant_specified_surface_variable_value

  ENTITY surface_2d_element_boundary_edge_constant_specified_variable_value
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_edge_variable;
      element_edge      : surface_2d_edge;
      coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_edge_constant_specified_variable_value

  ENTITY surface_2d_element_boundary_edge_location_point_surface_variable_values
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF surface_2d_element_value_and_volume_location;
      variable             : boundary_edge_variable;
      element_edge         : surface_2d_edge;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_edge_location_point_surface_variable_values

  ENTITY surface_2d_element_boundary_edge_location_point_variable_values
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 surface_2d_element_value_and_location;
      variable             : boundary_edge_variable;
      element_edge         : surface_2d_edge;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_edge_location_point_variable_values

  ENTITY surface_2d_element_boundary_edge_nodal_specified_variable_values
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : boundary_edge_variable;
      element_edge           : surface_2d_edge;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_edge_nodal_specified_variable_values

  ENTITY surface_2d_element_boundary_edge_whole_edge_variable_value
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_edge      : surface_2d_edge;
      coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_edge_whole_edge_variable_value

  ENTITY surface_2d_element_boundary_location_point_surface_variable_values
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 surface_2d_element_value_and_location;
      variable             : boundary_variable;
      element_face         : surface_2d_face;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_location_point_surface_variable_values

  ENTITY surface_2d_element_boundary_nodal_specified_variable_values
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : boundary_variable;
      element_face           : surface_2d_face;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_nodal_specified_variable_values

  ENTITY surface_2d_element_boundary_whole_face_variable_value
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_face      : surface_2d_face;
      coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_boundary_whole_face_variable_value

  ENTITY surface_2d_element_constant_specified_variable_value
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : surface_element_variable;
      coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_constant_specified_variable_value

  ENTITY surface_2d_element_constant_specified_volume_variable_value
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_variable;
      coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_constant_specified_volume_variable_value

  ENTITY surface_2d_element_field_variable_definition
    SUPERTYPE OF (ONEOF (
        surface_2d_element_location_point_volume_variable_values,
        surface_2d_element_location_point_variable_values,
        surface_2d_whole_element_variable_value,
        surface_2d_element_constant_specified_variable_value,
        surface_2d_element_constant_specified_volume_variable_value,
        surface_2d_element_nodal_specified_variable_values,
        surface_2d_element_boundary_location_point_surface_variable_values,
        surface_2d_element_boundary_whole_face_variable_value,
        surface_2d_element_boundary_constant_specified_variable_value,surface_2d_element_boundary_constant_specified_surface_variable_value,
        surface_2d_element_boundary_nodal_specified_variable_values,surface_2d_element_boundary_edge_location_point_surface_variable_values,
        surface_2d_element_boundary_edge_location_point_variable_values,
        surface_2d_element_boundary_edge_whole_edge_variable_value,
        surface_2d_element_boundary_edge_constant_specified_variable_value,surface_2d_element_boundary_edge_constant_specified_surface_variable_value,
        surface_2d_element_boundary_edge_nodal_specified_variable_values))
    SUBTYPE OF (field_variable_element_definition);
      element : surface_2d_element_output_reference;
  END_ENTITY; -- surface_2d_element_field_variable_definition

  ENTITY surface_2d_element_group
    SUBTYPE OF (element_group);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* elements | ((NOT ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION') IN TYPEOF(
               item))) AND (NOT (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION') IN TYPEOF(item)))) )) 
               = 0);
  END_ENTITY; -- surface_2d_element_group

  ENTITY surface_2d_element_integrated_matrix;
      descriptor              : surface_2d_element_descriptor;
      property_type           : surface_matrix_property_type;
      integration_description : text;
  END_ENTITY; -- surface_2d_element_integrated_matrix

  ENTITY surface_2d_element_integrated_matrix_with_definition
    SUBTYPE OF (surface_2d_element_integrated_matrix);
      integration_definition : surface_2d_element_integration;
  END_ENTITY; -- surface_2d_element_integrated_matrix_with_definition

  ENTITY surface_2d_element_integration;
      element_length : surface_2d_element_length_integration;
      section        : surface_section_integration;
  END_ENTITY; -- surface_2d_element_integration

  ENTITY surface_2d_element_length_integration_explicit;
      integration_positions_and_weights : SET [1:?] OF
                                              surface_position_weight;
  END_ENTITY; -- surface_2d_element_length_integration_explicit

  ENTITY surface_2d_element_length_integration_rule;
      integration_method : integration_rule;
      integration_order  : INTEGER;
  END_ENTITY; -- surface_2d_element_length_integration_rule

  ENTITY surface_2d_element_location_point_variable_values
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 surface_2d_element_value_and_location;
      variable             : surface_element_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_location_point_variable_values

  ENTITY surface_2d_element_location_point_volume_variable_values
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF surface_2d_element_value_and_volume_location;
      variable             : volume_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_location_point_volume_variable_values

  ENTITY surface_2d_element_nodal_specified_variable_values
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : surface_element_variable;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_element_nodal_specified_variable_values

  ENTITY surface_2d_element_value_and_location;
      simple_value      : field_value;
      location          : surface_element_location;
      coordinate_system : OPTIONAL surface_2d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- surface_2d_element_value_and_location

  ENTITY surface_2d_element_value_and_volume_location;
      simple_value      : field_value;
      location          : surface_volume_element_location;
      coordinate_system : OPTIONAL surface_2d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- surface_2d_element_value_and_volume_location

  ENTITY surface_2d_node_field_aggregated_variable_values
    SUBTYPE OF (surface_2d_node_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL surface_2d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_node_field_aggregated_variable_values

  ENTITY surface_2d_node_field_section_variable_values
    SUBTYPE OF (surface_2d_node_field_variable_definition);
      simple_value      : field_value;
      variable          : surface_element_variable;
      location          : surface_section_element_location;
      coordinate_system : OPTIONAL surface_2d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_node_field_section_variable_values

  ENTITY surface_2d_node_field_variable_definition
    SUPERTYPE OF (ONEOF (surface_2d_node_field_section_variable_values,
        surface_2d_node_field_aggregated_variable_values))
    SUBTYPE OF (field_variable_node_definition);
  END_ENTITY; -- surface_2d_node_field_variable_definition

  ENTITY surface_2d_substructure_element_reference;
      substructure_element_ref : substructure_element_representation;
      element_ref              : surface_2d_element_representation;
  END_ENTITY; -- surface_2d_substructure_element_reference

  ENTITY surface_2d_whole_element_variable_value
    SUBTYPE OF (surface_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL surface_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_2d_whole_element_variable_value

  ENTITY surface_3d_element_basis;
      descriptor              : surface_3d_element_descriptor;
      variable                : surface_element_variable;
      variable_order          : element_order;
      variable_shape_function : shape_function;
      evaluation_points       : LIST [1:?] OF surface_element_location;
  END_ENTITY; -- surface_3d_element_basis

  ENTITY surface_3d_element_boundary_constant_specified_surface_variable_value
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_variable;
      element_face      : surface_3d_face;
      coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_constant_specified_surface_variable_value

  ENTITY surface_3d_element_boundary_constant_specified_variable_value
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_face      : surface_3d_face;
      coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_constant_specified_variable_value

  ENTITY surface_3d_element_boundary_edge_constant_specified_surface_variable_value
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_edge_variable;
      element_edge      : surface_3d_edge;
      coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_edge_constant_specified_surface_variable_value

  ENTITY surface_3d_element_boundary_edge_constant_specified_variable_value
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_edge_variable;
      element_edge      : surface_3d_edge;
      coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_edge_constant_specified_variable_value

  ENTITY surface_3d_element_boundary_edge_location_point_surface_variable_values
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF surface_3d_element_value_and_volume_location;
      variable             : boundary_edge_variable;
      element_edge         : surface_3d_edge;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_edge_location_point_surface_variable_values

  ENTITY surface_3d_element_boundary_edge_location_point_variable_values
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 surface_3d_element_value_and_location;
      variable             : boundary_edge_variable;
      element_edge         : surface_3d_edge;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_edge_location_point_variable_values

  ENTITY surface_3d_element_boundary_edge_nodal_specified_variable_values
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : boundary_edge_variable;
      element_edge           : surface_3d_edge;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_edge_nodal_specified_variable_values

  ENTITY surface_3d_element_boundary_edge_whole_edge_variable_value
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_edge      : surface_3d_edge;
      coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_edge_whole_edge_variable_value

  ENTITY surface_3d_element_boundary_location_point_surface_variable_values
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 surface_3d_element_value_and_location;
      variable             : boundary_variable;
      element_face         : surface_3d_face;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_location_point_surface_variable_values

  ENTITY surface_3d_element_boundary_nodal_specified_variable_values
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : boundary_variable;
      element_face           : surface_3d_face;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_nodal_specified_variable_values

  ENTITY surface_3d_element_boundary_whole_face_variable_value
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_face      : surface_3d_face;
      coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_boundary_whole_face_variable_value

  ENTITY surface_3d_element_constant_specified_variable_value
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : surface_element_variable;
      coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_constant_specified_variable_value

  ENTITY surface_3d_element_constant_specified_volume_variable_value
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_variable;
      coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_constant_specified_volume_variable_value

  ENTITY surface_3d_element_descriptor
    SUBTYPE OF (element_descriptor);
      purpose : SET [1:?] OF SET [1:?] OF surface_element_purpose;
      shape   : element_2d_shape;
  END_ENTITY; -- surface_3d_element_descriptor

  ENTITY surface_3d_element_field_integration_explicit;
      integration_positions_and_weights : SET [1:?] OF
                                              surface_position_weight;
  END_ENTITY; -- surface_3d_element_field_integration_explicit

  ENTITY surface_3d_element_field_integration_rule;
      integration_method : integration_rule;
      integration_order  : ARRAY [1:2] OF INTEGER;
  END_ENTITY; -- surface_3d_element_field_integration_rule

  ENTITY surface_3d_element_field_variable_definition
    SUPERTYPE OF (ONEOF (
        surface_3d_element_location_point_volume_variable_values,
        surface_3d_element_location_point_variable_values,
        surface_3d_whole_element_variable_value,
        surface_3d_element_constant_specified_variable_value,
        surface_3d_element_constant_specified_volume_variable_value,
        surface_3d_element_nodal_specified_variable_values,
        surface_3d_element_boundary_location_point_surface_variable_values,
        surface_3d_element_boundary_whole_face_variable_value,
        surface_3d_element_boundary_constant_specified_variable_value,surface_3d_element_boundary_constant_specified_surface_variable_value,
        surface_3d_element_boundary_nodal_specified_variable_values,surface_3d_element_boundary_edge_location_point_surface_variable_values,
        surface_3d_element_boundary_edge_location_point_variable_values,
        surface_3d_element_boundary_edge_whole_edge_variable_value,
        surface_3d_element_boundary_edge_constant_specified_variable_value,surface_3d_element_boundary_edge_constant_specified_surface_variable_value,
        surface_3d_element_boundary_edge_nodal_specified_variable_values))
    SUBTYPE OF (field_variable_element_definition);
      element : surface_3d_element_output_reference;
  END_ENTITY; -- surface_3d_element_field_variable_definition

  ENTITY surface_3d_element_group
    SUBTYPE OF (element_group);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* elements | (NOT ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'SURFACE_3D_ELEMENT_REPRESENTATION') IN TYPEOF(item))) )) = 
               0);
  END_ENTITY; -- surface_3d_element_group

  ENTITY surface_3d_element_integrated_matrix;
      descriptor              : surface_3d_element_descriptor;
      property_type           : surface_matrix_property_type;
      integration_description : text;
  END_ENTITY; -- surface_3d_element_integrated_matrix

  ENTITY surface_3d_element_integrated_matrix_with_definition
    SUBTYPE OF (surface_3d_element_integrated_matrix);
      integration_definition : surface_3d_element_integration;
  END_ENTITY; -- surface_3d_element_integrated_matrix_with_definition

  ENTITY surface_3d_element_integration;
      field   : surface_3d_element_field_integration;
      section : surface_section_integration;
  END_ENTITY; -- surface_3d_element_integration

  ENTITY surface_3d_element_location_point_variable_values
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 surface_3d_element_value_and_location;
      variable             : surface_element_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_location_point_variable_values

  ENTITY surface_3d_element_location_point_volume_variable_values
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF surface_3d_element_value_and_volume_location;
      variable             : volume_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_location_point_volume_variable_values

  ENTITY surface_3d_element_nodal_specified_variable_values
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : surface_element_variable;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_element_nodal_specified_variable_values

  ENTITY surface_3d_element_representation
    SUBTYPE OF (element_representation);
      model_ref          : fea_model_3d;
      element_descriptor : surface_3d_element_descriptor;
      property           : surface_element_property;
      material           : element_material;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: ((SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PARAMETRIC_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM') IN 
               TYPEOF(item)) )) + SIZEOF(QUERY ( item <* SELF\
               representation.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'CONSTANT_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) )) + SIZEOF(QUERY ( item <* SELF\representation.items
                | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'ALIGNED_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) ))) = 1);
      wr2: (SIZEOF(QUERY ( item1 <* material.properties | (SIZEOF(
               QUERY ( item2 <* item1\property_definition_representation.
               used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_AREA_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SHELL_MEMBRANE_STIFFNESS','STRUCTURAL_ANALYSIS_DESIGN.' 
               + 'FEA_SHELL_BENDING_STIFFNESS',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_SHELL_SHEAR_STIFFNESS'] 
               * TYPEOF(item2)) = 1) )) = 1) )) >= 1);
      wr3: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
      fu1: required_2d_nodes(SELF\element_representation.node_list,
               element_descriptor.shape,element_descriptor\
               element_descriptor.topology_order);
  END_ENTITY; -- surface_3d_element_representation

  ENTITY surface_3d_element_value_and_location;
      simple_value      : field_value;
      location          : surface_element_location;
      coordinate_system : OPTIONAL surface_3d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- surface_3d_element_value_and_location

  ENTITY surface_3d_element_value_and_volume_location;
      simple_value      : field_value;
      location          : surface_volume_element_location;
      coordinate_system : OPTIONAL surface_3d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- surface_3d_element_value_and_volume_location

  ENTITY surface_3d_node_field_aggregated_variable_values
    SUBTYPE OF (surface_3d_node_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL surface_3d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_node_field_aggregated_variable_values

  ENTITY surface_3d_node_field_section_variable_values
    SUBTYPE OF (surface_3d_node_field_variable_definition);
      simple_value      : field_value;
      variable          : surface_element_variable;
      location          : surface_section_element_location;
      coordinate_system : OPTIONAL surface_3d_state_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_node_field_section_variable_values

  ENTITY surface_3d_node_field_variable_definition
    SUPERTYPE OF (ONEOF (surface_3d_node_field_section_variable_values,
        surface_3d_node_field_aggregated_variable_values))
    SUBTYPE OF (field_variable_node_definition);
  END_ENTITY; -- surface_3d_node_field_variable_definition

  ENTITY surface_3d_substructure_element_reference;
      substructure_element_ref : substructure_element_representation;
      element_ref              : surface_3d_element_representation;
  END_ENTITY; -- surface_3d_substructure_element_reference

  ENTITY surface_3d_whole_element_variable_value
    SUBTYPE OF (surface_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL surface_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- surface_3d_whole_element_variable_value

  ENTITY surface_constraint
    SUBTYPE OF (constraint_element);
      required_surface          : analysis_item_within_representation;
      coordinate_system         : fea_axis2_placement_3d;
      freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
      description               : text;
    WHERE
      wr1: (('STRUCTURAL_ANALYSIS_DESIGN.SURFACE' IN TYPEOF(
               required_surface.item)) OR (
               'STRUCTURAL_ANALYSIS_DESIGN.FACE_SURFACE' IN TYPEOF(
               required_surface.item)));
  END_ENTITY; -- surface_constraint

  ENTITY surface_curve
    SUPERTYPE OF (ONEOF (intersection_curve,seam_curve) ANDOR 
        bounded_surface_curve)
    SUBTYPE OF (curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (curve_3d.dim = 3);
      wr2: (('STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(
               associated_geometry[1])) OR (master_representation <> 
               pcurve_s1));
      wr3: (('STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(
               associated_geometry[2])) OR (master_representation <> 
               pcurve_s2));
      wr4: (NOT ('STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(curve_3d)));
  END_ENTITY; -- surface_curve

  ENTITY surface_element_location;
      coordinates : fea_parametric_point;
  END_ENTITY; -- surface_element_location

  ENTITY surface_element_property;
      property_id : identifier;
      description : text;
      section     : surface_section_field;
  END_ENTITY; -- surface_element_property

  ENTITY surface_freedom_action_definition
    SUBTYPE OF (surface_freedom_and_value_definition);
      action : action_type;
  END_ENTITY; -- surface_freedom_action_definition

  ENTITY surface_freedom_and_value_definition
    SUPERTYPE OF (ONEOF (surface_freedom_values,
        surface_freedom_action_definition))
    SUBTYPE OF (state_definition);
      required_surface   : analysis_item_within_representation;
      coordinate_system  : fea_axis2_placement_3d;
      degrees_of_freedom : freedoms_list;
      values             : LIST [1:?] OF measure_or_unspecified_value;
    WHERE
      wr1: (SIZEOF(degrees_of_freedom.freedoms) = SIZEOF(values));
      wr2: (('STRUCTURAL_ANALYSIS_DESIGN.SURFACE' IN TYPEOF(
               required_surface.item)) OR (
               'STRUCTURAL_ANALYSIS_DESIGN.FACE_SURFACE' IN TYPEOF(
               required_surface.item)));
  END_ENTITY; -- surface_freedom_and_value_definition

  ENTITY surface_freedom_values
    SUBTYPE OF (surface_freedom_and_value_definition);
  END_ENTITY; -- surface_freedom_values

  ENTITY surface_of_linear_extrusion
    SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
  END_ENTITY; -- surface_of_linear_extrusion

  ENTITY surface_of_revolution
    SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
    DERIVE
      axis_line : line := representation_item('')||
                        geometric_representation_item()|| curve()||
                        line(axis_position.location, representation_item('')||
                        geometric_representation_item()||
                        vector(axis_position.z, 1.0));
  END_ENTITY; -- surface_of_revolution

  ENTITY surface_patch
    SUBTYPE OF (founded_item);
      parent_surface : bounded_surface;
      u_transition   : transition_code;
      v_transition   : transition_code;
      u_sense        : BOOLEAN;
      v_sense        : BOOLEAN;
    INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR 
                          segments;
    WHERE
      wr1: (NOT ('STRUCTURAL_ANALYSIS_DESIGN.CURVE_BOUNDED_SURFACE' IN 
               TYPEOF(parent_surface)));
  END_ENTITY; -- surface_patch

  ENTITY surface_position_weight;
      integration_position : surface_element_location;
      integration_weight   : context_dependent_measure;
  END_ENTITY; -- surface_position_weight

  ENTITY surface_replica
    SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_surface_replica(SELF,parent_surface);
  END_ENTITY; -- surface_replica

  ENTITY surface_section
    SUPERTYPE OF (ONEOF (uniform_surface_section,
        uniform_surface_section_layered));
      offset                     : measure_or_unspecified_value;
      non_structural_mass        : measure_or_unspecified_value;
      non_structural_mass_offset : measure_or_unspecified_value;
  END_ENTITY; -- surface_section

  ENTITY surface_section_element_location
    SUPERTYPE OF (ONEOF (surface_section_element_location_absolute,
        surface_section_element_location_dimensionless));
      above_material_discontinuity : LOGICAL;
  END_ENTITY; -- surface_section_element_location

  ENTITY surface_section_element_location_absolute
    SUBTYPE OF (surface_section_element_location);
      offset : context_dependent_measure;
  END_ENTITY; -- surface_section_element_location_absolute

  ENTITY surface_section_element_location_dimensionless
    SUBTYPE OF (surface_section_element_location);
      coordinate : LIST [1:1] OF parameter_value;
    WHERE
      wr1: valid_parametric_coordinate(coordinate);
  END_ENTITY; -- surface_section_element_location_dimensionless

  ENTITY surface_section_field
    SUPERTYPE OF (ONEOF (surface_section_field_constant,
        surface_section_field_varying));
  END_ENTITY; -- surface_section_field

  ENTITY surface_section_field_constant
    SUBTYPE OF (surface_section_field);
      definition : surface_section;
  END_ENTITY; -- surface_section_field_constant

  ENTITY surface_section_field_varying
    SUBTYPE OF (surface_section_field);
      definitions            : LIST [1:?] OF surface_section;
      additional_node_values : BOOLEAN;
  END_ENTITY; -- surface_section_field_varying

  ENTITY surface_section_integration_explicit;
      integration_positions_and_weights : SET [1:?] OF surface_section_position_weight;
  END_ENTITY; -- surface_section_integration_explicit

  ENTITY surface_section_integration_rule;
      integration_method : integration_rule;
      integration_order  : INTEGER;
  END_ENTITY; -- surface_section_integration_rule

  ENTITY surface_section_position_weight;
      integration_position : surface_section_element_location;
      integration_weight   : context_dependent_measure;
  END_ENTITY; -- surface_section_position_weight

  ENTITY surface_volume_element_location;
      field_location   : surface_element_location;
      section_location : surface_section_element_location;
  END_ENTITY; -- surface_volume_element_location

  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,surface_of_revolution))
    SUBTYPE OF (surface);
      swept_curve : curve;
  END_ENTITY; -- swept_surface

  ENTITY symmetry_control
    SUPERTYPE OF (ONEOF (no_symmetry_control,cylindrical_symmetry_control));
  END_ENTITY; -- symmetry_control

  ENTITY system_and_freedom;
      matrix_coordinate_system : directionally_explicit_element_coordinate_system;
      freedom                  : degree_of_freedom;
  END_ENTITY; -- system_and_freedom

  ENTITY tensor_representation_item
    SUBTYPE OF (representation_item);
      tensor_value : tensor_type;
  END_ENTITY; -- tensor_representation_item

  ENTITY thermodynamic_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.THERMODYNAMIC_TEMPERATURE_UNIT' IN
                TYPEOF(SELF\measure_with_unit.unit_component));
  END_ENTITY; -- thermodynamic_temperature_measure_with_unit

  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 1) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- thermodynamic_temperature_unit

  ENTITY thickness_laminate_definition
    SUBTYPE OF (product_definition);
    WHERE
      wr1: (SIZEOF(QUERY ( pdr <* USEDIN(SELF,
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATING_PRODUCT_DEFINITION') | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'NEXT_ASSEMBLY_USAGE_OCCURRENCE') IN TYPEOF(pdr)) )) = 1);
  END_ENTITY; -- thickness_laminate_definition

  ENTITY time_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.TIME_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- time_measure_with_unit

  ENTITY time_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 1) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- time_unit

  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (vertex,edge,face_bound,face,vertex_shell,
        wire_shell,connected_edge_set,connected_face_set,loop ANDOR path))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- topological_representation_item

  ENTITY toroidal_surface
    SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY; -- toroidal_surface

  ENTITY transformation_with_derived_angle
    SUBTYPE OF (item_defined_transformation);
    DERIVE
      orientation_angle : plane_angle_measure := derive_angle(SELF\
                             item_defined_transformation.transform_item_1,
                             SELF\item_defined_transformation.
                             transform_item_2);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(SELF
               \item_defined_transformation.transform_item_1));
      wr2: ('STRUCTURAL_ANALYSIS_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(SELF
               \item_defined_transformation.transform_item_2));
      wr3: ((SELF\item_defined_transformation.transform_item_1\
               axis2_placement_3d.p[3].direction_ratios[1] = SELF\
               item_defined_transformation.transform_item_2\
               axis2_placement_3d.p[3].direction_ratios[1]) AND (SELF\
               item_defined_transformation.transform_item_1\
               axis2_placement_3d.p[3].direction_ratios[2] = SELF\
               item_defined_transformation.transform_item_2\
               axis2_placement_3d.p[3].direction_ratios[2]) AND (SELF\
               item_defined_transformation.transform_item_1\
               axis2_placement_3d.p[3].direction_ratios[3] = SELF\
               item_defined_transformation.transform_item_2\
               axis2_placement_3d.p[3].direction_ratios[3]));
  END_ENTITY; -- transformation_with_derived_angle

  ENTITY trimmed_curve
    SUBTYPE OF (bounded_curve);
      basis_curve           : curve;
      trim_1                : SET [1:2] OF trimming_select;
      trim_2                : SET [1:2] OF trimming_select;
      sense_agreement       : BOOLEAN;
      master_representation : trimming_preference;
    WHERE
      wr1: ((HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2])));
      wr2: ((HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2])));
  END_ENTITY; -- trimmed_curve

  ENTITY type_qualifier;
      name : label;
  END_ENTITY; -- type_qualifier

  ENTITY unary_generic_expression
    ABSTRACT SUPERTYPE
    SUBTYPE OF (generic_expression);
      operand : generic_expression;
  END_ENTITY; -- unary_generic_expression

  ENTITY unary_numeric_expression
    ABSTRACT SUPERTYPE
    SUBTYPE OF (numeric_expression, unary_generic_expression);
      SELF\unary_generic_expression.operand : numeric_expression;
  END_ENTITY; -- unary_numeric_expression

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : text;
    WHERE
      wr1: valid_measure_value(SELF\measure_with_unit.value_component);
  END_ENTITY; -- uncertainty_measure_with_unit

  ENTITY uncertainty_qualifier
    SUPERTYPE OF (ONEOF (standard_uncertainty,qualitative_uncertainty));
      measure_name : label;
      description  : text;
  END_ENTITY; -- uncertainty_qualifier

  ENTITY uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- uniform_curve

  ENTITY uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- uniform_surface

  ENTITY uniform_surface_section
    SUBTYPE OF (surface_section);
      thickness         : context_dependent_measure;
      bending_thickness : measure_or_unspecified_value;
      shear_thickness   : measure_or_unspecified_value;
  END_ENTITY; -- uniform_surface_section

  ENTITY uniform_surface_section_layered
    SUBTYPE OF (surface_section);
  END_ENTITY; -- uniform_surface_section_layered

  ENTITY variable
    ABSTRACT SUPERTYPE OF (numeric_variable)
    SUBTYPE OF (generic_variable);
  END_ENTITY; -- variable

  ENTITY variable_semantics
    ABSTRACT SUPERTYPE;
  END_ENTITY; -- variable_semantics

  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: (magnitude >= 0);
  END_ENTITY; -- vector

  ENTITY versioned_action_request;
      id          : identifier;
      version     : label;
      purpose     : text;
      description : text;
  END_ENTITY; -- versioned_action_request

  ENTITY vertex
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- vertex

  ENTITY vertex_loop
    SUBTYPE OF (loop);
      loop_vertex : vertex;
  END_ENTITY; -- vertex_loop

  ENTITY vertex_point
    SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
  END_ENTITY; -- vertex_point

  ENTITY vertex_shell
    SUBTYPE OF (topological_representation_item);
      vertex_shell_extent : vertex_loop;
  END_ENTITY; -- vertex_shell

  ENTITY volume_2d_element_basis;
      descriptor              : volume_2d_element_descriptor;
      variable                : volume_variable;
      variable_order          : element_order;
      variable_shape_function : shape_function;
      evaluation_points       : LIST [1:?] OF volume_element_location;
  END_ENTITY; -- volume_2d_element_basis

  ENTITY volume_2d_element_boundary_constant_specified_variable_value
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_variable;
      element_face      : volume_2d_face;
      coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_boundary_constant_specified_variable_value

  ENTITY volume_2d_element_boundary_edge_constant_specified_volume_variable_value
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_edge_variable;
      element_edge      : volume_2d_edge;
      coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_boundary_edge_constant_specified_volume_variable_value

  ENTITY volume_2d_element_boundary_edge_location_point_volume_variable_values
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 volume_2d_element_value_and_location;
      variable             : boundary_edge_variable;
      element_edge         : volume_2d_edge;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_boundary_edge_location_point_volume_variable_values

  ENTITY volume_2d_element_boundary_edge_nodal_specified_variable_values
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : boundary_edge_variable;
      element_edge           : volume_2d_edge;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_boundary_edge_nodal_specified_variable_values

  ENTITY volume_2d_element_boundary_edge_whole_edge_variable_value
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_edge      : volume_2d_edge;
      coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_boundary_edge_whole_edge_variable_value

  ENTITY volume_2d_element_boundary_location_point_variable_values
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 volume_2d_element_value_and_location;
      variable             : boundary_variable;
      element_face         : volume_2d_face;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_boundary_location_point_variable_values

  ENTITY volume_2d_element_boundary_nodal_specified_variable_values
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      variable               : boundary_variable;
      additional_node_values : BOOLEAN;
      element_face           : volume_2d_face;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_boundary_nodal_specified_variable_values

  ENTITY volume_2d_element_boundary_whole_face_variable_value
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_face      : volume_2d_face;
      coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_boundary_whole_face_variable_value

  ENTITY volume_2d_element_constant_specified_variable_value
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_variable;
      coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_constant_specified_variable_value

  ENTITY volume_2d_element_field_integration_explicit;
      integration_positions_and_weights : SET [1:?] OF
                                              volume_position_weight;
  END_ENTITY; -- volume_2d_element_field_integration_explicit

  ENTITY volume_2d_element_field_integration_rule;
      integration_method : integration_rule;
      integration_order  : ARRAY [1:2] OF INTEGER;
  END_ENTITY; -- volume_2d_element_field_integration_rule

  ENTITY volume_2d_element_field_variable_definition
    SUPERTYPE OF (ONEOF (volume_2d_element_location_point_variable_values,
        volume_2d_whole_element_variable_value,
        volume_2d_element_constant_specified_variable_value,
        volume_2d_element_nodal_specified_variable_values,
        volume_2d_element_boundary_location_point_variable_values,
        volume_2d_element_boundary_whole_face_variable_value,
        volume_2d_element_boundary_constant_specified_variable_value,
        volume_2d_element_boundary_nodal_specified_variable_values,volume_2d_element_boundary_edge_location_point_volume_variable_values,
        volume_2d_element_boundary_edge_whole_edge_variable_value,volume_2d_element_boundary_edge_constant_specified_volume_variable_value,
        volume_2d_element_boundary_edge_nodal_specified_variable_values))
    SUBTYPE OF (field_variable_element_definition);
      element : volume_2d_element_output_reference;
  END_ENTITY; -- volume_2d_element_field_variable_definition

  ENTITY volume_2d_element_group
    SUBTYPE OF (element_group);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* elements | ((NOT ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION') IN TYPEOF(
               item))) AND (NOT (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION') IN TYPEOF(item)))) )) 
               = 0);
  END_ENTITY; -- volume_2d_element_group

  ENTITY volume_2d_element_integrated_matrix;
      descriptor              : volume_2d_element_descriptor;
      property_type           : matrix_property_type;
      integration_description : text;
  END_ENTITY; -- volume_2d_element_integrated_matrix

  ENTITY volume_2d_element_integrated_matrix_with_definition
    SUBTYPE OF (volume_2d_element_integrated_matrix);
      integration_definition : volume_2d_element_field_integration;
  END_ENTITY; -- volume_2d_element_integrated_matrix_with_definition

  ENTITY volume_2d_element_location_point_variable_values
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 volume_2d_element_value_and_location;
      variable             : volume_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_location_point_variable_values

  ENTITY volume_2d_element_nodal_specified_variable_values
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : volume_variable;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_element_nodal_specified_variable_values

  ENTITY volume_2d_element_value_and_location;
      simple_value      : field_value;
      location          : volume_element_location;
      coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- volume_2d_element_value_and_location

  ENTITY volume_2d_node_field_variable_definition
    SUBTYPE OF (field_variable_node_definition);
      simple_value      : field_value;
      variable          : volume_variable;
      coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_node_field_variable_definition

  ENTITY volume_2d_substructure_element_reference;
      substructure_element_ref : substructure_element_representation;
      element_ref              : volume_2d_element_representation;
  END_ENTITY; -- volume_2d_substructure_element_reference

  ENTITY volume_2d_whole_element_variable_value
    SUBTYPE OF (volume_2d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL volume_2d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_2d_whole_element_variable_value

  ENTITY volume_3d_element_basis;
      descriptor              : volume_3d_element_descriptor;
      variable                : volume_variable;
      variable_order          : element_order;
      variable_shape_function : shape_function;
      evaluation_points       : LIST [1:?] OF volume_element_location;
  END_ENTITY; -- volume_3d_element_basis

  ENTITY volume_3d_element_boundary_constant_specified_variable_value
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_variable;
      element_face      : volume_3d_face;
      coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_boundary_constant_specified_variable_value

  ENTITY volume_3d_element_boundary_edge_constant_specified_volume_variable_value
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_edge_variable;
      element_edge      : volume_3d_edge;
      coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_boundary_edge_constant_specified_volume_variable_value

  ENTITY volume_3d_element_boundary_edge_location_point_volume_variable_values
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 volume_3d_element_value_and_location;
      variable             : boundary_edge_variable;
      element_edge         : volume_3d_edge;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_boundary_edge_location_point_volume_variable_values

  ENTITY volume_3d_element_boundary_edge_nodal_specified_variable_values
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : boundary_edge_variable;
      element_edge           : volume_3d_edge;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_boundary_edge_nodal_specified_variable_values

  ENTITY volume_3d_element_boundary_edge_whole_edge_variable_value
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_edge      : volume_3d_edge;
      coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_boundary_edge_whole_edge_variable_value

  ENTITY volume_3d_element_boundary_location_point_variable_values
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 volume_3d_element_value_and_location;
      variable             : boundary_variable;
      element_face         : volume_3d_face;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_boundary_location_point_variable_values

  ENTITY volume_3d_element_boundary_nodal_specified_variable_values
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : boundary_variable;
      element_face           : volume_3d_face;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_boundary_nodal_specified_variable_values

  ENTITY volume_3d_element_boundary_whole_face_variable_value
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : boundary_aggregated_variable;
      element_face      : volume_3d_face;
      coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_boundary_whole_face_variable_value

  ENTITY volume_3d_element_constant_specified_variable_value
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_variable;
      coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_constant_specified_variable_value

  ENTITY volume_3d_element_descriptor
    SUBTYPE OF (element_descriptor);
      purpose : SET [1:?] OF volume_element_purpose;
      shape   : volume_3d_element_shape;
  END_ENTITY; -- volume_3d_element_descriptor

  ENTITY volume_3d_element_field_integration_explicit;
      integration_positions_and_weights : SET [1:?] OF
                                              volume_position_weight;
  END_ENTITY; -- volume_3d_element_field_integration_explicit

  ENTITY volume_3d_element_field_integration_rule;
      integration_method : integration_rule;
      integration_order  : ARRAY [1:3] OF INTEGER;
  END_ENTITY; -- volume_3d_element_field_integration_rule

  ENTITY volume_3d_element_field_variable_definition
    SUPERTYPE OF (ONEOF (volume_3d_element_location_point_variable_values,
        volume_3d_whole_element_variable_value,
        volume_3d_element_constant_specified_variable_value,
        volume_3d_element_nodal_specified_variable_values,
        volume_3d_element_boundary_location_point_variable_values,
        volume_3d_element_boundary_whole_face_variable_value,
        volume_3d_element_boundary_constant_specified_variable_value,
        volume_3d_element_boundary_nodal_specified_variable_values,volume_3d_element_boundary_edge_location_point_volume_variable_values,
        volume_3d_element_boundary_edge_whole_edge_variable_value,volume_3d_element_boundary_edge_constant_specified_volume_variable_value,
        volume_3d_element_boundary_edge_nodal_specified_variable_values))
    SUBTYPE OF (field_variable_element_definition);
      element : volume_3d_element_output_reference;
  END_ENTITY; -- volume_3d_element_field_variable_definition

  ENTITY volume_3d_element_group
    SUBTYPE OF (element_group);
    WHERE
      wr1: (SIZEOF(QUERY ( item <* elements | (NOT ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'VOLUME_3D_ELEMENT_REPRESENTATION') IN TYPEOF(item))) )) = 0);
  END_ENTITY; -- volume_3d_element_group

  ENTITY volume_3d_element_integrated_matrix;
      descriptor              : volume_3d_element_descriptor;
      property_type           : matrix_property_type;
      integration_description : text;
  END_ENTITY; -- volume_3d_element_integrated_matrix

  ENTITY volume_3d_element_integrated_matrix_with_definition
    SUBTYPE OF (volume_3d_element_integrated_matrix);
      integration_definition : volume_3d_element_field_integration;
  END_ENTITY; -- volume_3d_element_integrated_matrix_with_definition

  ENTITY volume_3d_element_location_point_variable_values
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      basis                : BOOLEAN;
      values_and_locations : SET [1:?] OF
                                 volume_3d_element_value_and_location;
      variable             : volume_variable;
    WHERE
      wr1: consistent_set_values(values_and_locations,variable);
      wr2: appropriate_set_value_existence(values_and_locations,TYPEOF(
               SELF\state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_location_point_variable_values

  ENTITY volume_3d_element_nodal_specified_variable_values
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      values                 : LIST [1:?] OF field_value;
      additional_node_values : BOOLEAN;
      variable               : volume_variable;
    WHERE
      wr1: consistent_list_values(values,variable);
      wr2: appropriate_list_value_existence(values,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_element_nodal_specified_variable_values

  ENTITY volume_3d_element_representation
    SUBTYPE OF (element_representation);
      model_ref          : fea_model_3d;
      element_descriptor : volume_3d_element_descriptor;
      material           : element_material;
    UNIQUE
      ur1 : model_ref, name;
    WHERE
      wr1: ((SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'PARAMETRIC_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) )) + SIZEOF(QUERY ( item <* SELF\representation.items
                | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
               'ARBITRARY_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM') IN TYPEOF(
               item)) ))) = 1);
      wr2: (SIZEOF(QUERY ( item1 <* material.properties | (SIZEOF(
               QUERY ( item2 <* item1\property_definition_representation.
               used_representation.items | (SIZEOF([
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_LINEAR_ELASTICITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MASS_DENSITY',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 
               'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
               'STRUCTURAL_ANALYSIS_DESIGN.' + 'FEA_MOISTURE_ABSORPTION'] *
                TYPEOF(item2)) = 1) )) = 1) )) >= 1);
      wr3: ('STRUCTURAL_ANALYSIS_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
      fu1: required_3d_nodes(SELF\element_representation.node_list,
               element_descriptor.shape,element_descriptor\
               element_descriptor.topology_order);
  END_ENTITY; -- volume_3d_element_representation

  ENTITY volume_3d_element_value_and_location;
      simple_value      : field_value;
      location          : volume_element_location;
      coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
  END_ENTITY; -- volume_3d_element_value_and_location

  ENTITY volume_3d_node_field_variable_definition
    SUBTYPE OF (field_variable_node_definition);
      simple_value      : field_value;
      variable          : volume_variable;
      coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_node_field_variable_definition

  ENTITY volume_3d_substructure_element_reference;
      substructure_element_ref : substructure_element_representation;
      element_ref              : volume_3d_element_representation;
  END_ENTITY; -- volume_3d_substructure_element_reference

  ENTITY volume_3d_whole_element_variable_value
    SUBTYPE OF (volume_3d_element_field_variable_definition);
      simple_value      : field_value;
      variable          : volume_aggregated_variable;
      coordinate_system : OPTIONAL volume_3d_element_coordinate_system;
    WHERE
      wr1: necessary_value_coordinate_system(simple_value,
               coordinate_system);
      wr2: consistent_value(simple_value,variable);
      wr3: appropriate_value_existence(simple_value,TYPEOF(SELF\
               state_definition.defined_state));
  END_ENTITY; -- volume_3d_whole_element_variable_value

  ENTITY volume_element_location;
      coordinates : fea_parametric_point;
  END_ENTITY; -- volume_element_location

  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('STRUCTURAL_ANALYSIS_DESIGN.VOLUME_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- volume_measure_with_unit

  ENTITY volume_position_weight;
      integration_position : volume_element_location;
      integration_weight   : context_dependent_measure;
  END_ENTITY; -- volume_position_weight

  ENTITY volume_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 3) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- volume_unit

  ENTITY week_of_year_and_day_date
    SUBTYPE OF (date);
      week_component : week_in_year_number;
      day_component  : OPTIONAL day_in_week_number;
  END_ENTITY; -- week_of_year_and_day_date

  ENTITY whole_model_analysis_message
    SUPERTYPE OF (whole_model_modes_and_frequencies_analysis_message)
    SUBTYPE OF (analysis_message);
  END_ENTITY; -- whole_model_analysis_message

  ENTITY whole_model_modes_and_frequencies_analysis_message
    SUBTYPE OF (whole_model_analysis_message);
      mode      : count_measure;
      frequency : context_dependent_measure;
  END_ENTITY; -- whole_model_modes_and_frequencies_analysis_message

  ENTITY wire_shell
    SUBTYPE OF (topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
    WHERE
      wr1: (NOT mixed_loop_type_set(wire_shell_extent));
  END_ENTITY; -- wire_shell

  RULE action_directive_requires_date_time FOR (action_directive, 
               applied_date_and_time_assignment, applied_date_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( ad <* action_directive | (NOT ((SIZEOF(
             QUERY ( adta <* applied_date_and_time_assignment | ((ad IN 
             adta.items) AND (adta.role.name IN ['change date','start date'])) )) 
             + SIZEOF(QUERY ( ada <* applied_date_assignment | ((ad IN ada.
             items) AND (ada.role.name IN ['change date','start date'])) ))) 
             = 1)) )) = 0);

  END_RULE; -- action_directive_requires_date_time

  RULE action_request_requires_date_time FOR (versioned_action_request, 
             applied_date_and_time_assignment, applied_date_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT ((SIZEOF(
             QUERY ( adta <* applied_date_and_time_assignment | (ar IN adta
             .items) )) + SIZEOF(QUERY ( ada <* applied_date_assignment | (
             ar IN ada.items) ))) = 1)) )) = 0);

  END_RULE; -- action_request_requires_date_time

  RULE action_request_requires_person_organization FOR (
             versioned_action_request, 
             applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT ((SIZEOF(
             QUERY ( apoa <* applied_person_and_organization_assignment | (
             (ar IN apoa.items) AND (apoa.role.name = 'request recipient')) )) 
             + SIZEOF(QUERY ( aoa <* applied_organization_assignment | ((ar 
             IN aoa.items) AND (aoa.role.name = 'request recipient')) ))) 
             >= 1)) )) = 0);

  END_RULE; -- action_request_requires_person_organization

  RULE approval_requires_approval_date_time FOR (approval, 
             approval_date_time);

  WHERE
    wr1: (SIZEOF(QUERY ( e <* approval | (NOT (SIZEOF(QUERY ( s <* 
             approval_date_time | (e :=: s.dated_approval) )) = 1)) )) = 0);

  END_RULE; -- approval_requires_approval_date_time

  RULE approval_requires_approval_person_organization FOR (approval, 
             approval_person_organization);

  WHERE
    wr1: (SIZEOF(QUERY ( e <* approval | (NOT (SIZEOF(QUERY ( s <* 
             approval_person_organization | (e :=: s.authorized_approval) )) 
             >= 1)) )) = 0);

  END_RULE; -- approval_requires_approval_person_organization

  RULE approvals_are_assigned FOR (approval, approval_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( aa <* 
             approval_assignment | (app :=: aa.assigned_approval) )) >= 1)) )) 
             = 0);

  END_RULE; -- approvals_are_assigned

  RULE as_required_quantity FOR (measure_with_unit);

  WHERE
    wr1: (SIZEOF(QUERY ( m <* measure_with_unit | ((
             'STRUCTURAL_ANALYSIS_DESIGN.DESCRIPTIVE_MEASURE' IN TYPEOF(m.
             value_component)) AND (NOT (m.value_component = 'as required'))) )) 
             = 0);

  END_RULE; -- as_required_quantity

  RULE compatible_dimension FOR (cartesian_point, direction, 
             representation_context, geometric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 
             0) )) = 0);
    wr2: (SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) 
             > 0) )) = 0);

  END_RULE; -- compatible_dimension

  RULE component_class_for_assembly_select FOR (
             composite_assembly_sequence_definition, 
             next_assembly_usage_occurrence, 
             product_related_product_category);

    LOCAL
      i     : INTEGER;
      j     : INTEGER;
      k     : INTEGER;
      nnauo : INTEGER;
      dkuhr : LOGICAL;
      rp    : product;
      nprpc : INTEGER;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i := LOINDEX(composite_assembly_sequence_definition) TO 
        HIINDEX(composite_assembly_sequence_definition) BY 1;
      nnauo := 0;
      REPEAT j := LOINDEX(next_assembly_usage_occurrence) TO HIINDEX(
          next_assembly_usage_occurrence) BY 1;
        IF composite_assembly_sequence_definition[i] = 
            next_assembly_usage_occurrence[j].relating_product_definition
             THEN
          rp := next_assembly_usage_occurrence[j].
              related_product_definition.formation.of_product;
          nprpc := 0;
          REPEAT k := LOINDEX(product_related_product_category) TO 
              HIINDEX(product_related_product_category) BY 1;
            IF (rp IN product_related_product_category[k].products) AND (
                product_related_product_category[k].name IN ['ply',
                'ply laminate','filament laminate','processed core',
                'composite assembly']) THEN
              nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF nprpc = 1 THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF dkuhr = FALSE THEN
        ESCAPE;
      END_IF;
      IF nnauo = 0 THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: dkuhr;

  END_RULE; -- component_class_for_assembly_select

  RULE configuration_item_requires_person_organization FOR (
             configuration_item, applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT ((SIZEOF(
             QUERY ( apoa <* applied_person_and_organization_assignment | (
             ci IN apoa.items) )) + SIZEOF(QUERY ( aoa <* 
             applied_organization_assignment | (ci IN aoa.items) ))) = 1)) )) 
             = 0);

  END_RULE; -- configuration_item_requires_person_organization

  RULE coordinated_assembly_and_shape FOR (next_assembly_usage_occurrence);

  WHERE
    wr1: (SIZEOF(QUERY ( nauo <* next_assembly_usage_occurrence | (NOT 
             assembly_shape_is_defined(nauo)) )) = 0);

  END_RULE; -- coordinated_assembly_and_shape

  RULE dependent_instantiable_approval_status FOR (approval_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (SIZEOF(USEDIN(ast,
             '')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_approval_status

  RULE dependent_instantiable_certification_type FOR (certification_type);

  WHERE
    wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (SIZEOF(USEDIN(ct,
             '')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_certification_type

  RULE dependent_instantiable_contract_type FOR (contract_type);

  WHERE
    wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (SIZEOF(USEDIN(ct,'')) 
             >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_contract_type

  RULE dependent_instantiable_date FOR (date);

  WHERE
    wr1: (SIZEOF(QUERY ( dt <* date | (NOT (SIZEOF(USEDIN(dt,'')) >= 1)) )) 
             = 0);

  END_RULE; -- dependent_instantiable_date

  RULE dependent_instantiable_date_and_time FOR (date_and_time);

  WHERE
    wr1: (SIZEOF(QUERY ( dat <* date_and_time | (NOT (SIZEOF(USEDIN(dat,'')) 
             >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_date_and_time

  RULE dependent_instantiable_date_role FOR (date_role);

  WHERE
    wr1: (SIZEOF(QUERY ( dr <* date_role | (NOT (SIZEOF(USEDIN(dr,'')) >= 
             1)) )) = 0);

  END_RULE; -- dependent_instantiable_date_role

  RULE dependent_instantiable_date_time_role FOR (date_time_role);

  WHERE
    wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (SIZEOF(USEDIN(dtr,
             '')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_date_time_role

  RULE dependent_instantiable_document_type FOR (document_type);

  WHERE
    wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (SIZEOF(USEDIN(dt,'')) 
             >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_document_type

  RULE dependent_instantiable_named_unit FOR (named_unit);

  WHERE
    wr1: (SIZEOF(QUERY ( nu <* named_unit | (NOT (SIZEOF(USEDIN(nu,'')) >=
              1)) )) = 0);

  END_RULE; -- dependent_instantiable_named_unit

  RULE dependent_instantiable_organization_role FOR (organization_role);

  WHERE
    wr1: (SIZEOF(QUERY ( orl <* organization_role | (NOT (SIZEOF(USEDIN(
             orl,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_organization_role

  RULE dependent_instantiable_parametric_representation_context FOR (
             parametric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( prc <* parametric_representation_context | (NOT (
             SIZEOF(USEDIN(prc,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_parametric_representation_context

  RULE dependent_instantiable_person_and_organization_role FOR (
             person_and_organization_role);

  WHERE
    wr1: (SIZEOF(QUERY ( paor <* person_and_organization_role | (NOT (
             SIZEOF(USEDIN(paor,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_person_and_organization_role

  RULE dependent_instantiable_representation_item FOR (representation_item);

  WHERE
    wr1: (SIZEOF(QUERY ( ri <* representation_item | (NOT (SIZEOF(USEDIN(
             ri,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_representation_item

  RULE dependent_instantiable_security_classification_level FOR (
             security_classification_level);

  WHERE
    wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (
             SIZEOF(USEDIN(scl,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_security_classification_level

  RULE dependent_instantiable_shape_representation FOR (
             shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT (SIZEOF(USEDIN(
             sr,'')) >= 1)) )) = 0);

  END_RULE; -- dependent_instantiable_shape_representation

  RULE global_unit_assignment FOR (global_unit_assigned_context);

  WHERE
    wr1: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT (
             SIZEOF(guac.units) >= 2)) )) = 0);
    wr2: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT ((
             SIZEOF(QUERY ( u <* guac.units | (
             'STRUCTURAL_ANALYSIS_DESIGN.LENGTH_UNIT' IN TYPEOF(u)) )) = 1) 
             AND (SIZEOF(QUERY ( u <* guac.units | (
             'STRUCTURAL_ANALYSIS_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(u)) )) 
             = 1))) )) = 0);

  END_RULE; -- global_unit_assignment

  RULE pdu_requires_security_classification FOR (product_definition_usage, 
             applied_security_classification_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( e <* product_definition_usage | (NOT (SIZEOF(
             QUERY ( s <* applied_security_classification_assignment | (e 
             IN s.items) )) = 1)) )) = 0);

  END_RULE; -- pdu_requires_security_classification

  RULE ply_reference FOR (ply_laminate_sequence_definition, 
             next_assembly_usage_occurrence, 
             product_related_product_category);

    LOCAL
      i     : INTEGER;
      j     : INTEGER;
      k     : INTEGER;
      nnauo : INTEGER;
      dkuhr : LOGICAL;
      rp    : product;
      nprpc : INTEGER;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i := LOINDEX(ply_laminate_sequence_definition) TO HIINDEX(
        ply_laminate_sequence_definition) BY 1;
      nnauo := 0;
      REPEAT j := LOINDEX(next_assembly_usage_occurrence) TO HIINDEX(
          next_assembly_usage_occurrence) BY 1;
        IF ply_laminate_sequence_definition[i] = 
            next_assembly_usage_occurrence[j].relating_product_definition
             THEN
          rp := next_assembly_usage_occurrence[j].
              related_product_definition.formation.of_product;
          nprpc := 0;
          REPEAT k := LOINDEX(product_related_product_category) TO 
              HIINDEX(product_related_product_category) BY 1;
            IF (product_related_product_category[k].name = 'ply') AND (rp 
                IN product_related_product_category[k].products) THEN
              nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF nprpc = 1 THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF dkuhr = FALSE THEN
        ESCAPE;
      END_IF;
      IF nnauo = 0 THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: dkuhr;

  END_RULE; -- ply_reference

  RULE ply_stock_material_select FOR (product_related_product_category, 
             make_from_usage_option);

    LOCAL
      i     : INTEGER;
      j     : INTEGER;
      k     : INTEGER;
      dkuhr : LOGICAL;
      kp    : INTEGER;
      rp    : product;
      nprpc : INTEGER;
      nmfuo : INTEGER;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT kp := LOINDEX(product_related_product_category) TO HIINDEX(
        product_related_product_category) BY 1;
      IF product_related_product_category[kp].name = 'ply' THEN
        REPEAT i := LOINDEX(product_related_product_category[kp].products)
             TO HIINDEX(product_related_product_category[kp].products) BY 1;
          nmfuo := 0;
          REPEAT j := LOINDEX(make_from_usage_option) TO HIINDEX(
              make_from_usage_option) BY 1;
            IF product_related_product_category[kp].products[i] = 
                make_from_usage_option[j].relating_product_definition.
                formation.of_product THEN
              rp := make_from_usage_option[j].related_product_definition.
                  formation.of_product;
              REPEAT k := LOINDEX(product_related_product_category) TO 
                  HIINDEX(product_related_product_category) BY 1;
                IF (rp IN product_related_product_category[k].products) 
                    AND (product_related_product_category[k].name IN [
                    'isotropic material','filament assembly',
                    'discontinuous fiber assembly']) THEN
                  nprpc := nprpc + 1;
                END_IF;
              END_REPEAT;
              IF nprpc = 1 THEN
                nmfuo := nmfuo + 1;
              ELSE
                dkuhr := FALSE;
                ESCAPE;
              END_IF;
            END_IF;
          END_REPEAT;
          IF dkuhr = FALSE THEN
            ESCAPE;
          END_IF;
          IF nmfuo <> 1 THEN
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_REPEAT;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: dkuhr;

  END_RULE; -- ply_stock_material_select

  RULE product_concept_requires_configuration_item FOR (product_concept, 
             configuration_item);

  WHERE
    wr1: (SIZEOF(QUERY ( pc <* product_concept | (NOT (SIZEOF(
             QUERY ( ci <* configuration_item | (pc :=: ci.item_concept) )) 
             >= 1)) )) = 0);

  END_RULE; -- product_concept_requires_configuration_item

  RULE product_definition_requires_date_time FOR (product_definition, 
             applied_date_and_time_assignment, applied_date_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT ((SIZEOF(
             QUERY ( adta <* applied_date_and_time_assignment | (pd IN adta
             .items) )) + SIZEOF(QUERY ( ada <* applied_date_assignment | (
             pd IN ada.items) ))) = 1)) )) = 0);

  END_RULE; -- product_definition_requires_date_time

  RULE product_definition_requires_person_organization FOR (
             product_definition, applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT ((SIZEOF(
             QUERY ( apoa <* applied_person_and_organization_assignment | (
             pd IN apoa.items) )) + SIZEOF(QUERY ( aoa <* 
             applied_organization_assignment | (pd IN aoa.items) ))) = 1)) )) 
             = 0);

  END_RULE; -- product_definition_requires_person_organization

  RULE product_requires_person_organization FOR (product, 
             applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT ((SIZEOF(QUERY ( apoa <* 
             applied_person_and_organization_assignment | (prod IN apoa.
             items) )) + SIZEOF(QUERY ( aoa <* 
             applied_organization_assignment | (prod IN aoa.items) ))) = 1)) )) 
             = 0);

  END_RULE; -- product_requires_person_organization

  RULE product_requires_product_category FOR (product, 
             product_related_product_category);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( prpc <* 
             product_related_product_category | ((prod IN prpc.products) 
             AND (prpc.name IN ['assembly','inseparable assembly','detail',
             'customer furnished equipment'])) )) = 1)) )) = 0);

  END_RULE; -- product_requires_product_category

  RULE product_requires_version FOR (product, product_definition_formation);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( pdf <* 
             product_definition_formation | (prod :=: pdf.of_product) )) >=
              1)) )) = 0);

  END_RULE; -- product_requires_version

  RULE product_version_requires_person_organization FOR (
             product_definition_formation, 
             applied_person_and_organization_assignment, 
             applied_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT ((
             SIZEOF(QUERY ( apoa <* 
             applied_person_and_organization_assignment | ((pdf IN apoa.
             items) AND (apoa.role.name = 'creator')) )) + SIZEOF(
             QUERY ( aoa <* applied_organization_assignment | ((pdf IN aoa.
             items) AND (aoa.role.name = 'creator')) ))) = 1)) )) = 0);
    wr2: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT ((
             SIZEOF(QUERY ( apoa <* 
             applied_person_and_organization_assignment | ((pdf IN apoa.
             items) AND (apoa.role.name IN ['analysis supplier',
             'design supplier','part supplier'])) )) + SIZEOF(
             QUERY ( aoa <* applied_organization_assignment | ((pdf IN aoa.
             items) AND (aoa.role.name IN ['analysis supplier',
             'design supplier','part supplier'])) ))) >= 1)) )) = 0);

  END_RULE; -- product_version_requires_person_organization

  RULE product_version_requires_security_classification FOR (
             product_definition_formation, 
             applied_security_classification_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( e <* product_definition_formation | (NOT (SIZEOF(
             QUERY ( s <* applied_security_classification_assignment | (e 
             IN s.items) )) = 1)) )) = 0);

  END_RULE; -- product_version_requires_security_classification

  RULE restrict_action_request_status FOR (action_request_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ars <* action_request_status | (NOT (ars.status 
             IN ['proposed','in work','issued','hold'])) )) = 0);

  END_RULE; -- restrict_action_request_status

  RULE restrict_approval_status FOR (approval_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (ast.name IN [
             'approved','not yet approved','disapproved','withdrawn'])) )) 
             = 0);

  END_RULE; -- restrict_approval_status

  RULE restrict_date_time_role FOR (date_time_role, date_role);

  WHERE
    wr1: ((SIZEOF(QUERY ( dtr <* date_time_role | (NOT (dtr.name IN [
             'change date','creation date','request date','release date',
             'start date','earliest end date','latest end date',
             'contract date','sign off date','certification date',
             'classification date','declassification date'])) )) + SIZEOF(
             QUERY ( dr <* date_role | (NOT (dr.name IN ['change date',
             'creation date','request date','release date','start date',
             'earliest end date','latest end date','contract date',
             'sign off date','certification date','classification date',
             'declassification date'])) ))) = 0);

  END_RULE; -- restrict_date_time_role

  RULE restrict_person_organization_role FOR (person_and_organization_role, 
             organization_role);

  WHERE
    wr1: ((SIZEOF(QUERY ( porl <* person_and_organization_role | (NOT (
             porl.name IN ['request recipient','initiator','part supplier',
             'design supplier','analysis supplier','creator','design owner',
             'analysis owner','contractor','configuration manager',
             'classification officer'])) )) + SIZEOF(QUERY ( orl <* 
             organization_role | (NOT (orl.name IN ['request recipient',
             'initiator','part supplier','design supplier',
             'analysis supplier','creator','design owner','analysis owner',
             'contractor','configuration manager','classification officer'])) ))) 
             = 0);

  END_RULE; -- restrict_person_organization_role

  RULE restrict_product_category_value FOR (
             product_related_product_category);

  WHERE
    wr1: (SIZEOF(QUERY ( prpc <* product_related_product_category | (NOT (
             prpc.name IN ['assembly','detail',
             'customer furnished equipment','inseparable assembly',
             'standard part','linear static analysis',
             'linear modes and frequencies analysis','cast','coined',
             'drawn','extruded','forged','formed','machined','molded',
             'rolled','sheared','anisotropic material','composite assembly',
             'discontinuous fiber assembly','filament assembly',
             'filament laminate','isotropic material','ply','ply laminate',
             'ply piece','processed core','stock core'])) )) = 0);

  END_RULE; -- restrict_product_category_value

  RULE restrict_product_definition_context FOR (product_definition_context);

  WHERE
    wr1: (SIZEOF(QUERY ( pdc <* product_definition_context | (NOT (pdc.
             life_cycle_stage IN ['analysis','design'])) )) = 0);

  END_RULE; -- restrict_product_definition_context

  RULE restrict_security_classification_level FOR (
             security_classification_level);

  WHERE
    wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (scl.
             name IN ['unclassified','classified','proprietary',
             'confidential','secret','top secret'])) )) = 0);

  END_RULE; -- restrict_security_classification_level

  RULE stock_material_reference FOR (percentage_ply_definition, 
             make_from_usage_option, product_related_product_category);

    LOCAL
      i     : INTEGER;
      j     : INTEGER;
      k     : INTEGER;
      dkuhr : LOGICAL;
      rp    : product;
      nprpc : INTEGER;
      nmfuo : INTEGER;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i := LOINDEX(percentage_ply_definition) TO HIINDEX(
        percentage_ply_definition) BY 1;
      nmfuo := 0;
      REPEAT j := LOINDEX(make_from_usage_option) TO HIINDEX(
          make_from_usage_option) BY 1;
        IF percentage_ply_definition[i] = make_from_usage_option[j].
            relating_product_definition THEN
          rp := make_from_usage_option[j].related_product_definition.
              formation.of_product;
          nprpc := 0;
          REPEAT k := LOINDEX(product_related_product_category) TO 
              HIINDEX(product_related_product_category) BY 1;
            IF (rp IN product_related_product_category[k].products) AND (
                product_related_product_category[k].name IN [
                'anisotropic material','isotropic material','stock core',
                'filament assembly','discontinuous fiber assembly']) THEN
              nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF nprpc = 1 THEN
            nmfuo := nmfuo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF dkuhr = FALSE THEN
        ESCAPE;
      END_IF;
      IF nmfuo = 0 THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: dkuhr;

  END_RULE; -- stock_material_reference

  RULE subtype_mandatory_action FOR (action);

  WHERE
    wr1: (SIZEOF(QUERY ( act <* action | (NOT (
             'STRUCTURAL_ANALYSIS_DESIGN.DIRECTED_ACTION' IN TYPEOF(act))) )) 
             = 0);

  END_RULE; -- subtype_mandatory_action

  RULE subtype_mandatory_shape_representation FOR (shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT ((SIZEOF([
             'STRUCTURAL_ANALYSIS_DESIGN.' + 
             'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
             'STRUCTURAL_ANALYSIS_DESIGN.' + 
             'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION',
             'STRUCTURAL_ANALYSIS_DESIGN.' + 
             'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',
             'STRUCTURAL_ANALYSIS_DESIGN.' + 
             'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',
             'STRUCTURAL_ANALYSIS_DESIGN.' + 
             'MANIFOLD_SURFACE_SHAPE_REPRESENTATION',
             'STRUCTURAL_ANALYSIS_DESIGN.POINT_PATH',
             'STRUCTURAL_ANALYSIS_DESIGN.POINT_AND_VECTOR',
             'STRUCTURAL_ANALYSIS_DESIGN.POINT_REPRESENTATION','STRUCTURAL_ANALYSIS_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION','STRUCTURAL_ANALYSIS_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION',
             'STRUCTURAL_ANALYSIS_DESIGN.SHAPE_DIMENSION_REPRESENTATION',
             'STRUCTURAL_ANALYSIS_DESIGN.BEVELED_SHEET_REPRESENTATION',
             'STRUCTURAL_ANALYSIS_DESIGN.COMPOSITE_SHEET_REPRESENTATION'] *
              TYPEOF(sr)) > 0) OR (SIZEOF(QUERY ( it <* sr\representation.
             items | (NOT (SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.PLACEMENT',
             'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1)) )) 
             = 0) OR (SIZEOF(QUERY ( sdr <* QUERY ( pdr <* USEDIN(sr,
             'STRUCTURAL_ANALYSIS_DESIGN.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | ((
             'STRUCTURAL_ANALYSIS_DESIGN.' + 
             'SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) ) | (NOT (
             SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.SHAPE_ASPECT',
             'STRUCTURAL_ANALYSIS_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * 
             TYPEOF(sdr.definition.definition)) = 1)) )) = 0))) )) = 0);

  END_RULE; -- subtype_mandatory_shape_representation

  RULE thickness_laminate_table_component_select FOR (
             thickness_laminate_definition, next_assembly_usage_occurrence, 
             product_related_product_category);

    LOCAL
      i     : INTEGER;
      j     : INTEGER;
      k     : INTEGER;
      nnauo : INTEGER;
      dkuhr : LOGICAL;
      rp    : product;
      nprpc : INTEGER;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i := LOINDEX(thickness_laminate_definition) TO HIINDEX(
        thickness_laminate_definition) BY 1;
      nnauo := 0;
      REPEAT j := LOINDEX(next_assembly_usage_occurrence) TO HIINDEX(
          next_assembly_usage_occurrence) BY 1;
        IF thickness_laminate_definition[i] = 
            next_assembly_usage_occurrence[j].relating_product_definition
             THEN
          rp := next_assembly_usage_occurrence[j].
              related_product_definition.formation.of_product;
          nprpc := 0;
          REPEAT k := LOINDEX(product_related_product_category) TO 
              HIINDEX(product_related_product_category) BY 1;
            IF (rp IN product_related_product_category[k].products) AND (
                product_related_product_category[k].name IN ['ply',
                'filament laminate','processed core']) THEN
              nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF nprpc = 1 THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF dkuhr = FALSE THEN
        ESCAPE;
      END_IF;
      IF nnauo <> 1 THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: dkuhr;

  END_RULE; -- thickness_laminate_table_component_select

  RULE unique_version_change_order_rule FOR (action_directive);

  WHERE
    wr1: (SIZEOF(QUERY ( ad <* action_directive | (NOT 
             unique_version_change_order(ad)) )) = 0);

  END_RULE; -- unique_version_change_order_rule

  RULE versioned_action_request_requires_status FOR (
             versioned_action_request, action_request_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(
             QUERY ( ars <* action_request_status | (ar :=: ars.
             assigned_request) )) = 1)) )) = 0);

  END_RULE; -- versioned_action_request_requires_status

  FUNCTION acyclic(
               arg1: generic_expression;
               arg2: SET OF generic_expression
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.SIMPLE_GENERIC_EXPRESSION' IN TYPEOF(
        arg1) THEN
      RETURN(TRUE);
    END_IF;
    IF arg1 IN arg2 THEN
      RETURN(FALSE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.UNARY_GENERIC_EXPRESSION' IN TYPEOF(
        arg1) THEN
      RETURN(acyclic(arg1\unary_generic_expression.operand,arg2 + [arg1]));
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.BINARY_GENERIC_EXPRESSION' IN TYPEOF(
        arg1) THEN
      RETURN(acyclic(arg1\binary_generic_expression.operands[1],arg2 + [
          arg1]) AND acyclic(arg1\binary_generic_expression.operands[2],
          arg2 + [arg1]));
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN 
        TYPEOF(arg1) THEN
      result := TRUE;
      REPEAT i := 1 TO SIZEOF(arg1\multiple_arity_generic_expression.
          operands) BY 1;
        result := result AND acyclic(arg1\
            multiple_arity_generic_expression.operands[i],arg2 + [arg1]);
      END_REPEAT;
      RETURN(result);
    END_IF;

  END_FUNCTION; -- acyclic

  FUNCTION acyclic_curve_replica(
               rep: curve_replica;
               parent: curve
      ): BOOLEAN;
    IF NOT ('STRUCTURAL_ANALYSIS_DESIGN.CURVE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;

  END_FUNCTION; -- acyclic_curve_replica

  FUNCTION acyclic_mapped_representation(
               parent_set: SET OF representation;
               children_set: SET OF representation_item
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | (
        'STRUCTURAL_ANALYSIS_DESIGN.MAPPED_ITEM' IN TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
            'STRUCTURAL_ANALYSIS_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_mapped_representation

  FUNCTION acyclic_point_replica(
               rep: point_replica;
               parent: point
      ): BOOLEAN;
    IF NOT ('STRUCTURAL_ANALYSIS_DESIGN.POINT_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
    END_IF;

  END_FUNCTION; -- acyclic_point_replica

  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category
      ): LOGICAL;

    LOCAL
      i              : INTEGER;
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,'STRUCTURAL_ANALYSIS_DESIGN.' 
        + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_category_relationship

  FUNCTION acyclic_product_definition_relationship(
               relation: product_definition_relationship;
               relatives: SET [1:?] OF product_definition;
               specific_relation: STRING
      ): LOGICAL;

    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;
    IF relation.relating_product_definition IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( pd <* bag_to_set(USEDIN(relation.
        relating_product_definition,'STRUCTURAL_ANALYSIS_DESIGN.' + 
        'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))
         | (specific_relation IN TYPEOF(pd)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_definition_relationship(x[i],relatives + 
          relation.relating_product_definition,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_definition_relationship

  FUNCTION acyclic_surface_replica(
               rep: surface_replica;
               parent: surface
      ): BOOLEAN;
    IF NOT ('STRUCTURAL_ANALYSIS_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_surface_replica(rep,parent\surface_replica.
          parent_surface));
    END_IF;

  END_FUNCTION; -- acyclic_surface_replica

  FUNCTION applied_date_correlation(
               e: applied_date_assignment
      ): BOOLEAN;

    LOCAL
      dt_role : STRING;
    END_LOCAL;
    dt_role := e\date_assignment.role.name;
    CASE dt_role OF
      'change date'          :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (
            'STRUCTURAL_ANALYSIS_DESIGN.ACTION_DIRECTIVE' IN TYPEOF(x)) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'creation date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'PRODUCT_DEFINITION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'earliest end date'    :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.RETENTION' 
            IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'latest end date'      :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.RETENTION' 
            IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'request date'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (
            'STRUCTURAL_ANALYSIS_DESIGN.VERSIONED_ACTION_REQUEST' IN 
            TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'release date'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (
            'STRUCTURAL_ANALYSIS_DESIGN.ACTION_DIRECTIVE' IN TYPEOF(x)) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'start date'           :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF([
            'STRUCTURAL_ANALYSIS_DESIGN.ACTION_DIRECTIVE',
            'STRUCTURAL_ANALYSIS_DESIGN.RETENTION'] * TYPEOF(x)) = 1) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'sign off date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'APPROVAL_PERSON_ORGANIZATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'contract date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.CONTRACT' 
            IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'certification date'   :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (
            'STRUCTURAL_ANALYSIS_DESIGN.CERTIFICATION' IN TYPEOF(x)) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'classification date'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'declassification date'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      OTHERWISE              :         RETURN(TRUE);
      END_CASE;
    RETURN(TRUE);

  END_FUNCTION; -- applied_date_correlation

  FUNCTION applied_date_time_correlation(
               e: applied_date_and_time_assignment
      ): BOOLEAN;

    LOCAL
      dt_role : STRING;
    END_LOCAL;
    dt_role := e\date_and_time_assignment.role.name;
    CASE dt_role OF
      'change date'          :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (
            'STRUCTURAL_ANALYSIS_DESIGN.ACTION_DIRECTIVE' IN TYPEOF(x)) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'creation date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'PRODUCT_DEFINITION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'earliest end date'    :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.RETENTION' 
            IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'latest end date'      :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.RETENTION' 
            IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'request date'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (
            'STRUCTURAL_ANALYSIS_DESIGN.VERSIONED_ACTION_REQUEST' IN 
            TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'release date'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (
            'STRUCTURAL_ANALYSIS_DESIGN.ACTION_DIRECTIVE' IN TYPEOF(x)) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'start date'           :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF([
            'STRUCTURAL_ANALYSIS_DESIGN.ACTION_DIRECTIVE',
            'STRUCTURAL_ANALYSIS_DESIGN.RETENTION'] * TYPEOF(x)) = 1) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'sign off date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'APPROVAL_PERSON_ORGANIZATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'contract date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.CONTRACT' 
            IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'certification date'   :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (
            'STRUCTURAL_ANALYSIS_DESIGN.CERTIFICATION' IN TYPEOF(x)) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'classification date'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'declassification date'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      OTHERWISE              :         RETURN(TRUE);
      END_CASE;
    RETURN(TRUE);

  END_FUNCTION; -- applied_date_time_correlation

  FUNCTION applied_organization_correlation(
               e: applied_organization_assignment
      ): BOOLEAN;

    LOCAL
      po_role : STRING;
    END_LOCAL;
    po_role := e\organization_assignment.role.name;
    CASE po_role OF
      'request recipient'     :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'VERSIONED_ACTION_REQUEST') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'initiator'             :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.' +
             'VERSIONED_ACTION_REQUEST',
            'STRUCTURAL_ANALYSIS_DESIGN.ACTION_DIRECTIVE'] * TYPEOF(x)) = 1) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'creator'               :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.' +
             'PRODUCT_DEFINITION_FORMATION','STRUCTURAL_ANALYSIS_DESIGN.' +
             'PRODUCT_DEFINITION'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'part supplier'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'analysis supplier'     :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'design supplier'       :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'analysis owner'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.PRODUCT' IN
             TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'design owner'          :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.PRODUCT' IN
             TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'configuration manager' :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'CONFIGURATION_ITEM') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'contractor'            :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.CONTRACT' 
            IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'classification officer'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      OTHERWISE               :         RETURN(TRUE);
      END_CASE;
    RETURN(TRUE);

  END_FUNCTION; -- applied_organization_correlation

  FUNCTION applied_person_and_organization_correlation(
               e: applied_person_and_organization_assignment
      ): BOOLEAN;

    LOCAL
      po_role : STRING;
    END_LOCAL;
    po_role := e\person_and_organization_assignment.role.name;
    CASE po_role OF
      'request recipient'     :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'VERSIONED_ACTION_REQUEST') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'initiator'             :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.' +
             'VERSIONED_ACTION_REQUEST',
            'STRUCTURAL_ANALYSIS_DESIGN.ACTION_DIRECTIVE'] * TYPEOF(x)) = 1) ))
             THEN
          RETURN(FALSE);
        END_IF;
      'creator'               :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.' +
             'PRODUCT_DEFINITION_FORMATION','STRUCTURAL_ANALYSIS_DESIGN.' +
             'PRODUCT_DEFINITION'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'part supplier'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'analysis supplier'     :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'design supplier'       :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'analysis owner'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.PRODUCT' IN
             TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'design owner'          :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.PRODUCT' IN
             TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'configuration manager' :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'CONFIGURATION_ITEM') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'contractor'            :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('STRUCTURAL_ANALYSIS_DESIGN.CONTRACT' 
            IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'classification officer'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      OTHERWISE               :         RETURN(TRUE);
      END_CASE;
    RETURN(TRUE);

  END_FUNCTION; -- applied_person_and_organization_correlation

  FUNCTION appropriate_list_value_existence(
               values: LIST [1:?] OF GENERIC;
               type_self: SET [1:?] OF STRING
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(values) BY 1;
      IF NOT appropriate_value_existence(values[i],type_self) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- appropriate_list_value_existence

  FUNCTION appropriate_set_value_existence(
               values_and_locations: SET [1:?] OF GENERIC;
               type_self: SET [1:?] OF STRING
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(values_and_locations) BY 1;
      IF NOT appropriate_value_existence(values_and_locations[i].
          simple_value,type_self) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- appropriate_set_value_existence

  FUNCTION appropriate_value_existence(
               a_value_e: GENERIC;
               type_self: SET [1:?] OF STRING
      ): BOOLEAN;

    LOCAL
      feacr        : STRING;
      value_typeof : SET [1:?] OF STRING;
    END_LOCAL;
    feacr := 'STRUCTURAL_ANALYSIS_DESIGN.';
    value_typeof := TYPEOF(a_value_e);
    IF ((feacr + 'OUTPUT_REQUEST_STATE') IN type_self) AND (NOT ((feacr + 
        'UNSPECIFIED_VALUE') IN value_typeof)) THEN
      RETURN(FALSE);
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- appropriate_value_existence

  FUNCTION assembly_shape_is_defined(
               assy: next_assembly_usage_occurrence
      ): BOOLEAN;

    LOCAL
      srr_set   : SET OF shape_representation_relationship := [];
      i         : INTEGER;
      j         : INTEGER;
      sdr_set   : SET OF shape_definition_representation := [];
      sdr_a_set : SET OF shape_definition_representation := [];
      pr1_set   : SET OF property_definition := [];
      pdrel_set : SET OF product_definition_relationship := [];
      pr2_set   : SET OF property_definition := [];
    END_LOCAL;
    pr1_set := bag_to_set(USEDIN(assy.related_product_definition,
        'STRUCTURAL_ANALYSIS_DESIGN.PROPERTY_DEFINITION.' + 'DEFINITION'));
    REPEAT i := 1 TO HIINDEX(pr1_set) BY 1;
      sdr_set := sdr_set + QUERY ( pdr <* bag_to_set(USEDIN(pr1_set[i],
          'STRUCTURAL_ANALYSIS_DESIGN.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((
          'STRUCTURAL_ANALYSIS_DESIGN.' + 'SHAPE_DEFINITION_REPRESENTATION') 
          IN TYPEOF(pdr)) );
    END_REPEAT;
    pdrel_set := bag_to_set(USEDIN(assy.related_product_definition,
        'STRUCTURAL_ANALYSIS_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP.' + 
        'RELATED_PRODUCT_DEFINITION'));
    REPEAT j := 1 TO HIINDEX(pdrel_set) BY 1;
      pr2_set := pr2_set + bag_to_set(USEDIN(pdrel_set[j],
          'STRUCTURAL_ANALYSIS_DESIGN.PROPERTY_DEFINITION.' + 'DEFINITION'));
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(pr2_set) BY 1;
      sdr_set := sdr_set + QUERY ( pdr <* bag_to_set(USEDIN(pr2_set[i],
          'STRUCTURAL_ANALYSIS_DESIGN.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((
          'STRUCTURAL_ANALYSIS_DESIGN.' + 'SHAPE_DEFINITION_REPRESENTATION') 
          IN TYPEOF(pdr)) );
    END_REPEAT;
    pr1_set := bag_to_set(USEDIN(assy.relating_product_definition,
        'STRUCTURAL_ANALYSIS_DESIGN.PROPERTY_DEFINITION.' + 'DEFINITION'));
    REPEAT i := 1 TO HIINDEX(pr1_set) BY 1;
      sdr_a_set := sdr_a_set + QUERY ( pdr <* bag_to_set(USEDIN(pr1_set[i],
          'STRUCTURAL_ANALYSIS_DESIGN.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((
          'STRUCTURAL_ANALYSIS_DESIGN.' + 'SHAPE_DEFINITION_REPRESENTATION') 
          IN TYPEOF(pdr)) );
    END_REPEAT;
    IF (SIZEOF(sdr_set) > 0) AND (SIZEOF(sdr_a_set) > 0) THEN
      REPEAT i := 1 TO HIINDEX(sdr_set) BY 1;
        srr_set := QUERY ( rr <* bag_to_set(USEDIN(sdr_set[i]\
            property_definition_representation.used_representation,
            'STRUCTURAL_ANALYSIS_DESIGN.REPRESENTATION_RELATIONSHIP.REP_2'))
             | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
            'SHAPE_REPRESENTATION_RELATIONSHIP') IN TYPEOF(rr)) );
        IF SIZEOF(srr_set) > 0 THEN
          REPEAT j := 1 TO HIINDEX(srr_set) BY 1;
            IF SIZEOF(QUERY ( pdr <* bag_to_set(USEDIN(srr_set[j]\
                representation_relationship.rep_1,
                'STRUCTURAL_ANALYSIS_DESIGN.' + 
                'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                 | (('STRUCTURAL_ANALYSIS_DESIGN.' + 
                'SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) ) * 
                sdr_a_set) >= 1 THEN
              IF SIZEOF(QUERY ( cdsr <* bag_to_set(USEDIN(srr_set[j],
                  'STRUCTURAL_ANALYSIS_DESIGN.' + 
                  'CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' + 
                  'REPRESENTATION_RELATION')) | (NOT (cdsr.
                  represented_product_relation.definition :=: assy)) )) > 0
                   THEN
                RETURN(FALSE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- assembly_shape_is_defined

  FUNCTION associated_surface(
               arg: pcurve_or_surface
      ): surface;

    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(arg) THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);

  END_FUNCTION; -- associated_surface

  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;

    LOCAL
      i       : INTEGER;
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

  END_FUNCTION; -- bag_to_set

  FUNCTION base_axis(
               dim: INTEGER;
               axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;

    LOCAL
      u      : LIST [2:3] OF direction;
      d1     : direction;
      d2     : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));
      d2 := first_proj_axis(d1,axis1);
      u := [d2,second_proj_axis(d1,d2,axis2),d1];
    ELSE
      IF EXISTS(axis1) THEN
        d1 := normalise(axis1);
        u := [d1,orthogonal_complement(d1)];
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          d1 := normalise(axis2);
          u := [orthogonal_complement(d1),d1];
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u := [dummy_gri || direction([1,0]),dummy_gri || direction([0,1])];
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

  END_FUNCTION; -- base_axis

  FUNCTION boolean_choose(
               b: BOOLEAN;
               choice1, choice2: GENERIC:item
      ): GENERIC:item;
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;

  END_FUNCTION; -- boolean_choose

  FUNCTION build_2axes(
               ref_direction: direction
      ): LIST [2:2] OF direction;

    LOCAL
      d : direction := NVL(normalise(ref_direction),dummy_gri || 
           direction([1,0]));
    END_LOCAL;
    RETURN([d,orthogonal_complement(d)]);

  END_FUNCTION; -- build_2axes

  FUNCTION build_axes(
               axis, ref_direction: direction
      ): LIST [3:3] OF direction;

    LOCAL
      d1 : direction;
      d2 : direction;
    END_LOCAL;
    d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    d2 := first_proj_axis(d1,ref_direction);
    RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);

  END_FUNCTION; -- build_axes

  FUNCTION build_direction_node(
               node_1, node_2: node_representation
      ): LIST [2:3] OF REAL;

    LOCAL
      ndim                   : INTEGER;
      i                      : INTEGER;
      u                      : direction;
      node_2_point           : cartesian_point;
      node_1_point           : cartesian_point;
      rep_items              : SET [1:?] OF representation_item;
      nodal_direction_ratios : LIST [2:3] OF REAL;
    END_LOCAL;
    rep_items := node_1.items;
    REPEAT i := 1 TO SIZEOF(rep_items) BY 1;
      IF 'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(rep_items[
          i]) THEN
        node_1_point := rep_items[i];
        ESCAPE;
      END_IF;
    END_REPEAT;
    rep_items := node_2.items;
    REPEAT i := 1 TO SIZEOF(rep_items) BY 1;
      IF 'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(rep_items[
          i]) THEN
        node_2_point := rep_items[i];
        ESCAPE;
      END_IF;
    END_REPEAT;
    ndim := HIINDEX(node_2_point.coordinates);
    REPEAT i := 1 TO ndim BY 1;
      u.direction_ratios[i] := node_2_point.coordinates[i] - node_1_point.
          coordinates[i];
    END_REPEAT;
    u := normalise(u);
    REPEAT i := 1 TO ndim BY 1;
      nodal_direction_ratios[i] := u.direction_ratios[i];
    END_REPEAT;
    RETURN(nodal_direction_ratios);

  END_FUNCTION; -- build_direction_node

  FUNCTION closed_shell_reversed(
               a_shell: closed_shell
      ): oriented_closed_shell;

    LOCAL
      the_reverse : oriented_closed_shell;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(
        a_shell) THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell\oriented_closed_shell.
          closed_shell_element,NOT a_shell\oriented_closed_shell.
          orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- closed_shell_reversed

  FUNCTION conditional_reverse(
               p: BOOLEAN;
               an_item: reversible_topology
      ): reversible_topology;
    IF p THEN
      RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;

  END_FUNCTION; -- conditional_reverse

  FUNCTION consistent_element_or_group_reference(
               aspect, element: GENERIC
      ): BOOLEAN;

    LOCAL
      i    : INTEGER;
      srrs : STRING;
    END_LOCAL;
    srrs := 'STRUCTURAL_ANALYSIS_DESIGN.';
    IF (srrs + 'ELEMENT_REPRESENTATION') IN TYPEOF(element) THEN
      RETURN(consistent_element_reference(aspect,element));
    END_IF;
    IF (srrs + 'ELEMENT_GROUP') IN TYPEOF(element) THEN
      REPEAT i := 1 TO HIINDEX(element.elements) BY 1;
        IF NOT consistent_element_reference(aspect,element.elements[i])
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- consistent_element_or_group_reference

  FUNCTION consistent_element_reference(
               aspect: GENERIC;
               element: element_representation
      ): BOOLEAN;

    LOCAL
      element_type : SET [1:?] OF STRING;
      feacr        : STRING;
      srrs         : STRING;
      aspect_type  : SET [1:?] OF STRING;
    END_LOCAL;
    srrs := 'STRUCTURAL_ANALYSIS_DESIGN.';
    feacr := 'STRUCTURAL_ANALYSIS_DESIGN.';
    aspect_type := TYPEOF(aspect);
    element_type := TYPEOF(element);
    IF (srrs + 'ELEMENT_REPRESENTATION') IN element_type THEN
      IF (srrs + 'ELEMENT_VOLUME') IN aspect_type THEN
        RETURN(TRUE);
      END_IF;
    END_IF;
    IF (srrs + 'VOLUME_3D_ELEMENT_REPRESENTATION') IN element_type THEN
      IF ((feacr + 'VOLUME_3D_FACE') IN aspect_type) OR ((feacr + 
          'VOLUME_3D_EDGE') IN aspect_type) THEN
        RETURN(TRUE);
      END_IF;
    END_IF;
    IF ((srrs + 'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION') IN 
        element_type) OR ((srrs + 'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION') 
        IN element_type) THEN
      IF ((feacr + 'VOLUME_2D_FACE') IN aspect_type) OR ((feacr + 
          'VOLUME_2D_EDGE') IN aspect_type) THEN
        RETURN(TRUE);
      END_IF;
    END_IF;
    IF (srrs + 'SURFACE_3D_ELEMENT_REPRESENTATION') IN element_type THEN
      IF ((feacr + 'SURFACE_3D_FACE') IN aspect_type) OR ((feacr + 
          'SURFACE_3D_EDGE') IN aspect_type) THEN
        RETURN(TRUE);
      END_IF;
    END_IF;
    IF ((srrs + 'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION') IN 
        element_type) OR ((srrs + 'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION') 
        IN element_type) THEN
      IF ((feacr + 'SURFACE_2D_FACE') IN aspect_type) OR ((feacr + 
          'SURFACE_2D_EDGE') IN aspect_type) THEN
        RETURN(TRUE);
      END_IF;
    END_IF;
    IF ((srrs + 'CURVE_3D_ELEMENT_REPRESENTATION') IN element_type) OR ((
        srrs + 'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION') IN 
        element_type) OR ((srrs + 'PLANE_CURVE_2D_ELEMENT_REPRESENTATION') 
        IN element_type) THEN
      IF (srrs + 'CURVE_EDGE') IN aspect_type THEN
        RETURN(TRUE);
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- consistent_element_reference

  FUNCTION consistent_geometric_reference(
               aspect: GENERIC;
               item: geometric_representation_item
      ): BOOLEAN;

    LOCAL
      item_type   : SET [1:?] OF STRING;
      feacr       : STRING;
      srrs        : STRING;
      aspect_type : SET [1:?] OF STRING;
    END_LOCAL;
    srrs := 'STRUCTURAL_ANALYSIS_DESIGN.';
    feacr := 'STRUCTURAL_ANALYSIS_DESIGN.';
    aspect_type := TYPEOF(aspect);
    item_type := TYPEOF(item);
    IF 'STRUCTURAL_ANALYSIS_DESIGN.SOLID_MODEL' IN item_type THEN
      IF (srrs + 'ELEMENT_VOLUME') IN aspect_type THEN
        RETURN(TRUE);
      END_IF;
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.SURFACE' IN item_type) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.FACE_SURFACE' IN item_type) THEN
      IF SIZEOF([feacr + 'VOLUME_3D_FACE',feacr + 'VOLUME_2D_FACE',feacr +
           'SURFACE_3D_FACE',feacr + 'SURFACE_2D_FACE'] * aspect_type) = 1
           THEN
        RETURN(TRUE);
      END_IF;
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.CURVE' IN item_type) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.EDGE_CURVE' IN item_type) THEN
      IF SIZEOF([feacr + 'VOLUME_3D_EDGE',feacr + 'VOLUME_2D_EDGE',feacr +
           'SURFACE_3D_EDGE',feacr + 'SURFACE_2D_EDGE',srrs + 'CURVE_EDGE'] 
          * aspect_type) = 1 THEN
        RETURN(TRUE);
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- consistent_geometric_reference

  FUNCTION consistent_list_values(
               values: LIST [1:?] OF field_value;
               variable: GENERIC
      ): BOOLEAN;

    LOCAL
      fv_type : SET [1:?] OF STRING;
      i       : INTEGER;
      vv_type : STRING;
    END_LOCAL;
    vv_type := variable_value_type(variable);
    REPEAT i := 1 TO HIINDEX(values) BY 1;
      fv_type := TYPEOF(values[i]);
      IF NOT (('STRUCTURAL_ANALYSIS_DESIGN.' + 'UNSPECIFIED_VALUE') IN 
          fv_type) THEN
        IF NOT (vv_type IN fv_type) THEN
          RETURN(FALSE);
        END_IF;
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- consistent_list_values

  FUNCTION consistent_set_values(
               values_and_locations: SET [1:?] OF GENERIC;
               variable: GENERIC
      ): BOOLEAN;

    LOCAL
      fv_type : SET [1:?] OF STRING;
      i       : INTEGER;
      vv_type : STRING;
    END_LOCAL;
    vv_type := variable_value_type(variable);
    REPEAT i := 1 TO HIINDEX(values_and_locations) BY 1;
      fv_type := TYPEOF(values_and_locations[i].simple_value);
      IF NOT (('STRUCTURAL_ANALYSIS_DESIGN.' + 'UNSPECIFIED_VALUE') IN 
          fv_type) THEN
        IF NOT (vv_type IN fv_type) THEN
          RETURN(FALSE);
        END_IF;
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- consistent_set_values

  FUNCTION consistent_value(
               c_value: field_value;
               variable: GENERIC
      ): BOOLEAN;

    LOCAL
      fv_type : SET [1:?] OF STRING;
      vv_type : STRING;
    END_LOCAL;
    vv_type := variable_value_type(variable);
    fv_type := TYPEOF(c_value);
    IF NOT (('STRUCTURAL_ANALYSIS_DESIGN.' + 'UNSPECIFIED_VALUE') IN 
        fv_type) THEN
      IF NOT (vv_type IN fv_type) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- consistent_value

  FUNCTION constraints_composite_curve_on_surface(
               c: composite_curve_on_surface
      ): BOOLEAN;

    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) AND (NOT (
          'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_CURVE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) AND (NOT (
          'STRUCTURAL_ANALYSIS_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN 
          TYPEOF(c\composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_composite_curve_on_surface

  FUNCTION constraints_geometry_shell_based_surface_model(
               m: shell_based_surface_model
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
      IF (NOT ('STRUCTURAL_ANALYSIS_DESIGN.OPEN_SHELL' IN TYPEOF(m.
          sbsm_boundary[j]))) AND (NOT (
          'STRUCTURAL_ANALYSIS_DESIGN.CLOSED_SHELL' IN TYPEOF(m.
          sbsm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_geometry_shell_based_surface_model

  FUNCTION constraints_geometry_shell_based_wireframe_model(
               m: shell_based_wireframe_model
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
      IF (NOT ('STRUCTURAL_ANALYSIS_DESIGN.WIRE_SHELL' IN TYPEOF(m.
          sbwm_boundary[j]))) AND (NOT (
          'STRUCTURAL_ANALYSIS_DESIGN.VERTEX_SHELL' IN TYPEOF(m.
          sbwm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

  FUNCTION constraints_param_b_spline(
               degree, up_knots, up_cp: INTEGER;
               knot_mult: LIST OF INTEGER;
               knots: LIST OF parameter_value
      ): BOOLEAN;

    LOCAL
      k      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (
        degree + up_cp + 2)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k < 1) OR (k > (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i < up_knots) AND (k > degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k > (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_param_b_spline

  FUNCTION constraints_rectangular_composite_surface(
               s: rectangular_composite_surface
      ): BOOLEAN;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF NOT (('STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s
            .segments[i][j].parent_surface)) OR (
            'STRUCTURAL_ANALYSIS_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN 
            TYPEOF(s.segments[i][j].parent_surface))) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u - 1 BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF s.segments[i][j].u_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v - 1 BY 1;
        IF s.segments[i][j].v_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_rectangular_composite_surface

  FUNCTION cross_product(
               arg1, arg2: direction
      ): vector;

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(
            v1[3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[
            1])]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(arg1,0);
        END_IF;
        RETURN(result);
      END;
    END_IF;

  END_FUNCTION; -- cross_product

  FUNCTION curve_weights_positive(
               b: rational_b_spline_curve
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] <= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- curve_weights_positive

  FUNCTION derive_angle(
               placement_1, placement_2: axis2_placement_3d
      ): plane_angle_measure;

    LOCAL
      v2     : direction;
      v1     : direction;
      mag_v2 : REAL;
      mag_v1 : REAL;
      theta  : plane_angle_measure;
    END_LOCAL;
    v1 := placement_1.p[1];
    v2 := placement_2.p[1];
    mag_v1 := SQRT((v1.direction_ratios[1] * v1.direction_ratios[1]) + (v1
        .direction_ratios[2] * v1.direction_ratios[2]));
    mag_v2 := SQRT((v2.direction_ratios[1] * v2.direction_ratios[1]) + (v2
        .direction_ratios[2] * v2.direction_ratios[2]));
    IF (mag_v1 = 0) OR (mag_v2 = 0) THEN
      theta := 0;
      RETURN(theta);
    END_IF;
    theta := ACOS(((v1.direction_ratios[1] * v2.direction_ratios[1]) + (v1
        .direction_ratios[2] * v2.direction_ratios[2])) / (mag_v1 * mag_v2));
    RETURN(theta);

  END_FUNCTION; -- derive_angle

  FUNCTION derive_dimensional_exponents(
               x: unit
      ): dimensional_exponents;

    LOCAL
      i      : INTEGER;
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- derive_dimensional_exponents

  FUNCTION dimension_of(
               item: geometric_representation_item
      ): dimension_count;

    LOCAL
      x   : SET OF representation;
      y   : representation_context;
      dim : dimension_count;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(item) THEN
      dim := SIZEOF(item\cartesian_point.coordinates);
      RETURN(dim);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.DIRECTION' IN TYPEOF(item) THEN
      dim := SIZEOF(item\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.VECTOR' IN TYPEOF(item) THEN
      dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    x := using_representations(item);
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN(dim);

  END_FUNCTION; -- dimension_of

  FUNCTION dimensions_for_si_unit(
               n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      END_CASE;

  END_FUNCTION; -- dimensions_for_si_unit

  FUNCTION dot_product(
               arg1, arg2: direction
      ): REAL;

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);

  END_FUNCTION; -- dot_product

  FUNCTION edge_reversed(
               an_edge: edge
      ): oriented_edge;

    LOCAL
      the_reverse : oriented_edge;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge\oriented_edge.edge_element,NOT an_edge\
          oriented_edge.orientation);
    ELSE
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- edge_reversed

  FUNCTION face_bound_reversed(
               a_face_bound: face_bound
      ): face_bound;

    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(
        a_face_bound) THEN
      the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
          NOT a_face_bound\face_bound.orientation) || face_outer_bound();
    ELSE
      the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT 
          a_face_bound.orientation);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_bound_reversed

  FUNCTION face_reversed(
               a_face: face
      ): oriented_face;

    LOCAL
      the_reverse : oriented_face;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face\oriented_face.face_element,NOT 
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_reversed

  FUNCTION first_proj_axis(
               z_axis, arg: direction
      ): direction;

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN
      RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios <> [1,0,0] THEN
          v := dummy_gri || direction([1,0,0]);
        ELSE
          v := dummy_gri || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim <> 3 THEN
          RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

  END_FUNCTION; -- first_proj_axis

  FUNCTION gbsf_check_curve(
               cv: representation_item
      ): BOOLEAN;
    IF SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.BOUNDED_CURVE',
        'STRUCTURAL_ANALYSIS_DESIGN.CONIC',
        'STRUCTURAL_ANALYSIS_DESIGN.CURVE_REPLICA',
        'STRUCTURAL_ANALYSIS_DESIGN.LINE',
        'STRUCTURAL_ANALYSIS_DESIGN.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1
         THEN
      RETURN(FALSE);
    END_IF;
    IF SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.CIRCLE',
        'STRUCTURAL_ANALYSIS_DESIGN.ELLIPSE',
        'STRUCTURAL_ANALYSIS_DESIGN.TRIMMED_CURVE'] * TYPEOF(cv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (('STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND 
          (cv\b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve
          .self_intersect = UNKNOWN) THEN
        RETURN(TRUE);
      ELSE
        IF (('STRUCTURAL_ANALYSIS_DESIGN.COMPOSITE_CURVE' IN TYPEOF(cv)) 
            AND (cv\composite_curve.self_intersect = FALSE)) OR (cv\
            composite_curve.self_intersect = UNKNOWN) THEN
          RETURN(SIZEOF(QUERY ( seg <* cv\composite_curve.segments | (NOT 
              gbsf_check_curve(seg.parent_curve)) )) = 0);
        ELSE
          IF 'STRUCTURAL_ANALYSIS_DESIGN.CURVE_REPLICA' IN TYPEOF(cv)
               THEN
            RETURN(gbsf_check_curve(cv\curve_replica.parent_curve));
          ELSE
            IF ('STRUCTURAL_ANALYSIS_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) 
                AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
                offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
                'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE' IN TYPEOF(cv\
                offset_curve_3d.basis_curve))) THEN
              RETURN(gbsf_check_curve(cv\offset_curve_3d.basis_curve));
            ELSE
              IF 'STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(cv) THEN
                RETURN(gbsf_check_curve(cv\pcurve.reference_to_curve\
                    representation.items[1]) AND gbsf_check_surface(cv\
                    pcurve.basis_surface));
              ELSE
                IF 'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE' IN TYPEOF(cv)
                     THEN
                  IF SIZEOF(cv\polyline.points) >= 3 THEN
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF 'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_CURVE' IN TYPEOF(
                      cv) THEN
                    IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                      REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                          associated_geometry) BY 1;
                        IF 'STRUCTURAL_ANALYSIS_DESIGN.SURFACE' IN TYPEOF(
                            cv\surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_surface(cv\surface_curve.
                              associated_geometry[i]) THEN
                            RETURN(FALSE);
                          END_IF;
                        ELSE
                          IF 'STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN 
                              TYPEOF(cv\surface_curve.associated_geometry[i])
                               THEN
                            IF NOT gbsf_check_curve(cv\surface_curve.
                                associated_geometry[i]) THEN
                              RETURN(FALSE);
                            END_IF;
                          END_IF;
                        END_IF;
                      END_REPEAT;
                      RETURN(TRUE);
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- gbsf_check_curve

  FUNCTION gbsf_check_point(
               pnt: point
      ): BOOLEAN;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
        RETURN(gbsf_check_curve(pnt\point_on_curve.basis_curve));
      ELSE
        IF 'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_SURFACE' IN TYPEOF(pnt)
             THEN
          RETURN(gbsf_check_surface(pnt\point_on_surface.basis_surface));
        ELSE
          IF 'STRUCTURAL_ANALYSIS_DESIGN.DEGENERATE_PCURVE' IN TYPEOF(pnt)
               THEN
            RETURN(gbsf_check_curve(pnt\degenerate_pcurve.
                reference_to_curve\representation.items[1]) AND 
                gbsf_check_surface(pnt\degenerate_pcurve.basis_surface));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- gbsf_check_point

  FUNCTION gbsf_check_surface(
               sf: surface
      ): BOOLEAN;
    IF (('STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND 
        (sf\b_spline_surface.self_intersect = FALSE)) OR (sf\
        b_spline_surface.self_intersect = UNKNOWN) THEN
      RETURN(TRUE);
    ELSE
      IF SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.SPHERICAL_SURFACE',
          'STRUCTURAL_ANALYSIS_DESIGN.TOROIDAL_SURFACE',
          'STRUCTURAL_ANALYSIS_DESIGN.CURVE_BOUNDED_SURFACE',
          'STRUCTURAL_ANALYSIS_DESIGN.RECTANGULAR_TRIMMED_SURFACE'] * 
          TYPEOF(sf)) = 1 THEN
        RETURN(TRUE);
      ELSE
        IF (('STRUCTURAL_ANALYSIS_DESIGN.OFFSET_SURFACE' IN TYPEOF(sf)) 
            AND (sf\offset_surface.self_intersect = FALSE)) OR (sf\
            offset_surface.self_intersect = UNKNOWN) THEN
          RETURN(gbsf_check_surface(sf\offset_surface.basis_surface));
        ELSE
          IF 'STRUCTURAL_ANALYSIS_DESIGN.RECTANGULAR_COMPOSITE_SURFACE' IN
               TYPEOF(sf) THEN
            REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.
                segments) BY 1;
              REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.
                  segments[i]) BY 1;
                IF NOT gbsf_check_surface(sf\rectangular_composite_surface
                    .segments[i][j].parent_surface) THEN
                  RETURN(FALSE);
                END_IF;
              END_REPEAT;
            END_REPEAT;
            RETURN(TRUE);
          ELSE
            IF 'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_REPLICA' IN TYPEOF(sf)
                 THEN
              RETURN(gbsf_check_surface(sf\surface_replica.parent_surface));
            ELSE
              IF 'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_OF_REVOLUTION' IN 
                  TYPEOF(sf) THEN
                RETURN(gbsf_check_curve(sf\swept_surface.swept_curve));
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- gbsf_check_surface

  FUNCTION get_basis_surface(
               c: curve_on_surface
      ): SET [0:2] OF surface;

    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
         THEN
      n := SIZEOF(c\composite_curve.segments);
      surfs := get_basis_surface(c\composite_curve.segments[1].
          parent_curve);
      IF n > 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve.segments[i]
              .parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);

  END_FUNCTION; -- get_basis_surface

  FUNCTION is_acyclic(
               arg: generic_expression
      ): BOOLEAN;
    RETURN(acyclic(arg,[]));

  END_FUNCTION; -- is_acyclic

  FUNCTION is_int_expr(
               arg: numeric_expression
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.INT_LITERAL' IN TYPEOF(arg) THEN
      RETURN(TRUE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.REAL_LITERAL' IN TYPEOF(arg) THEN
      RETURN(FALSE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.INT_NUMERIC_VARIABLE' IN TYPEOF(arg)
         THEN
      RETURN(TRUE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg)
         THEN
      RETURN(FALSE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.ABS_FUNCTION' IN TYPEOF(arg) THEN
      RETURN(is_int_expr(arg\unary_numeric_expression.operand));
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.MINUS_FUNCTION' IN TYPEOF(arg) THEN
      RETURN(is_int_expr(arg\unary_numeric_expression.operand));
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.SIN_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.COS_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.TAN_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.ASIN_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.ACOS_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.ATAN_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.EXP_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.LOG_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.LOG2_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.LOG10_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg))
         THEN
      RETURN(FALSE);
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.PLUS_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.MULT_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.MINIMUM_FUNCTION' IN TYPEOF(arg)) THEN
      REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.
          operands) BY 1;
        IF NOT is_int_expr(arg\multiple_arity_numeric_expression.operands[
            i]) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.MINUS_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.POWER_EXPRESSION' IN TYPEOF(arg)) THEN
      RETURN(is_int_expr(arg\binary_numeric_expression.operands[1]) AND 
          is_int_expr(arg\binary_numeric_expression.operands[2]));
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.DIV_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.MOD_EXPRESSION' IN TYPEOF(arg)) THEN
      RETURN(TRUE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.SLASH_EXPRESSION' IN TYPEOF(arg) THEN
      RETURN(FALSE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.LENGTH_FUNCTION' IN TYPEOF(arg) THEN
      RETURN(TRUE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.VALUE_FUNCTION' IN TYPEOF(arg) THEN
      IF 'STRUCTURAL_ANALYSIS_DESIGN.INT_VALUE_FUNCTION' IN TYPEOF(arg)
           THEN
        RETURN(TRUE);
      ELSE
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.INTEGER_DEFINED_FUNCTION' IN TYPEOF(arg)
         THEN
      RETURN(TRUE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.REAL_DEFINED_FUNCTION' IN TYPEOF(arg)
         THEN
      RETURN(FALSE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg)
         THEN
      RETURN(FALSE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.STRING_DEFINED_FUNCTION' IN TYPEOF(arg)
         THEN
      RETURN(FALSE);
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- is_int_expr

  FUNCTION is_sql_mappable(
               arg: expression
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.SIMPLE_NUMERIC_EXPRESSION' IN TYPEOF(
        arg) THEN
      RETURN(TRUE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.SQL_MAPPABLE_DEFINED_FUNCTION' IN 
        TYPEOF(arg) THEN
      RETURN(TRUE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.MINUS_FUNCTION' IN TYPEOF(arg) THEN
      RETURN(is_sql_mappable(arg\unary_numeric_expression.operand));
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.ABS_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.SIN_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.COS_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.TAN_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.ASIN_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.ACOS_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.ATAN_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.EXP_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.LOG_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.LOG2_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.LOG10_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg)) 
        OR ('STRUCTURAL_ANALYSIS_DESIGN.VALUE_FUNCTION' IN TYPEOF(arg)) OR 
        ('STRUCTURAL_ANALYSIS_DESIGN.LENGTH_FUNCTION' IN TYPEOF(arg)) THEN
      RETURN(FALSE);
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.PLUS_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.MULT_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.MINIMUM_FUNCTION' IN TYPEOF(arg)) THEN
      REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.
          operands) BY 1;
        IF NOT is_sql_mappable(arg\multiple_arity_numeric_expression.
            operands[i]) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.MINUS_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.SLASH_EXPRESSION' IN TYPEOF(arg)) THEN
      RETURN(is_sql_mappable(arg\binary_numeric_expression.operands[1]) 
          AND is_sql_mappable(arg\binary_numeric_expression.operands[2]));
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.DIV_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.MOD_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.POWER_EXPRESSION' IN TYPEOF(arg)) THEN
      RETURN(FALSE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.SIMPLE_BOOLEAN_EXPRESSION' IN TYPEOF(
        arg) THEN
      RETURN(TRUE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.NOT_EXPRESSION' IN TYPEOF(arg) THEN
      RETURN(is_sql_mappable(arg\unary_generic_expression.operand));
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.ODD_FUNCTION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.XOR_EXPRESSION' IN TYPEOF(arg)) THEN
      RETURN(FALSE);
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.AND_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.OR_EXPRESSION' IN TYPEOF(arg)) THEN
      REPEAT i := 1 TO SIZEOF(arg\multiple_arity_boolean_expression.
          operands) BY 1;
        IF NOT is_sql_mappable(arg\multiple_arity_boolean_expression.
            operands[i]) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
      RETURN(TRUE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.EQUALS_EXPRESSION' IN TYPEOF(arg) THEN
      RETURN(is_sql_mappable(arg\binary_generic_expression.operands[1]) 
          AND is_sql_mappable(arg\binary_generic_expression.operands[2]));
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.COMPARISON_EQUAL' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.COMPARISON_GREATER' IN TYPEOF(arg)) OR 
        ('STRUCTURAL_ANALYSIS_DESIGN.COMPARISON_GREATER_EQUAL' IN TYPEOF(
        arg)) OR ('STRUCTURAL_ANALYSIS_DESIGN.COMPARISON_LESS' IN TYPEOF(
        arg)) OR ('STRUCTURAL_ANALYSIS_DESIGN.COMPARISON_LESS_EQUAL' IN 
        TYPEOF(arg)) OR ('STRUCTURAL_ANALYSIS_DESIGN.COMPARISON_NOT_EQUAL' 
        IN TYPEOF(arg)) OR ('STRUCTURAL_ANALYSIS_DESIGN.LIKE_EXPRESSION' IN
         TYPEOF(arg)) THEN
      RETURN(is_sql_mappable(arg\comparison_expression.operands[1]) AND 
          is_sql_mappable(arg\comparison_expression.operands[2]));
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.INTERVAL_EXPRESSION' IN TYPEOF(arg)
         THEN
      RETURN(is_sql_mappable(arg\interval_expression.interval_low) AND 
          is_sql_mappable(arg\interval_expression.interval_high) AND 
          is_sql_mappable(arg\interval_expression.interval_item));
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.NUMERIC_DEFINED_FUNCTION' IN TYPEOF(
        arg)) OR ('STRUCTURAL_ANALYSIS_DESIGN.BOOLEAN_DEFINED_FUNCTION' IN 
        TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.STRING_DEFINED_FUNCTION' IN TYPEOF(arg))
         THEN
      RETURN(FALSE);
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.SIMPLE_STRING_EXPRESSION' IN TYPEOF(arg)
         THEN
      RETURN(TRUE);
    END_IF;
    IF ('STRUCTURAL_ANALYSIS_DESIGN.INDEX_EXPRESSION' IN TYPEOF(arg)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.SUBSTRING_EXPRESSION' IN TYPEOF(arg)) 
        OR ('STRUCTURAL_ANALYSIS_DESIGN.CONCAT_EXPRESSION' IN TYPEOF(arg)) 
        OR ('STRUCTURAL_ANALYSIS_DESIGN.FORMAT_FUNCTION' IN TYPEOF(arg))
         THEN
      RETURN(FALSE);
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- is_sql_mappable

  FUNCTION item_in_context(
               item: representation_item;
               cntxt: representation_context
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,
        'STRUCTURAL_ANALYSIS_DESIGN.REPRESENTATION.ITEMS') * cntxt.
        representations_in_context) > 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | (
          'STRUCTURAL_ANALYSIS_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- item_in_context

  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- leap_year

  FUNCTION list_face_loops(
               f: face
      ): LIST [0:?] OF loop;

    LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);

  END_FUNCTION; -- list_face_loops

  FUNCTION list_of_topology_reversed(
               a_list: list_of_reversible_topology_item
      ): list_of_reversible_topology_item;

    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- list_of_topology_reversed

  FUNCTION list_to_array(
               lis: LIST [0:?] OF GENERIC:t;
               low, u: INTEGER
      ): ARRAY [low:u] OF GENERIC:t;

    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n <> ((u - low) + 1) THEN
      RETURN(?);
    ELSE
      res := [lis[1],n];
      REPEAT i := 2 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;

  END_FUNCTION; -- list_to_array

  FUNCTION list_to_set(
               l: LIST [0:?] OF GENERIC:t
      ): SET OF GENERIC:t;

    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);

  END_FUNCTION; -- list_to_set

  FUNCTION make_array_of_array(
               lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1, u1, low2, u2: INTEGER
      ): ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;

    LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN
      RETURN(?);
    END_IF;
    IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN
      RETURN(?);
    END_IF;
    res := [list_to_array(lis[1],low2,u2),(u1 - low1) + 1];
    REPEAT i := 2 TO HIINDEX(lis) BY 1;
      IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN
        RETURN(?);
      END_IF;
      res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    RETURN(res);

  END_FUNCTION; -- make_array_of_array

  FUNCTION mixed_loop_type_set(
               l: SET [0:?] OF loop
      ): LOGICAL;

    LOCAL
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) <= 1 THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := 'STRUCTURAL_ANALYSIS_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('STRUCTURAL_ANALYSIS_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) <> 
          poly_loop_type THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);

  END_FUNCTION; -- mixed_loop_type_set

  FUNCTION msb_shells(
               brep: manifold_solid_brep
      ): SET [1:?] OF closed_shell;
    IF SIZEOF(QUERY ( msbtype <* TYPEOF(brep) | (msbtype LIKE 
        '*BREP_WITH_VOIDS') )) >= 1 THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;

  END_FUNCTION; -- msb_shells

  FUNCTION msf_curve_check(
               cv: representation_item
      ): BOOLEAN;
    IF SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.BOUNDED_CURVE',
        'STRUCTURAL_ANALYSIS_DESIGN.CONIC',
        'STRUCTURAL_ANALYSIS_DESIGN.CURVE_REPLICA',
        'STRUCTURAL_ANALYSIS_DESIGN.LINE',
        'STRUCTURAL_ANALYSIS_DESIGN.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1
         THEN
      RETURN(FALSE);
    END_IF;
    IF (('STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (
        cv\b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve.
        self_intersect = UNKNOWN) THEN
      RETURN(TRUE);
    ELSE
      IF SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.CONIC',
          'STRUCTURAL_ANALYSIS_DESIGN.LINE'] * TYPEOF(cv)) = 1 THEN
        RETURN(TRUE);
      ELSE
        IF 'STRUCTURAL_ANALYSIS_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN
          RETURN(msf_curve_check(cv\curve_replica.parent_curve));
        ELSE
          IF ('STRUCTURAL_ANALYSIS_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) 
              AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
              offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
              'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE' IN TYPEOF(cv\
              offset_curve_3d.basis_curve))) THEN
            RETURN(msf_curve_check(cv\offset_curve_3d.basis_curve));
          ELSE
            IF 'STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(cv) THEN
              RETURN(msf_curve_check(cv\pcurve.reference_to_curve\
                  representation.items[1]) AND msf_surface_check(cv\pcurve.
                  basis_surface));
            ELSE
              IF 'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_CURVE' IN TYPEOF(cv)
                   THEN
                IF msf_curve_check(cv\surface_curve.curve_3d) THEN
                  REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                      associated_geometry) BY 1;
                    IF 'STRUCTURAL_ANALYSIS_DESIGN.SURFACE' IN TYPEOF(cv\
                        surface_curve.associated_geometry[i]) THEN
                      IF NOT msf_surface_check(cv\surface_curve.
                          associated_geometry[i]) THEN
                        RETURN(FALSE);
                      END_IF;
                    ELSE
                      IF 'STRUCTURAL_ANALYSIS_DESIGN.PCURVE' IN TYPEOF(cv\
                          surface_curve.associated_geometry[i]) THEN
                        IF NOT msf_curve_check(cv\surface_curve.
                            associated_geometry[i]) THEN
                          RETURN(FALSE);
                        END_IF;
                      END_IF;
                    END_IF;
                  END_REPEAT;
                  RETURN(TRUE);
                END_IF;
              ELSE
                IF 'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE' IN TYPEOF(cv)
                     THEN
                  IF SIZEOF(cv\polyline.points) >= 3 THEN
                    RETURN(TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- msf_curve_check

  FUNCTION msf_surface_check(
               surf: surface
      ): BOOLEAN;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(surf)
         THEN
      RETURN(TRUE);
    ELSE
      IF 'STRUCTURAL_ANALYSIS_DESIGN.SWEPT_SURFACE' IN TYPEOF(surf) THEN
        RETURN(msf_curve_check(surf\swept_surface.swept_curve));
      ELSE
        IF (('STRUCTURAL_ANALYSIS_DESIGN.OFFSET_SURFACE' IN TYPEOF(surf)) 
            AND (surf\offset_surface.self_intersect = FALSE)) OR (surf\
            offset_surface.self_intersect = UNKNOWN) THEN
          RETURN(msf_surface_check(surf\offset_surface.basis_surface));
        ELSE
          IF 'STRUCTURAL_ANALYSIS_DESIGN.SURFACE_REPLICA' IN TYPEOF(surf)
               THEN
            RETURN(msf_surface_check(surf\surface_replica.parent_surface));
          ELSE
            IF (('STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(
                surf)) AND (surf\b_spline_surface.self_intersect = FALSE)) 
                OR (surf\b_spline_surface.self_intersect = UNKNOWN) THEN
              RETURN(TRUE);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- msf_surface_check

  FUNCTION necessary_value_coordinate_system(
               cs_value: field_value;
               coordinate_system: GENERIC
      ): BOOLEAN;
    IF SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.TENSOR1_2D',
        'STRUCTURAL_ANALYSIS_DESIGN.TENSOR1_3D',
        'STRUCTURAL_ANALYSIS_DESIGN.SYMMETRIC_TENSOR2_2D',
        'STRUCTURAL_ANALYSIS_DESIGN.SYMMETRIC_TENSOR2_3D'] * TYPEOF(
        cs_value)) = 1 THEN
      IF NOT EXISTS(coordinate_system) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- necessary_value_coordinate_system

  FUNCTION normalise(
               arg: vector_or_direction
      ): vector_or_direction;

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      result := ?;
    ELSE
      ndim := arg.dim;
      IF 'STRUCTURAL_ANALYSIS_DESIGN.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          v := dummy_gri || direction(arg.orientation.direction_ratios);
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec := dummy_gri || vector(v,1);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction(arg.direction_ratios);
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'STRUCTURAL_ANALYSIS_DESIGN.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- normalise

  FUNCTION number_of_terms(
               node_dof_list: LIST [1:?] OF LIST [1:?] OF
                    degree_of_freedom;
               matrix_type: matrix_symmetry
      ): INTEGER;

    LOCAL
      num_terms          : INTEGER;
      number_of_freedoms : INTEGER;
    END_LOCAL;
    number_of_freedoms := 0;
    REPEAT i := 1 TO SIZEOF(node_dof_list) BY 1;
      number_of_freedoms := number_of_freedoms + SIZEOF(node_dof_list[i]);
    END_REPEAT;
    IF matrix_type = symmetric THEN
      num_terms := (number_of_freedoms * (number_of_freedoms + 1)) DIV 2;
    END_IF;
    IF matrix_type = diagonal THEN
      num_terms := number_of_freedoms;
    END_IF;
    RETURN(num_terms);

  END_FUNCTION; -- number_of_terms

  FUNCTION open_shell_reversed(
               a_shell: open_shell
      ): oriented_open_shell;

    LOCAL
      the_reverse : oriented_open_shell;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- open_shell_reversed

  FUNCTION orthogonal_complement(
               vec: direction
      ): direction;

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result := dummy_gri || direction([-vec.direction_ratios[2],vec.
          direction_ratios[1]]);
      RETURN(result);
    END_IF;

  END_FUNCTION; -- orthogonal_complement

  FUNCTION path_head_to_tail(
               a_path: path
      ): LOGICAL;

    LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);

  END_FUNCTION; -- path_head_to_tail

  FUNCTION path_reversed(
               a_path: path
      ): oriented_path;

    LOCAL
      the_reverse : oriented_path;
    END_LOCAL;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path\oriented_path.path_element,
          NOT a_path\oriented_path.orientation);
    ELSE
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- path_reversed

  FUNCTION required_0d_nodes(
               node_list: LIST [1:?] OF node_representation
      ): BOOLEAN;
    RETURN(SIZEOF(node_list) = 1);

  END_FUNCTION; -- required_0d_nodes

  FUNCTION required_1d_nodes(
               node_list: LIST [1:?] OF node_representation;
               order: element_order
      ): BOOLEAN;

    LOCAL
      end_nodes        : INTEGER;
      additional_nodes : INTEGER;
    END_LOCAL;
    end_nodes := 2;
    IF order = linear THEN
      additional_nodes := 0;
    END_IF;
    IF order = quadratic THEN
      additional_nodes := 1;
    END_IF;
    IF order = cubic THEN
      additional_nodes := 2;
    END_IF;
    RETURN(SIZEOF(node_list) = (end_nodes + additional_nodes));

  END_FUNCTION; -- required_1d_nodes

  FUNCTION required_2d_nodes(
               node_list: LIST [1:?] OF node_representation;
               element_shape: element_2d_shape;
               order: element_order
      ): BOOLEAN;

    LOCAL
      vertex_nodes         : INTEGER;
      edge_face_body_nodes : INTEGER;
      edge_nodes           : INTEGER;
    END_LOCAL;
    IF element_shape = triangle THEN
      vertex_nodes := 3;
      IF order = linear THEN
        edge_nodes := 0;
        edge_face_body_nodes := 0;
      END_IF;
      IF order = quadratic THEN
        edge_nodes := 3;
        edge_face_body_nodes := 3;
      END_IF;
      IF order = cubic THEN
        edge_nodes := 6;
        edge_face_body_nodes := 7;
      END_IF;
    END_IF;
    IF element_shape = quadrilateral THEN
      vertex_nodes := 4;
      IF order = linear THEN
        edge_nodes := 0;
        edge_face_body_nodes := 0;
      END_IF;
      IF order = quadratic THEN
        edge_nodes := 4;
        edge_face_body_nodes := 5;
      END_IF;
      IF order = cubic THEN
        edge_nodes := 8;
        edge_face_body_nodes := 12;
      END_IF;
    END_IF;
    RETURN((SIZEOF(node_list) = (vertex_nodes + edge_nodes)) OR (SIZEOF(
        node_list) = (vertex_nodes + edge_face_body_nodes)));

  END_FUNCTION; -- required_2d_nodes

  FUNCTION required_3d_nodes(
               node_list: LIST [1:?] OF node_representation;
               element_shape: volume_3d_element_shape;
               order: element_order
      ): BOOLEAN;

    LOCAL
      vertex_nodes         : INTEGER;
      edge_face_body_nodes : INTEGER;
      edge_nodes           : INTEGER;
    END_LOCAL;
    IF element_shape = hexahedron THEN
      vertex_nodes := 8;
      IF order = linear THEN
        edge_nodes := 0;
        edge_face_body_nodes := 0;
      END_IF;
      IF order = quadratic THEN
        edge_nodes := 12;
        edge_face_body_nodes := 19;
      END_IF;
      IF order = cubic THEN
        edge_nodes := 24;
        edge_face_body_nodes := 56;
      END_IF;
    END_IF;
    IF element_shape = wedge THEN
      vertex_nodes := 6;
      IF order = linear THEN
        edge_nodes := 0;
        edge_face_body_nodes := 0;
      END_IF;
      IF order = quadratic THEN
        edge_nodes := 9;
        edge_face_body_nodes := 12;
      END_IF;
      IF order = cubic THEN
        edge_nodes := 18;
        edge_face_body_nodes := 34;
      END_IF;
    END_IF;
    IF element_shape = tetrahedron THEN
      vertex_nodes := 4;
      IF order = linear THEN
        edge_nodes := 0;
        edge_face_body_nodes := 0;
      END_IF;
      IF order = quadratic THEN
        edge_nodes := 6;
        edge_face_body_nodes := 6;
      END_IF;
      IF order = cubic THEN
        edge_nodes := 12;
        edge_face_body_nodes := 16;
      END_IF;
    END_IF;
    IF element_shape = pyramid THEN
      vertex_nodes := 5;
      IF order = linear THEN
        edge_nodes := 0;
        edge_face_body_nodes := 0;
      END_IF;
      IF order = quadratic THEN
        edge_nodes := 8;
        edge_face_body_nodes := 9;
      END_IF;
      IF order = cubic THEN
        edge_nodes := 16;
        edge_face_body_nodes := 25;
      END_IF;
    END_IF;
    RETURN((SIZEOF(node_list) = (vertex_nodes + edge_nodes)) OR (SIZEOF(
        node_list) = (vertex_nodes + edge_face_body_nodes)));

  END_FUNCTION; -- required_3d_nodes

  FUNCTION scalar_times_vector(
               scalar: REAL;
               vec: vector_or_direction
      ): vector;

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      IF 'STRUCTURAL_ANALYSIS_DESIGN.VECTOR' IN TYPEOF(vec) THEN
        v := dummy_gri || direction(vec.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v),mag);
    END_IF;
    RETURN(result);

  END_FUNCTION; -- scalar_times_vector

  FUNCTION second_proj_axis(
               z_axis, x_axis, arg: direction
      ): direction;

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := dummy_gri || direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

  END_FUNCTION; -- second_proj_axis

  FUNCTION set_of_topology_reversed(
               a_set: set_of_reversible_topology_item
      ): set_of_reversible_topology_item;

    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- set_of_topology_reversed

  FUNCTION shell_reversed(
               a_shell: shell
      ): shell;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN
      RETURN(open_shell_reversed(a_shell));
    ELSE
      IF 'STRUCTURAL_ANALYSIS_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell)
           THEN
        RETURN(closed_shell_reversed(a_shell));
      ELSE
        RETURN(?);
      END_IF;
    END_IF;

  END_FUNCTION; -- shell_reversed

  FUNCTION surface_weights_positive(
               b: rational_b_spline_surface
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] <= 0 THEN
          result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- surface_weights_positive

  FUNCTION topology_reversed(
               an_item: reversible_topology
      ): reversible_topology;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.EDGE' IN TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.PATH' IN TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.FACE' IN TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.SHELL' IN TYPEOF(an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);

  END_FUNCTION; -- topology_reversed

  FUNCTION unique_version_change_order(
               ad: action_directive
      ): BOOLEAN;

    LOCAL
      i      : INTEGER;
      k      : INTEGER;
      vers   : SET OF product_definition_formation := [];
      varset : SET OF versioned_action_request := ad.requests;
      aara   : SET OF applied_action_request_assignment := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(varset) BY 1;
      aara := aara + QUERY ( ara <* bag_to_set(USEDIN(varset[i],
          'STRUCTURAL_ANALYSIS_DESIGN.' + 
          'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')) | ((
          'STRUCTURAL_ANALYSIS_DESIGN.' + 
          'APPLIED_ACTION_REQUEST_ASSIGNMENT') IN TYPEOF(ara)) );
    END_REPEAT;
    REPEAT k := 1 TO SIZEOF(aara) BY 1;
      vers := vers + bag_to_set(QUERY ( aarai <* aara[k].items | (
          'STRUCTURAL_ANALYSIS_DESIGN.PRODUCT_DEFINITION_FORMATION' IN 
          TYPEOF(aarai)) ));
    END_REPEAT;
    RETURN(SIZEOF(QUERY ( ver <* vers | (NOT (SIZEOF(QUERY ( other_ver <* 
        (vers - ver) | (ver.of_product :=: other_ver.of_product) )) = 0)) )) 
        = 0);

  END_FUNCTION; -- unique_version_change_order

  FUNCTION using_items(
               item: founded_item_select;
               checked_items: SET OF founded_item_select
      ): SET OF founded_item_select;

    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | ((
        'STRUCTURAL_ANALYSIS_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
        'STRUCTURAL_ANALYSIS_DESIGN.FOUNDED_ITEM' IN TYPEOF(z))) );
    IF SIZEOF(next_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);

  END_FUNCTION; -- using_items

  FUNCTION using_representations(
               item: founded_item_select
      ): SET OF representation;

    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,
        'STRUCTURAL_ANALYSIS_DESIGN.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],
            'STRUCTURAL_ANALYSIS_DESIGN.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);

  END_FUNCTION; -- using_representations

  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    IF NOT ((1 <= date.day_component) AND (date.day_component <= 31))
         THEN
      RETURN(FALSE);
    END_IF;
    CASE date.month_component OF
      4        :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      6        :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      9        :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      11       :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      2        :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      OTHERWISE  :         RETURN(TRUE);
      END_CASE;

  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_geometrically_bounded_wf_curve(
               crv: curve
      ): BOOLEAN;
    IF SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.POLYLINE',
        'STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_CURVE',
        'STRUCTURAL_ANALYSIS_DESIGN.ELLIPSE',
        'STRUCTURAL_ANALYSIS_DESIGN.CIRCLE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'STRUCTURAL_ANALYSIS_DESIGN.TRIMMED_CURVE' IN TYPEOF(crv) THEN
        IF SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.LINE',
            'STRUCTURAL_ANALYSIS_DESIGN.PARABOLA',
            'STRUCTURAL_ANALYSIS_DESIGN.HYPERBOLA'] * TYPEOF(crv\
            trimmed_curve.basis_curve)) = 1 THEN
          RETURN(TRUE);
        ELSE
          RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.
              basis_curve));
        END_IF;
      ELSE
        IF 'STRUCTURAL_ANALYSIS_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv)
             THEN
          RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.
              basis_curve));
        ELSE
          IF 'STRUCTURAL_ANALYSIS_DESIGN.CURVE_REPLICA' IN TYPEOF(crv)
               THEN
            RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.
                parent_curve));
          ELSE
            IF 'STRUCTURAL_ANALYSIS_DESIGN.COMPOSITE_CURVE' IN TYPEOF(crv)
                 THEN
              RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments | 
                  (NOT valid_geometrically_bounded_wf_curve(ccs.
                  parent_curve)) )) = 0);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_geometrically_bounded_wf_curve

  FUNCTION valid_geometrically_bounded_wf_point(
               pnt: point
      ): BOOLEAN;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'STRUCTURAL_ANALYSIS_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
        RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.
            basis_curve));
      ELSE
        IF 'STRUCTURAL_ANALYSIS_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
          RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.
              parent_pt));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_geometrically_bounded_wf_point

  FUNCTION valid_measure_value(
               m: measure_value
      ): BOOLEAN;
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m > 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN
        RETURN(m > 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;

  END_FUNCTION; -- valid_measure_value

  FUNCTION valid_parametric_coordinate(
               coordinates: LIST [1:3] OF parameter_value
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(coordinates) BY 1;
      IF (1 < coordinates[i]) OR (coordinates[i] < (-1)) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- valid_parametric_coordinate

  FUNCTION valid_time(
               time: local_time
      ): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- valid_time

  FUNCTION valid_units(
               m: measure_with_unit
      ): BOOLEAN;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.MASS_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.TIME_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(
        m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m
        .value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.AREA_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.RATIO_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- valid_units

  FUNCTION valid_wireframe_edge_curve(
               crv: curve
      ): BOOLEAN;
    IF SIZEOF(['STRUCTURAL_ANALYSIS_DESIGN.LINE',
        'STRUCTURAL_ANALYSIS_DESIGN.CONIC',
        'STRUCTURAL_ANALYSIS_DESIGN.B_SPLINE_CURVE',
        'STRUCTURAL_ANALYSIS_DESIGN.POLYLINE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'STRUCTURAL_ANALYSIS_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
        RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
      ELSE
        IF 'STRUCTURAL_ANALYSIS_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv)
             THEN
          RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.
              basis_curve));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_edge_curve

  FUNCTION valid_wireframe_vertex_point(
               pnt: point
      ): BOOLEAN;
    IF 'STRUCTURAL_ANALYSIS_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'STRUCTURAL_ANALYSIS_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
        RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_vertex_point

  FUNCTION variable_value_type(
               variable: GENERIC
      ): STRING;

    LOCAL
      svt             : STRING;
      feacr           : STRING;
      variable_typeof : SET [1:?] OF STRING;
    END_LOCAL;
    svt := 'STRUCTURAL_ANALYSIS_DESIGN.';
    feacr := 'STRUCTURAL_ANALYSIS_DESIGN.';
    variable_typeof := TYPEOF(variable);
    IF SIZEOF([feacr + 'CURVE_SCALAR_VARIABLE',feacr + 
        'SURFACE_SCALAR_VARIABLE',feacr + 'VOLUME_SCALAR_VARIABLE',feacr + 
        'BOUNDARY_CURVE_SCALAR_VARIABLE',feacr + 
        'BOUNDARY_SURFACE_SCALAR_VARIABLE',feacr + 
        'AGGREGATED_SCALAR_VARIABLE',feacr + 'VOLUME_ANGULAR_VARIABLE',
        feacr + 'AGGREGATED_ANGULAR_VARIABLE',feacr + 
        'APPLICATION_DEFINED_SCALAR_VARIABLE'] * variable_typeof) = 1 THEN
      RETURN(svt + 'SCALAR');
    END_IF;
    IF SIZEOF([feacr + 'CURVE_VECTOR_2D_VARIABLE',feacr + 
        'SURFACE_VECTOR_2D_VARIABLE',feacr + 
        'APPLICATION_DEFINED_VECTOR_2D_VARIABLE'] * variable_typeof) = 1
         THEN
      RETURN(svt + 'TENSOR1_2D');
    END_IF;
    IF SIZEOF([feacr + 'CURVE_VECTOR_3D_VARIABLE',feacr + 
        'SURFACE_VECTOR_3D_VARIABLE',feacr + 'VOLUME_VECTOR_3D_VARIABLE',
        feacr + 'BOUNDARY_CURVE_VECTOR_3D_VARIABLE',feacr + 
        'BOUNDARY_SURFACE_VECTOR_3D_VARIABLE',feacr + 
        'AGGREGATED_VECTOR_3D_VARIABLE',feacr + 
        'APPLICATION_DEFINED_VECTOR_3D_VARIABLE'] * variable_typeof) = 1
         THEN
      RETURN(svt + 'TENSOR1_3D');
    END_IF;
    IF SIZEOF([feacr + 'SURFACE_TENSOR2_2D_VARIABLE',feacr + 
        'APPLICATION_DEFINED_TENSOR2_2D_VARIABLE'] * variable_typeof) = 1
         THEN
      RETURN(svt + 'SYMMETRIC_TENSOR2_3D');
    END_IF;
    IF SIZEOF([feacr + 'VOLUME_TENSOR2_3D_VARIABLE',feacr + 
        'AGGREGATED_TENSOR2_3D_VARIABLE',feacr + 
        'APPLICATION_DEFINED_TENSOR2_3D_VARIABLE'] * variable_typeof) = 1
         THEN
      RETURN(svt + 'SYMMETRIC_TENSOR2_3D');
    END_IF;
    RETURN('NO_MATCH');

  END_FUNCTION; -- variable_value_type

  FUNCTION vector_difference(
               arg1, arg2: vector_or_direction
      ): vector;

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      RETURN(?);
    ELSE
      BEGIN
        IF 'STRUCTURAL_ANALYSIS_DESIGN.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'STRUCTURAL_ANALYSIS_DESIGN.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(vec1,0);
        END_IF;
      END;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- vector_difference

END_SCHEMA; -- structural_analysis_design
