(* AIM EXPRESS long form for ISO/IS 10303-215
    2003-12-14
    Peter Lazo
    ISO TC184/SC4 WG3 N1232
*)
SCHEMA ship_arrangement_schema;
 
CONSTANT dummy_gri : geometric_representation_item :=
  representation_item('') ||  geometric_representation_item();
  dummy_tri : topological_representation_item :=
  representation_item('') || topological_representation_item(); 
END_CONSTANT;
 
TYPE action_item = SELECT
    (action_request_solution,
     document,
     executed_action,
     group,
     product,
     product_definition,
     product_definition_relationship,
     product_definition_shape,
     product_related_product_category,
     property_definition
     );
END_TYPE; -- action_item

TYPE action_request_item = SELECT 
  (action, 
   executed_action); 
END_TYPE; -- action_request_item
 
TYPE ahead_or_behind = ENUMERATION OF 
  (exact, 
   ahead, 
   behind); 
END_TYPE; -- ahead_or_behind
 
TYPE amount_of_substance_measure = REAL; 
END_TYPE; -- amount_of_substance_measure
 
TYPE approval_item = SELECT(
	product_definition,
	product_definition_shape,
	product_related_product_category,
	property_definition
	);   
END_TYPE; -- approval_item
 
TYPE area_measure = REAL; 
END_TYPE; -- area_measure
 
TYPE axis2_placement = SELECT 
  (axis2_placement_2d, 
   axis2_placement_3d); 
END_TYPE; -- axis2_placement
 
TYPE b_spline_curve_form = ENUMERATION OF 
  (elliptic_arc, 
   polyline_form, 
   parabolic_arc, 
   circular_arc, 
   unspecified, 
   hyperbolic_arc); 
END_TYPE; -- b_spline_curve_form
 
TYPE b_spline_surface_form = ENUMERATION OF 
  (surf_of_linear_extrusion, 
   plane_surf, 
   generalised_cone, 
   toroidal_surf, 
   conical_surf, 
   spherical_surf, 
   unspecified, 
   ruled_surf, 
   surf_of_revolution, 
   cylindrical_surf, 
   quadric_surf); 
END_TYPE; -- b_spline_surface_form
 
TYPE characterized_definition = SELECT 
  (characterized_object, 
   characterized_product_definition, 
   shape_definition); 
END_TYPE; -- characterized_definition
 
TYPE characterized_product_definition = SELECT 
  (product_definition, 
   product_definition_relationship); 
END_TYPE; -- characterized_product_definition
 
TYPE classification_item = SELECT 
  (action, 
   action_request_solution, 
   applied_action_request_assignment, 
   approval,
   compound_representation_item, 
   document, 
   executed_action, 
   external_source, 
   group, 
   identification_assignment_relationship, 
   product, 
   product_definition, 
   product_definition_relationship, 
   product_definition_shape, 
   product_related_product_category, 
   property_definition, 
   property_definition_representation, 
   representation, 
   shape_aspect, 
   versioned_action_request); 
END_TYPE; -- classification_item
 
TYPE compound_item_definition = SELECT 
  (list_representation_item, 
   set_representation_item); 
END_TYPE; -- compound_item_definition
 
TYPE context_dependent_measure = REAL; 
END_TYPE; -- context_dependent_measure
 
TYPE count_measure = NUMBER; 
END_TYPE; -- count_measure
 
TYPE curve_on_surface = SELECT 
  (pcurve, 
   surface_curve, 
   composite_curve_on_surface); 
END_TYPE; -- curve_on_surface
 
TYPE date_and_time_item = SELECT 
  (action, 
   action_request_solution, 
   executed_action, 
   product_definition, 
   property_definition, 
   property_definition_representation, 
   versioned_action_request); 
END_TYPE; -- date_and_time_item
 
TYPE date_time_select = SELECT 
  (date, 
   local_time, 
   date_and_time); 
END_TYPE; -- date_time_select
 
TYPE day_in_month_number = INTEGER; 
WHERE 
  wr1: (1 <= SELF) AND (SELF <= 31); 
END_TYPE; -- day_in_month_number
 
TYPE day_in_week_number = INTEGER; 
WHERE 
  wr1: (1 <= SELF) AND (SELF <= 7); 
END_TYPE; -- day_in_week_number
 
TYPE day_in_year_number = INTEGER; 
WHERE 
  wr1: (1 <= SELF) AND (SELF <= 366); 
END_TYPE; -- day_in_year_number
 
TYPE description_attribute_select = SELECT 
  (action_request_solution, 
   application_context, 
   approval_role, 
   date_time_role, 
   effectivity,
   external_source, 
   organization_role, 
   person_and_organization_role, 
   person_and_organization, 
   person_role, 
   property_definition_representation, 
   representation); 
END_TYPE; -- description_attribute_select
 
TYPE dimension_count = INTEGER; 
WHERE 
  wr1: SELF > 0; 
END_TYPE; -- dimension_count
 
TYPE document_reference_item = SELECT 
  (action,
   product, 
   product_definition, 
   property_definition); 
END_TYPE; -- document_reference_item
 
TYPE electric_current_measure = REAL; 
END_TYPE; -- electric_current_measure
 
TYPE effectivity_item = SELECT 
   (product_definition,
   product_definition_shape,
   product_related_product_category,
   property_definition);
END_TYPE; -- effectivity_item

TYPE external_identification_item = SELECT 
  (action,
	document,
	product,
	product_definition,
	property_definition,
	     shape_aspect); 
END_TYPE; -- external_identification_item
 
TYPE founded_item_select = SELECT 
  (founded_item, 
   representation_item); 
END_TYPE; -- founded_item_select
 
TYPE group_item = SELECT 
  (applied_external_identification_assignment,
	approval,
	document,
	group,
	identification_assignment_relationship,
	product,
	product_definition,
	product_definition_relationship,
	product_definition_shape,
	product_related_product_category,
	     property_definition); 
END_TYPE; -- group_item
 
TYPE hour_in_day = INTEGER; 
WHERE 
  wr1: (0 <= SELF) AND (SELF < 24); 
END_TYPE; -- hour_in_day
 
TYPE id_attribute_select = SELECT 
  (action, 
   address, 
   product_category, 
   property_definition, 
   shape_aspect, 
   application_context, 
   group, 
   organizational_project, 
   representation); 
END_TYPE; -- id_attribute_select
 
TYPE identification_item = SELECT 
  (action, 
   action_request_solution, 
   document, 
   executed_action, 
   group, 
   product, 
   product_definition, 
   product_definition_relationship, 
   product_definition_shape, 
   product_related_product_category, 
   property_definition, 
   versioned_action_request); 
END_TYPE; -- identification_item
 
TYPE identifier = STRING; 
END_TYPE; -- identifier
 
TYPE knot_type = ENUMERATION OF 
  (uniform_knots, 
   quasi_uniform_knots, 
   piecewise_bezier_knots, 
   unspecified); 
END_TYPE; -- knot_type
 
TYPE label = STRING; 
END_TYPE; -- label
 
TYPE length_measure = REAL; 
END_TYPE; -- length_measure
 
TYPE list_of_reversible_topology_item = LIST [0:?] OF 
            reversible_topology_item; 
END_TYPE; -- list_of_reversible_topology_item
 
TYPE list_representation_item = LIST [1:?] OF representation_item; 
END_TYPE; -- list_representation_item
 
TYPE luminous_intensity_measure = REAL; 
END_TYPE; -- luminous_intensity_measure
 
TYPE mass_measure = REAL; 
END_TYPE; -- mass_measure
 
TYPE measure_value = SELECT 
  (length_measure, 
   mass_measure, 
   time_measure, 
   electric_current_measure, 
   thermodynamic_temperature_measure, 
   amount_of_substance_measure, 
   luminous_intensity_measure, 
   plane_angle_measure, 
   solid_angle_measure, 
   area_measure, 
   volume_measure, 
   ratio_measure, 
   parameter_value, 
   context_dependent_measure, 
   positive_length_measure, 
   positive_plane_angle_measure, 
   count_measure); 
END_TYPE; -- measure_value
 
TYPE minute_in_hour = INTEGER; 
WHERE 
  wr1: (0 <= SELF) AND (SELF <= 59); 
END_TYPE; -- minute_in_hour
 
TYPE month_in_year_number = INTEGER; 
WHERE 
  wr1: (1 <= SELF) AND (SELF <= 12); 
END_TYPE; -- month_in_year_number
 
TYPE name_attribute_select = SELECT 
  (action_request_solution, 
   address, 
   derived_unit, 
   effectivity,
   person_and_organization, 
   product_definition, 
   property_definition_representation); 
END_TYPE; -- name_attribute_select
 
TYPE organization_item = SELECT 
  (document, 
   product_definition, 
   property_definition); 
END_TYPE; -- organization_item
 
TYPE parameter_value = REAL; 
END_TYPE; -- parameter_value
 
TYPE pcurve_or_surface = SELECT 
  (pcurve, 
   surface); 
END_TYPE; -- pcurve_or_surface
 
TYPE person_and_organization_item = SELECT 
  (action, 
   action_request_solution, 
   document, 
   executed_action, 
   versioned_action_request); 
END_TYPE; -- person_and_organization_item
 
TYPE person_item = SELECT 
  (document); 
END_TYPE; -- person_item
 
TYPE person_organization_select = SELECT 
  (person, 
   organization, 
   person_and_organization); 
END_TYPE; -- person_organization_select
 
TYPE plane_angle_measure = REAL; 
END_TYPE; -- plane_angle_measure
 
TYPE positive_length_measure = length_measure; 
WHERE 
  wr1: SELF > 0; 
END_TYPE; -- positive_length_measure
 
TYPE positive_plane_angle_measure = plane_angle_measure; 
WHERE 
  wr1: SELF > 0; 
END_TYPE; -- positive_plane_angle_measure
 
TYPE preferred_surface_curve_representation = ENUMERATION OF 
  (pcurve_s2, 
   pcurve_s1, 
   curve_3d); 
END_TYPE; -- preferred_surface_curve_representation
 
TYPE product_or_formation_or_definition = SELECT 
  (product, 
   product_definition_formation, 
   product_definition); 
END_TYPE; -- product_or_formation_or_definition
 
TYPE ratio_measure = REAL; 
END_TYPE; -- ratio_measure
 
TYPE represented_definition = SELECT 
  (property_definition, 
   property_definition_relationship, 
   shape_aspect); 
END_TYPE; -- represented_definition
 
TYPE reversible_topology = SELECT 
  (reversible_topology_item, 
   list_of_reversible_topology_item, 
   set_of_reversible_topology_item); 
END_TYPE; -- reversible_topology
 
TYPE reversible_topology_item = SELECT 
  (edge, 
   path, 
   face, 
   face_bound, 
   closed_shell, 
   open_shell); 
END_TYPE; -- reversible_topology_item
 
TYPE role_select = SELECT 
  (action_request_assignment, 
   approval_assignment, 
   approval_date_time, 
   document_reference, 
   effectivity_assignment,
   group_assignment); 
END_TYPE; -- role_select
 
TYPE second_in_minute = REAL; 
WHERE 
  wr1: (0 <= SELF) AND (SELF <= 60); 
END_TYPE; -- second_in_minute
 
TYPE set_of_reversible_topology_item = SET [0:?] OF 
            reversible_topology_item; 
END_TYPE; -- set_of_reversible_topology_item
 
TYPE set_representation_item = SET [1:?] OF representation_item; 
END_TYPE; -- set_representation_item
 
TYPE shape_definition = SELECT 
  (product_definition_shape, 
   shape_aspect); 
END_TYPE; -- shape_definition

TYPE shell = SELECT
      (open_shell,
      closed_shell);
END_TYPE;
 
TYPE si_prefix = ENUMERATION OF 
  (exa, 
   pico, 
   mega, 
   femto, 
   atto, 
   centi, 
   nano, 
   hecto, 
   micro, 
   tera, 
   giga, 
   milli, 
   peta, 
   deci, 
   kilo, 
   deca); 
END_TYPE; -- si_prefix
 
TYPE si_unit_name = ENUMERATION OF 
  (hertz, 
   degree_celsius, 
   siemens, 
   sievert, 
   lux, 
   watt, 
   ohm, 
   second, 
   becquerel, 
   pascal, 
   henry, 
   tesla, 
   volt, 
   joule, 
   kelvin, 
   ampere, 
   gram, 
   steradian, 
   mole, 
   lumen, 
   gray, 
   candela, 
   farad, 
   radian, 
   newton, 
   metre, 
   weber, 
   coulomb); 
END_TYPE; -- si_unit_name
 
TYPE solid_angle_measure = REAL; 
END_TYPE; -- solid_angle_measure
 
TYPE source_item = SELECT 
  (identifier); 
END_TYPE; -- source_item
 
TYPE surface_model = SELECT 
  (face_based_surface_model); 
END_TYPE; -- surface_model
 
TYPE text = STRING; 
END_TYPE; -- text
 
TYPE thermodynamic_temperature_measure = REAL; 
END_TYPE; -- thermodynamic_temperature_measure
 
TYPE time_measure = REAL; 
END_TYPE; -- time_measure
 
TYPE transformation = SELECT 
  (item_defined_transformation, 
   functionally_defined_transformation); 
END_TYPE; -- transformation
 
TYPE transition_code = ENUMERATION OF 
  (discontinuous, 
   cont_same_gradient_same_curvature, 
   cont_same_gradient, 
   continuous); 
END_TYPE; -- transition_code
 
TYPE unit = SELECT 
  (named_unit, 
   derived_unit); 
END_TYPE; -- unit
 
TYPE vector_or_direction = SELECT 
  (vector, 
   direction); 
END_TYPE; -- vector_or_direction
 
TYPE volume_measure = REAL; 
END_TYPE; -- volume_measure
 
TYPE week_in_year_number = INTEGER; 
WHERE 
  wr1: (1 <= SELF) AND (SELF <= 53); 
END_TYPE; -- week_in_year_number
 
TYPE year_number = INTEGER; 
END_TYPE; -- year_number
 
ENTITY action; 
    name          : label; 
    description   : OPTIONAL text; 
    chosen_method : action_method; 
  DERIVE 
    id : identifier := get_id_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1; 
END_ENTITY; -- action

ENTITY  action_assignment
  ABSTRACT SUPERTYPE;
    assigned_action : action;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
END_ENTITY; -- action_assignment
 
ENTITY action_method; 
    name        : label; 
    description : OPTIONAL text; 
    consequence : text; 
    purpose     : text; 
END_ENTITY; -- action_method
 
ENTITY action_request_assignment 
  ABSTRACT SUPERTYPE; 
    assigned_action_request : versioned_action_request; 
  DERIVE 
    role : object_role := get_role(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1; 
END_ENTITY; -- action_request_assignment
 
ENTITY action_request_solution; 
    method  : action_method; 
    request : versioned_action_request; 
  DERIVE 
    description : text := get_description_value(SELF); 
    name        : label := get_name_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
    wr2: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1; 
END_ENTITY; -- action_request_solution
 
ENTITY address; 
    internal_location       : OPTIONAL label; 
    street_number           : OPTIONAL label; 
    street                  : OPTIONAL label; 
    postal_box              : OPTIONAL label; 
    town                    : OPTIONAL label; 
    region                  : OPTIONAL label; 
    postal_code             : OPTIONAL label; 
    country                 : OPTIONAL label; 
    facsimile_number        : OPTIONAL label; 
    telephone_number        : OPTIONAL label; 
    electronic_mail_address : OPTIONAL label; 
    telex_number            : OPTIONAL label; 
  DERIVE 
    name : label := get_name_value(SELF); 
    url  : identifier := get_id_value(SELF); 
  WHERE 
    wr1: ((((((((((EXISTS(internal_location) OR EXISTS(street_number))  
             OR EXISTS(street)) OR EXISTS(postal_box)) OR EXISTS(town))  
             OR EXISTS(region)) OR EXISTS(postal_code)) OR EXISTS(country))  
             OR EXISTS(facsimile_number)) OR EXISTS(telephone_number)) OR 
              EXISTS(electronic_mail_address)) OR EXISTS(telex_number); 
END_ENTITY; -- address
 
ENTITY advanced_face 
  SUBTYPE OF (face_surface); 
  WHERE 
    wr1 : SIZEOF(['SHIP_ARRANGEMENT_SCHEMA.ELEMENTARY_SURFACE', 
              'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_SURFACE', 
              'SHIP_ARRANGEMENT_SCHEMA.SWEPT_SURFACE'] * TYPEOF( 
              face_geometry)) = 1; 
    wr2 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | ( 
              'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) 
               | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path. 
              edge_list | (NOT ('SHIP_ARRANGEMENT_SCHEMA.EDGE_CURVE' IN  
              TYPEOF(oe\oriented_edge.edge_element))) )) = 0)) )) = 0; 
    wr3 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | ( 
              'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) 
               | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path. 
              edge_list | (NOT (SIZEOF(['SHIP_ARRANGEMENT_SCHEMA.LINE', 
              'SHIP_ARRANGEMENT_SCHEMA.CONIC', 
              'SHIP_ARRANGEMENT_SCHEMA.POLYLINE', 
              'SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE', 
              'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(oe. 
              edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) = 
               0; 
    wr4 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | ( 
              'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) 
               | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path. 
              edge_list | (NOT ((('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT'  
              IN TYPEOF(oe\edge.edge_start)) AND ( 
              'SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT' IN TYPEOF(oe\ 
              edge.edge_start\vertex_point.vertex_geometry))) AND (( 
              'SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT' IN TYPEOF(oe\edge. 
              edge_end)) AND ('SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT'  
              IN TYPEOF(oe\edge.edge_end\vertex_point.vertex_geometry))))) ))  
              = 0)) )) = 0; 
    wr5 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | ( 
              'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) 
               | ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_PATH' IN TYPEOF( 
              elp_fbnds.bound)) )) = 0; 
    wr6 : (NOT ('SHIP_ARRANGEMENT_SCHEMA.SWEPT_SURFACE' IN TYPEOF( 
              face_geometry))) OR (SIZEOF([ 
              'SHIP_ARRANGEMENT_SCHEMA.LINE', 
              'SHIP_ARRANGEMENT_SCHEMA.CONIC', 
              'SHIP_ARRANGEMENT_SCHEMA.POLYLINE', 
              'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE'] * TYPEOF( 
              face_geometry\swept_surface.swept_curve)) = 1); 
    wr7 : SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* bounds | ( 
              'SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) ) 
               | (NOT (('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT' IN  
              TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex))  
              AND ('SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT' IN TYPEOF( 
              vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\ 
              vertex_point.vertex_geometry)))) )) = 0; 
    wr8 : SIZEOF(QUERY ( bnd <* bounds | (NOT (SIZEOF([ 
              'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP', 
              'SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnd.bound))  
              = 1)) )) = 0; 
    wr9 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | ( 
              'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) 
               | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path. 
              edge_list | (('SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE' IN  
              TYPEOF(oe\oriented_edge.edge_element\edge_curve. 
              edge_geometry)) AND (NOT (SIZEOF(QUERY ( sc_ag <* oe. 
              edge_element\edge_curve.edge_geometry\surface_curve. 
              associated_geometry | (NOT ( 
              'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(sc_ag))) )) = 0))) ))  
              = 0)) )) = 0; 
    wr10: ((NOT ('SHIP_ARRANGEMENT_SCHEMA.SWEPT_SURFACE' IN TYPEOF( 
              face_geometry))) OR ((NOT ( 
              'SHIP_ARRANGEMENT_SCHEMA.POLYLINE' IN TYPEOF(face_geometry 
              \swept_surface.swept_curve))) OR (SIZEOF(face_geometry\ 
              swept_surface.swept_curve\polyline.points) >= 3))) AND ( 
              SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | ( 
              'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) 
               | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path. 
              edge_list | (('SHIP_ARRANGEMENT_SCHEMA.POLYLINE' IN  
              TYPEOF(oe\oriented_edge.edge_element\edge_curve. 
              edge_geometry)) AND (NOT (SIZEOF(oe\oriented_edge. 
              edge_element\edge_curve.edge_geometry\polyline.points) >= 3))) ))  
              = 0)) )) = 0); 
END_ENTITY; -- advanced_face
 
ENTITY application_context; 
    application : label; 
  DERIVE 
    description : text := get_description_value(SELF); 
    id          : identifier := get_id_value(SELF); 
  INVERSE 
    context_elements : SET [1:?] OF application_context_element FOR  
                          frame_of_reference; 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
    wr2: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1; 
END_ENTITY; -- application_context
 
ENTITY application_context_element 
  SUPERTYPE OF (ONEOF (product_context,product_definition_context)); 
    name               : label; 
    frame_of_reference : application_context; 
END_ENTITY; -- application_context_element
 
ENTITY application_protocol_definition; 
    status                                    : label; 
    application_interpreted_model_schema_name : label; 
    application_protocol_year                 : year_number; 
    application                               : application_context; 
END_ENTITY; -- application_protocol_definition
 
ENTITY applied_action_assignment
  SUBTYPE OF (action_assignment);
  items : SET [1:?] OF action_item;
END_ENTITY; -- applied_action_assignment

ENTITY applied_action_request_assignment 
  SUBTYPE OF (action_request_assignment); 
    items : SET [1:?] OF action_request_item; 
END_ENTITY; -- applied_action_request_assignment
 
ENTITY applied_approval_assignment 
  SUBTYPE OF (approval_assignment); 
    items : SET [1:?] OF approval_item; 
END_ENTITY; -- applied_approval_assignment
 
ENTITY applied_classification_assignment 
  SUBTYPE OF (classification_assignment); 
    items : SET [1:?] OF classification_item; 
END_ENTITY; -- applied_classification_assignment
 
ENTITY applied_date_and_time_assignment 
  SUBTYPE OF (date_and_time_assignment); 
    items : SET [1:?] OF date_and_time_item; 
END_ENTITY; -- applied_date_and_time_assignment
 
ENTITY applied_document_reference 
  SUBTYPE OF (document_reference); 
    items : SET [1:?] OF document_reference_item; 
END_ENTITY; -- applied_document_reference
 
ENTITY applied_effectivity_assignment
SUBTYPE OF (effectivity_assignment);
items : SET [1:?] OF effectivity_item;
END_ENTITY; -- applied_effectivity_assignment

ENTITY applied_external_identification_assignment 
  SUBTYPE OF (external_identification_assignment); 
    items : SET [1:?] OF external_identification_item; 
END_ENTITY; -- applied_external_identification_assignment
 
ENTITY applied_group_assignment 
  SUBTYPE OF (group_assignment); 
    items : SET [1:?] OF group_item; 
END_ENTITY; -- applied_group_assignment
 
ENTITY applied_identification_assignment 
  SUBTYPE OF (identification_assignment); 
    items : SET [1:?] OF identification_item; 
END_ENTITY; -- applied_identification_assignment
 
ENTITY applied_organization_assignment 
  SUBTYPE OF (organization_assignment); 
    items : SET [1:?] OF organization_item; 
END_ENTITY; -- applied_organization_assignment
 
ENTITY applied_person_and_organization_assignment 
  SUBTYPE OF (person_and_organization_assignment); 
    items : SET [1:?] OF person_and_organization_item; 
END_ENTITY; -- applied_person_and_organization_assignment
 
ENTITY applied_person_assignment 
  SUBTYPE OF (person_assignment); 
    items : SET [1:?] OF person_item; 
END_ENTITY; -- applied_person_assignment
 
ENTITY approval; 
    status : approval_status; 
    level  : label; 
END_ENTITY; -- approval
 
ENTITY approval_assignment 
  ABSTRACT SUPERTYPE; 
    assigned_approval : approval; 
  DERIVE 
    role : object_role := get_role(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1; 
END_ENTITY; -- approval_assignment
 
ENTITY approval_date_time; 
    date_time      : date_time_select; 
    dated_approval : approval; 
  DERIVE 
    role : object_role := get_role(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1; 
END_ENTITY; -- approval_date_time
 
ENTITY approval_person_organization; 
    person_organization : person_organization_select; 
    authorized_approval : approval; 
    role                : approval_role; 
END_ENTITY; -- approval_person_organization
 
ENTITY approval_role; 
    role : label; 
  DERIVE 
    description : text := get_description_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
END_ENTITY; -- approval_role
 
ENTITY approval_status; 
    name : label; 
END_ENTITY; -- approval_status
 
ENTITY axis1_placement 
  SUBTYPE OF (placement); 
    axis : OPTIONAL direction; 
  DERIVE 
    z : direction := NVL(normalise(axis),dummy_gri || direction([0,0,1])); 
  WHERE 
    wr1: SELF\geometric_representation_item.dim = 3; 
END_ENTITY; -- axis1_placement
 
ENTITY axis2_placement_2d 
  SUBTYPE OF (placement); 
    ref_direction : OPTIONAL direction; 
  DERIVE 
    p : LIST [2:2] OF direction := build_2axes(ref_direction); 
  WHERE 
    wr1: SELF\geometric_representation_item.dim = 2; 
END_ENTITY; -- axis2_placement_2d
 
ENTITY axis2_placement_3d 
  SUBTYPE OF (placement); 
    axis          : OPTIONAL direction; 
    ref_direction : OPTIONAL direction; 
  DERIVE 
    p : LIST [3:3] OF direction := build_axes(axis,ref_direction); 
  WHERE 
    wr1: SELF\placement.location.dim = 3; 
    wr2: (NOT EXISTS(axis)) OR (axis.dim = 3); 
    wr3: (NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3); 
    wr4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction))) OR ( 
             cross_product(axis,ref_direction).magnitude > 0); 
END_ENTITY; -- axis2_placement_3d
 
ENTITY b_spline_curve 
  SUPERTYPE OF (ONEOF (uniform_curve,b_spline_curve_with_knots, 
      quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve) 
  SUBTYPE OF (bounded_curve); 
    degree              : INTEGER; 
    control_points_list : LIST [2:?] OF cartesian_point; 
    curve_form          : b_spline_curve_form; 
    closed_curve        : LOGICAL; 
    self_intersect      : LOGICAL; 
  DERIVE 
    upper_index_on_control_points : INTEGER := SIZEOF( 
                                       control_points_list) - 1; 
    control_points                : ARRAY [0: 
                                       upper_index_on_control_points] OF 
                                        cartesian_point := list_to_array( 
                                       control_points_list,0, 
                                       upper_index_on_control_points); 
  WHERE 
    wr1: ((('SHIP_ARRANGEMENT_SCHEMA.UNIFORM_CURVE' IN TYPEOF(SELF)) OR 
              ('SHIP_ARRANGEMENT_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF( 
             SELF))) OR ('SHIP_ARRANGEMENT_SCHEMA.BEZIER_CURVE' IN  
             TYPEOF(SELF))) OR ( 
             'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN  
             TYPEOF(SELF)); 
END_ENTITY; -- b_spline_curve
 
ENTITY b_spline_curve_with_knots 
  SUBTYPE OF (b_spline_curve); 
    knot_multiplicities : LIST [2:?] OF INTEGER; 
    knots               : LIST [2:?] OF parameter_value; 
    knot_spec           : knot_type; 
  DERIVE 
    upper_index_on_knots : INTEGER := SIZEOF(knots); 
  WHERE 
    wr1: constraints_param_b_spline(degree,upper_index_on_knots, 
             upper_index_on_control_points,knot_multiplicities,knots); 
    wr2: SIZEOF(knot_multiplicities) = upper_index_on_knots; 
END_ENTITY; -- b_spline_curve_with_knots
 
ENTITY b_spline_surface 
  SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,uniform_surface, 
      quasi_uniform_surface,bezier_surface) ANDOR  
      rational_b_spline_surface) 
  SUBTYPE OF (bounded_surface); 
    u_degree            : INTEGER; 
    v_degree            : INTEGER; 
    control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point; 
    surface_form        : b_spline_surface_form; 
    u_closed            : LOGICAL; 
    v_closed            : LOGICAL; 
    self_intersect      : LOGICAL; 
  DERIVE 
    u_upper        : INTEGER := SIZEOF(control_points_list) - 1; 
    v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1; 
    control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF 
                         cartesian_point := make_array_of_array( 
                        control_points_list,0,u_upper,0,v_upper); 
  WHERE 
    wr1: ((('SHIP_ARRANGEMENT_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF))  
             OR ('SHIP_ARRANGEMENT_SCHEMA.QUASI_UNIFORM_SURFACE' IN  
             TYPEOF(SELF))) OR ('SHIP_ARRANGEMENT_SCHEMA.BEZIER_SURFACE'  
             IN TYPEOF(SELF))) OR ( 
             'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN  
             TYPEOF(SELF)); 
END_ENTITY; -- b_spline_surface
 
ENTITY b_spline_surface_with_knots 
  SUBTYPE OF (b_spline_surface); 
    u_multiplicities : LIST [2:?] OF INTEGER; 
    v_multiplicities : LIST [2:?] OF INTEGER; 
    u_knots          : LIST [2:?] OF parameter_value; 
    v_knots          : LIST [2:?] OF parameter_value; 
    knot_spec        : knot_type; 
  DERIVE 
    knot_u_upper : INTEGER := SIZEOF(u_knots); 
    knot_v_upper : INTEGER := SIZEOF(v_knots); 
  WHERE 
    wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree, 
             knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities, 
             u_knots); 
    wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree, 
             knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities, 
             v_knots); 
    wr3: SIZEOF(u_multiplicities) = knot_u_upper; 
    wr4: SIZEOF(v_multiplicities) = knot_v_upper; 
END_ENTITY; -- b_spline_surface_with_knots
 
ENTITY bezier_curve 
  SUBTYPE OF (b_spline_curve); 
END_ENTITY; -- bezier_curve
 
ENTITY bezier_surface 
  SUBTYPE OF (b_spline_surface); 
END_ENTITY; -- bezier_surface
 
ENTITY bounded_curve 
  SUPERTYPE OF (ONEOF (polyline,b_spline_curve,bounded_pcurve, 
      bounded_surface_curve,composite_curve)) 
  SUBTYPE OF (curve); 
END_ENTITY; -- bounded_curve
 
ENTITY bounded_pcurve 
  SUBTYPE OF (pcurve, bounded_curve); 
  WHERE 
    wr1: 'SHIP_ARRANGEMENT_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve. 
             reference_to_curve.items[1]); 
END_ENTITY; -- bounded_pcurve
 
ENTITY bounded_surface 
  SUPERTYPE OF (b_spline_surface) 
  SUBTYPE OF (surface); 
END_ENTITY; -- bounded_surface
 
ENTITY bounded_surface_curve 
  SUBTYPE OF (surface_curve, bounded_curve); 
  WHERE 
    wr1: 'SHIP_ARRANGEMENT_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\ 
             surface_curve.curve_3d); 
END_ENTITY; -- bounded_surface_curve
 
ENTITY calendar_date 
  SUBTYPE OF (date); 
    day_component   : day_in_month_number; 
    month_component : month_in_year_number; 
  WHERE 
    wr1: valid_calendar_date(SELF); 
END_ENTITY; -- calendar_date
 
ENTITY cartesian_point 
  SUBTYPE OF (point); 
    coordinates : LIST [1:3] OF length_measure; 
END_ENTITY; -- cartesian_point
 
ENTITY cartesian_transformation_operator 
  SUPERTYPE OF (cartesian_transformation_operator_3d) 
  SUBTYPE OF (geometric_representation_item,  
      functionally_defined_transformation); 
    axis1        : OPTIONAL direction; 
    axis2        : OPTIONAL direction; 
    local_origin : cartesian_point; 
    scale        : OPTIONAL REAL; 
  DERIVE 
    scl : REAL := NVL(scale,1); 
  WHERE 
    wr1: scl > 0; 
END_ENTITY; -- cartesian_transformation_operator
 
ENTITY cartesian_transformation_operator_3d 
  SUBTYPE OF (cartesian_transformation_operator); 
    axis3 : OPTIONAL direction; 
  DERIVE 
    u : LIST [3:3] OF direction := base_axis(3,SELF\ 
           cartesian_transformation_operator.axis1,SELF\ 
           cartesian_transformation_operator.axis2,axis3); 
  WHERE 
    wr1: SELF\geometric_representation_item.dim = 3; 
END_ENTITY; -- cartesian_transformation_operator_3d
 
ENTITY characterized_object; 
    name        : label; 
    description : OPTIONAL text; 
END_ENTITY; -- characterized_object
 
ENTITY circle 
  SUBTYPE OF (conic); 
    radius : positive_length_measure; 
END_ENTITY; -- circle
 
ENTITY class 
  SUBTYPE OF (group); 
  WHERE 
    wr1: SIZEOF(QUERY ( oa <* USEDIN(SELF, 
             'SHIP_ARRANGEMENT_SCHEMA.GROUP_ASSIGNMENT.ASSIGNED_GROUP') 
              | (NOT ('SHIP_ARRANGEMENT_SCHEMA.APPLIED_GROUP_ASSIGNMENT'  
             IN TYPEOF(oa))) )) = 0; 
END_ENTITY; -- class
 
ENTITY classification_assignment 
  ABSTRACT SUPERTYPE; 
    assigned_class : group; 
    role           : classification_role; 
END_ENTITY; -- classification_assignment
 
ENTITY classification_role; 
    name        : label; 
    description : OPTIONAL text; 
END_ENTITY; -- classification_role
 
ENTITY closed_shell 
  SUBTYPE OF (connected_face_set); 
END_ENTITY; -- closed_shell
 
ENTITY composite_curve 
  SUBTYPE OF (bounded_curve); 
    segments       : LIST [1:?] OF composite_curve_segment; 
    self_intersect : LOGICAL; 
  DERIVE 
    n_segments   : INTEGER := SIZEOF(segments); 
    closed_curve : LOGICAL := segments[n_segments].transition <>  
                      discontinuous; 
  WHERE 
    wr1: ((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | ( 
             temp.transition = discontinuous) )) = 1)) OR (closed_curve  
             AND (SIZEOF(QUERY ( temp <* segments | (temp.transition =  
             discontinuous) )) = 0)); 
END_ENTITY; -- composite_curve
 
ENTITY composite_curve_on_surface 
  SUBTYPE OF (composite_curve); 
  DERIVE 
    basis_surface : SET [0:2] OF surface := get_basis_surface(SELF); 
  WHERE 
    wr1: SIZEOF(basis_surface) > 0; 
    wr2: constraints_composite_curve_on_surface(SELF); 
END_ENTITY; -- composite_curve_on_surface
 
ENTITY composite_curve_segment 
  SUBTYPE OF (founded_item); 
    transition   : transition_code; 
    same_sense   : BOOLEAN; 
    parent_curve : curve; 
  INVERSE 
    using_curves : BAG [1:?] OF composite_curve FOR segments; 
  WHERE 
    wr1: 'SHIP_ARRANGEMENT_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve); 
END_ENTITY; -- composite_curve_segment
 
ENTITY compound_representation_item 
  SUBTYPE OF (representation_item); 
    item_element : compound_item_definition; 
END_ENTITY; -- compound_representation_item
 
ENTITY conic 
  SUPERTYPE OF (ONEOF (circle,ellipse,hyperbola,parabola)) 
  SUBTYPE OF (curve); 
    position : axis2_placement; 
END_ENTITY; -- conic
 
ENTITY conical_surface 
  SUBTYPE OF (elementary_surface); 
    radius     : length_measure; 
    semi_angle : plane_angle_measure; 
  WHERE 
    wr1: radius >= 0; 
END_ENTITY; -- conical_surface
 
ENTITY connected_face_set 
  SUPERTYPE OF (ONEOF (closed_shell,open_shell)) 
  SUBTYPE OF (topological_representation_item); 
    cfs_faces : SET [1:?] OF face; 
END_ENTITY; -- connected_face_set
 
ENTITY context_dependent_unit 
  SUBTYPE OF (named_unit); 
    name : label; 
END_ENTITY; -- context_dependent_unit
 
ENTITY coordinated_universal_time_offset; 
    hour_offset   : INTEGER; 
    minute_offset : OPTIONAL INTEGER; 
    sense         : ahead_or_behind; 
  DERIVE 
    actual_minute_offset : INTEGER := NVL(minute_offset,0); 
  WHERE 
    wr1: (0 <= hour_offset) AND (hour_offset < 24); 
    wr2: (0 <= actual_minute_offset) AND (actual_minute_offset <= 59); 
    wr3: NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND ( 
             sense = exact)); 
END_ENTITY; -- coordinated_universal_time_offset
 
ENTITY curve 
  SUPERTYPE OF (ONEOF (line,conic,pcurve,surface_curve,offset_curve_3d, 
      curve_replica)) 
  SUBTYPE OF (geometric_representation_item); 
END_ENTITY; -- curve
 
ENTITY curve_replica 
  SUBTYPE OF (curve); 
    parent_curve   : curve; 
    transformation : cartesian_transformation_operator; 
  WHERE 
    wr1: transformation.dim = parent_curve.dim; 
    wr2: acyclic_curve_replica(SELF,parent_curve); 
END_ENTITY; -- curve_replica
 
ENTITY cylindrical_surface 
  SUBTYPE OF (elementary_surface); 
    radius : positive_length_measure; 
END_ENTITY; -- cylindrical_surface
 
ENTITY date 
  SUPERTYPE OF (ONEOF (calendar_date,ordinal_date, 
      week_of_year_and_day_date)); 
    year_component : year_number; 
END_ENTITY; -- date
 
ENTITY date_and_time; 
    date_component : date; 
    time_component : local_time; 
END_ENTITY; -- date_and_time
 
ENTITY date_and_time_assignment 
  ABSTRACT SUPERTYPE; 
    assigned_date_and_time : date_and_time; 
    role                   : date_time_role; 
END_ENTITY; -- date_and_time_assignment
 
ENTITY date_time_role; 
    name : label; 
  DERIVE 
    description : text := get_description_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
END_ENTITY; -- date_time_role
 
ENTITY definitional_representation 
  SUBTYPE OF (representation); 
  WHERE 
    wr1: 'SHIP_ARRANGEMENT_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN 
              TYPEOF(SELF\representation.context_of_items); 
END_ENTITY; -- definitional_representation
 
ENTITY degenerate_pcurve 
  SUBTYPE OF (point); 
    basis_surface      : surface; 
    reference_to_curve : definitional_representation; 
  WHERE 
    wr1: SIZEOF(reference_to_curve\representation.items) = 1; 
    wr2: 'SHIP_ARRANGEMENT_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\ 
             representation.items[1]); 
    wr3: reference_to_curve\representation.items[1]\ 
             geometric_representation_item.dim = 2; 
END_ENTITY; -- degenerate_pcurve
 
ENTITY degenerate_toroidal_surface 
  SUBTYPE OF (toroidal_surface); 
    select_outer : BOOLEAN; 
  WHERE 
    wr1: major_radius < minor_radius; 
END_ENTITY; -- degenerate_toroidal_surface
 
ENTITY derived_unit; 
    elements : SET [1:?] OF derived_unit_element; 
  DERIVE 
    name : label := get_name_value(SELF); 
  WHERE 
    wr1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements 
             [1].exponent <> 1)); 
    wr2: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1; 
END_ENTITY; -- derived_unit
 
ENTITY derived_unit_element; 
    unit     : named_unit; 
    exponent : REAL; 
END_ENTITY; -- derived_unit_element
 
ENTITY description_attribute; 
    attribute_value : text; 
    described_item  : description_attribute_select; 
END_ENTITY; -- description_attribute
 
ENTITY descriptive_representation_item 
  SUBTYPE OF (representation_item); 
    description : text; 
END_ENTITY; -- descriptive_representation_item
 
ENTITY dimensional_exponents; 
    length_exponent                    : REAL; 
    mass_exponent                      : REAL; 
    time_exponent                      : REAL; 
    electric_current_exponent          : REAL; 
    thermodynamic_temperature_exponent : REAL; 
    amount_of_substance_exponent       : REAL; 
    luminous_intensity_exponent        : REAL; 
END_ENTITY; -- dimensional_exponents
 
ENTITY direction 
  SUBTYPE OF (geometric_representation_item); 
    direction_ratios : LIST [2:3] OF REAL; 
  WHERE 
    wr1: SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0; 
END_ENTITY; -- direction
 
ENTITY document; 
    id          : identifier; 
    name        : label; 
    description : OPTIONAL text; 
    kind        : document_type; 
  INVERSE 
    representation_types : SET [0:?] OF document_representation_type FOR  
                              represented_document; 
END_ENTITY; -- document
 
ENTITY document_reference 
  ABSTRACT SUPERTYPE; 
    assigned_document : document; 
    source            : label; 
  DERIVE 
    role : object_role := get_role(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1; 
END_ENTITY; -- document_reference
 
ENTITY document_representation_type; 
    name                 : label; 
    represented_document : document; 
END_ENTITY; -- document_representation_type
 
ENTITY document_type; 
    product_data_type : label; 
END_ENTITY; -- document_type
 
ENTITY document_usage_constraint; 
    source                : document; 
    subject_element       : label; 
    subject_element_value : text; 
END_ENTITY; -- document_usage_constraint
 
ENTITY edge 
  SUPERTYPE OF (ONEOF (edge_curve,oriented_edge)) 
  SUBTYPE OF (topological_representation_item); 
    edge_start : vertex; 
    edge_end   : vertex; 
END_ENTITY; -- edge
 
ENTITY edge_curve 
  SUBTYPE OF (edge, geometric_representation_item); 
    edge_geometry : curve; 
    same_sense    : BOOLEAN; 
END_ENTITY; -- edge_curve
 
ENTITY edge_loop 
  SUBTYPE OF (loop, path); 
  DERIVE 
    ne : INTEGER := SIZEOF(SELF\path.edge_list); 
  WHERE 
    wr1: SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne]. 
             edge_end; 
END_ENTITY; -- edge_loop
 
ENTITY effectivity
  SUPERTYPE OF (serial_numbered_effectivity);
    id : identifier;
  DERIVE
    name : label := get_name_value(SELF);
    description : text := get_description_value(SELF);
  WHERE
   wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +
     'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
   wr2: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +
     'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- effectivity

ENTITY effectivity_assignment
  ABSTRACT SUPERTYPE;
    assigned_effectivity : effectivity;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +
     'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- effectivity_assignment

ENTITY elementary_surface 
  SUPERTYPE OF (ONEOF (plane,cylindrical_surface,conical_surface, 
      spherical_surface,toroidal_surface)) 
  SUBTYPE OF (surface); 
    position : axis2_placement_3d; 
END_ENTITY; -- elementary_surface
 
ENTITY ellipse 
  SUBTYPE OF (conic); 
    semi_axis_1 : positive_length_measure; 
    semi_axis_2 : positive_length_measure; 
END_ENTITY; -- ellipse
 
ENTITY evaluated_degenerate_pcurve 
  SUBTYPE OF (degenerate_pcurve); 
    equivalent_point : cartesian_point; 
END_ENTITY; -- evaluated_degenerate_pcurve
 
ENTITY executed_action 
  SUBTYPE OF (action); 
END_ENTITY; -- executed_action
 
ENTITY external_identification_assignment 
  ABSTRACT SUPERTYPE 
  SUBTYPE OF (identification_assignment); 
    source : external_source; 
END_ENTITY; -- external_identification_assignment
 
ENTITY external_source; 
    source_id : source_item; 
  DERIVE 
    description : text := get_description_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
END_ENTITY; -- external_source
 
ENTITY external_source_relationship; 
    name            : label; 
    description     : OPTIONAL text; 
    relating_source : external_source; 
    related_source  : external_source; 
END_ENTITY; -- external_source_relationship
 
ENTITY face 
  SUPERTYPE OF (ONEOF (face_surface,oriented_face)) 
  SUBTYPE OF (topological_representation_item); 
    bounds : SET [1:?] OF face_bound; 
  WHERE 
    wr1: NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))); 
    wr2: SIZEOF(QUERY ( temp <* bounds | ( 
             'SHIP_ARRANGEMENT_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp)) ))  
             <= 1; 
END_ENTITY; -- face
 
ENTITY face_based_surface_model 
  SUBTYPE OF (geometric_representation_item); 
    fbsm_faces : SET [1:?] OF connected_face_set; 
END_ENTITY; -- face_based_surface_model
 
ENTITY face_bound 
  SUBTYPE OF (topological_representation_item); 
    bound       : loop; 
    orientation : BOOLEAN; 
END_ENTITY; -- face_bound
 
ENTITY face_outer_bound 
  SUBTYPE OF (face_bound); 
END_ENTITY; -- face_outer_bound
 
ENTITY face_surface 
  SUBTYPE OF (face, geometric_representation_item); 
    face_geometry : surface; 
    same_sense    : BOOLEAN; 
  WHERE 
    wr1: NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_SURFACE' IN TYPEOF( 
             face_geometry)); 
END_ENTITY; -- face_surface
 
ENTITY founded_item; 
END_ENTITY; -- founded_item
 
ENTITY functionally_defined_transformation; 
    name        : label; 
    description : OPTIONAL text; 
END_ENTITY; -- functionally_defined_transformation
 
ENTITY geometric_representation_context 
  SUBTYPE OF (representation_context); 
    coordinate_space_dimension : dimension_count; 
END_ENTITY; -- geometric_representation_context
 
ENTITY geometric_representation_item 
  SUPERTYPE OF (ONEOF (point,direction,vector,placement, 
      cartesian_transformation_operator,curve,surface,edge_curve, 
      face_surface,poly_loop,vertex_point,face_based_surface_model)) 
  SUBTYPE OF (representation_item); 
  DERIVE 
    dim : dimension_count := dimension_of(SELF); 
  WHERE 
    wr1: SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (NOT  
             ('SHIP_ARRANGEMENT_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT'  
             IN TYPEOF(using_rep.context_of_items))) )) = 0; 
END_ENTITY; -- geometric_representation_item
 
ENTITY  global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY; -- global_uncertainty_assigned_context

ENTITY global_unit_assigned_context 
  SUBTYPE OF (representation_context); 
    units : SET [1:?] OF unit; 
END_ENTITY; -- global_unit_assigned_context
 
ENTITY group; 
    name        : label; 
    description : OPTIONAL text; 
  DERIVE 
    id : identifier := get_id_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1; 
END_ENTITY; -- group

ENTITY group_assignment 
  ABSTRACT SUPERTYPE; 
    assigned_group : group; 
  DERIVE 
    role : object_role := get_role(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1; 
END_ENTITY; -- group_assignment

ENTITY group_relationship;
    name           : label;
    description    : OPTIONAL text;
    relating_group : group;
    related_group  : group;
END_ENTITY; -- group_relationship
 
ENTITY hyperbola 
  SUBTYPE OF (conic); 
    semi_axis      : positive_length_measure; 
    semi_imag_axis : positive_length_measure; 
END_ENTITY; -- hyperbola
 
ENTITY id_attribute; 
    attribute_value : identifier; 
    identified_item : id_attribute_select; 
END_ENTITY; -- id_attribute
 
ENTITY identification_assignment 
  ABSTRACT SUPERTYPE; 
    assigned_id : identifier; 
    role        : identification_role; 
END_ENTITY; -- identification_assignment
 
ENTITY identification_assignment_relationship; 
    name                               : label; 
    description                        : OPTIONAL text; 
    relating_identification_assignment : identification_assignment; 
    related_identification_assignment  : identification_assignment; 
END_ENTITY; -- identification_assignment_relationship
 
ENTITY identification_role; 
    name        : label; 
    description : OPTIONAL text; 
END_ENTITY; -- identification_role
 
ENTITY intersection_curve 
  SUBTYPE OF (surface_curve); 
  WHERE 
    wr1: SIZEOF(SELF\surface_curve.associated_geometry) = 2; 
    wr2: associated_surface(SELF\surface_curve.associated_geometry[1])  
             <> associated_surface(SELF\surface_curve.associated_geometry 
             [2]); 
END_ENTITY; -- intersection_curve
 
ENTITY item_defined_transformation; 
    name             : label; 
    description      : OPTIONAL text; 
    transform_item_1 : representation_item; 
    transform_item_2 : representation_item; 
END_ENTITY; -- item_defined_transformation
 
ENTITY length_unit 
  SUBTYPE OF (named_unit); 
  WHERE 
    wr1: ((((((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF 
             \named_unit.dimensions.mass_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.time_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.electric_current_exponent = 0)) AND ( 
             SELF\named_unit.dimensions. 
             thermodynamic_temperature_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.amount_of_substance_exponent = 0)) AND 
              (SELF\named_unit.dimensions.luminous_intensity_exponent = 0); 
END_ENTITY; -- length_unit
 
ENTITY line 
  SUBTYPE OF (curve); 
    pnt : cartesian_point; 
    dir : vector; 
  WHERE 
    wr1: dir.dim = pnt.dim; 
END_ENTITY; -- line
 
ENTITY local_time; 
    hour_component   : hour_in_day; 
    minute_component : OPTIONAL minute_in_hour; 
    second_component : OPTIONAL second_in_minute; 
    zone             : coordinated_universal_time_offset; 
  WHERE 
    wr1: valid_time(SELF); 
END_ENTITY; -- local_time
 
ENTITY loop 
  SUPERTYPE OF (ONEOF (vertex_loop,edge_loop,poly_loop)) 
  SUBTYPE OF (topological_representation_item); 
END_ENTITY; -- loop
 
ENTITY luminous_intensity_unit 
  SUBTYPE OF (named_unit); 
  WHERE 
    wr1: ((((((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF 
             \named_unit.dimensions.mass_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.time_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.electric_current_exponent = 0)) AND ( 
             SELF\named_unit.dimensions. 
             thermodynamic_temperature_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.amount_of_substance_exponent = 0)) AND 
              (SELF\named_unit.dimensions.luminous_intensity_exponent = 1); 
END_ENTITY; -- luminous_intensity_unit
 
ENTITY mapped_item 
  SUBTYPE OF (representation_item); 
    mapping_source : representation_map; 
    mapping_target : representation_item; 
  WHERE 
    wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]); 
END_ENTITY; -- mapped_item
 
ENTITY mass_unit 
  SUBTYPE OF (named_unit); 
  WHERE 
    wr1: ((((((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF 
             \named_unit.dimensions.mass_exponent = 1)) AND (SELF\ 
             named_unit.dimensions.time_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.electric_current_exponent = 0)) AND ( 
             SELF\named_unit.dimensions. 
             thermodynamic_temperature_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.amount_of_substance_exponent = 0)) AND 
              (SELF\named_unit.dimensions.luminous_intensity_exponent = 0); 
END_ENTITY; -- mass_unit
 
ENTITY measure_with_unit; 
    value_component : measure_value; 
    unit_component  : unit; 
  WHERE 
    wr1: valid_units(SELF); 
END_ENTITY; -- measure_with_unit
 
ENTITY name_attribute; 
    attribute_value : label; 
    named_item      : name_attribute_select; 
END_ENTITY; -- name_attribute
 
ENTITY named_unit 
  SUPERTYPE OF (ONEOF (si_unit,context_dependent_unit) ANDOR ONEOF ( 
      length_unit,mass_unit,time_unit,thermodynamic_temperature_unit, 
      luminous_intensity_unit,plane_angle_unit, ratio_unit)); 
    dimensions : dimensional_exponents; 
END_ENTITY; -- named_unit
 
ENTITY non_manifold_surface_shape_representation 
  SUBTYPE OF (shape_representation); 
  WHERE 
    wr1 : SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([ 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL', 
              'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM', 
              'SHIP_ARRANGEMENT_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it))  
              = 1)) )) = 0; 
    wr2 : SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([ 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL', 
              'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) ))  
              > 0; 
    wr3 : SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | ( 
              NOT ((('SHIP_ARRANGEMENT_SCHEMA.' +  
              'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION') IN TYPEOF(mi\ 
              mapped_item.mapping_source.mapped_representation)) AND ( 
              SIZEOF(QUERY ( mr_it <* mi\mapped_item.mapping_source. 
              mapped_representation.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(mr_it)) )) > 0))) )) = 0; 
    wr4 : SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( fa <* cfs.cfs_faces | (NOT (SIZEOF([ 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE', 
              'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_FACE'] * TYPEOF(fa)) = 1)) ))  
              = 0)) )) = 0)) )) = 0; 
    wr5 : SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR (SIZEOF(['SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_SURFACE', 
              'SHIP_ARRANGEMENT_SCHEMA.ELEMENTARY_SURFACE', 
              'SHIP_ARRANGEMENT_SCHEMA.OFFSET_SURFACE', 
              'SHIP_ARRANGEMENT_SCHEMA.SURFACE_REPLICA', 
              'SHIP_ARRANGEMENT_SCHEMA.SWEPT_SURFACE'] * TYPEOF(f_sf\ 
              face_surface.face_geometry)) = 1))) )) = 0)) )) = 0)) )) =  
              0; 
    wr6 : SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR nmsf_surface_check(f_sf\face_surface.face_geometry))) ))  
              = 0)) )) = 0)) )) = 0; 
    wr7 : SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR (SIZEOF(QUERY ( bnds <* f_sf.bounds | (NOT (SIZEOF([ 
              'SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP', 
              'SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnds.bound))  
              = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0; 
    wr8 : SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* f_sf.bounds 
               | ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds. 
              bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path. 
              edge_list | (NOT ('SHIP_ARRANGEMENT_SCHEMA.EDGE_CURVE' IN  
              TYPEOF(oe.edge_element))) )) = 0)) )) = 0))) )) = 0)) )) =  
              0)) )) = 0; 
    wr9 : SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* f_sf.bounds 
               | ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds. 
              bound)) ) | (NOT (SIZEOF(QUERY ( oe_cv <* QUERY ( oe <*  
              elp_fbnds\path.edge_list | ( 
              'SHIP_ARRANGEMENT_SCHEMA.EDGE_CURVE' IN TYPEOF(oe. 
              edge_element)) ) | (NOT (SIZEOF([ 
              'SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE', 
              'SHIP_ARRANGEMENT_SCHEMA.CONIC', 
              'SHIP_ARRANGEMENT_SCHEMA.CURVE_REPLICA', 
              'SHIP_ARRANGEMENT_SCHEMA.LINE', 
              'SHIP_ARRANGEMENT_SCHEMA.OFFSET_CURVE_3D', 
              'SHIP_ARRANGEMENT_SCHEMA.PCURVE', 
              'SHIP_ARRANGEMENT_SCHEMA.POLYLINE', 
              'SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE'] * TYPEOF(oe_cv. 
              edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) = 
               0))) )) = 0)) )) = 0)) )) = 0; 
    wr10: SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* f_sf.bounds 
               | ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds. 
              bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path. 
              edge_list | (NOT nmsf_curve_check(oe.edge_element\ 
              edge_curve.edge_geometry)) )) = 0)) )) = 0))) )) = 0)) )) = 
               0)) )) = 0; 
    wr11: SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* f_sf.bounds 
               | ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds. 
              bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path. 
              edge_list | (NOT (('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT'  
              IN TYPEOF(oe.edge_element.edge_start)) AND ( 
              'SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT' IN TYPEOF(oe. 
              edge_element.edge_end)))) )) = 0)) )) = 0))) )) = 0)) )) =  
              0)) )) = 0; 
    wr12: SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* f_sf.bounds 
               | ('SHIP_ARRANGEMENT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds. 
              bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path. 
              edge_list | (NOT ((SIZEOF([ 
              'SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT', 
              'SHIP_ARRANGEMENT_SCHEMA.DEGENERATE_PCURVE', 
              'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_CURVE', 
              'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe. 
              edge_element.edge_start\vertex_point.vertex_geometry)) = 1)  
              AND (SIZEOF(['SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT', 
              'SHIP_ARRANGEMENT_SCHEMA.DEGENERATE_PCURVE', 
              'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_CURVE', 
              'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe. 
              edge_element.edge_end\vertex_point.vertex_geometry)) = 1))) ))  
              = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0; 
    wr13: SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* f_sf.bounds 
               | ('SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds. 
              bound)) ) | (NOT ('SHIP_ARRANGEMENT_SCHEMA.VERTEX_POINT'  
              IN TYPEOF(vlp_fbnds\vertex_loop.loop_vertex))) )) = 0))) ))  
              = 0)) )) = 0)) )) = 0; 
    wr14: SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_BASED_SURFACE_MODEL' IN  
              TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\ 
              face_based_surface_model.fbsm_faces | (NOT (SIZEOF( 
              QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) OR ( 
              'SHIP_ARRANGEMENT_SCHEMA.FACE_SURFACE' IN TYPEOF(fa\ 
              oriented_face.face_element))) ) | (NOT (( 
              'SHIP_ARRANGEMENT_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf))  
              OR (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* f_sf.bounds 
               | ('SHIP_ARRANGEMENT_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds. 
              bound)) ) | (NOT (SIZEOF([ 
              'SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT', 
              'SHIP_ARRANGEMENT_SCHEMA.DEGENERATE_PCURVE', 
              'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_CURVE', 
              'SHIP_ARRANGEMENT_SCHEMA.POINT_ON_SURFACE'] * TYPEOF( 
              vlp_fbnds\vertex_loop.loop_vertex\vertex_point. 
              vertex_geometry)) = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0; 
END_ENTITY; -- non_manifold_surface_shape_representation
 
ENTITY object_role; 
    name        : label; 
    description : OPTIONAL text; 
END_ENTITY; -- object_role
 
ENTITY offset_curve_3d 
  SUBTYPE OF (curve); 
    basis_curve    : curve; 
    distance       : length_measure; 
    self_intersect : LOGICAL; 
    ref_direction  : direction; 
  WHERE 
    wr1: (basis_curve.dim = 3) AND (ref_direction.dim = 3); 
END_ENTITY; -- offset_curve_3d
 
ENTITY offset_surface 
  SUBTYPE OF (surface); 
    basis_surface  : surface; 
    distance       : length_measure; 
    self_intersect : LOGICAL; 
END_ENTITY; -- offset_surface
 
ENTITY open_shell 
  SUBTYPE OF (connected_face_set); 
END_ENTITY; -- open_shell
 
ENTITY ordinal_date 
  SUBTYPE OF (date); 
    day_component : day_in_year_number; 
  WHERE 
    wr1: ((NOT leap_year(SELF.year_component)) AND ((1 <= day_component)  
             AND (day_component <= 365))) OR (leap_year(SELF. 
             year_component) AND ((1 <= day_component) AND (day_component  
             <= 366))); 
END_ENTITY; -- ordinal_date
 
ENTITY organization; 
    id          : OPTIONAL identifier; 
    name        : label; 
    description : OPTIONAL text; 
END_ENTITY; -- organization
 
ENTITY organization_assignment 
  ABSTRACT SUPERTYPE; 
    assigned_organization : organization; 
    role                  : organization_role; 
END_ENTITY; -- organization_assignment
 
ENTITY organization_role; 
    name : label; 
  DERIVE 
    description : text := get_description_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
END_ENTITY; -- organization_role
 
ENTITY organizational_address 
  SUBTYPE OF (address); 
    organizations : SET [1:?] OF organization; 
    description   : OPTIONAL text; 
END_ENTITY; -- organizational_address
 
ENTITY organizational_project; 
    name                      : label; 
    description               : OPTIONAL text; 
    responsible_organizations : SET [1:?] OF organization; 
  DERIVE 
    id : identifier := get_id_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1; 
END_ENTITY; -- organizational_project
 
ENTITY oriented_closed_shell 
  SUBTYPE OF (closed_shell); 
    closed_shell_element : closed_shell; 
    orientation          : BOOLEAN; 
  DERIVE 
    SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=  
                                           conditional_reverse(SELF. 
                                           orientation,SELF. 
                                           closed_shell_element.cfs_faces); 
  WHERE 
    wr1: NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_CLOSED_SHELL' IN  
             TYPEOF(SELF.closed_shell_element)); 
END_ENTITY; -- oriented_closed_shell
 
ENTITY oriented_edge 
  SUBTYPE OF (edge); 
    edge_element : edge; 
    orientation  : BOOLEAN; 
  DERIVE 
    SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation, 
                              SELF.edge_element.edge_start,SELF. 
                              edge_element.edge_end); 
    SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation, 
                              SELF.edge_element.edge_end,SELF. 
                              edge_element.edge_start); 
  WHERE 
    wr1: NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_EDGE' IN TYPEOF(SELF. 
             edge_element)); 
END_ENTITY; -- oriented_edge
 
ENTITY oriented_face 
  SUBTYPE OF (face); 
    face_element : face; 
    orientation  : BOOLEAN; 
  DERIVE 
    SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse( 
                          SELF.orientation,SELF.face_element.bounds); 
  WHERE 
    wr1: NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_FACE' IN TYPEOF(SELF. 
             face_element)); 
END_ENTITY; -- oriented_face
 
ENTITY oriented_open_shell 
  SUBTYPE OF (open_shell); 
    open_shell_element : open_shell; 
    orientation        : BOOLEAN; 
  DERIVE 
    SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=  
                                           conditional_reverse(SELF. 
                                           orientation,SELF. 
                                           open_shell_element.cfs_faces); 
  WHERE 
    wr1: NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF( 
             SELF.open_shell_element)); 
END_ENTITY; -- oriented_open_shell
 
ENTITY oriented_path 
  SUBTYPE OF (path); 
    path_element : path; 
    orientation  : BOOLEAN; 
  DERIVE 
    SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge :=  
                             conditional_reverse(SELF.orientation,SELF. 
                             path_element.edge_list); 
  WHERE 
    wr1: NOT ('SHIP_ARRANGEMENT_SCHEMA.ORIENTED_PATH' IN TYPEOF(SELF. 
             path_element)); 
END_ENTITY; -- oriented_path
 
ENTITY oriented_surface 
  SUBTYPE OF (surface); 
    orientation : BOOLEAN; 
END_ENTITY; -- oriented_surface
 
ENTITY parabola 
  SUBTYPE OF (conic); 
    focal_dist : length_measure; 
  WHERE 
    wr1: focal_dist <> 0; 
END_ENTITY; -- parabola
 
ENTITY parametric_representation_context 
  SUBTYPE OF (representation_context); 
END_ENTITY; -- parametric_representation_context
 
ENTITY path 
  SUPERTYPE OF (ONEOF (edge_loop,oriented_path)) 
  SUBTYPE OF (topological_representation_item); 
    edge_list : LIST [1:?] OF UNIQUE oriented_edge; 
  WHERE 
    wr1: path_head_to_tail(SELF); 
END_ENTITY; -- path
 
ENTITY pcurve 
  SUBTYPE OF (curve); 
    basis_surface      : surface; 
    reference_to_curve : definitional_representation; 
  WHERE 
    wr1: SIZEOF(reference_to_curve\representation.items) = 1; 
    wr2: 'SHIP_ARRANGEMENT_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\ 
             representation.items[1]); 
    wr3: reference_to_curve\representation.items[1]\ 
             geometric_representation_item.dim = 2; 
END_ENTITY; -- pcurve
 
ENTITY person; 
    id            : identifier; 
    last_name     : OPTIONAL label; 
    first_name    : OPTIONAL label; 
    middle_names  : OPTIONAL LIST [1:?] OF label; 
    prefix_titles : OPTIONAL LIST [1:?] OF label; 
    suffix_titles : OPTIONAL LIST [1:?] OF label; 
  WHERE 
    wr1: EXISTS(last_name) OR EXISTS(first_name); 
END_ENTITY; -- person
 
ENTITY person_and_organization; 
    the_person       : person; 
    the_organization : organization; 
  DERIVE 
    name        : label := get_name_value(SELF); 
    description : text := get_description_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1; 
    wr2: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
END_ENTITY; -- person_and_organization
 
ENTITY person_and_organization_assignment 
  ABSTRACT SUPERTYPE; 
    assigned_person_and_organization : person_and_organization; 
    role                             : person_and_organization_role; 
END_ENTITY; -- person_and_organization_assignment
 
ENTITY person_and_organization_role; 
    name : label; 
  DERIVE 
    description : text := get_description_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
END_ENTITY; -- person_and_organization_role
 
ENTITY person_assignment 
  ABSTRACT SUPERTYPE; 
    assigned_person : person; 
    role            : person_role; 
END_ENTITY; -- person_assignment
 
ENTITY person_role; 
    name : label; 
  DERIVE 
    description : text := get_description_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
END_ENTITY; -- person_role
 
ENTITY personal_address 
  SUBTYPE OF (address); 
    people      : SET [1:?] OF person; 
    description : OPTIONAL text; 
END_ENTITY; -- personal_address
 
ENTITY placement 
  SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d, 
      axis2_placement_3d)) 
  SUBTYPE OF (geometric_representation_item); 
    location : cartesian_point; 
END_ENTITY; -- placement
 
ENTITY plane 
  SUBTYPE OF (elementary_surface); 
END_ENTITY; -- plane
 
ENTITY plane_angle_unit 
  SUBTYPE OF (named_unit); 
  WHERE 
    wr1: ((((((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF 
             \named_unit.dimensions.mass_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.time_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.electric_current_exponent = 0)) AND ( 
             SELF\named_unit.dimensions. 
             thermodynamic_temperature_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.amount_of_substance_exponent = 0)) AND 
              (SELF\named_unit.dimensions.luminous_intensity_exponent = 0); 
END_ENTITY; -- plane_angle_unit
 
ENTITY point 
  SUPERTYPE OF (ONEOF (cartesian_point,point_on_curve,point_on_surface, 
      degenerate_pcurve)) 
  SUBTYPE OF (geometric_representation_item); 
END_ENTITY; -- point
 
ENTITY point_on_curve 
  SUBTYPE OF (point); 
    basis_curve     : curve; 
    point_parameter : parameter_value; 
END_ENTITY; -- point_on_curve
 
ENTITY point_on_surface 
  SUBTYPE OF (point); 
    basis_surface     : surface; 
    point_parameter_u : parameter_value; 
    point_parameter_v : parameter_value; 
END_ENTITY; -- point_on_surface
 
ENTITY poly_loop 
  SUBTYPE OF (loop, geometric_representation_item); 
    polygon : LIST [3:?] OF UNIQUE cartesian_point; 
END_ENTITY; -- poly_loop
 
ENTITY polyline 
  SUBTYPE OF (bounded_curve); 
    points : LIST [2:?] OF cartesian_point; 
END_ENTITY; -- polyline
 
ENTITY product; 
    id                 : identifier; 
    name               : label; 
    description        : OPTIONAL text; 
    frame_of_reference : SET [1:?] OF product_context; 
END_ENTITY; -- product
 
ENTITY product_category; 
    name        : label; 
    description : OPTIONAL text; 
  DERIVE 
    id : identifier := get_id_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1; 
END_ENTITY; -- product_category
 
ENTITY product_context 
  SUBTYPE OF (application_context_element); 
    discipline_type : label; 
END_ENTITY; -- product_context
 
ENTITY product_definition; 
    id                 : identifier; 
    description        : OPTIONAL text; 
    formation          : product_definition_formation; 
    frame_of_reference : product_definition_context; 
  DERIVE 
    name : label := get_name_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1; 
END_ENTITY; -- product_definition
 
ENTITY product_definition_context 
  SUBTYPE OF (application_context_element); 
    life_cycle_stage : label; 
END_ENTITY; -- product_definition_context
 
ENTITY product_definition_formation; 
    id          : identifier; 
    description : OPTIONAL text; 
    of_product  : product; 
  UNIQUE 
    ur1 : id, of_product; 
END_ENTITY; -- product_definition_formation
 
ENTITY product_definition_relationship; 
    id                          : identifier; 
    name                        : label; 
    description                 : OPTIONAL text; 
    relating_product_definition : product_definition; 
    related_product_definition  : product_definition; 
END_ENTITY; -- product_definition_relationship
 
ENTITY product_definition_shape 
  SUBTYPE OF (property_definition); 
  UNIQUE 
    ur1 : definition; 
  WHERE 
    wr1: SIZEOF([ 
             'SHIP_ARRANGEMENT_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION', 
             'SHIP_ARRANGEMENT_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF( 
             SELF\property_definition.definition)) > 0; 
END_ENTITY; -- product_definition_shape
 
ENTITY product_definition_with_associated_documents 
  SUBTYPE OF (product_definition); 
    documentation_ids : SET [1:?] OF document; 
END_ENTITY; -- product_definition_with_associated_documents
 
ENTITY product_related_product_category 
  SUBTYPE OF (product_category); 
    products : SET [1:?] OF product; 
END_ENTITY; -- product_related_product_category
 
ENTITY property_definition; 
    name        : label; 
    description : OPTIONAL text; 
    definition  : characterized_definition; 
  DERIVE 
    id : identifier := get_id_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1; 
END_ENTITY; -- property_definition
 
ENTITY property_definition_relationship; 
    name                         : label; 
    description                  : text; 
    relating_property_definition : property_definition; 
    related_property_definition  : property_definition; 
END_ENTITY; -- property_definition_relationship
 
ENTITY property_definition_representation; 
    definition          : represented_definition; 
    used_representation : representation; 
  DERIVE 
    description : text := get_description_value(SELF); 
    name        : label := get_name_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
    wr2: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1; 
END_ENTITY; -- property_definition_representation
 
ENTITY quasi_uniform_curve 
  SUBTYPE OF (b_spline_curve); 
END_ENTITY; -- quasi_uniform_curve
 
ENTITY quasi_uniform_surface 
  SUBTYPE OF (b_spline_surface); 
END_ENTITY; -- quasi_uniform_surface
 
ENTITY ratio_unit 
  SUBTYPE OF (named_unit); 
  WHERE 
    wr1: ((((((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF 
             \named_unit.dimensions.mass_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.time_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.electric_current_exponent = 0)) AND ( 
             SELF\named_unit.dimensions. 
             thermodynamic_temperature_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.amount_of_substance_exponent = 0)) AND 
              (SELF\named_unit.dimensions.luminous_intensity_exponent = 0); 
END_ENTITY; -- ratio_unit
 
ENTITY rational_b_spline_curve 
  SUBTYPE OF (b_spline_curve); 
    weights_data : LIST [2:?] OF REAL; 
  DERIVE 
    weights : ARRAY [0:upper_index_on_control_points] OF REAL :=  
                 list_to_array(weights_data,0, 
                 upper_index_on_control_points); 
  WHERE 
    wr1: SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve. 
             control_points_list); 
    wr2: curve_weights_positive(SELF); 
END_ENTITY; -- rational_b_spline_curve
 
ENTITY rational_b_spline_surface 
  SUBTYPE OF (b_spline_surface); 
    weights_data : LIST [2:?] OF LIST [2:?] OF REAL; 
  DERIVE 
    weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL :=  
                 make_array_of_array(weights_data,0,u_upper,0,v_upper); 
  WHERE 
    wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface. 
             control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF( 
             SELF\b_spline_surface.control_points_list[1])); 
    wr2: surface_weights_positive(SELF); 
END_ENTITY; -- rational_b_spline_surface
 
ENTITY representation; 
    name             : label; 
    items            : SET [1:?] OF representation_item; 
    context_of_items : representation_context; 
  DERIVE 
    id          : identifier := get_id_value(SELF); 
    description : text := get_description_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1; 
    wr2: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1; 
END_ENTITY; -- representation
 
ENTITY representation_context; 
    context_identifier : identifier; 
    context_type       : text; 
  INVERSE 
    representations_in_context : SET [1:?] OF representation FOR  
                                    context_of_items; 
END_ENTITY; -- representation_context
 
ENTITY representation_item; 
    name : label; 
  WHERE 
    wr1: SIZEOF(using_representations(SELF)) > 0; 
END_ENTITY; -- representation_item
 
ENTITY representation_map; 
    mapping_origin        : representation_item; 
    mapped_representation : representation; 
  INVERSE 
    map_usage : SET [1:?] OF mapped_item FOR mapping_source; 
  WHERE 
    wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation. 
             context_of_items); 
END_ENTITY; -- representation_map
 
ENTITY representation_relationship; 
    name        : label; 
    description : OPTIONAL text; 
    rep_1       : representation; 
    rep_2       : representation; 
END_ENTITY; -- representation_relationship
 
ENTITY role_association; 
    role           : object_role; 
    item_with_role : role_select; 
END_ENTITY; -- role_association
ENTITY seam_curve 
  SUBTYPE OF (surface_curve); 
  WHERE 
    wr1: SIZEOF(SELF\surface_curve.associated_geometry) = 2; 
    wr2: associated_surface(SELF\surface_curve.associated_geometry[1]) = 
              associated_surface(SELF\surface_curve.associated_geometry[2]); 
    wr3: 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve. 
             associated_geometry[1]); 
    wr4: 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve. 
             associated_geometry[2]); 
END_ENTITY; -- seam_curve

ENTITY serial_numbered_effectivity
  		SUBTYPE OF (effectivity);
    effectivity_start_id : identifier;
    effectivity_end_id : OPTIONAL identifier;
END_ENTITY; -- serial_numbered_effectivity
 
ENTITY shape_aspect; 
    name                 : label; 
    description          : OPTIONAL text; 
    of_shape             : product_definition_shape; 
    product_definitional : LOGICAL; 
  DERIVE 
    id : identifier := get_id_value(SELF); 
  WHERE 
    wr1: SIZEOF(USEDIN(SELF,'SHIP_ARRANGEMENT_SCHEMA.' +  
             'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1; 
END_ENTITY; -- shape_aspect

ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: (('SHIP_ARRANGEMENT_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN 
               TYPEOF(SELF.definition)) OR (
               'SHIP_ARRANGEMENT_SCHEMA.SHAPE_DEFINITION' IN 			TYPEOF(SELF.definition.definition)));
      wr2: ('SHIP_ARRANGEMENT_SCHEMA.SHAPE_REPRESENTATION' IN 	TYPEOF(SELF.used_representation));
END_ENTITY; -- shape_definition_representation
 
ENTITY shape_representation 
  SUBTYPE OF (representation); 
END_ENTITY; -- shape_representation
 
ENTITY si_unit 
  SUBTYPE OF (named_unit); 
    prefix : OPTIONAL si_prefix; 
    name   : si_unit_name; 
  DERIVE 
    SELF\named_unit.dimensions : dimensional_exponents :=  
                                    dimensions_for_si_unit(name); 
END_ENTITY; -- si_unit
 
ENTITY spherical_surface 
  SUBTYPE OF (elementary_surface); 
    radius : positive_length_measure; 
END_ENTITY; -- spherical_surface
 
ENTITY surface 
  SUPERTYPE OF (ONEOF (elementary_surface,swept_surface,bounded_surface, 
      offset_surface,surface_replica)) 
  SUBTYPE OF (geometric_representation_item); 
END_ENTITY; -- surface
 
ENTITY surface_curve 
  SUPERTYPE OF (ONEOF (intersection_curve,seam_curve) ANDOR  
      bounded_surface_curve) 
  SUBTYPE OF (curve); 
    curve_3d              : curve; 
    associated_geometry   : LIST [1:2] OF pcurve_or_surface; 
    master_representation : preferred_surface_curve_representation; 
  DERIVE 
    basis_surface : SET [1:2] OF surface := get_basis_surface(SELF); 
  WHERE 
    wr1: curve_3d.dim = 3; 
    wr2: ('SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF( 
             associated_geometry[1])) OR (master_representation <>  
             pcurve_s1); 
    wr3: ('SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF( 
             associated_geometry[2])) OR (master_representation <>  
             pcurve_s2); 
    wr4: NOT ('SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(curve_3d)); 
END_ENTITY; -- surface_curve
 
ENTITY surface_of_linear_extrusion 
  SUBTYPE OF (swept_surface); 
    extrusion_axis : vector; 
END_ENTITY; -- surface_of_linear_extrusion
 
ENTITY surface_of_revolution 
  SUBTYPE OF (swept_surface); 
    axis_position : axis1_placement; 
  DERIVE 
    axis_line : line := (dummy_gri || curve()) || line(axis_position. 
                   location,dummy_gri || vector(axis_position.z,1)); 
END_ENTITY; -- surface_of_revolution
 
ENTITY surface_replica 
  SUBTYPE OF (surface); 
    parent_surface : surface; 
    transformation : cartesian_transformation_operator_3d; 
  WHERE 
    wr1: acyclic_surface_replica(SELF,parent_surface); 
END_ENTITY; -- surface_replica
 
ENTITY swept_surface 
  SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,surface_of_revolution)) 
  SUBTYPE OF (surface); 
    swept_curve : curve; 
END_ENTITY; -- swept_surface
 
ENTITY thermodynamic_temperature_unit 
  SUBTYPE OF (named_unit); 
  WHERE 
    wr1: ((((((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF 
             \named_unit.dimensions.mass_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.time_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.electric_current_exponent = 0)) AND ( 
             SELF\named_unit.dimensions. 
             thermodynamic_temperature_exponent = 1)) AND (SELF\ 
             named_unit.dimensions.amount_of_substance_exponent = 0)) AND 
              (SELF\named_unit.dimensions.luminous_intensity_exponent = 0); 
END_ENTITY; -- thermodynamic_temperature_unit
 
ENTITY time_unit 
  SUBTYPE OF (named_unit); 
  WHERE 
    wr1: ((((((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF 
             \named_unit.dimensions.mass_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.time_exponent = 1)) AND (SELF\ 
             named_unit.dimensions.electric_current_exponent = 0)) AND ( 
             SELF\named_unit.dimensions. 
             thermodynamic_temperature_exponent = 0)) AND (SELF\ 
             named_unit.dimensions.amount_of_substance_exponent = 0)) AND 
              (SELF\named_unit.dimensions.luminous_intensity_exponent = 0); 
END_ENTITY; -- time_unit
 
ENTITY topological_representation_item 
  SUPERTYPE OF (ONEOF (vertex,edge,face_bound,face,connected_face_set, 
      loop ANDOR path)) 
  SUBTYPE OF (representation_item); 
END_ENTITY; -- topological_representation_item
 
ENTITY toroidal_surface 
  SUBTYPE OF (elementary_surface); 
    major_radius : positive_length_measure; 
    minor_radius : positive_length_measure; 
END_ENTITY; -- toroidal_surface
 
ENTITY uncertainty_measure_with_unit 
  SUBTYPE OF (measure_with_unit); 
    name        : label; 
    description : OPTIONAL text; 
  WHERE 
    wr1: valid_measure_value(SELF\measure_with_unit.value_component); 
END_ENTITY; -- uncertainty_measure_with_unit
 
ENTITY uniform_curve 
  SUBTYPE OF (b_spline_curve); 
END_ENTITY; -- uniform_curve
 
ENTITY uniform_surface 
  SUBTYPE OF (b_spline_surface); 
END_ENTITY; -- uniform_surface
 
ENTITY value_representation_item 
  SUBTYPE OF (representation_item); 
    value_component : measure_value; 
  WHERE 
    wr1: SIZEOF(QUERY ( rep <* using_representations(SELF) | (NOT ( 
             'SHIP_ARRANGEMENT_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN  
             TYPEOF(rep.context_of_items))) )) = 0; 
END_ENTITY; -- value_representation_item
 
ENTITY vector 
  SUBTYPE OF (geometric_representation_item); 
    orientation : direction; 
    magnitude   : length_measure; 
  WHERE 
    wr1: magnitude >= 0; 
END_ENTITY; -- vector
 
ENTITY versioned_action_request; 
    id          : identifier; 
    version     : label; 
    purpose     : text; 
    description : OPTIONAL text; 
END_ENTITY; -- versioned_action_request
 
ENTITY vertex 
  SUBTYPE OF (topological_representation_item); 
END_ENTITY; -- vertex
 
ENTITY vertex_loop 
  SUBTYPE OF (loop); 
    loop_vertex : vertex; 
END_ENTITY; -- vertex_loop
 
ENTITY vertex_point 
  SUBTYPE OF (vertex, geometric_representation_item); 
    vertex_geometry : point; 
END_ENTITY; -- vertex_point
 
ENTITY week_of_year_and_day_date 
  SUBTYPE OF (date); 
    week_component : week_in_year_number; 
    day_component  : OPTIONAL day_in_week_number; 
END_ENTITY; -- week_of_year_and_day_date
 

RULE action_request_solution_connected_to_action FOR (action_request_solution, action );
   LOCAL
      t1_set : SET OF action_request_solution := [];
      t2_set : SET OF action := [];
      set_3 : SET OF action_method := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* action_request_solution| VALUE_IN(WHICH_CLASS(a), 'change plan'));
      t2_set := QUERY (b <* action| VALUE_IN(WHICH_CLASS(b), 'change'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         set_3 := [];
         REPEAT j := 1 TO HIINDEX(t2_set);
            set_3 := set_3 + [ t2_set[j].chosen_method ];
         END_REPEAT;
         violate := VALUE_IN(set_3, t1_set[i].method);
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
END_RULE;

RULE action_request_solution_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF action_request_solution := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['change plan'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
     t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');

      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE action_with_identification_assignment 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF action := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['change', 'versionable object change event', 'check'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
  'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
     t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE alternative_version_relationship_has_mandatory_description FOR (identification_assignment_relationship );
   LOCAL
      t1_set : SET OF identification_assignment_relationship := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* identification_assignment_relationship| VALUE_IN(WHICH_CLASS(i), 'alternative version relationship'));
      violate := SIZEOF(QUERY (k <* t1_set | NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
END_RULE;

RULE alternative_version_relationship_has_unique_versions 
FOR (identification_assignment_relationship );
   LOCAL
      t1_set : SET OF identification_assignment_relationship := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* identification_assignment_relationship| VALUE_IN(WHICH_CLASS(a), 'alternative version relationship'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         violate := t1_set[i].relating_identification_assignment.assigned_id = t1_set[i].related_identification_assignment.assigned_id;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
END_RULE;

RULE alternative_version_relationship_versionable_object FOR (applied_identification_assignment,
     identification_assignment_relationship);
LOCAL
 violate: LOGICAL := FALSE;
END_LOCAL;

REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1 WHILE NOT violate;

 IF ( (SIZEOF(USEDIN(applied_identification_assignment[i],
            ('SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
             +'RELATING_IDENTIFICATION_ASSIGNMENT'))) > 0) OR
      (SIZEOF(USEDIN(applied_identification_assignment[i],
            ('SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
             +'RELATED_IDENTIFICATION_ASSIGNMENT'))) > 0) ) THEN
  REPEAT j := 1 to HIINDEX(applied_identification_assignment[i].items) BY 1 WHILE NOT violate;
 violate := NOT VALUE_IN(which_class(
applied_identification_assignment [i].items[j]),'versionable object');
  END_REPEAT;
 END_IF;

END_REPEAT;

WHERE
wr1: NOT violate;
END_RULE;

RULE applied_approval_assignment_has_exactly_one_elements FOR (object_role, applied_approval_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (ass_inst <* applied_approval_assignment| NOT ((ass_inst.role.NAME = 'subject') AND (SIZEOF(ass_inst.items) = 1)))) = 0;
END_RULE;

RULE applied_group_assignment_has_at_least_one_elements FOR (object_role, applied_group_assignment );
   WHERE
      WR1:
         SIZEOF(QUERY (ass_inst <* applied_group_assignment| NOT (((ass_inst.role.NAME = 'approvals') AND (SIZEOF(ass_inst.items) >= 1)) AND (SIZEOF(QUERY (item <* ass_inst.items | NOT ('SHIP_ARRANGEMENT_SCHEMA.APPROVAL' IN TYPEOF(item)))) = 0)))) = 0;
END_RULE;

RULE approval_event_with_approval_date_time 
FOR(approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF approval_date_time := [];
    violate: LOGICAL := FALSE;
    
  END_LOCAL;

t1_set := QUERY(i <* approval |
 VALUE_IN(WHICH_CLASS(i), 'approval event')); 

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPROVAL_DATE_TIME.' +
'DATED_APPROVAL'));
    violate := NOT (SIZEOF(t2_set) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violate;
END_RULE;

RULE approval_event_with_approval_person_organization FOR(approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF approval_person_organization := [];
    violate: LOGICAL := FALSE;

  END_LOCAL;

t1_set := QUERY(i <* approval |
 VALUE_IN(WHICH_CLASS(i), 'approval event')); 

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPROVAL_PERSON_ORGANIZATION.' + 'AUTHORIZED_APPROVAL'));
 
    violate := NOT (SIZEOF(t2_set) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violate;
END_RULE;

RULE approval_history_approves_same_definition FOR (applied_group_assignment, applied_approval_assignment);
LOCAL
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    t3_set:  SET OF APPROVAL :=[];  
    t4_set:  SET OF group_item :=[];   
    t5_set:  SET OF APPLIED_APPROVAL_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;

t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
                VALUE_IN(WHICH_CLASS(a.ASSIGNED_GROUP),
				'approval history'));

t3_set := QUERY(b <* t2_set[1].items |
 'SHIP_ARRANGEMENT_SCHEMA.APPROVAL' IN TYPEOF(b));

t4_set := QUERY(b <* t2_set[1].items |
 VALUE_IN(WHICH_CLASS(b), 'definition'));

violate := NOT(SIZEOF(t4_set) = 1);

REPEAT i := 1 TO HIINDEX(t3_set) WHILE NOT violate;
    t5_set := QUERY(a <* APPLIED_APPROVAL_ASSIGNMENT | 
(a.ASSIGNED_APPROVAL = t3_set[i]) AND
(NOT (VALUE_IN(a.ITEMS, t4_set[1]))));

    violate := (SIZEOF(t5_set) > 0);
  END_REPEAT;

WHERE
    wr1: NOT violate; 
    wr2: (SIZEOF(t4_set) = 1);
END_RULE;

RULE approval_history_has_at_least_one_member FOR (GROUP, APPLIED_GROUP_ASSIGNMENT);
LOCAL
    t1_set:  SET OF GROUP := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;

t1_set := QUERY(i <* group |
 VALUE_IN(WHICH_CLASS(i), 'approval history')); 

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT |
		 a.ASSIGNED_GROUP = t1_set[i]);

    violate := NOT(SIZEOF(t2_set) = 1);
  END_REPEAT;

WHERE
    wr1: NOT violate; 
END_RULE;

RULE approvals_references_approval_history 
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group |
 VALUE_IN(WHICH_CLASS(a), 'approval history'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_group_assignment | 
   NOT ((b.assigned_group = t1_set[i]) AND (b.role.name = 'approvals')));

    violate := SIZEOF(a_set) > 0;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE author_for_change_plan 
FOR(applied_person_and_organization_assignment, action_request_solution);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action_request_solution | 
             VALUE_IN(WHICH_CLASS(a), 'change plan'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE author_for_change_realization FOR(applied_person_and_organization_assignment,executed_action);
  LOCAL
    t1_set:  SET OF executed_action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* executed_action | 
             VALUE_IN(WHICH_CLASS(a), 'change realization'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE author_for_change_request FOR(applied_person_and_organization_assignment, versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_check FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 'check'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_envisaged_version_creation FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'envisaged version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_version_creation FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:   SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_version_deletion FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version deletion'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_version_modification FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:   SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version modification'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_check 
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 'check'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_envisaged_version_creation 
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 
             'envisaged version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_version_creation 
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_version_deletion 
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version deletion'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_version_modification 
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version modification'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE centre_location_compound_representation_has_specified_name FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['longitudinal location', 'transversal location', 'vertical location'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'centre location');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) 	<> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE change_impact_with_versionable_object_change_event FOR(applied_action_request_assignment);
  LOCAL
    t1_set:  SET OF applied_action_request_assignment := [];
    a_set:   SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  
   t1_set := QUERY(b <* applied_action_request_assignment | 
                   (b.role.name= 'change impact'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
          a_set := QUERY(b <* t1_set[i].items | 
          ('SHIP_ARRANGEMENT_SCHEMA.ACTION' IN TYPEOF(b)) AND
             VALUE_IN(WHICH_CLASS(b), 'versionable object change event'));
         violate := SIZEOF(a_set) = 0;
      END_REPEAT;

WHERE
    WR1: NOT violate;
END_RULE;

RULE change_plan_has_mandatory_attribute_description 
FOR (action_request_solution);
LOCAL
    t1_set:  SET OF action_request_solution := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action_request_solution | 
  VALUE_IN(WHICH_CLASS(i), 'change plan')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE class_and_statutory_designation_has_properties 
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_list: LIST OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_list: LIST OF property_definition := [];
    t4_list: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_list := t1_list + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'class and statutory designation');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_list := t3_list + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_list);
    t4_list := t4_list + t3_list[i].definition;
  END_REPEAT;
  violation := t1_list <> t4_list;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE class_notation_with_named_representation_items 
FOR (representation);
LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['class notations hull', 
                                  'class notations machinery'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
             'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
             'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) < 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE class_parameters_has_properties 
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class parameters');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'class parameters');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE compatible_dimension FOR (cartesian_point, direction, representation_context, geometric_representation_context );
   WHERE
      WR1:
         SIZEOF(QUERY (x <* cartesian_point| (SIZEOF(QUERY (y <* geometric_representation_context| item_in_context(x, y) AND (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0))) = 0;
      WR2:
         SIZEOF(QUERY (x <* direction| (SIZEOF(QUERY (y <* geometric_representation_context| item_in_context(x, y) AND (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension))) > 0))) = 0;
END_RULE;

RULE date_time_for_change_plan 
FOR(applied_date_and_time_assignment,  action_request_solution);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action_request_solution | 
             VALUE_IN(WHICH_CLASS(a), 'change plan'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE date_time_for_change_realization 
FOR(applied_date_and_time_assignment, executed_action);
  LOCAL
    t1_set:  SET OF executed_action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* executed_action | 
             VALUE_IN(WHICH_CLASS(a), 'change realization'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE date_time_for_change_request 
FOR(applied_date_and_time_assignment,  versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE document_has_at_least_one_references 
FOR(document);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF document_representation_type := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
                                   'document')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.DOCUMENT_REPRESENTATION_TYPE.'+
      'REPRESENTED_DOCUMENT'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE document_has_exactly_one_author 
FOR(document);
  LOCAL
    bag_1: BAG OF applied_person_assignment := [];
    bag_2: BAG OF applied_person_and_organization_assignment := [];
    bag_3: BAG OF applied_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
REPEAT i := 1 TO SIZEOF(document) WHILE (NOT violate);
  bag_1 := USEDIN(document[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
         'APPLIED_PERSON_ASSIGNMENT.ITEMS'); 
     bag_1 := QUERY( assign <* bag_1 | assign.role.name = 'author');
   bag_2 := USEDIN(document[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
         'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS');
  bag_2 := QUERY( assign <* bag_2 | assign.role.name = 'author');
  bag_3 := USEDIN(document[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
         'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS');

  bag_3 := QUERY( assign <* bag_3 | assign.role.name = 'author');
    violate := NOT ((SIZEOF( bag_1 ) + SIZEOF( bag_2 )+ SIZEOF( bag_3 ))= 1);
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE document_reference_with_address_has_at_least_one_references 
FOR(document);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF applied_external_identification_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
                                'document reference with address')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
  'SHIP_ARRANGEMENT_SCHEMA.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE envisaged_version_creation_has_mandatory_attribute_description 
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
   'envisaged version creation')); 
   violate := (SIZEOF(QUERY(k <* t1_set | 
   NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE executed_action_with_identification_assignment 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF executed_action := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'change realization'];
    violation: LOGICAL := FALSE;
  END_LOCAL;


    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
	t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');
      	violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE external_instance_reference_has_same_identifier 
FOR (applied_external_identification_assignment);
LOCAL
 violation    : LOGICAL := FALSE;
 extref_set   : SET OF applied_external_identification_assignment := [];
 aia_set      : SET OF applied_identification_assignment := [];
END_LOCAL;

 extref_set := QUERY ( i <* applied_external_identification_assignment | (i.role.name = 'external instance reference') );

 REPEAT i := 1 TO HIINDEX(extref_set) BY 1 WHILE NOT violation;
   aia_set := USEDIN(extref_set[i].items[1],
       'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS');
   violation := NOT (aia_set[1].assigned_id = extref_set[i].assigned_id);
 END_REPEAT;
 WHERE
   wr1: NOT violation;
 END_RULE;

RULE floating_position_compound_representation_with_name 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['moulded form displacement',
	'draught at amidships', 'length of waterline', 'breadth of waterline', 	'angle of trim', 'angle of heel'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'floating position');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
  violation := (SIZEOF(QUERY(items <* t2_set |
		items.name = arg_list[j])) 	<> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE freeboard_characteristics_has_properties 
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'freeboard characteristics');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'freeboard characteristics');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE global_axis_placement_has_properties 
FOR (property_definition_representation, 
group, applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'global axis placement');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'global axis placement');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE global_id_is_unique 
FOR (APPLIED_IDENTIFICATION_ASSIGNMENT);
  LOCAL
    set_1:  SET OF APPLIED_IDENTIFICATION_ASSIGNMENT:= [];
    bag_2:     BAG OF STRING := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;



  set_1 := QUERY(i <* APPLIED_IDENTIFICATION_ASSIGNMENT |
          (i.role.name = 'globally unambiguous identifier'));

REPEAT i := 1 TO HIINDEX(set_1);
    bag_2 := bag_2 + [set_1[i].assigned_id];

END_REPEAT;
violation := SIZEOF (QUERY(i <* set_1 | (SIZEOF(i.items) = 1))) <> SIZEOF(set_1);

WHERE
    WR1: VALUE_UNIQUE(bag_2);
    WR2: NOT violation;
END_RULE;

RULE identification_role_optional_attribute_description_required FOR (identification_role );
   WHERE
      WR1:
         SIZEOF(QUERY (i <* identification_role | (i.NAME = 'external reference') AND NOT 	EXISTS(i.description))) = 0;
END_RULE;

RULE initiator_for_change_request 
FOR(applied_person_and_organization_assignment,
    versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'initiator')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE lightship_definition_has_properties 
FOR (property_definition_representation, 
group, applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'lightship definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'lightship definition parameters');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE mandatory_entity_type_for_external_instance_reference 
FOR(external_source, external_source_relationship);
  LOCAL
    bag_1: BAG OF external_source := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
bag_1 := QUERY(a <* external_source |
					 a.description = 'schema name');
 
REPEAT i := 1 TO SIZEOF(bag_1) WHILE (NOT violate);
violate := (SIZEOF( QUERY(a <* external_source_relationship |
					(a.relating_source :=: bag_1[i]) AND 
           	(a.related_source.description = 'entity type'))) = 0 );
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE members_is_referenced_by_at_least_one_revision 
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'revision'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
    (b.assigned_group :=: t1_set[i]) AND (b.role.name = 'members'));

    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE no_approvals_except_in_approval_history 
FOR (approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
   t1_set := QUERY(a <* approval |
		 VALUE_IN(WHICH_CLASS(a), 'approval event'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   t2_set := bag_to_set(USEDIN(t1_set[i], 
   'SHIP_ARRANGEMENT_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
    violate := (SIZEOF(t2_set) = 0);
   REPEAT k := 1 TO HIINDEX(t2_set) WHILE NOT violate;
      violate := NOT (VALUE_IN(WHICH_CLASS(t2_set[k].ASSIGNED_GROUP), 
      'approval history'));
   END_REPEAT;
END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;

RULE principal_characteristics_has_properties
FOR (property_definition_representation,
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
          i.assigned_class.NAME = 'principal characteristics');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'principal characteristics');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE product_definition_for_call_sign 
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],         'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
        'call sign')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_certifying_organization 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
             i.assigned_class.name = 'coating certification');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	t2_inst.role.name = 'certifying organization')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_class_notation 
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 	
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
		 'class notation' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE product_definition_for_expiry_date 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'coating certification');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.role.name = 'expiry date')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_flag_state 
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'flag state')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_loadline 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'freeboard characteristics');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
	 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	 'loadline' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_managing_company 
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =
                    'owner designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
    'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'managing company')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_ordering_company 
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'owner designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
    'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'ordering company')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_owning_company 
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'owner designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_ARRANGEMENT_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'owning company')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_port_of_registration 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name =
     'port of registration')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_regulation 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 'regulation' 
    IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE product_definition_for_shipyard 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'shipyard designation');
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_ARRANGEMENT_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'shipyard')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_relationship_references_are_distinct
FOR (product_definition_relationship);
  LOCAL
    cyclic_relationship: LOGICAL := FALSE;
  END_LOCAL;

  REPEAT i := 1 TO HIINDEX(product_definition_relationship) 
                                               WHILE NOT cyclic_relationship;
    cyclic_relationship:= 
                product_definition_relationship[i].related_product_definition 
                  :=: product_definition_relationship[i].relating_product_definition;
  END_REPEAT;

  WHERE
    wr1: NOT cyclic_relationship;
END_RULE;

RULE product_definition_relationship_with_identification_assignment 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_relationship := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['space arrangement relationship'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
	t2_set := QUERY ( j <* t2_set |
  j.role.name = 'globally unambiguous identifier');
     violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_shape_for_deck_zone_design FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF product_definition_shape := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME =
 'deck zone design definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
         t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set |
 (t2_inst.name = 'deck zone design parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE product_definition_shape_with_identification_assignment 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
 c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
 t1_set: SET OF product_definition_shape := [];
 t2_set: SET OF applied_identification_assignment := [];
 arg_list: LIST OF STRING := ['design definition'];
 violation: LOGICAL := FALSE;
END_LOCAL;

REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
		   i.assigned_class.NAME = arg_LIST[j]);
END_REPEAT;

REPEAT i := 1 TO HIINDEX(c_a_set);
 REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
  t1_set := t1_set + c_a_set[i].items[j];
 END_REPEAT;
END_REPEAT;

REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
 t2_set := bag_to_set(USEDIN(t1_set[i],
    'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
 t2_set := QUERY ( j <* t2_set | 
		     j.role.name = 'globally unambiguous identifier'); 
 violation := NOT (SIZEOF(T2_SET) = 1);
END_REPEAT;
WHERE
wr1: NOT violation;
END_RULE;

RULE product_definition_with_date_freeboard_assigned 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                i.assigned_class.name = 'freeboard characteristics');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	 t2_inst.role.name = 'date freeboard assigned')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_with_freeboard_assigned_by 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
               i.assigned_class.name = 'freeboard characteristics');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
	 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
		 t2_inst.role.name = 'freeboard assigned by')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_with_identification_assignment 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'definition',
                                   'definable object'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
		     j.role.name = 'globally unambiguous identifier');              violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_related_product_category_with_identification_assignment 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_related_product_category := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'shiptype'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');
           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_with_identification_assignment 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['ship'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_class_bulk_load_requirement_definition 
FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class bulk load requirement definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
       t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set |
(t2_inst.name = 'class bulk load requirement definition parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE property_definition_for_class_compartment_requirement_definition 
FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class compartment requirement definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set |
(t2_inst.name = 'class compartment requirement definition parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE property_definition_for_class_deck_load_requirement_definition 
FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class deck load requirement definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
       t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set |
(t2_inst.name = 'class deck load requirement definition parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE property_definition_for_class_notation 
FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class notation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
        t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set |
 (t2_inst.name = 'class notation'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE property_definition_for_class_society 
FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF applied_organization_assignment := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class notation');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
        t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set | (t2_inst.role.name = 'class society'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE property_definition_for_class_tank_requirement_definition 
FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'class tank requirement definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
        t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set |
 (t2_inst.name = 'class tank requirement definition parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE property_definition_for_compartment_design_requirement 
FOR (applied_classification_assignment);
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'compartment design requirement');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
        t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set |
 (t2_inst.name = 'compartment design requirement parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE property_definition_for_compartment_function 
FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'compartment functional definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
        t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set |
 (t2_inst.name = 'compartment function parameters'))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE property_definition_for_compensated_gross_tonnage 
FOR (applied_classification_assignment );
   LOCAL
      c_a_set : SET OF applied_classification_assignment := [];
      t1_set : SET OF property_definition := [];
      t2_set : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      c_a_set := QUERY (i <* applied_classification_assignment| i.assigned_class.NAME = 'tonnage definition');
      REPEAT i := 1 TO HIINDEX(c_a_set);
         REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
            t1_set := t1_set + c_a_set[i].items[j];
         END_REPEAT;
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
       t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
         violation := NOT (SIZEOF(QUERY (t2_inst <* t2_set |
('compensated gross tonnage' IN WHICH_CLASS(t2_inst)))) = 1);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE property_definition_for_damage_stability_definition_requires_reference FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF representation := [];
    t3_set:  SET OF property_definition_representation := [];
    t4_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'damage stability definition');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'stability table');

  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + bag_to_set(USEDIN(t2_set[i], 
            'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'));
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;

  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;
  
END_RULE;

RULE property_definition_for_date_of_loading 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
         i.ASSIGNED_CLASS.NAME = 'loading condition operating definition');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.role.name = 'date of loading')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_deck_zone_function 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
         i.assigned_class.name = 'deck zone functional definition');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'deck zone function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_gross_tonnage 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
              i.assigned_class.name = 'tonnage definition');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 'gross tonnage' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_local_coordinate_system 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'local co ordinate system');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	t2_inst.name = 'local coordinate system')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_local_coordinate_system_with_position 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'local co ordinate system with position reference');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'local coordinate system with position reference')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE property_definition_for_net_tonnage 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'tonnage definition');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	 'net tonnage' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_stability_definition_requires_reference 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF representation := [];
    t3_set:  SET OF property_definition_representation := [];
    t4_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'stability definition');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'stability table');

  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + bag_to_set(USEDIN(t2_set[i], 
            'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'));
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;

  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;
  
END_RULE;

RULE property_definition_for_tonnage_definition 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'tonnage definition');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'tonnage definition parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_zone_function 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'zone functional definition');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'zone function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_has_references_with_name_loadline 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'loadline');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'loadline')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_representation_for_date_of_measurement 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition_representation := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'tonnage measurement');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' +  'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 'date of 	measurement')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_representation_for_gross_tonnage 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition_representation := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'gross tonnage');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
                 'SHIP_ARRANGEMENT_SCHEMA.' +  'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 'date of measurement')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_representation_for_net_tonnage 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition_representation := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'net tonnage');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' +  'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 'date of 	measurement')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_with_identification_assignment 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := 
['cargo bay definition', 'compartment functional definition', 'deck zone functional definition', 'design requirement', 'loading condition definition', 'local co ordinate system', 'spacing table', 'stability definition', 'tonnage definition', 'zone functional definition'];
        violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_with_lightship_weight_item 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'lightship weight item');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'lightship weight item')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_with_weight_and_centre_of_gravity 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'weight and centre of gravity');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'weight and centre of gravity')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE representation_for_absolute_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['position', 'orientation'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'absolute cargo position parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_adjacent_space_surface_area FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['surface area'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'adjacent space surface area parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_bulk_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['natural angle of repose', 'pollution code', 'required carriage temperature', 'type of', 'un type code'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'bulk cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_bulk_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['actual angle of repose', 'assignment context', 'cargo height', 'cargo identifier', 'trimmed'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'bulk cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_capacity_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['capacity level origin', 'capacity centre', 'capacity level', 'capacity trim angle', 'capacity heel angle', 'capacity volume', 'capacity context'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'capacity properties'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_cargo_compartment_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'design stowage density'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'cargo compartment property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_cargo_footprint FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['contact material', 'shape', 'transferred mass'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'cargo footprint'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_class_and_statutory_designation 
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['class number'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'class and statutory designation')
                   )
              ) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_class_bulk_load_requirement_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['ambient temperature', 'angle of repose', 'bulk cargo mass', 'cargo density', 'cargo height', 'coating', 'damage waterline', 'max pressure', 'max temperature', 'min pressure', 'min temperature', 'permeability', 'top of hatch'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'class bulk load requirement definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_class_compartment_requirement_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['ambient temperature', 'cargo density', 'cargo height', 'coating', 'damage waterline', 'max pressure', 'max temperature', 'min pressure', 'min temperature'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'class compartment requirement definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_class_notation FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['service area', 'approval required for oil cargo', 'approval required for loading unloading aground', 'approval required for unloading grabs'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'class notation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_class_parameters FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['length class', 'length solas', 'scantlings draught', 'block coefficient class', 'design speed ahead', 'design speed astern'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'class parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_class_tank_requirement_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['ambient temperature', 'cargo density', 'cargo height', 'coating', 'damage waterline', 'max pressure', 'max temperature', 'min pressure', 'min temperature', 'overflow height', 'partial filling', 'pressure relief setting'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'class tank requirement definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['dry film thickness', 'number of coats', 'surface preparation'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_coating_level FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['lower extent', 'upper extent'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'coating level'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_abbreviated_name FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'name'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment abbreviated name'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items |
	    (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_acceleration FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'acceleration g force'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment acceleration'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_access_authorization FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'authorization classification'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment access authorization'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_air_circulation_rate FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'air circulation rate'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment air circulation rate'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['assignment context', 'cargo identifier'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'compartment cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment coating'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_design_requirement FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['description', 'requirement type'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'compartment design requirement parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['used for'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_group FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['tonnage volume'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment group parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_horizontal_cross_sectional_area FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'horizontal cross sectional area'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'compartment horizontal cross sectional area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_illumination FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'illumination value'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment illumination'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_insulation FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'insulation category'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment insulation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_noise_category FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'noise category'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment noise category'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_nuclear_classification FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'nuclear classification'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment nuclear classification'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_occupancy FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'occupancy'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment occupancy'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_safety_class FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'safety category'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment safety class'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_security_classification FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'security classification'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment security classification'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_stiffened_surface_area_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'stiffened surface area'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'compartment stiffened surface area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_tightness FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'required bulkhead tightness'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment tightness'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_unstiffened_surface_area_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'unstiffened surface area'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'compartment unstiffened surface area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_vertical_longitudinal_sectional_area FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context',
 'vertical 	longitudinal cross 	sectional area'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'compartment vertical longitudinal sectional area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_vertical_transverse_sectional_area FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := 
['context', 'vertical transverse cross sectional area'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'compartment vertical transverse sectional area property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_volume_permeability_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'permeability'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'compartment volume permeability property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_volume_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['centre of volume', 'context', 'volume'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment volume property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compartment_ziplist_number FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'department ziplist number', 'division ziplist number'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment ziplist number'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_compensated_gross_tonnage FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['compensation factor', 'tonnage value'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compensated gross tonnage'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_corrosion_control_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['applicability', 'dry film thickness', 'number of coats', 'surface preparation', 'type of'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'corrosion control coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_corrosion_protection FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['cathodic protection'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'corrosion protection'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_damage_case FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['damage cause', 'relative damage position'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'damage case parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_damage_position FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['centre of damage', 'position accuracy'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'damage position parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_dangerous_goods_code FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['class', 'subsidiary risks'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'dangerous goods code parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_deck_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['assignment context', 'cargo identifier'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'deck cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_deck_zone_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['used for'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'deck zone function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_dry_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['pollution code', 'un type code'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'dry cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_fire_safe_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['dry film thickness', 'low flame spread', 'nitro cellulose based', 'number of coats', 'surface preparation'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'fire safe coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_freeboard_characteristics FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['assigned code', 'freeboard'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'freeboard characteristics'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_gaseous_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['cargo type', 'carried in liquid state', 'pollution code', 'un type code'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'gaseous cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_gaseous_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['assignment context', 'cargo identifier'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'gaseous cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_global_axis_placement 
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['global axes and origin', 'after perpendicular offset', 'orientation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'global axis placement')
                   )
              ) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_gross_tonnage FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['overdeck tonnage', 'tonnage value', 'underdeck tonnage'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'gross tonnage'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_lightship_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['lightship weight', 'lightship centre of gravity'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'lightship definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items |
	 (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_lightship_weight_item FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['aft weight extent', 'fwd weight extent'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'lightship weight item'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_liquid_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['cargo type', 'pollution code', 'un type code'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'liquid cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_liquid_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['assignment context', 'cargo height', 'cargo identifier'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'liquid cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_loading_condition_design_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['type of'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'loading condition design definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_loading_condition_operating_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['type of'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'loading condition operating definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_loadline FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['load line length', 'load line depth', 'load line displacement', 'load line block coefficient', 'load line regulation'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'loadline'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_local_coordinate_system 
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['local axes and origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'local coordinate system')
                   )
              ) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_moment_3d_restricts_representation_item FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['longitudinal moment', 'transverse moment', 'vertical moment', 'origin'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (i <* representation| i.NAME = 'moment 3d');
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_moments_of_inertia FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['long moment of inertia', 'trans moment of inertia'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'moments of inertia'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_net_tonnage FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['tonnage value'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'net tonnage'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_person_group FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['number of people', 'person type', 'volume'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'person group parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items |
	 (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_primer_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['dry film thickness', 'number of coats', 'surface preparation'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'primer coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_principal_characteristics FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['length between perpendiculars', 'moulded breadth', 'moulded depth'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'principal characteristics'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_space_adjacency_relationship FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['adjacency access', 'adjacency type'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'space adjacency relationship parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_space_positional_relationship FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['relationship type'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'space positional relationship parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_stability_table_restricted 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF representation := [];
    t2_set:  SET OF representation_item := [];
    t3_set:  SET OF representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability table');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability properties for one floating position');

  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].items);
      t3_set := t3_set + t1_set[i].items[j];
    END_REPEAT;
  violation := (SIZEOF(t3_set* t2_set) < 1);
  t3_set:= [];
  END_REPEAT;

WHERE
    wr1: NOT violation;
  END_RULE;

RULE representation_for_stability_table_restricted_by_class_id 
FOR (applied_classification_assignment);
LOCAL
  c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
  t1_set: SET OF REPRESENTATION := [];
  arg_list: LIST OF STRING := ['mean shell thickness'];
  violation: LOGICAL := FALSE;
END_LOCAL;


c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
  i.assigned_class.NAME = 'stability table');


REPEAT i := 1 TO HIINDEX(c_a_set);
  REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
    t1_set := t1_set + c_a_set[i].items[j];
  END_REPEAT;
END_REPEAT;

REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
  REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
    violation:= (SIZEOF(QUERY(rep_item<* t1_set[i].items |
    rep_item.name = arg_list[j])) <> 1);
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: NOT violation;
END_RULE;

RULE representation_for_tank_compartment_property FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['context', 'design stowage density'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'tank compartment property'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_tonnage_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['tonnage regulation'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'tonnage definition'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_tonnage_measurement FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['tonnage value'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'tonnage measurement'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_unit_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['cargo type', 'pollution code', 'un type code'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'unit cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_unit_cargo_assignment FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['assignment context', 'cargo identifier'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'unit cargo assignment parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_unit_cargo_bounding_box FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['point max', 'point min'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'unit cargo bounding box'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_unit_cargo_group FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['volume'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'unit cargo group parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_vehicle_load_description FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['load handling', 'load per wheel', 'number of wheels', 'type of vehicle'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'vehicle load description'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_for_zone_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['used for'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'zone function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE representation_has_global_uncertainty_assigned_context 
FOR (SHAPE_REPRESENTATION);  
LOCAL    
 has_gunac: LOGICAL := TRUE;  
END_LOCAL;  

REPEAT i := 1 TO HIINDEX(SHAPE_REPRESENTATION) WHILE has_gunac;
 has_gunac := ('SHIP_ARRANGEMENT_SCHEMA.GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN 
               TYPEOF(SHAPE_REPRESENTATION[i].CONTEXT_OF_ITEMS));
END_REPEAT;

WHERE    
 WR1: has_gunac;  
END_RULE;

RULE representation_has_global_unit_assigned_context 
FOR (representation );
   LOCAL
      has_guac : LOGICAL := TRUE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE has_guac;
         REPEAT j := 1 TO SIZEOF(representation[i].items) WHILE has_guac;
            IF ('SHIP_ARRANGEMENT_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF(representation[i].items[j])) OR ('SHIP_ARRANGEMENT_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(representation[i].items[j])) THEN
               has_guac := 'SHIP_ARRANGEMENT_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(representation[i].CONTEXT_OF_ITEMS);
            END_IF;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         has_guac;
END_RULE;

RULE representation_item_for_transformation_to_parent 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF representation := [];
    t4_set:  SET OF representation_map := [];
    t5_set:  SET OF mapped_item := [];
    arg_list:  LIST OF STRING := 
['local coordinate system position in global coordinate system', 
'local coordinate system position in parent local coordinate system',
'local coordinate system position in parent local coordinate system with position reference'];
    violation1: LOGICAL := FALSE;
    violation2: LOGICAL := FALSE;

  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
            i.assigned_class.NAME =  'local co ordinate system');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation1 := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.used_representation.name = 
      'local axis representation')) = 1);
    t3_set := t3_set + t2_set[i].used_representation;
  END_REPEAT;
  
   REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t4_set := bag_to_set(USEDIN(t3_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
  END_REPEAT;
  
   REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t5_set := bag_to_set(USEDIN(t4_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
      REPEAT j := 1 TO 3 WHILE NOT violation2;
      violation2 := NOT (SIZEOF(QUERY(t2_inst <* t5_set | t2_inst.name = 
      ARG_LIST[j])) = 1);
      END_REPEAT;
  END_REPEAT;  
  
  WHERE
    WR1: NOT violation1;
    WR2: NOT violation2;
END_RULE;

RULE representation_items_optional_for_bulk_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['flash point', 'required carriage temperature', 'permeability', 'stowage factor', 'user def cargo'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'bulk cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_capacity_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined capacity context'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'capacity properties'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_class_deck_load_requirement_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['grab weight', 'stowage height', 'stowage rate', 'vehicle load'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'class deck load requirement definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_class_notation 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['ice class notation','service factor', 'approval required for heavy cargo'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'class notation'))) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_access_authorization FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined value'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment access authorization'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_design_requirement FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined value'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'compartment design requirement parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user def function'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_insulation FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined value'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment insulation'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_noise_category FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined value'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment noise category'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_safety_class FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined value'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment safety class'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_security FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined value'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment security classification'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_tightness FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined value'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'compartment tightness'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_corrosion_control_coating FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined type'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'corrosion control coating parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_damage_case FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user defined'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'damage case parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_deck_zone_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user def function'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'deck zone function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:  NOT found;
END_RULE;

RULE representation_items_optional_for_detailed_cargo_material_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['density', 'expansion coefficient', 'specific heat capacity',
 'thermal conductivity', 'viscosity'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation | SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.NAME = 'detailed cargo material properties parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_dry_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['flash point', 'required carriage temperature', 'user def cargo', 'permeability', 'stowage factor'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'dry cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_gaseous_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['flash point', 'required carriage pressure', 'required carriage temperature', 'user def cargo'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'gaseous cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_general_cargo_material_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['density'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'general cargo material properties parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_liquid_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['flash point', 'required carriage pressure', 'required carriage temperature', 'user def cargo'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'liquid cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_loading_condition_operating_definition FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['place of loading'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'loading condition operating definition parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_principal_characteristics 
FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['block coefficient', 'design draught',
 'design deadweight', 'min draught at fp', 'max draught at fp', 'min draught at ap',
 'max draught at ap'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'principal characteristics'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_space_connection_relationship FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['connecting system'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME =
 'space connection relationship parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_tank_geometric_parameters FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['breadth wash', 'length wash'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'tank geometric parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_tank_piping_design_properties FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['airpipe height', 'filling height', 'relief valve pressure setting', 'sounding pipe height'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'tank piping design properties'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_unit_cargo FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['flash point', 'permeability', 'stowage factor',
 'required carriage temperature', 'stack limit', 'user def cargo', 'volume'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'unit cargo parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_vehicle_load_description FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['max tyre pressure', 'print area'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'vehicle load description'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_items_optional_for_zone_function FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['user def function'];
      found : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'zone function parameters'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT found;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT found;
            found := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) > 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT found;
END_RULE;

RULE representation_local_coordinate_system_with_position_reference 
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['local axes and origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
		 'local coordinate system with position reference')
                   )
              ) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_restricted_weight_and_centre_of_gravity FOR (representation );
   LOCAL
      reps : BAG OF representation := [];
      arg_list : LIST OF STRING := ['mass ', 'centre of gravity'];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      reps := QUERY (temp_rep <* representation| SIZEOF(QUERY (temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep, 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.NAME = 'weight and centre of gravity'))) > 0);
      REPEAT i := 1 TO HIINDEX(reps) WHILE NOT violation;
         REPEAT j := 1 TO HIINDEX(arg_list) WHILE NOT violation;
            violation := SIZEOF(QUERY (rep_item <* reps[i].items | (rep_item.NAME = arg_list[j]))) <> 1;
         END_REPEAT;
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE revision_has_mandatory_attribute_description 
FOR (group);
LOCAL
    t1_set:  SET OF group := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(i <* group | VALUE_IN(WHICH_CLASS(i), 'revision')); 

violate := (SIZEOF(QUERY(k <* t1_set |
NOT EXISTS (k.description))) > 0);

WHERE
    wr1: NOT violate; 
END_RULE;

RULE revision_with_context_referenced_for_context_of_revision 
FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      a_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group|
 VALUE_IN(WHICH_CLASS(a),	 'revision with context'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_group_assignment|
			(b.ASSIGNED_GROUP = t1_set[i]) AND
			(b.role.NAME = 'context of revision'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
END_RULE;

RULE shape_representation_subtype_exclusiveness 
FOR (shape_representation );
   WHERE
      WR1:
         SIZEOF(QUERY (sr <* shape_representation| NOT (SIZEOF(TYPEOF(sr) * ['SHIP_ARRANGEMENT_SCHEMA.NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION']) <= 2))) = 0;
END_RULE;

RULE ship_designation_has_one_specified_names 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'ship designation');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | (t2_inst.role.name = 'imo number')OR (t2_inst.role.name = 'pennant hull number') )) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE spacing_position_compound_representation_has_name 
FOR (applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET Of representation_item := [];
    arg_list:  LIST OF STRING := ['position number', 'position'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
        violation := (SIZEOF(QUERY(items <* t2_set |
           items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE spacing_position_with_offset_compound_representation_has_class 
FOR (applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET Of representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position with offset');       REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position');
 
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
      t3_set := t3_set + t1_set[i].item_element;
    END_REPEAT;
    violation := (SIZEOF(t3_set * t2_set) <> 1);
    t3_set:= [];
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE spacing_position_with_offset_compound_representation_has_name 
FOR (applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET Of representation_item := [];
    arg_list:  LIST OF STRING := ['offset'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'spacing position with offset');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
        violation := (SIZEOF(QUERY(items <* t2_set | 
        items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE stability_properties_for_floating_position_has_class 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET OF REPRESENTATION_ITEM := [];
    l_rep_item : list_representation_item;
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability properties for one floating position');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability property');

  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
          l_rep_item := t1_set[i].item_element;
      t3_set := t3_set + l_rep_item[j];
    END_REPEAT;
    violation := (SIZEOF(t3_set * t2_set) < 1);
    t3_set:= [];
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE stability_properties_for_floating_position_has_name 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['centre of gravity above keel', 'definition of starting floating position'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name =
 'stability properties for one floating position');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
  violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE stability_property_has_name 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['angle of heel', 'righting arm',
 'centre of buoyancy'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability property');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set |
 items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE tonnage_definition_has_properties 
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  LIST OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  LIST OF property_definition := [];
    t4_set:  LIST OF product_definition := [];

    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'tonnage definition');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'tonnage definition');

  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;

  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;

END_RULE;

RULE unique_approvals_in_approval_history 
FOR (GROUP, APPLIED_GROUP_ASSIGNMENT);
LOCAL
    t1_set:  SET OF GROUP := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    t3_set:  SET OF approval :=[];
    violate: LOGICAL := FALSE;
END_LOCAL;
  t1_set := QUERY(i <* GROUP | VALUE_IN(WHICH_CLASS(i), 
    'approval history')); 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
     a.ASSIGNED_GROUP = t1_set[i]);
   t3_set := QUERY(b <* t2_set[1].items | 
     'SHIP_ARRANGEMENT_SCHEMA.APPROVAL' IN TYPEOF(b));
    violate := NOT (VALUE_UNIQUE(t3_set));
END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;

RULE user_def_cargo_description_required_for_cargo_type 
FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'cargo type')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user def cargo'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_def_cargo_description_required_for_type_of FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'type of')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user def cargo'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_def_function_description_required FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'used for')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user def function'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_capacity_context_description_required_for_capacity_context FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'capacity context')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined capacity context'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_description_required_for_damage_cause FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'damage cause')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_type_description_required_for_type_of FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'type of')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined type'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_authorization_classification FOR (representation );
   LOCAL
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'authorization classification')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_insulation FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment insulation')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_noise_category FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment noise category')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_safety_class FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment safety class')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_security FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment security classification')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_tightness FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'compartment tightness')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_requirement_type FOR (representation );
   LOCAL
      rep_set : SET OF representation := [];
      violation : LOGICAL := FALSE;
   END_LOCAL;
      REPEAT i := 1 TO HIINDEX(representation) WHILE NOT violation;
         violation := (SIZEOF(QUERY (r <* representation[i].items | (('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(r)) AND (r.NAME = 'requirement type')) AND (r\descriptive_representation_item.description = 'user defined'))) > 0) AND (SIZEOF(QUERY (r <* representation[i].items |
 (r.NAME = 'user defined value'))) = 0);
      END_REPEAT;
   WHERE
      WR1:
         NOT violation;
END_RULE;

RULE version_creation_has_mandatory_attribute_description FOR (action );
   LOCAL
      t1_set : SET OF action := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* action|
 VALUE_IN(WHICH_CLASS(i), 'version creation'));
      violate := SIZEOF(QUERY (k <* t1_set |
 NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
END_RULE;

RULE version_deletion_has_mandatory_attribute_description FOR (action );
   LOCAL
      t1_set : SET OF action := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* action|
 VALUE_IN(WHICH_CLASS(i), 'version deletion'));
      violate := SIZEOF(QUERY (k <* t1_set |
 NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
END_RULE;

RULE version_history_has_exactly_one_assigned_group 
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    set_1, set_2: SET OF applied_group_assignment := [];
    set_3: SET OF group_item := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   set_1 := QUERY(b <* applied_group_assignment | 
           (b.assigned_group = t1_set[i]) AND
				 (b.role.name = 'current version'));

   set_2 := QUERY(c <* applied_group_assignment | 
             (c.assigned_group = t1_set[i]) AND
					 (c.role.name = 'members'));

   violate := ((SIZEOF(set_1) <> 1) OR (SIZEOF(set_2) <> 1));

   IF NOT violate THEN
      set_3 := set_1[1].items * set_2[1].items;

      violate := (SIZEOF(set_3) <> 1) OR 
                  NOT (VALUE_IN(WHICH_CLASS(set_3[1]),
						 'versionable object'));
   END_IF;
END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE version_history_is_referenced_by_at_least_one_versions 
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
           (b.assigned_group = t1_set[i]) AND
				 (b.role.name = 'versions'));

    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE version_history_referenced_by_exactly_one_current_version FOR (applied_group_assignment, group );
   LOCAL
      t1_set : SET OF group := [];
      a_set : SET OF applied_group_assignment := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (a <* group| VALUE_IN(WHICH_CLASS(a), 'version history'));
      REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
         a_set := QUERY (b <* applied_group_assignment| (b.ASSIGNED_GROUP = t1_set[i]) AND (b.role.NAME = 'current version'));
         violate := SIZEOF(a_set) <> 1;
      END_REPEAT;
   WHERE
      WR1:
         NOT violate;
END_RULE;

RULE version_history_referenced_by_multiple_roles 
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
    (b.assigned_group = t1_set[i]) AND NOT (b.role.name IN ['versions', 'current version', 'relationships']));
    violate := SIZEOF(a_set) < 1;
END_REPEAT;
WHERE
    wr1: NOT violate;
END_RULE;

RULE version_modification_has_mandatory_attribute_description 
FOR (action );
   LOCAL
      t1_set : SET OF action := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* action| VALUE_IN(WHICH_CLASS(i), 'version modification'));
      violate := SIZEOF(QUERY (k <* t1_set |
	 NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
END_RULE;

RULE version_relationship_associates_with_versionable_object 
FOR (applied_identification_assignment);
LOCAL
    violate: LOGICAL := FALSE;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1 WHILE NOT violate;
 IF ( (SIZEOF(USEDIN(applied_identification_assignment[i],           ('SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATING_IDENTIFICATION_ASSIGNMENT'))) > 0) OR
      (SIZEOF(USEDIN(applied_identification_assignment[i],
      ('SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT'))) > 0) ) THEN
  REPEAT j := 1 to HIINDEX(applied_identification_assignment[i].items) BY 1 WHILE NOT violate;
   violate := NOT  VALUE_IN(which_class(applied_identification_assignment[i].items[j]),            'versionable object');
  END_REPEAT;
 END_IF;

END_REPEAT; 
WHERE
    WR1: NOT violate; 
END_RULE;

RULE version_relationship_has_mandatory_attribute_description FOR (identification_assignment_relationship );
   LOCAL
      t1_set : SET OF identification_assignment_relationship := [];
      violate : LOGICAL := FALSE;
   END_LOCAL;
      t1_set := QUERY (i <* identification_assignment_relationship| VALUE_IN(WHICH_CLASS(i), 'version relationship'));
      violate := SIZEOF(QUERY (k <* t1_set | NOT EXISTS(k.description))) > 0;
   WHERE
      WR1:
         NOT violate;
END_RULE;

RULE version_relationship_has_unique_versions 
FOR (identification_assignment_relationship);
LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
   t1_set := QUERY(a <* identification_assignment_relationship | 
   VALUE_IN(WHICH_CLASS(a), 'version relationship'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    violate := 
          ( t1_set[i].relating_identification_assignment.assigned_id =
            t1_set[i].related_identification_assignment.assigned_id );
END_REPEAT; 
WHERE
    WR1: NOT violate; 
END_RULE;

RULE versionable_object_has_one_version_id 
FOR(APPLIED_IDENTIFICATION_ASSIGNMENT);
  LOCAL
    version_ids:         SET OF APPLIED_IDENTIFICATION_ASSIGNMENT := [];
    versionable_objects: BAG OF identification_item := [];
    duplicate:           LOGICAL := FALSE;
  END_LOCAL;
 
  version_ids := QUERY(i <* APPLIED_IDENTIFICATION_ASSIGNMENT |
                       i.ROLE.NAME = 'version identifier');
 
  REPEAT i := 1 TO HIINDEX(version_ids);
    versionable_objects := versionable_objects + version_ids[i].items;
  END_REPEAT;
   REPEAT i := 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
    REPEAT j := i + 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
      duplicate := versionable_objects[i] :=: versionable_objects[j];
    END_REPEAT;
  END_REPEAT;
  WHERE
    WR1: NOT duplicate;
END_RULE;

RULE versioned_action_request_with_identification_assignment 
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF versioned_action_request := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['change request'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE versions_is_referenced_by_at_least_one_version_history 
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group |
 VALUE_IN(WHICH_CLASS(a), 'versions'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;

   a_set := QUERY(b <* applied_group_assignment | 
      (b.assigned_group = t1_set[i]) AND
		 (b.role.name = 'version history'));

    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;


FUNCTION acyclic_curve_replica( 
             rep: curve_replica; 
             parent: curve 
    ): BOOLEAN; 
  IF NOT ('SHIP_ARRANGEMENT_SCHEMA.CURVE_REPLICA' IN TYPEOF(parent)) 
       THEN 
    RETURN(TRUE); 
  END_IF; 
  IF parent :=: rep THEN 
    RETURN(FALSE); 
  ELSE 
    RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve)); 
  END_IF;
 
END_FUNCTION; -- acyclic_curve_replica
 
FUNCTION acyclic_mapped_representation( 
             parent_set: SET OF representation; 
             children_set: SET OF representation_item 
    ): BOOLEAN;
 
  LOCAL 
    x : SET OF representation_item; 
    y : SET OF representation_item; 
  END_LOCAL; 
  x := QUERY ( z <* children_set | ( 
      'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM' IN TYPEOF(z)) ); 
  IF SIZEOF(x) > 0 THEN 
    REPEAT i := 1 TO HIINDEX(x) BY 1; 
      IF x[i]\mapped_item.mapping_source.mapped_representation IN  
          parent_set THEN 
        RETURN(FALSE); 
      END_IF; 
      IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item 
          .mapping_source.mapped_representation,x[i]\mapped_item. 
          mapping_source.mapped_representation.items) THEN 
        RETURN(FALSE); 
      END_IF; 
    END_REPEAT; 
  END_IF; 
  x := children_set - x; 
  IF SIZEOF(x) > 0 THEN 
    REPEAT i := 1 TO HIINDEX(x) BY 1; 
      y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | ( 
          'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) ); 
      IF NOT acyclic_mapped_representation(parent_set,y) THEN 
        RETURN(FALSE); 
      END_IF; 
    END_REPEAT; 
  END_IF; 
  RETURN(TRUE);
 
END_FUNCTION; -- acyclic_mapped_representation
 
FUNCTION acyclic_surface_replica( 
             rep: surface_replica; 
             parent: surface 
    ): BOOLEAN; 
  IF NOT ('SHIP_ARRANGEMENT_SCHEMA.SURFACE_REPLICA' IN TYPEOF(parent)) 
       THEN 
    RETURN(TRUE); 
  END_IF; 
  IF parent :=: rep THEN 
    RETURN(FALSE); 
  ELSE 
    RETURN(acyclic_surface_replica(rep,parent\surface_replica. 
        parent_surface)); 
  END_IF;
 
END_FUNCTION; -- acyclic_surface_replica
 
FUNCTION associated_surface( 
             arg: pcurve_or_surface 
    ): surface;
 
  LOCAL 
    surf : surface; 
  END_LOCAL; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(arg) THEN 
    surf := arg.basis_surface; 
  ELSE 
    surf := arg; 
  END_IF; 
  RETURN(surf);
 
END_FUNCTION; -- associated_surface
 
FUNCTION bag_to_set( 
             the_bag: BAG OF GENERIC:intype 
    ): SET OF GENERIC:intype;
 
  LOCAL 
    the_set : SET OF GENERIC:intype := []; 
  END_LOCAL; 
  IF SIZEOF(the_bag) > 0 THEN 
    REPEAT i := 1 TO HIINDEX(the_bag) BY 1; 
      the_set := the_set + the_bag[i]; 
    END_REPEAT; 
  END_IF; 
  RETURN(the_set);
 
END_FUNCTION; -- bag_to_set
 
FUNCTION base_axis( 
             dim: INTEGER; 
             axis1, axis2, axis3: direction 
    ): LIST [2:3] OF direction;
 
  LOCAL 
    u      : LIST [2:3] OF direction; 
    d1     : direction; 
    d2     : direction; 
    factor : REAL; 
  END_LOCAL; 
  IF dim = 3 THEN 
    d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1])); 
    d2 := first_proj_axis(d1,axis1); 
    u := [d2,second_proj_axis(d1,d2,axis2),d1]; 
  ELSE 
    IF EXISTS(axis1) THEN 
      d1 := normalise(axis1); 
      u := [d1,orthogonal_complement(d1)]; 
      IF EXISTS(axis2) THEN 
        factor := dot_product(axis2,u[2]); 
        IF factor < 0 THEN 
          u[2].direction_ratios[1] := -u[2].direction_ratios[1]; 
          u[2].direction_ratios[2] := -u[2].direction_ratios[2]; 
        END_IF; 
      END_IF; 
    ELSE 
      IF EXISTS(axis2) THEN 
        d1 := normalise(axis2); 
        u := [orthogonal_complement(d1),d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1]; 
        u[1].direction_ratios[2] := -u[1].direction_ratios[2]; 
      ELSE 
        u := [dummy_gri || direction([1,0]),dummy_gri || direction([0,1])]; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(u);
 
END_FUNCTION; -- base_axis
 
FUNCTION boolean_choose( 
             b: BOOLEAN; 
             choice1, choice2: GENERIC:item 
    ): GENERIC:item; 
  IF b THEN 
    RETURN(choice1); 
  ELSE 
    RETURN(choice2); 
  END_IF;
 
END_FUNCTION; -- boolean_choose
 
FUNCTION build_2axes( 
             ref_direction: direction 
    ): LIST [2:2] OF direction;
 
  LOCAL 
    d : direction := NVL(normalise(ref_direction),dummy_gri ||  
         direction([1,0])); 
  END_LOCAL; 
  RETURN([d,orthogonal_complement(d)]);
 
END_FUNCTION; -- build_2axes
 
FUNCTION build_axes( 
             axis, ref_direction: direction 
    ): LIST [3:3] OF direction;
 
  LOCAL 
    d1 : direction; 
    d2 : direction; 
  END_LOCAL; 
  d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1])); 
  d2 := first_proj_axis(d1,ref_direction); 
  RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);
 
END_FUNCTION; -- build_axes
 
FUNCTION closed_shell_reversed( 
             a_shell: closed_shell 
    ): oriented_closed_shell;
 
  LOCAL 
    the_reverse : oriented_closed_shell; 
  END_LOCAL; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell) 
       THEN 
    the_reverse := ((dummy_tri || connected_face_set(a_shell\ 
        connected_face_set.cfs_faces)) || closed_shell()) ||  
        oriented_closed_shell(a_shell\oriented_closed_shell. 
        closed_shell_element,NOT a_shell\oriented_closed_shell. 
        orientation); 
  ELSE 
    the_reverse := ((dummy_tri || connected_face_set(a_shell\ 
        connected_face_set.cfs_faces)) || closed_shell()) ||  
        oriented_closed_shell(a_shell,FALSE); 
  END_IF; 
  RETURN(the_reverse);
 
END_FUNCTION; -- closed_shell_reversed
 
FUNCTION conditional_reverse( 
             p: BOOLEAN; 
             an_item: reversible_topology 
    ): reversible_topology; 
  IF p THEN 
    RETURN(an_item); 
  ELSE 
    RETURN(topology_reversed(an_item)); 
  END_IF;
 
END_FUNCTION; -- conditional_reverse
 
FUNCTION constraints_composite_curve_on_surface( 
             c: composite_curve_on_surface 
    ): BOOLEAN;
 
  LOCAL 
    n_segments : INTEGER := SIZEOF(c.segments); 
  END_LOCAL; 
  REPEAT k := 1 TO n_segments BY 1; 
    IF ((NOT ('SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(c\ 
        composite_curve.segments[k].parent_curve))) AND (NOT ( 
        'SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE' IN TYPEOF(c\ 
        composite_curve.segments[k].parent_curve)))) AND (NOT ( 
        'SHIP_ARRANGEMENT_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c 
        \composite_curve.segments[k].parent_curve))) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_REPEAT; 
  RETURN(TRUE);
 
END_FUNCTION; -- constraints_composite_curve_on_surface
 
FUNCTION constraints_param_b_spline( 
             degree, up_knots, up_cp: INTEGER; 
             knot_mult: LIST OF INTEGER; 
             knots: LIST OF parameter_value 
    ): BOOLEAN;
 
  LOCAL 
    k      : INTEGER; 
    sum    : INTEGER; 
    result : BOOLEAN := TRUE; 
  END_LOCAL; 
  sum := knot_mult[1]; 
  REPEAT i := 2 TO up_knots BY 1; 
    sum := sum + knot_mult[i]; 
  END_REPEAT; 
  IF (((degree < 1) OR (up_knots < 2)) OR (up_cp < degree)) OR (sum <> ( 
      (degree + up_cp) + 2)) THEN 
    result := FALSE; 
    RETURN(result); 
  END_IF; 
  k := knot_mult[1]; 
  IF (k < 1) OR (k > (degree + 1)) THEN 
    result := FALSE; 
    RETURN(result); 
  END_IF; 
  REPEAT i := 2 TO up_knots BY 1; 
    IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN 
      result := FALSE; 
      RETURN(result); 
    END_IF; 
    k := knot_mult[i]; 
    IF (i < up_knots) AND (k > degree) THEN 
      result := FALSE; 
      RETURN(result); 
    END_IF; 
    IF (i = up_knots) AND (k > (degree + 1)) THEN 
      result := FALSE; 
      RETURN(result); 
    END_IF; 
  END_REPEAT; 
  RETURN(result);
 
END_FUNCTION; -- constraints_param_b_spline
 
FUNCTION cross_product( 
             arg1, arg2: direction 
    ): vector;
 
  LOCAL 
    v2     : LIST [3:3] OF REAL; 
    v1     : LIST [3:3] OF REAL; 
    mag    : REAL; 
    res    : direction; 
    result : vector; 
  END_LOCAL; 
  IF ((NOT EXISTS(arg1)) OR (arg1.dim = 2)) OR ((NOT EXISTS(arg2)) OR ( 
      arg2.dim = 2)) THEN 
    RETURN(?); 
  ELSE 
    BEGIN 
      v1 := normalise(arg1).direction_ratios; 
      v2 := normalise(arg2).direction_ratios; 
      res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),( 
          v1[3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[ 
          1])]); 
      mag := 0; 
      REPEAT i := 1 TO 3 BY 1; 
        mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]); 
      END_REPEAT; 
      IF mag > 0 THEN 
        result := dummy_gri || vector(res,SQRT(mag)); 
      ELSE 
        result := dummy_gri || vector(arg1,0); 
      END_IF; 
      RETURN(result); 
    END; 
  END_IF;
 
END_FUNCTION; -- cross_product
 
FUNCTION curve_weights_positive( 
             b: rational_b_spline_curve 
    ): BOOLEAN;
 
  LOCAL 
    result : BOOLEAN := TRUE; 
  END_LOCAL; 
  REPEAT i := 0 TO b.upper_index_on_control_points BY 1; 
    IF b.weights[i] <= 0 THEN 
      result := FALSE; 
      RETURN(result); 
    END_IF; 
  END_REPEAT; 
  RETURN(result);
 
END_FUNCTION; -- curve_weights_positive
 
FUNCTION derive_dimensional_exponents( 
             x: unit 
    ): dimensional_exponents;
 
  LOCAL 
    result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0, 
              0); 
  END_LOCAL; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN 
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1; 
      result.length_exponent := result.length_exponent + (x.elements[i]. 
          exponent * x.elements[i].unit.dimensions.length_exponent); 
      result.mass_exponent := result.mass_exponent + (x.elements[i]. 
          exponent * x.elements[i].unit.dimensions.mass_exponent); 
      result.time_exponent := result.time_exponent + (x.elements[i]. 
          exponent * x.elements[i].unit.dimensions.time_exponent); 
      result.electric_current_exponent := result. 
          electric_current_exponent + (x.elements[i].exponent * x. 
          elements[i].unit.dimensions.electric_current_exponent); 
      result.thermodynamic_temperature_exponent := result. 
          thermodynamic_temperature_exponent + (x.elements[i].exponent *  
          x.elements[i].unit.dimensions. 
          thermodynamic_temperature_exponent); 
      result.amount_of_substance_exponent := result. 
          amount_of_substance_exponent + (x.elements[i].exponent * x. 
          elements[i].unit.dimensions.amount_of_substance_exponent); 
      result.luminous_intensity_exponent := result. 
          luminous_intensity_exponent + (x.elements[i].exponent * x. 
          elements[i].unit.dimensions.luminous_intensity_exponent); 
    END_REPEAT; 
  ELSE 
    result := x.dimensions; 
  END_IF; 
  RETURN(result);
 
END_FUNCTION; -- derive_dimensional_exponents
 
FUNCTION dimension_of( 
             item: geometric_representation_item 
    ): dimension_count;
 
  LOCAL 
    x   : SET OF representation; 
    y   : representation_context; 
    dim : dimension_count; 
  END_LOCAL; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN 
    dim := SIZEOF(item\cartesian_point.coordinates); 
    RETURN(dim); 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.DIRECTION' IN TYPEOF(item) THEN 
    dim := SIZEOF(item\direction.direction_ratios); 
    RETURN(dim); 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(item) THEN 
    dim := SIZEOF(item\vector.orientation\direction.direction_ratios); 
    RETURN(dim); 
  END_IF; 
  x := using_representations(item); 
  y := x[1].context_of_items; 
  dim := y\geometric_representation_context.coordinate_space_dimension; 
  RETURN(dim);
 
END_FUNCTION; -- dimension_of
 
FUNCTION dimensions_for_si_unit( 
             n: si_unit_name 
    ): dimensional_exponents; 
  CASE n OF 
    metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0)); 
    gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0)); 
    second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0)); 
    ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0)); 
    kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0)); 
    mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0)); 
    candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1)); 
    radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0)); 
    steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0)); 
    hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0)); 
    newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0)); 
    pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0)); 
    joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0)); 
    watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0)); 
    coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0)); 
    volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0)); 
    farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0)); 
    ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0)); 
    siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0)); 
    weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0)); 
    tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0)); 
    henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0)); 
    degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0)); 
    lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1)); 
    lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1)); 
    becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0)); 
    gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0)); 
    sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0)); 
    END_CASE;
 
END_FUNCTION; -- dimensions_for_si_unit
 
FUNCTION dot_product( 
             arg1, arg2: direction 
    ): REAL;
 
  LOCAL 
    ndim   : INTEGER; 
    scalar : REAL; 
    vec1   : direction; 
    vec2   : direction; 
  END_LOCAL; 
  IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN 
    scalar := ?; 
  ELSE 
    IF arg1.dim <> arg2.dim THEN 
      scalar := ?; 
    ELSE 
      BEGIN 
        vec1 := normalise(arg1); 
        vec2 := normalise(arg2); 
        ndim := arg1.dim; 
        scalar := 0; 
        REPEAT i := 1 TO ndim BY 1; 
          scalar := scalar + (vec1.direction_ratios[i] * vec2. 
              direction_ratios[i]); 
        END_REPEAT; 
      END; 
    END_IF; 
  END_IF; 
  RETURN(scalar);
 
END_FUNCTION; -- dot_product
 
FUNCTION edge_reversed( 
             an_edge: edge 
    ): oriented_edge;
 
  LOCAL 
    the_reverse : oriented_edge; 
  END_LOCAL; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN 
    the_reverse := (dummy_tri || edge(an_edge.edge_end,an_edge. 
        edge_start)) || oriented_edge(an_edge\oriented_edge.edge_element, 
        NOT an_edge\oriented_edge.orientation); 
  ELSE 
    the_reverse := (dummy_tri || edge(an_edge.edge_end,an_edge. 
        edge_start)) || oriented_edge(an_edge,FALSE); 
  END_IF; 
  RETURN(the_reverse);
 
END_FUNCTION; -- edge_reversed
 
FUNCTION face_bound_reversed( 
             a_face_bound: face_bound 
    ): face_bound;
 
  LOCAL 
    the_reverse : face_bound; 
  END_LOCAL; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound) 
       THEN 
    the_reverse := (dummy_tri || face_bound(a_face_bound\face_bound. 
        bound,NOT a_face_bound\face_bound.orientation)) ||  
        face_outer_bound(); 
  ELSE 
    the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT  
        a_face_bound.orientation); 
  END_IF; 
  RETURN(the_reverse);
 
END_FUNCTION; -- face_bound_reversed
 
FUNCTION face_reversed( 
             a_face: face 
    ): oriented_face;
 
  LOCAL 
    the_reverse : oriented_face; 
  END_LOCAL; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_FACE' IN TYPEOF(a_face) THEN 
    the_reverse := (dummy_tri || face(set_of_topology_reversed(a_face. 
        bounds))) || oriented_face(a_face\oriented_face.face_element,NOT  
        a_face\oriented_face.orientation); 
  ELSE 
    the_reverse := (dummy_tri || face(set_of_topology_reversed(a_face. 
        bounds))) || oriented_face(a_face,FALSE); 
  END_IF; 
  RETURN(the_reverse);
 
END_FUNCTION; -- face_reversed
 
FUNCTION first_proj_axis( 
             z_axis, arg: direction 
    ): direction;
 
  LOCAL 
    x_vec  : vector; 
    v      : direction; 
    z      : direction; 
    x_axis : direction; 
  END_LOCAL; 
  IF NOT EXISTS(z_axis) THEN 
    RETURN(?); 
  ELSE 
    z := normalise(z_axis); 
    IF NOT EXISTS(arg) THEN 
      IF z.direction_ratios <> [1,0,0] THEN 
        v := dummy_gri || direction([1,0,0]); 
      ELSE 
        v := dummy_gri || direction([0,1,0]); 
      END_IF; 
    ELSE 
      IF arg.dim <> 3 THEN 
        RETURN(?); 
      END_IF; 
      IF cross_product(arg,z).magnitude = 0 THEN 
        RETURN(?); 
      ELSE 
        v := normalise(arg); 
      END_IF; 
    END_IF; 
    x_vec := scalar_times_vector(dot_product(v,z),z); 
    x_axis := vector_difference(v,x_vec).orientation; 
    x_axis := normalise(x_axis); 
  END_IF; 
  RETURN(x_axis);
 
END_FUNCTION; -- first_proj_axis
 
FUNCTION get_basis_surface( 
             c: curve_on_surface 
    ): SET [0:2] OF surface;
 
  LOCAL 
    surfs : SET [0:2] OF surface; 
    n     : INTEGER; 
  END_LOCAL; 
  surfs := []; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(c) THEN 
    surfs := [c\pcurve.basis_surface]; 
  ELSE 
    IF 'SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE' IN TYPEOF(c) THEN 
      n := SIZEOF(c\surface_curve.associated_geometry); 
      REPEAT i := 1 TO n BY 1; 
        surfs := surfs + associated_surface(c\surface_curve. 
            associated_geometry[i]); 
      END_REPEAT; 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c) 
       THEN 
    n := SIZEOF(c\composite_curve.segments); 
    surfs := get_basis_surface(c\composite_curve.segments[1]. 
        parent_curve); 
    IF n > 1 THEN 
      REPEAT i := 2 TO n BY 1; 
        surfs := surfs * get_basis_surface(c\composite_curve.segments[i] 
            .parent_curve); 
      END_REPEAT; 
    END_IF; 
  END_IF; 
  RETURN(surfs);
 
END_FUNCTION; -- get_basis_surface
 
FUNCTION get_description_value( 
             obj: description_attribute_select 
    ): text;
 
  LOCAL 
    description_bag : BAG OF description_attribute := USEDIN(obj,( 
                       'SHIP_ARRANGEMENT_SCHEMA.' +  
                       'DESCRIPTION_ATTRIBUTE.') + 'DESCRIBED_ITEM'); 
  END_LOCAL; 
  IF SIZEOF(description_bag) = 1 THEN 
    RETURN(description_bag[1].attribute_value); 
  ELSE 
    RETURN(?); 
  END_IF;
 
END_FUNCTION; -- get_description_value
 
FUNCTION get_id_value( 
             obj: id_attribute_select 
    ): identifier;
 
  LOCAL 
    id_bag : BAG OF id_attribute := USEDIN(obj,( 
              'SHIP_ARRANGEMENT_SCHEMA.' + 'ID_ATTRIBUTE.') +  
              'IDENTIFIED_ITEM'); 
  END_LOCAL; 
  IF SIZEOF(id_bag) = 1 THEN 
    RETURN(id_bag[1].attribute_value); 
  ELSE 
    RETURN(?); 
  END_IF;
 
END_FUNCTION; -- get_id_value
 
FUNCTION get_name_value( 
             obj: name_attribute_select 
    ): label;
 
  LOCAL 
    name_bag : BAG OF name_attribute := USEDIN(obj,( 
                'SHIP_ARRANGEMENT_SCHEMA.' + 'NAME_ATTRIBUTE.') +  
                'NAMED_ITEM'); 
  END_LOCAL; 
  IF SIZEOF(name_bag) = 1 THEN 
    RETURN(name_bag[1].attribute_value); 
  ELSE 
    RETURN(?); 
  END_IF;
 
END_FUNCTION; -- get_name_value
 
FUNCTION get_role( 
             obj: role_select 
    ): object_role;
 
  LOCAL 
    role_bag : BAG OF role_association := USEDIN(obj,( 
                'SHIP_ARRANGEMENT_SCHEMA.' + 'ROLE_ASSOCIATION.') +  
                'ITEM_WITH_ROLE'); 
  END_LOCAL; 
  IF SIZEOF(role_bag) = 1 THEN 
    RETURN(role_bag[1].role); 
  ELSE 
    RETURN(?); 
  END_IF;
 
END_FUNCTION; -- get_role
 
FUNCTION item_in_context( 
             item: representation_item; 
             cntxt: representation_context 
    ): BOOLEAN;
 
  LOCAL 
    y : BAG OF representation_item; 
  END_LOCAL; 
  IF SIZEOF(USEDIN(item,'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION.ITEMS')  
      * cntxt.representations_in_context) > 0 THEN 
    RETURN(TRUE); 
  ELSE 
    y := QUERY ( z <* USEDIN(item,'') | ( 
        'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) ); 
    IF SIZEOF(y) > 0 THEN 
      REPEAT i := 1 TO HIINDEX(y) BY 1; 
        IF item_in_context(y[i],cntxt) THEN 
          RETURN(TRUE); 
        END_IF; 
      END_REPEAT; 
    END_IF; 
  END_IF; 
  RETURN(FALSE);
 
END_FUNCTION; -- item_in_context
 
FUNCTION leap_year( 
             year: year_number 
    ): BOOLEAN; 
  IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 
       0) THEN 
    RETURN(TRUE); 
  ELSE 
    RETURN(FALSE); 
  END_IF;
 
END_FUNCTION; -- leap_year
 
FUNCTION list_face_loops( 
             f: face 
    ): LIST [0:?] OF loop;
 
  LOCAL 
    loops : LIST [0:?] OF loop := []; 
  END_LOCAL; 
  REPEAT i := 1 TO SIZEOF(f.bounds) BY 1; 
    loops := loops + f.bounds[i].bound; 
  END_REPEAT; 
  RETURN(loops);
 
END_FUNCTION; -- list_face_loops
 
FUNCTION list_of_topology_reversed( 
             a_list: list_of_reversible_topology_item 
    ): list_of_reversible_topology_item;
 
  LOCAL 
    the_reverse : list_of_reversible_topology_item; 
  END_LOCAL; 
  the_reverse := []; 
  REPEAT i := 1 TO SIZEOF(a_list) BY 1; 
    the_reverse := topology_reversed(a_list[i]) + the_reverse; 
  END_REPEAT; 
  RETURN(the_reverse);
 
END_FUNCTION; -- list_of_topology_reversed
 
FUNCTION list_to_array( 
             lis: LIST [0:?] OF GENERIC:t; 
             low, u: INTEGER 
    ): ARRAY OF GENERIC:t;
 
  LOCAL 
    n   : INTEGER; 
    res : ARRAY [low:u] OF GENERIC:t; 
  END_LOCAL; 
  n := SIZEOF(lis); 
  IF n <> ((u - low) + 1) THEN 
    RETURN(?); 
  ELSE 
    res := [lis[1],n]; 
    REPEAT i := 2 TO n BY 1; 
      res[(low + i) - 1] := lis[i]; 
    END_REPEAT; 
    RETURN(res); 
  END_IF;
 
END_FUNCTION; -- list_to_array
 
FUNCTION list_to_set( 
             l: LIST [0:?] OF GENERIC:t 
    ): SET OF GENERIC:t;
 
  LOCAL 
    s : SET OF GENERIC:t := []; 
  END_LOCAL; 
  REPEAT i := 1 TO SIZEOF(l) BY 1; 
    s := s + l[i]; 
  END_REPEAT; 
  RETURN(s);
 
END_FUNCTION; -- list_to_set
 
FUNCTION make_array_of_array( 
             lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t; 
             low1, u1, low2, u2: INTEGER 
    ): ARRAY OF ARRAY OF GENERIC:t;
 
  LOCAL 
    res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t; 
  END_LOCAL; 
  IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN 
    RETURN(?); 
  END_IF; 
  IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN 
    RETURN(?); 
  END_IF; 
  res := [list_to_array(lis[1],low2,u2),(u1 - low1) + 1]; 
  REPEAT i := 2 TO HIINDEX(lis) BY 1; 
    IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN 
      RETURN(?); 
    END_IF; 
    res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2); 
  END_REPEAT; 
  RETURN(res);
 
END_FUNCTION; -- make_array_of_array
 
FUNCTION mixed_loop_type_set( 
             l: SET [0:?] OF loop 
    ): LOGICAL;
 
  LOCAL 
    poly_loop_type : LOGICAL; 
  END_LOCAL; 
  IF SIZEOF(l) <= 1 THEN 
    RETURN(FALSE); 
  END_IF; 
  poly_loop_type := 'SHIP_ARRANGEMENT_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]); 
  REPEAT i := 2 TO SIZEOF(l) BY 1; 
    IF ('SHIP_ARRANGEMENT_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <>  
        poly_loop_type THEN 
      RETURN(TRUE); 
    END_IF; 
  END_REPEAT; 
  RETURN(FALSE);
 
END_FUNCTION; -- mixed_loop_type_set
 
FUNCTION nmsf_curve_check( 
             cv: curve 
    ): BOOLEAN; 
  IF SIZEOF(['SHIP_ARRANGEMENT_SCHEMA.BOUNDED_CURVE', 
      'SHIP_ARRANGEMENT_SCHEMA.CONIC', 
      'SHIP_ARRANGEMENT_SCHEMA.CURVE_REPLICA', 
      'SHIP_ARRANGEMENT_SCHEMA.LINE', 
      'SHIP_ARRANGEMENT_SCHEMA.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN 
    RETURN(FALSE); 
  ELSE 
    IF (('SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_CURVE' IN TYPEOF(cv)) AND ( 
        cv\b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve. 
        self_intersect = UNKNOWN) THEN 
      RETURN(TRUE); 
    ELSE 
      IF SIZEOF(['SHIP_ARRANGEMENT_SCHEMA.CONIC', 
          'SHIP_ARRANGEMENT_SCHEMA.LINE'] * TYPEOF(cv)) = 1 THEN 
        RETURN(TRUE); 
      ELSE 
        IF 'SHIP_ARRANGEMENT_SCHEMA.CURVE_REPLICA' IN TYPEOF(cv) THEN 
          RETURN(nmsf_curve_check(cv\curve_replica.parent_curve)); 
        ELSE 
          IF (('SHIP_ARRANGEMENT_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(cv))  
              AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\ 
              offset_curve_3d.self_intersect = UNKNOWN))) AND (NOT ( 
              'SHIP_ARRANGEMENT_SCHEMA.POLYLINE' IN TYPEOF(cv. 
              basis_curve))) THEN 
            RETURN(nmsf_curve_check(cv\offset_curve_3d.basis_curve)); 
          ELSE 
            IF 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(cv) THEN 
              RETURN(nmsf_curve_check(cv\pcurve.reference_to_curve\ 
                  representation.items[1]) AND nmsf_surface_check(cv\ 
                  pcurve.basis_surface)); 
            ELSE 
              IF 'SHIP_ARRANGEMENT_SCHEMA.SURFACE_CURVE' IN TYPEOF(cv) 
                   THEN 
                IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN 
                  REPEAT i := 1 TO SIZEOF(cv\surface_curve. 
                      associated_geometry) BY 1; 
                    IF 'SHIP_ARRANGEMENT_SCHEMA.SURFACE' IN TYPEOF(cv\ 
                        surface_curve.associated_geometry[i]) THEN 
                      IF NOT nmsf_surface_check(cv\surface_curve. 
                          associated_geometry[i]) THEN 
                        RETURN(FALSE); 
                      END_IF; 
                    ELSE 
                      IF 'SHIP_ARRANGEMENT_SCHEMA.PCURVE' IN TYPEOF(cv\ 
                          surface_curve.associated_geometry[i]) THEN 
                        IF NOT nmsf_curve_check(cv\surface_curve. 
                            associated_geometry[i]) THEN 
                          RETURN(FALSE); 
                        END_IF; 
                      END_IF; 
                    END_IF; 
                  END_REPEAT; 
                  RETURN(TRUE); 
                END_IF; 
              ELSE 
                IF 'SHIP_ARRANGEMENT_SCHEMA.POLYLINE' IN TYPEOF(cv) 
                     THEN 
                  IF SIZEOF(cv\polyline.points) >= 3 THEN 
                    RETURN(TRUE); 
                  END_IF; 
                END_IF; 
              END_IF; 
            END_IF; 
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE);
 
END_FUNCTION; -- nmsf_curve_check
 
FUNCTION nmsf_surface_check( 
             surf: surface 
    ): BOOLEAN; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN 
    RETURN(TRUE); 
  ELSE 
    IF 'SHIP_ARRANGEMENT_SCHEMA.SWEPT_SURFACE' IN TYPEOF(surf) THEN 
      RETURN(nmsf_curve_check(surf\swept_surface.swept_curve)); 
    ELSE 
      IF (('SHIP_ARRANGEMENT_SCHEMA.OFFSET_SURFACE' IN TYPEOF(surf))  
          AND (surf\offset_surface.self_intersect = FALSE)) OR (surf\ 
          offset_surface.self_intersect = UNKNOWN) THEN 
        RETURN(nmsf_surface_check(surf\offset_surface.basis_surface)); 
      ELSE 
        IF 'SHIP_ARRANGEMENT_SCHEMA.SURFACE_REPLICA' IN TYPEOF(surf) 
             THEN 
          RETURN(nmsf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE 
          IF (('SHIP_ARRANGEMENT_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF( 
              surf)) AND (surf\b_spline_surface.self_intersect = FALSE))  
              OR (surf\b_spline_surface.self_intersect = UNKNOWN) THEN 
            RETURN(TRUE); 
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE);
 
END_FUNCTION; -- nmsf_surface_check
 
FUNCTION normalise( 
             arg: vector_or_direction 
    ): vector_or_direction;
 
  LOCAL 
    ndim   : INTEGER; 
    v      : direction; 
    vec    : vector; 
    mag    : REAL; 
    result : vector_or_direction; 
  END_LOCAL; 
  IF NOT EXISTS(arg) THEN 
    result := ?; 
  ELSE 
    ndim := arg.dim; 
    IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN 
      BEGIN 
        v := dummy_gri || direction(arg.orientation.direction_ratios); 
        IF arg.magnitude = 0 THEN 
          RETURN(?); 
        ELSE 
          vec := dummy_gri || vector(v,1); 
        END_IF; 
      END; 
    ELSE 
      v := dummy_gri || direction(arg.direction_ratios); 
    END_IF; 
    mag := 0; 
    REPEAT i := 1 TO ndim BY 1; 
      mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]); 
    END_REPEAT; 
    IF mag > 0 THEN 
      mag := SQRT(mag); 
      REPEAT i := 1 TO ndim BY 1; 
        v.direction_ratios[i] := v.direction_ratios[i] / mag; 
      END_REPEAT; 
      IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN 
        vec.orientation := v; 
        result := vec; 
      ELSE 
        result := v; 
      END_IF; 
    ELSE 
      RETURN(?); 
    END_IF; 
  END_IF; 
  RETURN(result);
 
END_FUNCTION; -- normalise
 
FUNCTION open_shell_reversed( 
             a_shell: open_shell 
    ): oriented_open_shell;
 
  LOCAL 
    the_reverse : oriented_open_shell; 
  END_LOCAL; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell) 
       THEN 
    the_reverse := ((dummy_tri || connected_face_set(a_shell\ 
        connected_face_set.cfs_faces)) || open_shell()) ||  
        oriented_open_shell(a_shell\oriented_open_shell. 
        open_shell_element,NOT a_shell\oriented_open_shell.orientation); 
  ELSE 
    the_reverse := ((dummy_tri || connected_face_set(a_shell\ 
        connected_face_set.cfs_faces)) || open_shell()) ||  
        oriented_open_shell(a_shell,FALSE); 
  END_IF; 
  RETURN(the_reverse);
 
END_FUNCTION; -- open_shell_reversed
 
FUNCTION orthogonal_complement( 
             vec: direction 
    ): direction;
 
  LOCAL 
    result : direction; 
  END_LOCAL; 
  IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN 
    RETURN(?); 
  ELSE 
    result := dummy_gri || direction([-vec.direction_ratios[2],vec. 
        direction_ratios[1]]); 
    RETURN(result); 
  END_IF;
 
END_FUNCTION; -- orthogonal_complement
 
FUNCTION path_head_to_tail( 
             a_path: path 
    ): BOOLEAN;
 
  LOCAL 
    n : INTEGER; 
    p : BOOLEAN := TRUE; 
  END_LOCAL; 
  n := SIZEOF(a_path.edge_list); 
  REPEAT i := 2 TO n BY 1; 
    p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i] 
        .edge_start); 
  END_REPEAT; 
  RETURN(p);
 
END_FUNCTION; -- path_head_to_tail
 
FUNCTION path_reversed( 
             a_path: path 
    ): oriented_path;
 
  LOCAL 
    the_reverse : oriented_path; 
  END_LOCAL; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.ORIENTED_PATH' IN TYPEOF(a_path) THEN 
    the_reverse := (dummy_tri || path(list_of_topology_reversed(a_path. 
        edge_list))) || oriented_path(a_path\oriented_path.path_element, 
        NOT a_path\oriented_path.orientation); 
  ELSE 
    the_reverse := (dummy_tri || path(list_of_topology_reversed(a_path. 
        edge_list))) || oriented_path(a_path,FALSE); 
  END_IF; 
  RETURN(the_reverse);
 
END_FUNCTION; -- path_reversed
 
FUNCTION scalar_times_vector( 
             scalar: REAL; 
             vec: vector_or_direction 
    ): vector;
 
  LOCAL 
    v      : direction; 
    mag    : REAL; 
    result : vector; 
  END_LOCAL; 
  IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN 
    RETURN(?); 
  ELSE 
    IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(vec) THEN 
      v := dummy_gri || direction(vec.orientation.direction_ratios); 
      mag := scalar * vec.magnitude; 
    ELSE 
      v := dummy_gri || direction(vec.direction_ratios); 
      mag := scalar; 
    END_IF; 
    IF mag < 0 THEN 
      REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1; 
        v.direction_ratios[i] := -v.direction_ratios[i]; 
      END_REPEAT; 
      mag := -mag; 
    END_IF; 
    result := dummy_gri || vector(normalise(v),mag); 
  END_IF; 
  RETURN(result);
 
END_FUNCTION; -- scalar_times_vector
 
FUNCTION second_proj_axis( 
             z_axis, x_axis, arg: direction 
    ): direction;
 
  LOCAL 
    temp   : vector; 
    v      : direction; 
    y_axis : vector; 
  END_LOCAL; 
  IF NOT EXISTS(arg) THEN 
    v := dummy_gri || direction([0,1,0]); 
  ELSE 
    v := arg; 
  END_IF; 
  temp := scalar_times_vector(dot_product(v,z_axis),z_axis); 
  y_axis := vector_difference(v,temp); 
  temp := scalar_times_vector(dot_product(v,x_axis),x_axis); 
  y_axis := vector_difference(y_axis,temp); 
  y_axis := normalise(y_axis); 
  RETURN(y_axis.orientation);
 
END_FUNCTION; -- second_proj_axis
 
FUNCTION set_of_topology_reversed( 
             a_set: set_of_reversible_topology_item 
    ): set_of_reversible_topology_item;
 
  LOCAL 
    the_reverse : set_of_reversible_topology_item; 
  END_LOCAL; 
  the_reverse := []; 
  REPEAT i := 1 TO SIZEOF(a_set) BY 1; 
    the_reverse := the_reverse + topology_reversed(a_set[i]); 
  END_REPEAT; 
  RETURN(the_reverse);
 
END_FUNCTION; -- set_of_topology_reversed
 
FUNCTION shell_reversed( 
             a_shell: shell 
    ): shell; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.OPEN_SHELL' IN TYPEOF(a_shell) THEN 
    RETURN(open_shell_reversed(a_shell)); 
  ELSE 
    IF 'SHIP_ARRANGEMENT_SCHEMA.CLOSED_SHELL' IN TYPEOF(a_shell) THEN 
      RETURN(closed_shell_reversed(a_shell)); 
    ELSE 
      RETURN(?); 
    END_IF; 
  END_IF;
 
END_FUNCTION; -- shell_reversed
 
FUNCTION surface_weights_positive( 
             b: rational_b_spline_surface 
    ): BOOLEAN;
 
  LOCAL 
    result : BOOLEAN := TRUE; 
  END_LOCAL; 
  REPEAT i := 0 TO b.u_upper BY 1; 
    REPEAT j := 0 TO b.v_upper BY 1; 
      IF b.weights[i][j] <= 0 THEN 
        result := FALSE; 
        RETURN(result); 
      END_IF; 
    END_REPEAT; 
  END_REPEAT; 
  RETURN(result);
 
END_FUNCTION; -- surface_weights_positive
 
FUNCTION topology_reversed( 
             an_item: reversible_topology 
    ): reversible_topology; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.EDGE' IN TYPEOF(an_item) THEN 
    RETURN(edge_reversed(an_item)); 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.PATH' IN TYPEOF(an_item) THEN 
    RETURN(path_reversed(an_item)); 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.FACE_BOUND' IN TYPEOF(an_item) THEN 
    RETURN(face_bound_reversed(an_item)); 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.FACE' IN TYPEOF(an_item) THEN 
    RETURN(face_reversed(an_item)); 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.SHELL' IN TYPEOF(an_item) THEN 
    RETURN(shell_reversed(an_item)); 
  END_IF; 
  IF 'SET' IN TYPEOF(an_item) THEN 
    RETURN(set_of_topology_reversed(an_item)); 
  END_IF; 
  IF 'LIST' IN TYPEOF(an_item) THEN 
    RETURN(list_of_topology_reversed(an_item)); 
  END_IF; 
  RETURN(?);
 
END_FUNCTION; -- topology_reversed
 
FUNCTION using_items( 
             item: founded_item_select; 
             checked_items: SET OF founded_item_select 
    ): SET OF founded_item_select;
 
  LOCAL 
    next_items      : SET OF founded_item_select; 
    new_check_items : SET OF founded_item_select; 
    result_items    : SET OF founded_item_select; 
  END_LOCAL; 
  result_items := []; 
  new_check_items := checked_items + item; 
  next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | (( 
      'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR ( 
      'SHIP_ARRANGEMENT_SCHEMA.FOUNDED_ITEM' IN TYPEOF(z))) ); 
  IF SIZEOF(next_items) > 0 THEN 
    REPEAT i := 1 TO HIINDEX(next_items) BY 1; 
      IF NOT (next_items[i] IN new_check_items) THEN 
        result_items := (result_items + next_items[i]) + using_items( 
            next_items[i],new_check_items); 
      END_IF; 
    END_REPEAT; 
  END_IF; 
  RETURN(result_items);
 
END_FUNCTION; -- using_items
 
FUNCTION using_representations( 
             item: founded_item_select 
    ): SET OF representation;
 
  LOCAL 
    results            : SET OF representation; 
    intermediate_items : SET OF founded_item_select; 
    result_bag         : BAG OF representation; 
  END_LOCAL; 
  results := []; 
  result_bag := USEDIN(item, 
      'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION.ITEMS'); 
  IF SIZEOF(result_bag) > 0 THEN 
    REPEAT i := 1 TO HIINDEX(result_bag) BY 1; 
      results := results + result_bag[i]; 
    END_REPEAT; 
  END_IF; 
  intermediate_items := using_items(item,[]); 
  IF SIZEOF(intermediate_items) > 0 THEN 
    REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1; 
      result_bag := USEDIN(intermediate_items[i], 
          'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION.ITEMS'); 
      IF SIZEOF(result_bag) > 0 THEN 
        REPEAT j := 1 TO HIINDEX(result_bag) BY 1; 
          results := results + result_bag[j]; 
        END_REPEAT; 
      END_IF; 
    END_REPEAT; 
  END_IF; 
  RETURN(results);
 
END_FUNCTION; -- using_representations
 
FUNCTION valid_calendar_date( 
             date: calendar_date 
    ): LOGICAL; 
  CASE date.month_component OF 
    1 :         RETURN((1 <= date.day_component) AND (date.day_component  
          <= 31)); 
    2 :         BEGIN 
        IF leap_year(date.year_component) THEN 
          RETURN((1 <= date.day_component) AND (date.day_component <= 29)); 
        ELSE 
          RETURN((1 <= date.day_component) AND (date.day_component <= 28)); 
        END_IF; 
      END; 
    3 :         RETURN((1 <= date.day_component) AND (date.day_component  
          <= 31)); 
    4 :         RETURN((1 <= date.day_component) AND (date.day_component  
          <= 30)); 
    5 :         RETURN((1 <= date.day_component) AND (date.day_component  
          <= 31)); 
    6 :         RETURN((1 <= date.day_component) AND (date.day_component  
          <= 30)); 
    7 :         RETURN((1 <= date.day_component) AND (date.day_component  
          <= 31)); 
    8 :         RETURN((1 <= date.day_component) AND (date.day_component  
          <= 31)); 
    9 :         RETURN((1 <= date.day_component) AND (date.day_component  
          <= 30)); 
    10  :         RETURN((1 <= date.day_component) AND (date. 
          day_component <= 31)); 
    11  :         RETURN((1 <= date.day_component) AND (date. 
          day_component <= 30)); 
    12  :         RETURN((1 <= date.day_component) AND (date. 
          day_component <= 31)); 
    END_CASE; 
  RETURN(FALSE);
 
END_FUNCTION; -- valid_calendar_date
 
FUNCTION valid_measure_value( 
             m: measure_value 
    ): BOOLEAN; 
  IF 'REAL' IN TYPEOF(m) THEN 
    RETURN(m > 0); 
  ELSE 
    IF 'INTEGER' IN TYPEOF(m) THEN 
      RETURN(m > 0); 
    ELSE 
      RETURN(TRUE); 
    END_IF; 
  END_IF;
 
END_FUNCTION; -- valid_measure_value
 
FUNCTION valid_time( 
             time: local_time 
    ): BOOLEAN; 
  IF EXISTS(time.second_component) THEN 
    RETURN(EXISTS(time.minute_component)); 
  ELSE 
    RETURN(TRUE); 
  END_IF;
 
END_FUNCTION; -- valid_time
 
FUNCTION valid_units( 
             m: measure_with_unit 
    ): BOOLEAN; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m. 
      value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(1,0,0,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component) 
       THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,1,0,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component) 
       THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,0,1,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m. 
      value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,0,0,1,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN  
      TYPEOF(m.value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,0,0,0,1,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m. 
      value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,0,0,0,0,1,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m. 
      value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,0,0,0,0,0,1) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m. 
      value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,0,0,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m. 
      value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,0,0,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component) 
       THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(2,0,0,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m. 
      value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(3,0,0,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.RATIO_MEASURE' IN TYPEOF(m. 
      value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,0,0,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m. 
      value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(1,0,0,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  IF 'SHIP_ARRANGEMENT_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m 
      .value_component) THEN 
    IF derive_dimensional_exponents(m.unit_component) <>  
        dimensional_exponents(0,0,0,0,0,0,0) THEN 
      RETURN(FALSE); 
    END_IF; 
  END_IF; 
  RETURN(TRUE);
 
END_FUNCTION; -- valid_units
 
FUNCTION vector_difference( 
             arg1, arg2: vector_or_direction 
    ): vector;
 
  LOCAL 
    ndim   : INTEGER; 
    mag2   : REAL; 
    mag1   : REAL; 
    mag    : REAL; 
    res    : direction; 
    vec1   : direction; 
    vec2   : direction; 
    result : vector; 
  END_LOCAL; 
  IF ((NOT EXISTS(arg1)) OR (NOT EXISTS(arg2))) OR (arg1.dim <> arg2.dim) 
       THEN 
    RETURN(?); 
  ELSE 
    BEGIN 
      IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN 
        mag1 := arg1.magnitude; 
        vec1 := arg1.orientation; 
      ELSE 
        mag1 := 1; 
        vec1 := arg1; 
      END_IF; 
      IF 'SHIP_ARRANGEMENT_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN 
        mag2 := arg2.magnitude; 
        vec2 := arg2.orientation; 
      ELSE 
        mag2 := 1; 
        vec2 := arg2; 
      END_IF; 
      vec1 := normalise(vec1); 
      vec2 := normalise(vec2); 
      ndim := SIZEOF(vec1.direction_ratios); 
      mag := 0; 
      res := dummy_gri || direction(vec1.direction_ratios); 
      REPEAT i := 1 TO ndim BY 1; 
        res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + ( 
            mag2 * vec2.direction_ratios[i]); 
        mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]); 
      END_REPEAT; 
      IF mag > 0 THEN 
        result := dummy_gri || vector(res,SQRT(mag)); 
      ELSE 
        result := dummy_gri || vector(vec1,0); 
      END_IF; 
    END; 
  END_IF; 
  RETURN(result);
 
END_FUNCTION; -- vector_difference
 
FUNCTION which_class( 
             t: GENERIC 
    ): LIST OF STRING;
 
  LOCAL 
    class_list : LIST OF STRING := []; 
    elements   : BAG OF applied_classification_assignment; 
  END_LOCAL; 
  elements := USEDIN(t, 
      'SHIP_ARRANGEMENT_SCHEMA.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS'); 
  REPEAT i := 1 TO HIINDEX(elements) BY 1; 
    IF elements[i]\classification_assignment.role.name =  
        'class membership' THEN 
      class_list := class_list + elements[i]\classification_assignment. 
          assigned_class\group.name; 
    END_IF; 
  END_REPEAT; 
  RETURN(class_list);
 
END_FUNCTION; -- which_class

END_SCHEMA; -- ship_arrangement_schema

