(***********************************************************************
 AIM long form for ISO/IS 10303-204
 ISO TC184/SC4/WG3 N1027
 2001-08-31
 Ray Goult
***********************************************************************)

SCHEMA part_204_brep_product_schema; -- from part 204 FDIS WG3 N1025 July 2001.
CONSTANT
 dummy_gri : geometric_representation_item := representation_item('')||
                   geometric_representation_item();

   dummy_tri : topological_representation_item := representation_item('')||
                  topological_representation_item();
END_CONSTANT;

(* types below are introduced only to solve compiler problems arising
   in topology reverse functions, etc., they are not to be used explicitly:
  shell, transition_code, list_of_reversible_topology_item
  geometric_set_select, trimming_select
*)
TYPE area_or_view = SELECT
  (presentation_area,
   presentation_view);
END_TYPE;

TYPE axis2_placement = SELECT
   (axis2_placement_2d, 
    axis2_placement_3d);
END_TYPE;

TYPE BOOLEAN_OPERAND = SELECT (
   SOLID_MODEL);
END_TYPE;

TYPE b_spline_curve_form = ENUMERATION OF
   (polyline_form,
    circular_arc,
    elliptic_arc,
    parabolic_arc,
    hyperbolic_arc,
    unspecified);
END_TYPE;
 
TYPE b_spline_surface_form = ENUMERATION OF
   (plane_surf,
    cylindrical_surf,
    conical_surf,
    spherical_surf,
    toroidal_surf,
    surf_of_revolution,
    ruled_surf,
    generalised_cone,
    quadric_surf,
    surf_of_linear_extrusion,
    unspecified);
END_TYPE;
 
TYPE central_or_parallel = ENUMERATION OF
  (central, 
   parallel);
END_TYPE;

TYPE CHARACTERIZED_DEFINITION = SELECT (
   SHAPE_DEFINITION);
END_TYPE;

TYPE CURVE_FONT_OR_SCALED_CURVE_FONT_SELECT = SELECT (
   CURVE_STYLE_FONT_SELECT);
END_TYPE;

TYPE curve_on_surface = SELECT
   (pcurve, 
    surface_curve, 
    composite_curve_on_surface);
END_TYPE;

TYPE curve_or_render = SELECT
  (curve_style,
   curve_style_rendering);
END_TYPE;

TYPE CURVE_STYLE_FONT_SELECT = SELECT (
   CURVE_STYLE_FONT,
   PRE_DEFINED_CURVE_FONT);
END_TYPE;

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

TYPE direction_count_select = SELECT
  (u_direction_count,
   v_direction_count);
END_TYPE;

TYPE FILL_STYLE_SELECT = SELECT (
   FILL_AREA_STYLE_COLOUR);
END_TYPE;

TYPE founded_item_select = SELECT
  (founded_item,
   representation_item);
END_TYPE;

TYPE geometric_set_select = SELECT
   (point,
    curve,
    surface);
 END_TYPE;
 
TYPE identifier = STRING;
END_TYPE; 

TYPE INVISIBLE_ITEM = SELECT (
   STYLED_ITEM,
   REPRESENTATION);
END_TYPE;

TYPE knot_type = ENUMERATION OF
   (uniform_knots,
    unspecified,
    quasi_uniform_knots,
    piecewise_bezier_knots);
 END_TYPE;
 
TYPE label = STRING;
END_TYPE;

TYPE layered_item = SELECT
  (presentation_representation,
   representation_item);
END_TYPE;

TYPE length_measure = REAL;
END_TYPE;

TYPE list_of_reversible_topology_item =
                               LIST [0:?] of reversible_topology_item;
END_TYPE;
 
TYPE MARKER_SELECT = SELECT (
   MARKER_TYPE);
END_TYPE;

TYPE marker_type = ENUMERATION OF
  (dot,
   x,
   plus,
   asterisk,
   ring,
   square,
   triangle);
END_TYPE;

TYPE MEASURE_VALUE = SELECT (
   LENGTH_MEASURE,
   PLANE_ANGLE_MEASURE,
   RATIO_MEASURE,
   PARAMETER_VALUE,
   POSITIVE_LENGTH_MEASURE,
   POSITIVE_PLANE_ANGLE_MEASURE,
   POSITIVE_RATIO_MEASURE);
END_TYPE;

TYPE parameter_value = REAL;
END_TYPE;

TYPE pcurve_or_surface = SELECT
   (pcurve, 
    surface);
 END_TYPE;
 
TYPE plane_angle_measure = REAL;
END_TYPE;

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0;
END_TYPE;

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0;
END_TYPE;

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0;
END_TYPE;

TYPE preferred_surface_curve_representation = ENUMERATION OF
   (curve_3d,
    pcurve_s1, 
    pcurve_s2);
 END_TYPE;
 
TYPE presentation_representation_select = SELECT
  (presentation_representation,
   presentation_set);
END_TYPE;

TYPE presentation_size_assignment_select = SELECT
  (presentation_view,
   presentation_area,
   area_in_set);
END_TYPE;

TYPE PRESENTATION_STYLE_SELECT = SELECT (
   POINT_STYLE,
   CURVE_STYLE,
   SURFACE_STYLE_USAGE,
   FILL_AREA_STYLE);
END_TYPE;

TYPE ratio_measure = REAL;
END_TYPE;

TYPE rendering_properties_select = SELECT
  (surface_style_reflectance_ambient,
   surface_style_transparent);
END_TYPE;

TYPE reversible_topology = SELECT 
           (reversible_topology_item,
            list_of_reversible_topology_item,
            set_of_reversible_topology_item);
END_TYPE;

TYPE reversible_topology_item = SELECT
   (edge, 
    path, 
    face, 
    face_bound,
    closed_shell, 
    open_shell);
END_TYPE;
 
TYPE set_of_reversible_topology_item =
                       SET [0:?] of reversible_topology_item;
 END_TYPE;
  
TYPE shading_curve_method = ENUMERATION OF
  (constant_colour,
   linear_colour);
END_TYPE;

TYPE shading_surface_method = ENUMERATION OF
  (constant_shading,
   colour_shading,
   dot_shading,
   normal_shading);
END_TYPE;

TYPE SHAPE_DEFINITION = SELECT (
   PRODUCT_DEFINITION_SHAPE);
END_TYPE;

TYPE SHELL = SELECT (
   OPEN_SHELL,
   CLOSED_SHELL);
END_TYPE;

TYPE si_prefix = ENUMERATION OF
  (exa, 
   peta, 
   tera, 
   giga, 
   mega, 
   kilo, 
   hecto, 
   deca, 
   deci,
   centi, 
   milli, 
   micro, 
   nano, 
   pico, 
   femto, 
   atto);
END_TYPE;

TYPE si_unit_name = ENUMERATION OF
  (metre, 
   gram, 
   second, 
   ampere, 
   kelvin, 
   mole, 
   candela, 
   radian, 
   steradian,
   hertz, 
   newton, 
   pascal, 
   joule, 
   watt, 
   coulomb, 
   volt, 
   farad, 
   ohm, 
   siemens, 
   weber, 
   tesla, 
   henry, 
   degree_Celsius, 
   lumen, 
   lux, 
   becquerel, 
   gray, 
   sievert);
END_TYPE;

TYPE SIZE_SELECT = SELECT (
   POSITIVE_LENGTH_MEASURE,
   MEASURE_WITH_UNIT);
END_TYPE;

TYPE STYLE_CONTEXT_SELECT = SELECT (
   REPRESENTATION,
   REPRESENTATION_ITEM,
   PRESENTATION_SET);
END_TYPE;

TYPE surface_side = ENUMERATION OF
  (positive,
   negative,
   both);
END_TYPE;

TYPE SURFACE_SIDE_STYLE_SELECT = SELECT (
   SURFACE_SIDE_STYLE);
END_TYPE;

TYPE surface_style_element_select = SELECT
  (surface_style_fill_area,
   surface_style_boundary,
   surface_style_silhouette,
   surface_style_segmentation_curve,
   surface_style_control_grid,
   surface_style_parameter_line,
   surface_style_rendering);
END_TYPE;

TYPE text = STRING;
END_TYPE;

TYPE TRANSFORMATION = SELECT (
   FUNCTIONALLY_DEFINED_TRANSFORMATION);
END_TYPE;

TYPE transition_code = ENUMERATION OF
   (discontinuous,
    continuous,
    cont_same_gradient,
    cont_same_gradient_same_curvature);
END_TYPE;

TYPE trimming_select = SELECT 
   (cartesian_point, 
    parameter_value);
END_TYPE;
TYPE u_direction_count = INTEGER;
WHERE
  WR1: SELF > 1;
END_TYPE;

TYPE UNIT = SELECT (
   NAMED_UNIT);
END_TYPE;

TYPE v_direction_count = INTEGER;
WHERE
  WR1: SELF > 1;
END_TYPE;

TYPE vector_or_direction = SELECT
   (vector, 
    direction);
END_TYPE;

(* entities below are introduced only to solve compiler problems arising
   in topology reverse functions, etc., they are not to be used explicitly:
   composite_curve, composite_curve_segment,
  open_shell,  oriented_face,  oriented_path, oriented_open_shell;
*)
 ENTITY advanced_brep_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
     WR1: SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
              'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP',
              'PART_204_BREP_PRODUCT_SCHEMA.FACETED_BREP',
              'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM',
              'PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT_3D'] *
                        TYPEOF(it)) = 1)) ))  = 0;
     WR2: SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
              'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP',
              'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'] *
                                     TYPEOF(it)) = 1) )) > 0;
     WR3: SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items |
              ('PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP' IN
                         TYPEOF(it)) ) |
             ( NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) |
                              (NOT (SIZEOF(QUERY ( fcs <* csh\
              connected_face_set.cfs_faces | (NOT (
           'PART_204_BREP_PRODUCT_SCHEMA.ADVANCED_FACE'
                        IN TYPEOF(fcs))) )) = 0)) ))
              = 0)) )) = 0;
     WR4: SIZEOF(QUERY ( msb <* QUERY ( it <* items |
            ( 'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP' IN
                             TYPEOF(it)) ) |
            (  'PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_CLOSED_SHELL' IN
                 TYPEOF(msb\manifold_solid_brep.outer)) )) = 0;
     WR5: SIZEOF(QUERY ( brv <* QUERY ( it <* items |
           ( 'PART_204_BREP_PRODUCT_SCHEMA.BREP_WITH_VOIDS' IN
               TYPEOF(it)) ) |
               (NOT(SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids |
              ( csh\oriented_closed_shell.orientation)))  = 0)) ))
              = 0;
     WR6: SIZEOF(QUERY ( mi <* QUERY ( it <* items |
            ( 'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) |
            (NOT
        ( 'PART_204_BREP_PRODUCT_SCHEMA.ADVANCED_BREP_SHAPE_REPRESENTATION'
          IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))
              )) = 0;
 END_ENTITY;
 
ENTITY advanced_face
  SUBTYPE OF (face_surface);
WHERE
  WR1 : SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.ELEMENTARY_SURFACE',
          'PART_204_BREP_PRODUCT_SCHEMA.B_SPLINE_SURFACE',
          'PART_204_BREP_PRODUCT_SCHEMA.SWEPT_SURFACE'] *
            TYPEOF(face_geometry)) = 1;
  WR2 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds |
         'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
          NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
              NOT('PART_204_BREP_PRODUCT_SCHEMA.EDGE_CURVE' IN
              TYPEOF(oe\oriented_edge.edge_element)))) = 0))) = 0;
  WR3 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds |
         'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            NOT (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.LINE',
                         'PART_204_BREP_PRODUCT_SCHEMA.CONIC',
                         'PART_204_BREP_PRODUCT_SCHEMA.POLYLINE',
                         'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_CURVE',
                         'PART_204_BREP_PRODUCT_SCHEMA.B_SPLINE_CURVE'] *
              TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
                )) = 0))) = 0;
  WR4 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds |
         'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT(SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list |
             NOT(((('PART_204_BREP_PRODUCT_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(oe\edge.edge_start)) AND
            ( 'PART_204_BREP_PRODUCT_SCHEMA.CARTESIAN_POINT' IN
             TYPEOF(oe\edge.edge_start\vertex_point.vertex_geometry)))) AND
                 (('PART_204_BREP_PRODUCT_SCHEMA.VERTEX_POINT' IN
                    TYPEOF(oe\edge.edge_end)) AND
                   ( 'PART_204_BREP_PRODUCT_SCHEMA.CARTESIAN_POINT' IN
                     TYPEOF(oe\edge.edge_end\vertex_point.vertex_geometry)))
              ))) = 0))) = 0;
  WR5 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds |
       'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            'PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_PATH' IN
             TYPEOF(elp_fbnds.bound))) = 0;
  WR6 : (NOT ('PART_204_BREP_PRODUCT_SCHEMA.SWEPT_SURFACE' IN
                                              TYPEOF(face_geometry))) OR
             (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.LINE',
                       'PART_204_BREP_PRODUCT_SCHEMA.CONIC',
                       'PART_204_BREP_PRODUCT_SCHEMA.POLYLINE',
                       'PART_204_BREP_PRODUCT_SCHEMA.B_SPLINE_CURVE'] *
                  TYPEOF(face_geometry\swept_surface.swept_curve)) = 1);
  WR7 : SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* bounds |
      'PART_204_BREP_PRODUCT_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) |
          NOT(('PART_204_BREP_PRODUCT_SCHEMA.VERTEX_POINT' IN
          TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                  ('PART_204_BREP_PRODUCT_SCHEMA.CARTESIAN_POINT' IN
                     TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                     loop_vertex\vertex_point.vertex_geometry))
              ))) = 0;
  WR8 : SIZEOF (QUERY (bnd <* bounds |
         NOT (SIZEOF(['PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP',
         'PART_204_BREP_PRODUCT_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnd.bound))
                                = 1))) = 0;
  WR9 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* bounds |
        'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            ('PART_204_BREP_PRODUCT_SCHEMA.SURFACE_CURVE' IN
            TYPEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry))
            AND (NOT (SIZEOF (QUERY (sc_ag <*
            oe.edge_element\edge_curve.edge_geometry\
            surface_curve.associated_geometry |
            NOT ('PART_204_BREP_PRODUCT_SCHEMA.PCURVE' IN
            TYPEOF(sc_ag)))) = 0)))) = 0))) = 0;
  WR10 : ((NOT ('PART_204_BREP_PRODUCT_SCHEMA.SWEPT_SURFACE' IN
         TYPEOF(face_geometry))) OR
         ((NOT ('PART_204_BREP_PRODUCT_SCHEMA.POLYLINE' IN
         TYPEOF(face_geometry\swept_surface.swept_curve))) OR
         (SIZEOF(face_geometry\swept_surface.swept_curve\polyline.points)
         >= 3))) AND
         (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* bounds |
         'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
         NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
         ('PART_204_BREP_PRODUCT_SCHEMA.POLYLINE' IN
        TYPEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND
         (NOT (SIZEOF (oe\oriented_edge.edge_element\
            edge_curve.edge_geometry\polyline.points) >= 3)))) = 0))) = 0);
 END_ENTITY;
 
ENTITY application_context;
  application          : text; 
INVERSE   
  context_elements : SET [1:?] OF  application_context_element 
                                FOR frame_of_reference;
END_ENTITY;

ENTITY application_context_element
  SUPERTYPE OF (ONEOF (
              PRODUCT_CONTEXT,
              PRODUCT_DEFINITION_CONTEXT));
  name                 : label;
  frame_of_reference   : application_context;
END_ENTITY;

ENTITY area_in_set;
  area   : presentation_area;
  in_set : presentation_set;
END_ENTITY;

ENTITY assembly_component_usage
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier; 
END_ENTITY; 

ENTITY axis1_placement
 SUBTYPE OF (placement);
   axis     : OPTIONAL direction;
 DERIVE
   z : direction := NVL(normalise(axis), dummy_gri ||
                                 direction([0.0,0.0,1.0]));
 WHERE
   WR1: SELF\geometric_representation_item.dim  = 3;
END_ENTITY;

ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [2:2] OF direction := build_2axes(ref_direction);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;
 
ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
   axis          : OPTIONAL direction;
   ref_direction : OPTIONAL direction;
 DERIVE
   p        : LIST [3:3] OF direction := build_axes(axis,ref_direction);
 WHERE
   WR1: SELF\placement.location.dim = 3;
   WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
   WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
   WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR
          (cross_product(axis,ref_direction).magnitude > 0.0);
 END_ENTITY;
 
ENTITY background_colour
  SUBTYPE OF (colour);
  presentation : area_or_view;
UNIQUE
  UR1:  presentation;
END_ENTITY;

ENTITY b_spline_curve
   SUPERTYPE OF (ONEOF (
              UNIFORM_CURVE,
              B_SPLINE_CURVE_WITH_KNOTS,
              QUASI_UNIFORM_CURVE,
              BEZIER_CURVE)
              ANDOR 
              RATIONAL_B_SPLINE_CURVE)
  SUBTYPE OF (bounded_curve);
   degree               : INTEGER;
   control_points_list  : LIST [2:?] OF cartesian_point;
   curve_form           : b_spline_curve_form;
   closed_curve         : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   upper_index_on_control_points  : INTEGER 
                                  := (SIZEOF(control_points_list) - 1);
   control_points       : ARRAY [0:upper_index_on_control_points]
                                                        OF cartesian_point
                                  := list_to_array(control_points_list,0,
                                           upper_index_on_control_points);
 WHERE
   WR1: ('PART_204_BREP_PRODUCT_SCHEMA.UNIFORM_CURVE'
         IN TYPEOF(self)) OR
        ('PART_204_BREP_PRODUCT_SCHEMA.QUASI_UNIFORM_CURVE'
            IN TYPEOF(self)) OR
        ('PART_204_BREP_PRODUCT_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR
        ('PART_204_BREP_PRODUCT_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS'
             IN TYPEOF(self));
END_ENTITY;

ENTITY b_spline_curve_with_knots
   SUBTYPE OF (b_spline_curve);
   knot_multiplicities  : LIST [2:?] OF INTEGER;
   knots                : LIST [2:?] OF parameter_value;
   knot_spec            : knot_type;
 DERIVE
   upper_index_on_knots : INTEGER := SIZEOF(knots);
 WHERE
   WR1: constraints_param_b_spline(degree, upper_index_on_knots,
                               upper_index_on_control_points,
                               knot_multiplicities, knots);
    WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

ENTITY b_spline_surface
   SUPERTYPE OF (ONEOF (
              B_SPLINE_SURFACE_WITH_KNOTS,
              UNIFORM_SURFACE,
              QUASI_UNIFORM_SURFACE,
              BEZIER_SURFACE)
              ANDOR 
              RATIONAL_B_SPLINE_SURFACE)
  SUBTYPE OF (bounded_surface);
   u_degree             : INTEGER;
   v_degree             : INTEGER;
   control_points_list  : LIST [2:?] OF
                            LIST [2:?] OF cartesian_point;
   surface_form         : b_spline_surface_form;
   u_closed             : LOGICAL;
   v_closed             : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
   v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
   control_points      : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF 
                         cartesian_point 
                       := make_array_of_array(control_points_list,
                                              0,u_upper,0,v_upper);
 WHERE
   WR1: ('PART_204_BREP_PRODUCT_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('PART_204_BREP_PRODUCT_SCHEMA.QUASI_UNIFORM_SURFACE' IN
              TYPEOF(SELF)) OR
        ('PART_204_BREP_PRODUCT_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
        ('PART_204_BREP_PRODUCT_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS'
            IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_surface_with_knots
   SUBTYPE OF (b_spline_surface);
   u_multiplicities  : LIST [2:?] OF INTEGER;
   v_multiplicities  : LIST [2:?] OF INTEGER;
   u_knots           : LIST [2:?] OF parameter_value;
   v_knots           : LIST [2:?] OF parameter_value;
   knot_spec         : knot_type;
 DERIVE
   knot_u_upper      : INTEGER := SIZEOF(u_knots);
   knot_v_upper      : INTEGER := SIZEOF(v_knots);
 WHERE
    WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
                   knot_u_upper, SELF\b_spline_surface.u_upper,
                               u_multiplicities, u_knots);
    WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
                   knot_v_upper, SELF\b_spline_surface.v_upper,
                               v_multiplicities, v_knots);
    WR3: SIZEOF(u_multiplicities) = knot_u_upper;
    WR4: SIZEOF(v_multiplicities) = knot_v_upper;
 END_ENTITY;

ENTITY bezier_curve
   SUBTYPE OF (b_spline_curve);
END_ENTITY;
 
ENTITY bezier_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;
 
ENTITY bounded_curve
   SUPERTYPE OF (ONEOF (
              POLYLINE,
              B_SPLINE_CURVE,
              COMPOSITE_CURVE))
  SUBTYPE OF (curve);
END_ENTITY;

ENTITY bounded_surface
   SUPERTYPE OF (ONEOF (
              B_SPLINE_SURFACE))
  SUBTYPE OF (surface);
END_ENTITY;

ENTITY brep_with_voids
   SUBTYPE OF (manifold_solid_brep);
   voids : SET [1:?] OF oriented_closed_shell;
END_ENTITY;


ENTITY camera_image
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'PART_204_BREP_PRODUCT_SCHEMA.CAMERA_USAGE'
       IN TYPEOF (SELF\mapped_item.mapping_source);
  WR2: 'PART_204_BREP_PRODUCT_SCHEMA.PLANAR_BOX'
       IN TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'PART_204_BREP_PRODUCT_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM'

       IN TYPEOF (SELF);
END_ENTITY;

ENTITY camera_image_3d_with_scale
  SUBTYPE OF (camera_image);
DERIVE
  scale: positive_ratio_measure := ((SELF\mapped_item.mapping_target\
         planar_extent.size_in_x) / (SELF\mapped_item.mapping_source.
         mapping_origin\camera_model_d3.perspective_of_volume.view_window.
         size_in_x));
WHERE
  WR1: ('PART_204_BREP_PRODUCT_SCHEMA.CAMERA_MODEL_D3'
       IN TYPEOF (SELF\mapped_item.mapping_source.mapping_origin));
  WR2: aspect_ratio(SELF\mapped_item.mapping_target) =
       aspect_ratio(SELF\mapped_item.mapping_source.mapping_origin\
       camera_model_d3.perspective_of_volume.view_window);
  WR3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.front_plane_clipping
       AND
       SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_volume_sides_clipping;
  WR4: (SELF\mapped_item.mapping_target\planar_extent.size_in_x > 0)
       AND
       (SELF\mapped_item.mapping_target\planar_extent.size_in_y > 0);
  WR5: (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_window.size_in_x > 0)
       AND
       (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_window.size_in_y > 0);
  WR6: ('PART_204_BREP_PRODUCT_SCHEMA.' +
       'AXIS2_PLACEMENT_2D' IN TYPEOF (SELF\mapped_item.
       mapping_target\planar_box.placement))
       AND NOT ('PART_204_BREP_PRODUCT_SCHEMA.' +

       'AXIS2_PLACEMENT_3D' IN TYPEOF (SELF\mapped_item.
       mapping_target\planar_box.placement));
END_ENTITY;

ENTITY camera_model
  SUPERTYPE OF (ONEOF (
              CAMERA_MODEL_D3))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: (SIZEOF (USEDIN (SELF, 'PART_204_BREP_PRODUCT_SCHEMA.' +
                              'ITEM_DEFINED_TRANSFORMATION.' +
                              'TRANSFORM_ITEM_1')) +
        SIZEOF (USEDIN (SELF, 'PART_204_BREP_PRODUCT_SCHEMA.' +
                              'REPRESENTATION_MAP.MAPPING_ORIGIN'))
       ) > 0;
  WR2: SIZEOF(USEDIN(SELF,'PART_204_BREP_PRODUCT_SCHEMA.'+

                          'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;

ENTITY camera_model_d3
  SUBTYPE OF (camera_model);
  view_reference_system : axis2_placement_3d;
  perspective_of_volume : view_volume;
WHERE
  WR1: (dot_product (SELF.view_reference_system.p[3],
         SELF.perspective_of_volume.view_window.placement.p[3]) = 1.0)
         AND
       (SELF.view_reference_system.location.coordinates[3] =
        SELF.perspective_of_volume.view_window.
             placement.location.coordinates[3]);
  WR2: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY camera_model_d3_with_hlhsr
  SUBTYPE OF (camera_model_d3);
  hidden_line_surface_removal : BOOLEAN;
END_ENTITY;

ENTITY camera_model_with_light_sources
  SUBTYPE OF (camera_model_d3);
  sources : SET [1:?] OF light_source;
END_ENTITY;

ENTITY camera_usage
  SUBTYPE OF (representation_map);
WHERE
  WR1: NOT ('PART_204_BREP_PRODUCT_SCHEMA.PRESENTATION_REPRESENTATION'
       IN TYPEOF(SELF\representation_map.mapped_representation));
  WR2: 'PART_204_BREP_PRODUCT_SCHEMA.CAMERA_MODEL'

       IN TYPEOF (SELF\representation_map.mapping_origin);
END_ENTITY;

ENTITY cartesian_point
 SUBTYPE OF (point);
   coordinates  : LIST [1:3] OF length_measure;
END_ENTITY;

ENTITY cartesian_transformation_operator
   SUPERTYPE OF (ONEOF (
              CARTESIAN_TRANSFORMATION_OPERATOR_3D))
  SUBTYPE OF (geometric_representation_item,
                            functionally_defined_transformation);
   axis1        : OPTIONAL direction;
   axis2        : OPTIONAL direction;
   local_origin : cartesian_point;
   scale        : OPTIONAL REAL;
 DERIVE
   scl          : REAL := NVL(scale, 1.0);
 WHERE
   WR1: scl > 0.0;
END_ENTITY;

ENTITY cartesian_transformation_operator_3d
   SUBTYPE OF (cartesian_transformation_operator);
   axis3 : OPTIONAL direction;
 DERIVE
   u     : LIST[3:3] OF direction 
         := base_axis(3,SELF\cartesian_transformation_operator.axis1,
                   SELF\cartesian_transformation_operator.axis2,axis3);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;
 ENTITY circle
   SUBTYPE OF (conic);
   radius   : positive_length_measure;
 END_ENTITY;
 
ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
END_ENTITY;

ENTITY colour;
END_ENTITY;

ENTITY colour_rgb
  SUBTYPE OF (colour_specification);
  red   : REAL;
  green : REAL;
  blue  : REAL;
WHERE
  WR1: {0.0 <= red <= 1.0};
  WR2: {0.0 <= green <= 1.0};
  WR3: {0.0 <= blue <= 1.0};
END_ENTITY;

ENTITY colour_specification
  SUBTYPE OF (colour);
  name : label;
END_ENTITY;

ENTITY composite_curve
   SUBTYPE OF (bounded_curve);
   segments       : LIST [1:?] OF composite_curve_segment;
   self_intersect : LOGICAL;
 DERIVE
   n_segments     : INTEGER := SIZEOF(segments);
   closed_curve   : LOGICAL 
                  := segments[n_segments].transition <> discontinuous;
 WHERE
   WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments |
                temp.transition = discontinuous)) = 1)) OR
            ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | 
                temp.transition = discontinuous)) = 0));
END_ENTITY;

ENTITY composite_curve_on_surface
  SUBTYPE OF (composite_curve);
 DERIVE
   basis_surface : SET[0:2] OF surface :=
                get_basis_surface(SELF);
 WHERE
   WR1: SIZEOF(basis_surface) > 0;
   WR2: constraints_composite_curve_on_surface(SELF);
 END_ENTITY;

ENTITY composite_curve_segment
 SUBTYPE OF (founded_item);
   transition    : transition_code;
   same_sense    : BOOLEAN;
   parent_curve  : curve;
 INVERSE
   using_curves  : BAG[1:?] OF composite_curve FOR segments;
 WHERE
   WR1 : ('PART_204_BREP_PRODUCT_SCHEMA.BOUNDED_CURVE' IN
                                 TYPEOF(parent_curve));
END_ENTITY;

ENTITY  conical_surface
   SUBTYPE OF (elementary_surface);
   radius     : length_measure;
   semi_angle : plane_angle_measure;
 WHERE
   WR1: radius >= 0.0;
 END_ENTITY;

ENTITY conic
   SUPERTYPE OF (ONEOF (
              CIRCLE,
              ELLIPSE,
              HYPERBOLA,
              PARABOLA))
  SUBTYPE OF (curve);
   position: axis2_placement;
END_ENTITY;

ENTITY connected_face_set
   SUPERTYPE OF (ONEOF (
              CLOSED_SHELL,
              OPEN_SHELL))
  SUBTYPE OF (topological_representation_item);
   cfs_faces : SET [1:?] OF face;
END_ENTITY;

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name              : label;
  conversion_factor : measure_with_unit;
END_ENTITY;

ENTITY curve
   SUPERTYPE OF (ONEOF (
              LINE,
              CONIC,
              PCURVE,
              SURFACE_CURVE))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;


ENTITY curve_style;
  name         : label;
  curve_font   : curve_font_or_scaled_curve_font_select;
  curve_width  : size_select;
  curve_colour : colour;
END_ENTITY;

ENTITY curve_style_font;
  name         : label;
  pattern_list : LIST [1:?] OF curve_style_font_pattern;
END_ENTITY;

ENTITY curve_style_font_pattern;
  visible_segment_length   : positive_length_measure;
  invisible_segment_length : positive_length_measure;
END_ENTITY;

ENTITY curve_style_rendering;
  rendering_method     : shading_curve_method;
  rendering_properties : surface_rendering_properties;
END_ENTITY;

ENTITY  cylindrical_surface
   SUBTYPE OF (elementary_surface);
   radius : positive_length_measure;
 END_ENTITY;

ENTITY definitional_representation
  SUBTYPE OF ( representation );
WHERE
  WR1: 'PART_204_BREP_PRODUCT_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
       IN TYPEOF( SELF\representation.context_of_items );
END_ENTITY;

ENTITY degenerate_toroidal_surface
   SUBTYPE OF (toroidal_surface);
   select_outer : BOOLEAN;
 WHERE
  WR1: major_radius <   minor_radius;
 END_ENTITY;
 
 ENTITY design_context
  SUBTYPE OF (product_definition_context);
 WHERE
    WR1 : SELF.life_cycle_stage = 'design';
 END_ENTITY;
 
ENTITY dimensional_exponents;
  length_exponent                    : REAL; 
  mass_exponent                      : REAL;
  time_exponent                      : REAL;
  electric_current_exponent          : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent       : REAL;
  luminous_intensity_exponent        : REAL;
END_ENTITY;

 ENTITY direction
   SUBTYPE OF (geometric_representation_item);
   direction_ratios : LIST [2:3] OF REAL;
 WHERE
   WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
 END_ENTITY;

ENTITY draughting_pre_defined_colour
  SUBTYPE OF (pre_defined_colour);
WHERE
  WR1: SELF.name IN
      ['red',
       'green',
       'blue',
       'yellow',
       'magenta',
       'cyan',
       'black',
       'white'];
END_ENTITY;

ENTITY draughting_pre_defined_curve_font
  SUBTYPE OF (pre_defined_curve_font);
WHERE
  WR1: SELF.name IN
       ['continuous',
        'chain',
        'chain double dash',
        'dashed',
        'dotted'];
END_ENTITY;

ENTITY edge
   SUPERTYPE OF (ONEOF (
              EDGE_CURVE,
              ORIENTED_EDGE))
  SUBTYPE OF (topological_representation_item);
   edge_start : vertex;
   edge_end   : vertex;
END_ENTITY;

ENTITY edge_curve
   SUBTYPE OF(edge,geometric_representation_item);
   edge_geometry : curve;
   same_sense    : BOOLEAN;
END_ENTITY;

ENTITY edge_loop
   SUBTYPE OF (loop,path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_start) :=:
        (SELF\path.edge_list[ne].edge_end);
END_ENTITY;

ENTITY elementary_brep_shape_representation
 SUBTYPE OF (shape_representation);
 WHERE
   WR1 : SIZEOF (QUERY (it <* SELF.items |
        NOT (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP',
                'PART_204_BREP_PRODUCT_SCHEMA.FACETED_BREP',
                'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM',
                'PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
   WR2 : SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP',
     'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR3 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
      'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh.cfs_faces |
                NOT('PART_204_BREP_PRODUCT_SCHEMA.FACE_SURFACE' IN
                               TYPEOF(fcs)))) = 0
                 ))) = 0
                   ))) = 0;
   WR4 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP'
                     IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
              NOT(('PART_204_BREP_PRODUCT_SCHEMA.ELEMENTARY_SURFACE' IN
                   TYPEOF(fcs\face_surface.face_geometry))
             ))) = 0
                 ))) = 0
                   ))) = 0;
   WR5 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP'
                      IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
              NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
        'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
               NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT('PART_204_BREP_PRODUCT_SCHEMA.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)))) = 0
                   ))) = 0
                 ))) = 0
               ))) = 0
             ))) = 0;
   WR6 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP'
                             IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
           NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
            NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
      'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
             NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.LINE',
                         'PART_204_BREP_PRODUCT_SCHEMA.CONIC',
                         'PART_204_BREP_PRODUCT_SCHEMA.POLYLINE'] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
   WR7 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
            'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP'
                        IN TYPEOF(it)) |
         NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
          NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
           NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
     'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            NOT(('PART_204_BREP_PRODUCT_SCHEMA.VERTEX_POINT'
                     IN TYPEOF(oe.edge_start))
                AND ('PART_204_BREP_PRODUCT_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0;
   WR8 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP'
                IN TYPEOF(it)) |
         NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
          NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
           NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
     'PART_204_BREP_PRODUCT_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('PART_204_BREP_PRODUCT_SCHEMA.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
   WR9 : SIZEOF (QUERY (msb <* QUERY (it <* items |
          'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP'
                     IN TYPEOF(it)) |
          'PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_CLOSED_SHELL'
             IN TYPEOF(msb\manifold_solid_brep.outer))) = 0;
   WR10 : SIZEOF (QUERY (brv <* QUERY (it <* items |
          'PART_204_BREP_PRODUCT_SCHEMA.BREP_WITH_VOIDS'
                        IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
           csh\oriented_closed_shell.orientation)) = 0))) = 0;
   WR11 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
                       IN TYPEOF(it)) |
          NOT (
     'PART_204_BREP_PRODUCT_SCHEMA.ELEMENTARY_BREP_SHAPE_REPRESENTATION'
             IN  TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR12 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP'
                        IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
           NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
            NOT (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fcs.bounds |
         'PART_204_BREP_PRODUCT_SCHEMA.VERTEX_LOOP'
                    IN TYPEOF(bnds.bound)) |
           NOT(('PART_204_BREP_PRODUCT_SCHEMA.VERTEX_POINT' IN
               TYPEOF(vlp_fbnds\face_bound.
                      bound\vertex_loop.loop_vertex)) AND
            ('PART_204_BREP_PRODUCT_SCHEMA.CARTESIAN_POINT' IN
               TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                     loop_vertex\vertex_point.vertex_geometry))
            ))) = 0))) = 0))) = 0))) =0;
END_ENTITY;

ENTITY elementary_surface
   SUPERTYPE OF (ONEOF (
              PLANE,
              CYLINDRICAL_SURFACE,
              CONICAL_SURFACE,
              SPHERICAL_SURFACE,
              TOROIDAL_SURFACE))
  SUBTYPE OF (surface);
   position : axis2_placement_3d;
END_ENTITY;

ENTITY ellipse
   SUBTYPE OF (conic);
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
 END_ENTITY;

ENTITY face
   SUPERTYPE OF (ONEOF (
              FACE_SURFACE,
              ORIENTED_FACE))
  SUBTYPE OF (topological_representation_item);
   bounds : SET[1:?] OF face_bound;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
   WR2: SIZEOF(QUERY(temp <* bounds |
        'PART_204_BREP_PRODUCT_SCHEMA.FACE_OUTER_BOUND' IN
                                  TYPEOF(temp))) <= 1;
END_ENTITY;

ENTITY face_bound
   SUBTYPE OF(topological_representation_item);
   bound       :  loop;
   orientation :  BOOLEAN;
END_ENTITY;

ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
END_ENTITY;

ENTITY face_surface
   SUBTYPE OF(face,geometric_representation_item);
   face_geometry :  surface;
   same_sense    :  BOOLEAN;
END_ENTITY;

ENTITY faceted_brep
   SUBTYPE OF (manifold_solid_brep);
END_ENTITY;

ENTITY faceted_brep_shape_representation
   SUBTYPE OF (shape_representation);
 WHERE
   WR1 : SIZEOF (QUERY (it <* items |
      NOT (SIZEOF(['PART_204_BREP_PRODUCT_SCHEMA.FACETED_BREP',
            'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM',
            'PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT_3D'] *
             TYPEOF(it)) = 1))) = 0;
   WR2 : SIZEOF (QUERY (it <* items |
          SIZEOF(['PART_204_BREP_PRODUCT_SCHEMA.FACETED_BREP',
          'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'] *
                     TYPEOF(it)) = 1)) > 0;
   WR3 : SIZEOF (QUERY (fbrep <* QUERY ( it <* items |
          'PART_204_BREP_PRODUCT_SCHEMA.FACETED_BREP'
                               IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* msb_shells(fbrep) |
   NOT (SIZEOF (QUERY (fcs <* csh\connected_face_set.cfs_faces |
          NOT (('PART_204_BREP_PRODUCT_SCHEMA.FACE_SURFACE'
                        IN TYPEOF (fcs)) AND
          (('PART_204_BREP_PRODUCT_SCHEMA.PLANE' IN TYPEOF
               (fcs\face_surface.face_geometry)) AND
          ('PART_204_BREP_PRODUCT_SCHEMA.CARTESIAN_POINT'
             IN TYPEOF (fcs\face_surface.face_geometry\
                  elementary_surface.position.location))))))
                      = 0))) = 0))) = 0;
   WR4 : SIZEOF (QUERY (fbrep <* QUERY ( it <* items |
          'PART_204_BREP_PRODUCT_SCHEMA.FACETED_BREP' IN TYPEOF(it)) |
        NOT (SIZEOF (QUERY (csh <* msb_shells(fbrep) |
        NOT (SIZEOF (QUERY (fcs <* csh\connected_face_set.cfs_faces |
        NOT (SIZEOF (QUERY (bnds <* fcs.bounds |
      'PART_204_BREP_PRODUCT_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds)))
              = 1))) = 0))) = 0))) = 0;
   WR5 : SIZEOF (QUERY (msb <* QUERY (it <* items |
          'PART_204_BREP_PRODUCT_SCHEMA.MANIFOLD_SOLID_BREP'
                          IN TYPEOF(it)) |
          'PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_CLOSED_SHELL' IN
              TYPEOF (msb\manifold_solid_brep.outer))) = 0;
   WR6 : SIZEOF (QUERY (brv <* QUERY (it <* items |
          'PART_204_BREP_PRODUCT_SCHEMA.BREP_WITH_VOIDS'
                   IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
           csh\oriented_closed_shell.orientation)) = 0))) = 0;
   WR7 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
            'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) |
  NOT ('PART_204_BREP_PRODUCT_SCHEMA.FACETED_BREP_SHAPE_REPRESENTATION'
     IN  TYPEOF(mi\mapped_item.mapping_source.
                         mapped_representation)))) = 0;
END_ENTITY;

ENTITY fill_area_style;
  name       : label;
  fill_styles : SET [1:?] OF fill_style_select;
WHERE
  WR1: SIZEOF(QUERY(fill_style <* SELF.fill_styles |
         'PART_204_BREP_PRODUCT_SCHEMA.'+
         'FILL_AREA_STYLE_COLOUR' IN
         TYPEOF(fill_style)
         )) <= 1;
END_ENTITY;

ENTITY fill_area_style_colour;
  name        : label;
  fill_colour : colour;
END_ENTITY;

ENTITY founded_item;
END_ENTITY;

ENTITY functionally_defined_transformation;
  name        : label;
  description : text;
END_ENTITY;

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF (
              POINT,
              DIRECTION,
              VECTOR,
              PLACEMENT,
              CARTESIAN_TRANSFORMATION_OPERATOR,
              CURVE,
              SURFACE,
              EDGE_CURVE,
              FACE_SURFACE,
              POLY_LOOP,
              VERTEX_POINT,
              SOLID_MODEL))
  SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) |
       NOT('PART_204_BREP_PRODUCT_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT'
             IN TYPEOF (using_rep.context_of_items)))) = 0;
END_ENTITY;

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET [1:?] OF unit;
END_ENTITY; 

ENTITY hyperbola
   SUBTYPE OF (conic);
   semi_axis      : positive_length_measure;
   semi_imag_axis : positive_length_measure;
 END_ENTITY;
 
ENTITY invisibility;
  invisible_items : SET [1:?] OF invisible_item;
END_ENTITY;

ENTITY light_source
  SUPERTYPE OF (ONEOF (
              LIGHT_SOURCE_AMBIENT,
              LIGHT_SOURCE_DIRECTIONAL,
              LIGHT_SOURCE_POSITIONAL,
              LIGHT_SOURCE_SPOT))
  SUBTYPE OF (geometric_representation_item);
  light_colour : colour;
WHERE
  WR1: SIZEOF(USEDIN(SELF,'PART_204_BREP_PRODUCT_SCHEMA.'+

                         'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;

ENTITY light_source_ambient
  SUBTYPE OF (light_source);
END_ENTITY;

ENTITY light_source_directional
  SUBTYPE OF (light_source);
  orientation : direction;
END_ENTITY;

ENTITY light_source_positional
  SUBTYPE OF (light_source);
  position             : cartesian_point;
  constant_attenuation : REAL;
  distance_attenuation : REAL;
END_ENTITY;

ENTITY light_source_spot
  SUBTYPE OF (light_source);
  position               : cartesian_point;
  orientation            : direction;
  concentration_exponent : REAL;
  constant_attenuation   : REAL;
  distance_attenuation   : REAL;
  spread_angle           : positive_plane_angle_measure;
END_ENTITY;

ENTITY line
   SUBTYPE OF (curve);
   pnt : cartesian_point;
   dir : vector;
 WHERE
   WR1: dir.dim  = pnt.dim;
 END_ENTITY;
 
ENTITY loop
   SUPERTYPE OF (ONEOF (
              VERTEX_LOOP,
              EDGE_LOOP,
              POLY_LOOP))
  SUBTYPE OF (topological_representation_item);
END_ENTITY;

ENTITY manifold_solid_brep
   SUBTYPE OF (solid_model);
   outer : closed_shell;
END_ENTITY;

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;

ENTITY measure_with_unit;
  value_component : measure_value;
  unit_component  : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;

ENTITY mechanical_context
   SUBTYPE OF (product_context);
   WHERE
     WR1 : SELF.discipline_type = 'mechanical';
 END_ENTITY;


ENTITY mechanical_design_geometric_presentation_area
  SUBTYPE OF (presentation_area);
WHERE
  WR1:  -- only presentation_views or axis2_placements in
        -- mechanical_design_geometric_presentation_area
        SIZEOF(QUERY(it1 <* SELF.items |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT'
        IN TYPEOF(it1))
        OR
        (('PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF(it1)) AND
        ('PART_204_BREP_PRODUCT_SCHEMA.PRESENTATION_VIEW'
        IN TYPEOF
   (it1\mapped_item.mapping_source.mapped_representation)))))) = 0;
  WR2: -- only mechanical_design_geometric_presentation_representation
       -- via camera_image_3d_with_scale or axis2_placements in
       -- presentation_views
        SIZEOF(QUERY(pv <* QUERY(mi1 <* QUERY(it1 <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF(it1)) |
        'PART_204_BREP_PRODUCT_SCHEMA.PRESENTATION_VIEW'
        IN TYPEOF
        (mi1\mapped_item.mapping_source.mapped_representation)) |
    -- search in all presentation_views for axis2_placements and
    -- mapped_items and for the subtype of mapped_item
    -- camera_image_3d_with_scale; the latter shall reference
    -- a mechanical_design_geometric_presentation_representation;
    -- the supertype mapped_item shall reference presentation_view.
        NOT (SIZEOF(QUERY(it2 <* pv\mapped_item.mapping_source.
        mapped_representation\representation.items |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT'
        IN TYPEOF(it2))
        OR
        (('PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF(it2)) AND NOT
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (
        'PART_204_BREP_PRODUCT_SCHEMA.PRESENTATION_VIEW'
        IN TYPEOF
        (it2\mapped_item.mapping_source.mapped_representation)))
        OR
        (('PART_204_BREP_PRODUCT_SCHEMA.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))
        AND NOT (
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION'
        IN TYPEOF
            (it2\mapped_item.mapping_source.mapped_representation) ))
        ))) = 0))) = 0;
  WR3:  (SIZEOF(QUERY(ps <* USEDIN (SELF\presentation_area,
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | ((ps.size\planar_extent.
                   size_in_x <= 0)
        OR
        (ps.size\planar_extent.size_in_y <= 0)))) = 0)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF\presentation_area,
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ((ps.size\planar_extent.size_in_x <= 0)
        OR
        (ps.size\planar_extent.size_in_y <= 0)))) > 0))) = 0);
  WR4:  (SIZEOF(QUERY(ps <* USEDIN (SELF\presentation_area,
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1)
        AND
        (SIZEOF(QUERY(ps <* USEDIN (SELF\presentation_area,
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0)
        OR
        ((SIZEOF(QUERY(ais <* USEDIN (SELF\presentation_area,
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF
                    (ps.size.placement)))) = 1))) = 1)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF\presentation_area,
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'AXIS2_PLACEMENT_3D' IN
             TYPEOF (ps.size.placement)))) = 0))) = 1));
END_ENTITY;

ENTITY mechanical_design_geometric_presentation_representation
  SUBTYPE OF (representation);
WHERE
  WR1:  SIZEOF(QUERY(it <* SELF.items |
        NOT (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM',
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM',
        'PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT',
        'PART_204_BREP_PRODUCT_SCHEMA.CAMERA_MODEL_D3']
        * TYPEOF(it)) = 1))) = 0;
  WR2:  -- only shape_representations and
  -- mechanical_design_geometric_presentation_representations
 -- shall be referenced from mapped_items
        SIZEOF(QUERY(mi <* QUERY(it <* SELF.items |
        ('PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF(it))) | NOT (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.' +
        'SHAPE_REPRESENTATION',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
    'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION']
   * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))
        = 1))) = 0;
  WR3:  -- a mapped_item that is styled shall reference a
        -- shape_representation
        SIZEOF(QUERY(smi <* QUERY(si <* QUERY(it <* SELF.items |
        ('PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it))) |
        ('PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF(si\styled_item.item))) | NOT (
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.
 item\mapped_item.mapping_source.mapped_representation))) )) = 0;
  WR4:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) | NOT
              (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(pss <* psa.styles | NOT (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.POINT_STYLE',
        'PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE',
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE']
        * TYPEOF(pss)) = 1))) = 0))) = 0))) = 0;
  WR5:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT
        (SIZEOF(QUERY(psbc <* QUERY(psa <* si\styled_item.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(psa)) |
         NOT (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.' +
        'REPRESENTATION_ITEM',
        'PART_204_BREP_PRODUCT_SCHEMA.REPRESENTATION']
        * TYPEOF(psbc\presentation_style_by_context.style_context))
        = 1))) = 0))) = 0;
  WR6:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) |
          NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ps <* QUERY(pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.POINT_STYLE'
        IN TYPEOF(pss)) | NOT
        (('PART_204_BREP_PRODUCT_SCHEMA.' +
        'POSITIVE_LENGTH_MEASURE' IN
              TYPEOF (ps\point_style.marker_size))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ps\point_style.marker_colour))
        = 1)))) = 0))) = 0))) = 0;
  WR7:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) | NOT
            (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(cs <* QUERY(pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF(pss)) | NOT((SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(cs\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'POSITIVE_LENGTH_MEASURE' IN
             TYPEOF (cs\curve_style.curve_width))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_FONT',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(cs\curve_style.curve_font)) = 1))))
                   = 0))) = 0))) = 0;
  WR8:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) | NOT
              (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) |
        NOT ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_SIDE_STYLE' IN TYPEOF
        (ssu\surface_style_usage.style)))) = 0))) = 0))) = 0;
  WR9:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) | NOT
             (SIZEOF(QUERY(psa <* si\styled_item.styles |
      NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
      'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
      IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sses <*
      ssu\surface_style_usage.style\surface_side_style.styles |
        NOT (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_PARAMETER_LINE',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_CONTROL_GRID',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_SILHOUETTE',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_FILL_AREA',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_BOUNDARY']
        * TYPEOF(sses)) = 1))) = 0))) = 0))) = 0))) = 0;
  WR10: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) | NOT
          (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sspl <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF(sses)) |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF
      (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_colour)) = 1)
        AND (
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_width))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_FONT',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
  WR11: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) | NOT
              (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sscg <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF(sses)) |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF
          (sscg\surface_style_control_grid.style_of_control_grid))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF 
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_width))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_FONT',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
  WR12: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssh <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF(sses)) |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF
          (sssh\surface_style_silhouette.style_of_silhouette))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssh\surface_style_silhouette.style_of_silhouette\curve_style.
        curve_width))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_FONT',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
  WR13: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) | NOT
            (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssc <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF(sses)) |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF
        (sssc\surface_style_segmentation_curve.
                        style_of_segmentation_curve))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_width))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_FONT',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
  WR14: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it)) | NOT
            (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(ssbd <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'SURFACE_STYLE_BOUNDARY' IN TYPEOF(sses)) |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'POSITIVE_LENGTH_MEASURE' IN
              TYPEOF (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_width))
        AND (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_FONT',
        'PART_204_BREP_PRODUCT_SCHEMA.' +

        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_font)) = 1)))) = 0)))
        = 0))) = 0))) = 0;
END_ENTITY;

ENTITY mechanical_design_shaded_presentation_area
    SUBTYPE OF (presentation_area);
  WHERE
  WR1 : (* only presentation_views or axis2_placements in
           mechanical_design_shaded_presentation_area *)
        SIZEOF (QUERY (it1 <* SELF.items |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT'
        IN TYPEOF (it1))
        OR
        (('PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF (it1)) AND
        ('PART_204_BREP_PRODUCT_SCHEMA.PRESENTATION_VIEW'
        IN TYPEOF
     (it1\mapped_item.mapping_source.mapped_representation)))))) = 0;
  WR2 : (* only mechanical_design_shaded_presentation_representation
           via camera_image_3d_with_scale or axis2_placements in 
           presentation_views *)
      SIZEOF (QUERY (pv <* QUERY (mi1 <* QUERY (it1 <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF (it1)) |
        'PART_204_BREP_PRODUCT_SCHEMA.PRESENTATION_VIEW'
        IN TYPEOF
        (mi1\mapped_item.mapping_source.mapped_representation)) |
    (* search in all presentation_views for axis2_placements and
         mapped_items and for the subtype of mapped_item,
         camera_image_3d_with_scale; the latter shall reference
         a mechanical_design_geometric_presentation_representation;
       the supertype mapped_item shall reference presentation_view. *)
        NOT (SIZEOF(QUERY(it2 <* pv\mapped_item.mapping_source.
        mapped_representation\presentation_view.items |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT'
        IN TYPEOF(it2))
        OR
        (('PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF(it2)) AND NOT
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (
        'PART_204_BREP_PRODUCT_SCHEMA.PRESENTATION_VIEW'
        IN TYPEOF
        (it2\mapped_item.mapping_source.mapped_representation)))
        OR
        (('PART_204_BREP_PRODUCT_SCHEMA.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))
        AND NOT (
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION'
        IN TYPEOF
          (it2\mapped_item.mapping_source.mapped_representation) ))
            ))) = 0))) = 0;
  WR3: (* Presentation_size shall be a positive rectangle for area and set.
           Check for this presentation_area subtype first. *)
        (SIZEOF (QUERY(ps <* USEDIN (SELF, 
        'PART_204_BREP_PRODUCT_SCHEMA.' + 
      'PRESENTATION_SIZE.UNIT') |
           NOT ((ps.size\planar_extent.size_in_x > 0)
        AND (ps.size\planar_extent.size_in_y > 0)) )) = 0)
        AND
        (* check secondly for presentation_set, via area_in_set *)
        (SIZEOF (QUERY(pset <* QUERY(ais <* 
        USEDIN (SELF, 'PART_204_BREP_PRODUCT_SCHEMA.' + 
        'AREA_IN_SET.AREA') 
        | 'PART_204_BREP_PRODUCT_SCHEMA.' +
        'PRESENTATION_SET' IN TYPEOF (ais.in_set)) |
   (* after having collected all presentation_set, check their sizes *)
        SIZEOF (QUERY(psize <* USEDIN(pset, 
        'PART_204_BREP_PRODUCT_SCHEMA.' + 
        'PRESENTATION_SIZE.UNIT')
        | NOT ((psize.size\planar_extent.size_in_x > 0) 
        AND (psize.size\planar_extent.size_in_y > 0)) )) = 0)) = 0);
  WR4:  (* Drawing space shall be defined in 2D.
           Check for this presentation_area subtype first. *)
        (SIZEOF(QUERY( psize <* USEDIN (SELF, 
        'PART_204_BREP_PRODUCT_SCHEMA.' + 
        'PRESENTATION_SIZE.UNIT') 
        | 'PART_204_BREP_PRODUCT_SCHEMA.' +
        'AXIS2_PLACEMENT_2D' 
        IN TYPEOF (psize.size.placement))) = 1)
        AND
        (* check secondly for presentation_set, via area_in_set *)
        (SIZEOF (QUERY(pset <* QUERY(ais <* 
        USEDIN (SELF, 'PART_204_BREP_PRODUCT_SCHEMA.' +
        'AREA_IN_SET.AREA')
        | 'PART_204_BREP_PRODUCT_SCHEMA.' +
        'PRESENTATION_SET' IN TYPEOF (ais.in_set)) |
    (* after having collected all presentation_set, check their
           dimension *)
        SIZEOF (QUERY(psize <* USEDIN(pset, 
        'PART_204_BREP_PRODUCT_SCHEMA.' + 
        'PRESENTATION_SIZE.UNIT')
        | NOT ('PART_204_BREP_PRODUCT_SCHEMA.' + 
        'AXIS2_PLACEMENT_2D' 
        IN TYPEOF (psize.size.placement)) )) = 0)) = 0);
  WR5 : (* valid types of camera_models
        get for all presentation_areas their presentation_views *)
      SIZEOF (QUERY (pv <* QUERY (mi1 <* QUERY (it1 <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM' 
        IN TYPEOF (it1)) |
        'PART_204_BREP_PRODUCT_SCHEMA.PRESENTATION_VIEW' 
        IN TYPEOF 
        (mi1\mapped_item.mapping_source.mapped_representation)) |
       (* search in all presentation_views for
          mapped_items and for the subtype of mapped_item,
          camera_image_3d_with_scale; the latter shall reference
          a camera_usage that shall have as its mapping_origin either
          camera_model_d3, camera_model_d3_with_hlhsr, or
          camera_model_with_light_sources. *)
        NOT (SIZEOF(QUERY(ci <* pv\mapped_item.mapping_source.
        mapped_representation\presentation_view.items |
        ('PART_204_BREP_PRODUCT_SCHEMA.'+
         'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(ci))
        AND
        (SIZEOF(['PART_204_BREP_PRODUCT_SCHEMA.'+
        'CAMERA_MODEL_D3',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'CAMERA_MODEL_D3_WITH_HLHSR',
        'PART_204_BREP_PRODUCT_SCHEMA.'+

        'CAMERA_MODEL_WITH_LIGHT_SOURCES'] * TYPEOF
     (ci\camera_image_3d_with_scale.mapping_source.mapping_origin))
        = 1))) = 0))) = 0;
END_ENTITY; (* mechanical_design_shaded_presentation_area *)

ENTITY mechanical_design_shaded_presentation_representation
   SUBTYPE OF (representation);
WHERE
  WR1:  SIZEOF(QUERY(it <* SELF.items |
        NOT (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM',
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM',
        'PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT',
        'PART_204_BREP_PRODUCT_SCHEMA.CAMERA_MODEL_D3']
        * TYPEOF(it)) = 1))) = 0;
  WR2:  (* for all mapped_items check that only
           shape_representations and
           mechanical_design_shaded_presentation_representations
           are referenced *)
        SIZEOF(QUERY(mi <* QUERY(it <* SELF.items |
        ('PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF(it))) | NOT (SIZEOF(
        ['PART_204_BREP_PRODUCT_SCHEMA.' +
        'SHAPE_REPRESENTATION',
        'PART_204_BREP_PRODUCT_SCHEMA.' +
        'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION']
      * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))
        = 1))) = 0;
  WR3:  (* for all styled_item.item check that in case they are
           mapped_items that they are shape_representations *)
        SIZEOF(QUERY(smi <* QUERY(si <* QUERY(it <* SELF.items |
        ('PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF(it))) |
        ('PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM'
        IN TYPEOF(si\styled_item.item))) | NOT (
        ('PART_204_BREP_PRODUCT_SCHEMA.' +
        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.
     item\mapped_item.mapping_source.mapped_representation))) )) = 0;
  WR4 : (* for all styled_items get their styles via
           presentation_style_assignment.styles and check for valid
           style types *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (pss <* psa.styles |
        NOT (SIZEOF (
        ['PART_204_BREP_PRODUCT_SCHEMA.POINT_STYLE',
        'PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE',
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE']
        *  TYPEOF (pss)) = 1))) = 0))) = 0))) = 0;
  WR5 : (* for all styled_items get those assigned styles that 
           are presentation_style_by_contexts and ensure that
           these reference only representation_items and 
           representations as valid contexts *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psbc <*
              QUERY (psa <* si\styled_item.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF (psa))  |
        NOT (SIZEOF (
        ['PART_204_BREP_PRODUCT_SCHEMA.REPRESENTATION_ITEM',
        'PART_204_BREP_PRODUCT_SCHEMA.REPRESENTATION']
        * TYPEOF
        (psbc\presentation_style_by_context.style_context)) = 1)))
             = 0))) = 0;
  WR6 : (* for all styled_items get all assigned point_styles  
           and ensure that marker_select, marker_size and
           marker_colour are valid *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ps <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.POINT_STYLE'
        IN TYPEOF (pss)) |
        NOT (
        ('PART_204_BREP_PRODUCT_SCHEMA.MARKER_TYPE'
        IN TYPEOF (ps\point_style.marker))
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.POSITIVE_LENGTH_MEASURE'
         IN TYPEOF(ps\point_style.marker_size))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ps\point_style.marker_colour)) = 1)))) = 0))) = 0))) = 0;
  WR7 : (* for all styled_items get all assigned curve_styles  
           and ensure that curve_width, curve_font and
           curve_colour are valid *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (cs <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF (pss)) |
        NOT (
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (cs\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.POSITIVE_LENGTH_MEASURE'
          IN TYPEOF(cs\curve_style.curve_width))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.'+
        'CURVE_STYLE_FONT', 'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (cs\curve_style.curve_font)) = 1)))) = 0))) = 0))) = 0;
  WR8 : (* for all styled_items get all assigned surface_style_usages
           and ensure that its style is a surface_side_style *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT ('PART_204_BREP_PRODUCT_SCHEMA.SURFACE_SIDE_STYLE'
     IN TYPEOF (ssu\surface_style_usage.style)) )) = 0))) = 0 ))) = 0;
  WR9 : (* for all styled_items get all assigned surface_style_usages
           and the surface_side_styles that they reference, and ensure
           that the styles referenced by those surface_side_styles
           are among the valid subset *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        NOT (SIZEOF (
        ['PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_PARAMETER_LINE',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_CONTROL_GRID',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_SILHOUETTE',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_SEGMENTATION_CURVE',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_BOUNDARY',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_FILL_AREA',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_RENDERING'] * TYPEOF (sses)) = 1)))
            = 0))) = 0))) = 0))) = 0;
  WR10: (* for all surface_style_fill_areas that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to their colour representation *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (ssfa <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_FILL_AREA'
        IN TYPEOF (sses)) |
        NOT (SIZEOF (QUERY (fss <*
        ssfa\surface_style_fill_area.fill_area.fill_styles |
        NOT (('PART_204_BREP_PRODUCT_SCHEMA.'+
        'FILL_AREA_STYLE_COLOUR' IN TYPEOF (fss))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (fss\fill_area_style_colour.fill_colour)) = 1))))
           = 0))) = 0)))  = 0))) = 0))) = 0;
  WR11: (* for all surface_style_parameter_lines that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sspl <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF (sses)) |
        NOT ((
        ('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF
         (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN
        TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_width))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.'+
        'CURVE_STYLE_FONT', 'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_font)) = 1))
        OR (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_RENDERING'
        IN TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines\
         curve_style_rendering.rendering_properties.rendered_colour))
             = 1))) )) = 0))) = 0))) = 0))) = 0;
  WR12: (* for all surface_style_control_grids that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sscg <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF (sses)) |
        NOT ((
        ('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF
            (sscg\surface_style_control_grid.style_of_control_grid))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN
        TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_width))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.'+
        'CURVE_STYLE_FONT', 'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_font)) = 1))
        OR (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_RENDERING'
        IN TYPEOF
        (sscg\surface_style_control_grid.style_of_control_grid))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sscg\surface_style_control_grid.style_of_control_grid\
        curve_style_rendering.rendering_properties.rendered_colour))
         = 1))) )) = 0))) = 0))) = 0))) = 0;
  WR13: (* for all surface_style_silhouettes that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sssh <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF (sses)) |
        NOT ((
        ('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_width))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.'+
        'CURVE_STYLE_FONT', 'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_font)) = 1)) 
        OR (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_RENDERING'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssh\surface_style_silhouette.style_of_silhouette\
        curve_style_rendering.rendering_properties.rendered_colour))
         = 1))) )) = 0))) = 0))) = 0))) = 0;
  WR14: (* for all surface_style_segmentation_curves that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sssc <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF (sses)) |
        NOT ((
        ('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF
        (sssc\surface_style_segmentation_curve.
          style_of_segmentation_curve))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN
        TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_width))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.'+
        'CURVE_STYLE_FONT', 'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_font)) = 1)) 
        OR (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_RENDERING'
        IN TYPEOF (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
     (sssc\surface_style_segmentation_curve.style_of_segmentation_curve\
        curve_style_rendering.rendering_properties.rendered_colour))
         = 1))) ))  = 0))) = 0))) = 0))) = 0;
  WR15: (* for all surface_style_boundaries that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (ssbd <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_BOUNDARY' IN TYPEOF (sses)) |
        NOT ((
        ('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_colour)) = 1)
        AND
        ('PART_204_BREP_PRODUCT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN
        TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_width))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.'+
        'CURVE_STYLE_FONT', 'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_font)) = 1)) 
        OR (('PART_204_BREP_PRODUCT_SCHEMA.CURVE_STYLE_RENDERING'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND
        (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ssbd\surface_style_boundary.
        style_of_boundary\curve_style_rendering.
         rendering_properties.rendered_colour)) = 1))) ))
        = 0))) = 0))) = 0))) = 0;
  WR16: (* for all surface_style_renderings that are referenced by
           any surface_side_styles ensure that the colour
           representation is valid *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (ssre <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'PART_204_BREP_PRODUCT_SCHEMA.'+
        'SURFACE_STYLE_RENDERING' IN TYPEOF (sses)) |
        NOT (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.COLOUR_RGB',
        'PART_204_BREP_PRODUCT_SCHEMA.'+
         'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ssre\surface_style_rendering.surface_colour)) = 1)))
        = 0))) = 0))) = 0))) = 0;
END_ENTITY;

ENTITY named_unit
  SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY open_shell
   SUBTYPE OF (connected_face_set);
END_ENTITY;

END_ENTITY;
 ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
   closed_shell_element : closed_shell;
   orientation          : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                 := conditional_reverse(SELF.orientation,
                                     SELF.closed_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_CLOSED_SHELL' 
                IN TYPEOF (SELF.closed_shell_element));
END_ENTITY;

ENTITY oriented_edge
   SUBTYPE OF (edge);
   edge_element : edge;
   orientation  : BOOLEAN;
 DERIVE
   SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                                       SELF.edge_element.edge_start,
                                         SELF.edge_element.edge_end);
   SELF\edge.edge_end   : vertex := boolean_choose (SELF.orientation,
                                           SELF.edge_element.edge_end,
                                         SELF.edge_element.edge_start);
 WHERE
   WR1: NOT ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_EDGE' IN
                                    TYPEOF (SELF.edge_element));
END_ENTITY;

ENTITY oriented_face
   SUBTYPE OF (face);
   face_element : face;
   orientation  : BOOLEAN;
 DERIVE
   SELF\face.bounds : SET[1:?] OF face_bound
          := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
 WHERE
   WR1: NOT ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_FACE'
                              IN TYPEOF (SELF.face_element));
END_ENTITY;

ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
   open_shell_element : open_shell;
   orientation        : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                 := conditional_reverse(SELF.orientation,
                                       SELF.open_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_OPEN_SHELL' 
                IN TYPEOF (SELF.open_shell_element));
END_ENTITY;

ENTITY oriented_path
   SUBTYPE OF (path);
   path_element : path;
   orientation  : BOOLEAN;
 DERIVE
   SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge
                           := conditional_reverse(SELF.orientation,
                                         SELF.path_element.edge_list);
 WHERE
   WR1: NOT ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_PATH' IN
      TYPEOF (SELF.path_element));
END_ENTITY;

ENTITY over_riding_styled_item
  SUBTYPE OF (styled_item);
  over_ridden_style : styled_item;
END_ENTITY;

ENTITY parabola
   SUBTYPE OF (conic);
   focal_dist : length_measure;
 WHERE
   WR1: focal_dist <> 0.0;
 END_ENTITY;
 
ENTITY parametric_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY path
   SUPERTYPE OF (ONEOF (
              EDGE_LOOP,
              ORIENTED_PATH))
  SUBTYPE OF (topological_representation_item);
   edge_list  : LIST [1:?] OF UNIQUE oriented_edge;
 WHERE
   WR1: path_head_to_tail(SELF);
END_ENTITY;

ENTITY pcurve
   SUBTYPE OF (curve);
   basis_surface      : surface;
   reference_to_curve : definitional_representation;
 WHERE
   WR1: SIZEOF(reference_to_curve\representation.items) = 1;
   WR2: 'PART_204_BREP_PRODUCT_SCHEMA.CURVE' IN TYPEOF

                    (reference_to_curve\representation.items[1]);
   WR3: reference_to_curve\representation.
                   items[1]\geometric_representation_item.dim =2;
 END_ENTITY;
 
ENTITY placement
   SUPERTYPE OF (ONEOF (
              AXIS1_PLACEMENT,
              AXIS2_PLACEMENT_2D,
              AXIS2_PLACEMENT_3D))
  SUBTYPE OF (geometric_representation_item);
   location : cartesian_point;
END_ENTITY;

ENTITY planar_box
  SUBTYPE OF (planar_extent);
  placement:  axis2_placement;
END_ENTITY;

ENTITY planar_extent
  SUBTYPE OF (geometric_representation_item);
   size_in_x : length_measure;
   size_in_y : length_measure;
END_ENTITY;

ENTITY plane
 SUBTYPE OF (elementary_surface);
 END_ENTITY;
 
ENTITY point
   SUPERTYPE OF (ONEOF (
              CARTESIAN_POINT))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY point_style;
  name          : label;
  marker        : marker_select;
  marker_size   : size_select;
  marker_colour : colour;
END_ENTITY;

ENTITY polyline
   SUBTYPE OF (bounded_curve);
   points : LIST [2:?] OF cartesian_point;
 END_ENTITY;
 
ENTITY poly_loop
   SUBTYPE OF (loop,geometric_representation_item);
   polygon : LIST [3:?] OF UNIQUE cartesian_point;
END_ENTITY;

ENTITY pre_defined_colour
  SUBTYPE OF (pre_defined_item, colour);
END_ENTITY;

ENTITY pre_defined_curve_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_item;
  name : label;
END_ENTITY;

ENTITY presentation_area
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: ((SIZEOF (QUERY (ais <*
       USEDIN (SELF, 'PART_204_BREP_PRODUCT_SCHEMA.' +
                                          'AREA_IN_SET.AREA') |
           SIZEOF (USEDIN (ais, 'PART_204_BREP_PRODUCT_SCHEMA.' +
                             'PRESENTATION_SIZE.UNIT')) =1)) > 0) OR
         (SIZEOF (USEDIN (SELF, 'PART_204_BREP_PRODUCT_SCHEMA.' +
                                    'PRESENTATION_SIZE.UNIT')) =1));
END_ENTITY;

ENTITY presentation_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SELF\representation.
            context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: 'PART_204_BREP_PRODUCT_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT'
       IN TYPEOF (SELF\representation.context_of_items);
END_ENTITY;

ENTITY presentation_set;
INVERSE
  areas : SET [1:?] OF area_in_set FOR in_set;
END_ENTITY;

ENTITY presentation_size;
  unit : presentation_size_assignment_select;
  size : planar_box;
WHERE
  WR1: (('PART_204_BREP_PRODUCT_SCHEMA.PRESENTATION_REPRESENTATION'
         IN TYPEOF (SELF.unit)) AND
         item_in_context (SELF.size, 
                          SELF.unit\representation.context_of_items)
       )
            OR
       (
        ('PART_204_BREP_PRODUCT_SCHEMA.AREA_IN_SET'

          IN TYPEOF (SELF.unit)) AND
     (SIZEOF (QUERY ( ais <* SELF.unit\area_in_set.in_set.areas |
             NOT item_in_context (SELF.size, ais.area\representation.
                                           context_of_items) )) = 0)
       ); 
END_ENTITY;

ENTITY presentation_style_assignment;
  styles : SET [1:?] OF presentation_style_select;
WHERE
  WR1: SIZEOF (QUERY (style1 <* SELF.styles |
         NOT (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           NOT ((TYPEOF (style1) <> TYPEOF (style2)) OR
             (SIZEOF (['PART_204_BREP_PRODUCT_SCHEMA.' +
                       'SURFACE_STYLE_USAGE',
                       'PART_204_BREP_PRODUCT_SCHEMA.'+
                       'EXTERNALLY_DEFINED_STYLE'] *
                     TYPEOF (style1)) = 1)
           ))) = 0
         ))) = 0;
  WR2: SIZEOF (QUERY (style1 <* SELF.styles |
         'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_STYLE_USAGE' IN

         TYPEOF(style1)
         )) <= 2;
END_ENTITY;

ENTITY presentation_style_by_context
  SUBTYPE OF (presentation_style_assignment);
  style_context : style_context_select;
END_ENTITY;

ENTITY presentation_view
  SUBTYPE OF (presentation_representation);
END_ENTITY;

ENTITY product;
  id                 : identifier; 
  name               : label; 
  description        : text; 
  frame_of_reference : SET [1:?] OF product_context;
UNIQUE
  UR1: id;
END_ENTITY; 

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

ENTITY product_definition;
  id                 : identifier; 
  description        : text; 
  formation          : product_definition_formation; 
  frame_of_reference : product_definition_context; 
END_ENTITY; 

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;

ENTITY product_definition_formation; 
  id          : identifier; 
  description : text; 
  of_product  : product; 
UNIQUE
  UR1: id, of_product;
END_ENTITY; 

ENTITY product_definition_relationship; 
  id                          : identifier;
  name                        : label;
  description                 : text;
  relating_product_definition : product_definition; 
  related_product_definition  : product_definition; 
END_ENTITY; 

ENTITY product_definition_shape
 SUBTYPE OF (property_definition);
UNIQUE
 UR1:  SELF\property_definition.definition;
WHERE
 WR1:  NOT ('PART_204_BREP_PRODUCT_SCHEMA.SHAPE_DEFINITION'

       IN TYPEOF (SELF\property_definition.definition));
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (
              ASSEMBLY_COMPONENT_USAGE))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
        [SELF\product_definition_relationship.related_product_definition],
         'PART_204_BREP_PRODUCT_SCHEMA.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY property_definition;
  name        : label;
  description : text;
  definition  : characterized_definition;
END_ENTITY;

ENTITY property_definition_representation;
  definition          : property_definition;
  used_representation : representation;
END_ENTITY;

ENTITY quasi_uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;
 
ENTITY quasi_uniform_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;
 
ENTITY rational_b_spline_curve
   SUBTYPE OF (b_spline_curve);
   weights_data : LIST [2:?] OF REAL;
 DERIVE
   weights           : ARRAY [0:upper_index_on_control_points] OF REAL
                                  := list_to_array(weights_data,0,
                                         upper_index_on_control_points);
 WHERE
   WR1:  SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
                                            control_points_list);
   WR2:  curve_weights_positive(SELF);
 END_ENTITY;

ENTITY rational_b_spline_surface
   SUBTYPE OF (b_spline_surface);
   weights_data : LIST [2:?] OF
                    LIST [2:?] OF REAL;
 DERIVE
   weights       : ARRAY [0:u_upper] OF
                      ARRAY [0:v_upper] OF REAL
                 := make_array_of_array(weights_data,0,u_upper,0,v_upper);
 WHERE
   WR1: (SIZEOF(weights_data) =
                     SIZEOF(SELF\b_spline_surface.control_points_list))
           AND (SIZEOF(weights_data[1]) =
                     SIZEOF(SELF\b_spline_surface.control_points_list[1]));
   WR2: surface_weights_positive(SELF);
 END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;

ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET[1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY;

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('PART_204_BREP_PRODUCT_SCHEMA.SHAPE_DEFINITION' IN
       TYPEOF (SELF.definition.definition))
       OR
       ('PART_204_BREP_PRODUCT_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
       TYPEOF (SELF.definition)); 
  WR2: 'PART_204_BREP_PRODUCT_SCHEMA.SHAPE_REPRESENTATION' IN

       TYPEOF(SELF.used_representation);
END_ENTITY;

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix     : OPTIONAL si_prefix;
  name       : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents 
                             := dimensions_for_si_unit (SELF.name);
END_ENTITY;

ENTITY solid_model
   SUPERTYPE OF (ONEOF (
              MANIFOLD_SOLID_BREP))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY spherical_surface
   SUBTYPE OF (elementary_surface);
   radius   : positive_length_measure;
END_ENTITY;

ENTITY styled_item
  SUBTYPE OF (representation_item);
  styles :  SET [1:?] OF presentation_style_assignment;
  item   :  representation_item;
WHERE
  WR1: (SIZEOF(SELF.styles) = 1)
               XOR
       (SIZEOF(QUERY(pres_style <* SELF.styles |
         NOT ('PART_204_BREP_PRODUCT_SCHEMA.' +

              'PRESENTATION_STYLE_BY_CONTEXT' IN
         TYPEOF(pres_style))
         )) = 0);
END_ENTITY;

ENTITY surface
   SUPERTYPE OF (ONEOF (
              ELEMENTARY_SURFACE,
              SWEPT_SURFACE,
              BOUNDED_SURFACE))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY surface_curve
  SUBTYPE OF (curve);
   curve_3d              : curve;
   associated_geometry   : LIST[1:2] OF pcurve_or_surface;
   master_representation : preferred_surface_curve_representation;
 DERIVE
   basis_surface         : SET[1:2] OF surface
                         := get_basis_surface(SELF);
 WHERE
   WR1: curve_3d.dim = 3;
   WR2: ('PART_204_BREP_PRODUCT_SCHEMA.PCURVE' IN
        TYPEOF(associated_geometry[1])) OR
                        (master_representation <> pcurve_s1);
   WR3: ('PART_204_BREP_PRODUCT_SCHEMA.PCURVE' IN
                   TYPEOF(associated_geometry[2])) OR
                        (master_representation <> pcurve_s2);
   WR4: NOT ('PART_204_BREP_PRODUCT_SCHEMA.PCURVE' IN TYPEOF(curve_3d));

END_ENTITY;

ENTITY surface_of_linear_extrusion
   SUBTYPE OF (swept_surface);
   extrusion_axis      : vector;
END_ENTITY;

ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
  axis_position       : axis1_placement;
DERIVE
  axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis_position.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis_position.z, 1.0));
END_ENTITY;

ENTITY surface_rendering_properties;
  rendered_colour : colour;
END_ENTITY;

ENTITY surface_side_style;
  name   : label;
  styles : SET [1:7] OF surface_style_element_select;
WHERE
  WR1: SIZEOF(QUERY( style1 <* SELF.styles |
         SIZEOF(QUERY( style2 <* SELF.styles - style1 |
           TYPEOF(style1) = TYPEOF(style2)
           )) > 0
         )) = 0;
END_ENTITY;

ENTITY surface_style_boundary;
  style_of_boundary : curve_or_render;
END_ENTITY;

ENTITY surface_style_control_grid;
  style_of_control_grid : curve_or_render;
END_ENTITY;

ENTITY surface_style_fill_area;
  fill_area : fill_area_style;
END_ENTITY;

ENTITY surface_style_parameter_line;
  style_of_parameter_lines : curve_or_render;
  direction_counts         : SET [1:2] OF direction_count_select;
WHERE
  WR1: (HIINDEX(SELF.direction_counts) = 1)
                        XOR
       (TYPEOF(SELF.direction_counts[1]) <>
          TYPEOF(SELF.direction_counts[2]));
END_ENTITY;

ENTITY surface_style_reflectance_ambient;
  ambient_reflectance : REAL;
END_ENTITY;

ENTITY surface_style_reflectance_ambient_diffuse
  SUBTYPE OF (surface_style_reflectance_ambient);
  diffuse_reflectance : REAL;
END_ENTITY;

ENTITY surface_style_reflectance_ambient_diffuse_specular
  SUBTYPE OF (surface_style_reflectance_ambient_diffuse);
  specular_reflectance : REAL;
  specular_exponent    : REAL;
  specular_colour      : colour;
END_ENTITY;

ENTITY surface_style_rendering;
  rendering_method : shading_surface_method;
  surface_colour   : colour;
END_ENTITY;

ENTITY surface_style_rendering_with_properties
  SUBTYPE OF (surface_style_rendering);
  properties : SET [1:2] OF rendering_properties_select;
WHERE
  WR1: (HIINDEX(SELF.properties) = 1)
                   XOR
       (TYPEOF(SELF.properties[1]) <> TYPEOF(SELF.properties[2]));
END_ENTITY;

ENTITY surface_style_segmentation_curve;
  style_of_segmentation_curve : curve_or_render;
END_ENTITY;

ENTITY surface_style_silhouette;
  style_of_silhouette : curve_or_render;
END_ENTITY;

ENTITY surface_style_transparent;
  transparency : REAL;
WHERE
  WR1: {0.0 <= transparency <= 1.0};
END_ENTITY;

ENTITY surface_style_usage;
  side  : surface_side;
  style : surface_side_style_select;
END_ENTITY;

ENTITY swept_surface
   SUPERTYPE OF (ONEOF (
              SURFACE_OF_LINEAR_EXTRUSION,
              SURFACE_OF_REVOLUTION))
  SUBTYPE OF (surface);
   swept_curve : curve;
 END_ENTITY;
 
ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF (
              VERTEX,
              EDGE,
              FACE_BOUND,
              FACE,
              CONNECTED_FACE_SET,(
              LOOP
              ANDOR 
              PATH)))
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY toroidal_surface
   SUBTYPE OF (elementary_surface);
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
END_ENTITY;

ENTITY uniform_curve
   SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY uniform_surface
   SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY vector
   SUBTYPE OF (geometric_representation_item);
   orientation : direction;
   magnitude   : length_measure;
 WHERE
   WR1 : magnitude >= 0.0;
END_ENTITY;

ENTITY vertex
   SUBTYPE OF (topological_representation_item);
END_ENTITY;

ENTITY vertex_loop
   SUBTYPE OF (loop);
   loop_vertex : vertex;
END_ENTITY;

ENTITY vertex_point
    SUBTYPE OF(vertex,geometric_representation_item);
      vertex_geometry : point;
END_ENTITY;

ENTITY view_volume
  SUBTYPE OF (founded_item);
  projection_type            : central_or_parallel;
  projection_point           : cartesian_point;
  view_plane_distance        : length_measure;
  front_plane_distance       : length_measure;
  front_plane_clipping       : BOOLEAN;
  back_plane_distance        : length_measure;
  back_plane_clipping        : BOOLEAN;
  view_volume_sides_clipping : BOOLEAN;
  view_window                : planar_box;
END_ENTITY;

RULE advanced_or_elementary_or_faceted FOR(shape_representation);
WHERE
   WR1: SIZEOF (QUERY (sr <* shape_representation |
                NOT( SIZEOF(
  ['PART_204_BREP_PRODUCT_SCHEMA.ADVANCED_BREP_SHAPE_REPRESENTATION',
   'PART_204_BREP_PRODUCT_SCHEMA.ELEMENTARY_BREP_SHAPE_REPRESENTATION',
    'PART_204_BREP_PRODUCT_SCHEMA.FACETED_BREP_SHAPE_REPRESENTATION']
           * TYPEOF (sr)) =1 ))) = 0;
END_RULE;

RULE compatible_dimension FOR 
  (cartesian_point,
  direction,
  representation_context,
  geometric_representation_context);
WHERE

  -- ensure that the count of coordinates of each cartesian_point
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR1: SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;

  -- ensure that the count of direction_ratios of each direction
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR2: SIZEOF(QUERY(x <* direction | SIZEOF( QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)))
       > 0 )) = 0;
END_RULE;

RULE dependent_instantiation_of_geometry FOR
                          (geometric_representation_item);
   WHERE
      WR1 : SIZEOF ( QUERY (gri <* geometric_representation_item |
                 NOT (SIZEOF (USEDIN (gri,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_mapped_item FOR (mapped_item);
   WHERE
      WR1 : SIZEOF ( QUERY (mi <* mapped_item |
                 NOT (SIZEOF (USEDIN (mi,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_mechanical_design_geometric_p_r
   FOR (mechanical_design_geometric_presentation_representation);
WHERE
  WR1 : SIZEOF ( QUERY (mdpr <*
        mechanical_design_geometric_presentation_representation |
        NOT (SIZEOF (USEDIN (mdpr,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_mechanical_design_shaded_p_r
   FOR (mechanical_design_shaded_presentation_representation);
WHERE
  WR1 : SIZEOF ( QUERY (mdpr <*
        mechanical_design_shaded_presentation_representation |
        NOT (SIZEOF (USEDIN (mdpr,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_named_unit FOR (named_unit);
   WHERE
      WR1 : SIZEOF ( QUERY (nmu <* named_unit |
                 NOT (SIZEOF (USEDIN (nmu,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_pre_defined_item FOR
                   (pre_defined_item);
   WHERE
      WR1 : SIZEOF ( QUERY (pdi <* pre_defined_item |
                 NOT (SIZEOF (USEDIN (pdi,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_presentation_style FOR
                   (presentation_style_assignment);
   WHERE
      WR1 : SIZEOF ( QUERY (psa <* presentation_style_assignment |
                 NOT (SIZEOF (USEDIN (psa,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_product_context FOR (product_context);
WHERE
  WR1 : SIZEOF ( QUERY (pc <* product_context |
        NOT (SIZEOF (USEDIN (pc,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_product_definition
                              FOR (product_definition);
WHERE
  WR1 : SIZEOF ( QUERY (pd <* product_definition |
        NOT (SIZEOF (USEDIN (pd,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_product_definition_context FOR 
     (product_definition_context);
WHERE
  WR1 : SIZEOF ( QUERY (pdc <* product_definition_context |
        NOT (SIZEOF (USEDIN (pdc,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_product_definition_formation
             FOR (product_definition_formation);
WHERE
  WR1 : SIZEOF ( QUERY (pdf <* product_definition_formation |
-- old        NOT (SIZEOF (USEDIN (pv,'')) > 0 ))) = 0;
-- new JH:
        NOT (SIZEOF (USEDIN (pdf,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_product_definition_relationship FOR 
     (product_definition_relationship);
WHERE
  WR1 : SIZEOF ( QUERY (pdr <* product_definition_relationship |
        NOT (SIZEOF (USEDIN (pdr,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_shape_representation
                               FOR (shape_representation);
WHERE
  WR1 : SIZEOF ( QUERY (sr <* shape_representation |
        NOT (SIZEOF (USEDIN (sr,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_styled_item FOR (styled_item);
   WHERE
      WR1 : SIZEOF ( QUERY (si <* styled_item |
                 NOT (SIZEOF (USEDIN (si,'')) > 0 ))) = 0;
END_RULE;

RULE dependent_instantiation_of_topology
             FOR (topological_representation_item);
   WHERE
      WR1 : SIZEOF ( QUERY (tri <* topological_representation_item |
                 NOT (SIZEOF (USEDIN (tri,'')) > 0 ))) = 0;
END_RULE;

RULE global_units_in_geometric_representation_context FOR 
      (geometric_representation_context);
WHERE
  WR1 :  SIZEOF (QUERY (grc <* geometric_representation_context |
         NOT ('PART_204_BREP_PRODUCT_SCHEMA.' +
         'GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF (grc)))) = 0 ;
END_RULE;

RULE global_units_required FOR (global_unit_assigned_context);
   WHERE
      WR1 : SIZEOF ( QUERY (guac <* global_unit_assigned_context |
                 NOT (SIZEOF (guac.units) <= 2))) = 0;
      WR2 : SIZEOF ( QUERY (guac <* global_unit_assigned_context |
                 NOT (SIZEOF (QUERY( u <* guac.units |
                   'PART_204_BREP_PRODUCT_SCHEMA.LENGTH_UNIT' IN TYPEOF
                   (u))) =1 ))) = 0;
      WR3:  SIZEOF ( QUERY (guac <* global_unit_assigned_context |
                 NOT (SIZEOF (QUERY( u <* guac.units |
         NOT (( 'PART_204_BREP_PRODUCT_SCHEMA.LENGTH_UNIT' IN TYPEOF(u))
                 OR ( 'PART_204_BREP_PRODUCT_SCHEMA.PLANE_ANGLE_UNIT' IN

                       TYPEOF (u))))) = 0))) = 0;
END_RULE;

RULE illegal_complex_named_units FOR (named_unit);
WHERE
  WR1: SIZEOF (QUERY (nu <* named_unit |
       NOT (SIZEOF (TYPEOF(nu) *
       ['PART_204_BREP_PRODUCT_SCHEMA.LENGTH_UNIT',
        'PART_204_BREP_PRODUCT_SCHEMA.PLANE_ANGLE_UNIT']) < 2 )
       AND
       NOT (SIZEOF (TYPEOF(nu) *
       ['PART_204_BREP_PRODUCT_SCHEMA.LENGTH_UNIT',
        'PART_204_BREP_PRODUCT_SCHEMA.CONVERSION_BASED_UNIT']) < 2 )

       )) = 0;
END_RULE;

RULE no_complex_subtypes FOR(geometric_representation_item);
   WHERE
    WR1: SIZEOF (QUERY (gri <* geometric_representation_item |
    NOT (SIZEOF (TYPEOF(gri) *
             ['PART_204_BREP_PRODUCT_SCHEMA.CAMERA_IMAGE',
              'PART_204_BREP_PRODUCT_SCHEMA.CAMERA_MODEL',
   'PART_204_BREP_PRODUCT_SCHEMA.CARTESIAN_TRANSFORMATION_OPERATOR',
               'PART_204_BREP_PRODUCT_SCHEMA.CURVE',
                'PART_204_BREP_PRODUCT_SCHEMA.DIRECTION',
           'PART_204_BREP_PRODUCT_SCHEMA.EDGE_CURVE',
           'PART_204_BREP_PRODUCT_SCHEMA.FACE_SURFACE',
            'PART_204_BREP_PRODUCT_SCHEMA.PLACEMENT',
             'PART_204_BREP_PRODUCT_SCHEMA.POINT',
           'PART_204_BREP_PRODUCT_SCHEMA.POLY_LOOP',
             'PART_204_BREP_PRODUCT_SCHEMA.SOLID_MODEL',
              'PART_204_BREP_PRODUCT_SCHEMA.SURFACE',
               'PART_204_BREP_PRODUCT_SCHEMA.VECTOR',
           'PART_204_BREP_PRODUCT_SCHEMA.VERTEX_POINT']) < 2 ))) = 0;
END_RULE;

RULE product_context_mechanical FOR (product_context);
   WHERE
      WR1 : SIZEOF ( QUERY (pc <* product_context |
               NOT ('PART_204_BREP_PRODUCT_SCHEMA.MECHANICAL_CONTEXT'
            IN TYPEOF(pc)))) = 0;
END_RULE;

RULE product_definition_context_design FOR (product_definition_context);
   WHERE
      WR1 : SIZEOF ( QUERY (pdc <* product_definition_context |
                 NOT ('PART_204_BREP_PRODUCT_SCHEMA.DESIGN_CONTEXT'

                   IN TYPEOF(pdc)))) = 0;
END_RULE;

RULE shape_representation_required FOR (product_definition_shape);
   WHERE
      WR1 : SIZEOF ( QUERY (pds <* product_definition_shape |
              NOT ( SIZEOF(USEDIN
            (pds,'PART_204_BREP_PRODUCT_SCHEMA.'+
                 'SHAPE_DEFINITION_REPRESENTATION.DEFINITION')) > 0
                 ))) = 0;
END_RULE;  -- shape_representation_required


RULE single_curve_style FOR (curve);
   WHERE
      WR1 : SIZEOF ( QUERY (crv <* curve |
                 SIZEOF(USEDIN
            (crv,'PART_204_BREP_PRODUCT_SCHEMA.STYLED_ITEM.ITEM')) > 1
                 )) = 0;
END_RULE;  -- single_curve_style

RULE three_dimensional_geometry FOR(geometric_representation_item);
   WHERE
    WR1: SIZEOF(QUERY(gri <* geometric_representation_item |
         (dimension_of(gri) = 2) AND NOT ( (SIZEOF (
            ['PART_204_BREP_PRODUCT_SCHEMA.PLANAR_BOX',
            'PART_204_BREP_PRODUCT_SCHEMA.AXIS2_PLACEMENT_2D'] *
              TYPEOF(gri)) = 1 )
              OR
              (SIZEOF(QUERY(rep <* using_representations(gri) |
              'PART_204_BREP_PRODUCT_SCHEMA.DEFINITIONAL_REPRESENTATION'

           IN TYPEOF(rep) )) > 0 )
              ))) = 0;
 END_RULE;

FUNCTION acyclic_mapped_representation
  (parent_set   : SET OF representation;
   children_set : SET OF representation_item) : BOOLEAN;
  LOCAL
    x,y : SET OF representation_item;
    i   : INTEGER;
  END_LOCAL;
  -- Determine the subset of children_set that are mapped_items.
  x := QUERY(z <* children_set |
      'PART_204_BREP_PRODUCT_SCHEMA.MAPPED_ITEM' IN TYPEOF(z));
  -- Determine that the subset has elements.
  IF SIZEOF(x) > 0 THEN
    -- Check each element of the set.
    REPEAT i := 1 TO HIINDEX(x);
      -- If the selected element maps a representation in the
      --  parent_set, then return false.
      IF x[i]\mapped_item.mapping_source.mapped_representation
        IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      -- Recursive check of the items of mapped_rep.
      IF NOT acyclic_mapped_representation
        (parent_set + x[i]\mapped_item.mapping_source.
            mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.
                                       items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Determine the subset of children_set that are not
  -- mapped_items.
  x := children_set - x;
  -- Determine that the subset has elements.
  IF SIZEOF(x) > 0 THEN
    -- For each element of the set:
    REPEAT i := 1 TO HIINDEX(x);
      -- Determine the set of representation_items referenced.
      y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
           'PART_204_BREP_PRODUCT_SCHEMA.REPRESENTATION_ITEM'
               IN TYPEOF(z));
      -- Recursively check for an offending mapped_item.
      -- Return false for any errors encountered.
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return true when all elements are checked and
  -- no error conditions found.
  RETURN (TRUE);
END_FUNCTION;

FUNCTION acyclic_product_definition_relationship
  (relation          : product_definition_relationship;
   relatives         : SET [1:?] OF product_definition;
   specific_relation : STRING) : LOGICAL;

  LOCAL
    x                : SET OF product_definition_relationship;
  END_LOCAL;

  IF relation.relating_product_definition IN relatives THEN
    RETURN (FALSE);
  END_IF;             -- IN is based in instance equality

  x := QUERY (pd <* bag_to_set (USEDIN
       (relation.relating_product_definition,
        'PART_204_BREP_PRODUCT_SCHEMA.' +

        'PRODUCT_DEFINITION_RELATIONSHIP.' +
        'RELATED_PRODUCT_DEFINITION')) |
         specific_relation IN TYPEOF (pd));

  REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
    IF NOT acyclic_product_definition_relationship
           (x[i],
            relatives + relation.relating_product_definition,
            specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;  -- acyclic_product_definition_relationship

FUNCTION aspect_ratio (p : planar_box) : positive_ratio_measure;
(* if the dimensions of the planar_box are greater than zero,
      compute the aspect ratio and return the resulting value. *)
   IF (p.size_in_x > 0.) AND (p.size_in_y > 0.) THEN
      RETURN (p.size_in_x / p.size_in_y);
   ELSE
      RETURN (?);
   END_IF;
END_FUNCTION; 

FUNCTION associated_surface(arg : pcurve_or_surface) : surface;
   LOCAL
     surf : surface;
   END_LOCAL;
   IF 'PART_204_BREP_PRODUCT_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
     surf := arg.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);
END_FUNCTION;

FUNCTION bag_to_set (the_bag : BAG OF GENERIC : intype) :
                                    SET OF GENERIC : intype;
  LOCAL
    the_set: SET OF GENERIC : intype := [];
    i      : INTEGER;
  END_LOCAL;
  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 to HIINDEX (the_bag);
      the_set := the_set + the_bag [i];
    END_REPEAT;
  END_IF;
  RETURN (the_set);
END_FUNCTION;

FUNCTION base_axis(dim : INTEGER; axis1, axis2, axis3 : direction) :
                                LIST [2:3] OF direction;
  LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION;

FUNCTION boolean_choose (b : boolean;
           choice1, choice2 : generic : item) : generic : item;
 
   IF b THEN
     RETURN (choice1);
   ELSE
     RETURN (choice2);
   END_IF;
END_FUNCTION;

FUNCTION build_axes(axis, ref_direction : direction) :
                                          LIST [3:3] OF direction;
   LOCAL
     d1, d2 : direction;
   END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);
END_FUNCTION;

FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);
END_FUNCTION;

FUNCTION closed_shell_reversed (a_shell : closed_shell) :
                                      oriented_closed_shell;
 LOCAL
   the_reverse : oriented_closed_shell;
 END_LOCAL;
  IF ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_CLOSED_SHELL'
         IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                       a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
  ELSE
     the_reverse := dummy_tri ||
                   connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;

FUNCTION conditional_reverse (p       : BOOLEAN;
                               an_item : reversible_topology)
                                       : reversible_topology;
   IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;
END_FUNCTION;

FUNCTION constraints_composite_curve_on_surface
               (c: composite_curve_on_surface) : BOOLEAN;
   LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('PART_204_BREP_PRODUCT_SCHEMA.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('PART_204_BREP_PRODUCT_SCHEMA.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
     (NOT('PART_204_BREP_PRODUCT_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
END_FUNCTION;

FUNCTION constraints_param_b_spline(degree, up_knots, up_cp : INTEGER;
                                          knot_mult : LIST OF INTEGER;
                        knots : LIST OF parameter_value) : BOOLEAN;
   LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   k := knot_mult[1];
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
     k := knot_mult[i];
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
END_FUNCTION;

FUNCTION cross_product (arg1, arg2 : direction) : vector;
  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
          (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
END_FUNCTION;

FUNCTION curve_weights_positive(b: rational_b_spline_curve) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
END_FUNCTION;

FUNCTION derive_dimensional_exponents (x : unit) :
                                   dimensional_exponents;
  LOCAL
    i      : INTEGER;
    result : dimensional_exponents := 
             dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0); 
  END_LOCAL;

  IF 'PART_204_BREP_PRODUCT_SCHEMA.DERIVED_UNIT'
               IN TYPEOF(x) THEN -- x is a derived unit
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);

      result.length_exponent :=
        result.length_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.length_exponent);

      result.mass_exponent :=
        result.mass_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.mass_exponent);

     result.time_exponent := 
        result.time_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.time_exponent); 

      result.electric_current_exponent :=
        result.electric_current_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.electric_current_exponent);

      result.thermodynamic_temperature_exponent :=
        result.thermodynamic_temperature_exponent + 
        (x.elements[i].exponent * 
   x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
 
      result.amount_of_substance_exponent :=
        result.amount_of_substance_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.amount_of_substance_exponent);

      result.luminous_intensity_exponent :=
        result.luminous_intensity_exponent + 
        (x.elements[i].exponent * 
         x.elements[i].unit.dimensions.luminous_intensity_exponent);
 
    END_REPEAT;
  ELSE -- x is a unitless or a named unit
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION;

FUNCTION dimension_of(item : geometric_representation_item) :
  dimension_count;
  LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
-- For cartesian_point, direction, or vector dimension is determined by
-- counting components.
    IF 'PART_204_BREP_PRODUCT_SCHEMA.CARTESIAN_POINT' IN
       TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'PART_204_BREP_PRODUCT_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'PART_204_BREP_PRODUCT_SCHEMA.VECTOR' IN TYPEOF(item) THEN
     dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
 -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 
  x := using_representations(item);
  -- Determines the dimension_count of the
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.
                 coordinate_space_dimension;
    RETURN (dim);
END_FUNCTION;

FUNCTION dimensions_for_si_unit(n : si_unit_name) : dimensional_exponents;
  CASE n  OF
    metre          : RETURN (dimensional_exponents 
                             (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents 
                             (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                             (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                             (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                             (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                             (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                             (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                             (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                             (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                             (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                             (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                             (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                             (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                             (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                             (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                             (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                             (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                             (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                             (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                             (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
  END_CASE;      
END_FUNCTION; 

FUNCTION dot_product(arg1, arg2 : direction) : REAL;
   LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
  (* When function is called with invalid data a NULL result is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
  (* When function is called with invalid data a NULL result is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);
END_FUNCTION;

FUNCTION edge_reversed (an_edge : edge) : oriented_edge;
  LOCAL
    the_reverse : oriented_edge; 
  END_LOCAL;

  IF ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_EDGE'
           IN TYPEOF (an_edge) ) THEN
    the_reverse := dummy_tri ||
            edge(an_edge.edge_end, an_edge.edge_start) ||
            oriented_edge(an_edge\oriented_edge.edge_element,
                       NOT (an_edge\oriented_edge.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
            edge(an_edge.edge_end, an_edge.edge_start) ||
            oriented_edge(an_edge, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;

FUNCTION face_bound_reversed (a_face_bound : face_bound) : face_bound;
  LOCAL
    the_reverse : face_bound ;
  END_LOCAL;
  IF ('PART_204_BREP_PRODUCT_SCHEMA.FACE_OUTER_BOUND'
        IN TYPEOF (a_face_bound) ) THEN
    the_reverse := dummy_tri ||
                    face_bound(a_face_bound\face_bound.bound,
                        NOT (a_face_bound\face_bound.orientation))
                           || face_outer_bound() ;
  ELSE
    the_reverse := dummy_tri ||
     face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
  END_IF;
 RETURN (the_reverse);
END_FUNCTION;

FUNCTION face_reversed (a_face : face) : oriented_face;
  LOCAL
    the_reverse : oriented_face ;
  END_LOCAL;
  IF ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_FACE'
           IN TYPEOF (a_face) ) THEN
    the_reverse := dummy_tri ||
      face(set_of_topology_reversed(a_face.bounds)) ||
         oriented_face(a_face\oriented_face.face_element,
                    NOT (a_face\oriented_face.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
      face(set_of_topology_reversed(a_face.bounds)) ||
                             oriented_face(a_face, FALSE) ;
  END_IF;
     RETURN (the_reverse);
END_FUNCTION;

FUNCTION first_proj_axis(z_axis, arg : direction) : direction;
  LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
          (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;

FUNCTION get_basis_surface (c : curve_on_surface) : SET[0:2] OF surface;
  LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'PART_204_BREP_PRODUCT_SCHEMA.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'PART_204_BREP_PRODUCT_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
             associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.COMPOSITE_CURVE_ON_SURFACE'
        IN TYPEOF (c) THEN
(* For a composite_curve_on_surface the basis_surface is the
 intersection of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
   surfs := get_basis_surface(c\composite_curve.segments[1].
                   parent_curve);
     IF n > 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(c\composite_curve.
                                          segments[i].parent_curve);
       END_REPEAT;
     END_IF;
  END_IF;
  RETURN(surfs);
END_FUNCTION;

FUNCTION item_in_context
  (item  : representation_item;
   cntxt : representation_context) : BOOLEAN;
  LOCAL
    i : INTEGER;
    y : BAG OF representation_item;
  END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item,
          'PART_204_BREP_PRODUCT_SCHEMA.REPRESENTATION.ITEMS')
             * cntxt.representations_in_context) > 0 THEN
    RETURN (TRUE);
    -- Determine the bag of representation_items that reference
    -- item.
    ELSE
    y := QUERY(z <* USEDIN (item , '') |
     'PART_204_BREP_PRODUCT_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
     -- Ensure that the set is not empty.
      IF SIZEOF(y) > 0 THEN
      -- For each element in the set
      REPEAT i := 1 TO HIINDEX(y);
        -- Check to see it is an item in the input cntxt.
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN (FALSE);
END_FUNCTION;

FUNCTION list_face_loops(f: face) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
   RETURN(loops);
END_FUNCTION;

FUNCTION list_of_topology_reversed (a_list
                                  : list_of_reversible_topology_item)
                                  : list_of_reversible_topology_item;
   LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
   RETURN (the_reverse);
END_FUNCTION;

FUNCTION list_to_array(lis : LIST [0:?] OF GENERIC : T;
                   low,u : INTEGER) : ARRAY [low:u] OF GENERIC : T;
   LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;
END_FUNCTION;

FUNCTION list_to_set(l : LIST [0:?] OF GENERIC:T): SET OF GENERIC:T;
   LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   RETURN(s);
END_FUNCTION;

FUNCTION make_array_of_array
      (lis : LIST[1:?] OF LIST [1:?] OF GENERIC : T;
                           low1, u1, low2, u2 : INTEGER):
                 ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;
(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   RETURN (res);
END_FUNCTION;

FUNCTION mixed_loop_type_set(l: SET[0:?] OF loop): LOGICAL;
   LOCAL
     poly_loop_type: LOGICAL;
   END_LOCAL;
   IF(SIZEOF(l) <= 1) THEN
     RETURN(FALSE);
   END_IF;
   poly_loop_type := ('PART_204_BREP_PRODUCT_SCHEMA.POLY_LOOP'
        IN TYPEOF(l[1]));
   REPEAT i := 2 TO SIZEOF(l);
     IF(('PART_204_BREP_PRODUCT_SCHEMA.POLY_LOOP' IN
           TYPEOF(l[i])) <> poly_loop_type) THEN
          RETURN(TRUE);
      END_IF;
   END_REPEAT;
   RETURN(FALSE);
END_FUNCTION;

FUNCTION msb_shells (brep: manifold_solid_brep) :
                         SET [1:?] OF  closed_shell;
    IF SIZEOF (QUERY (msbtype <* TYPEOF (brep) |
      msbtype LIKE '*BREP_WITH_VOIDS')) >= 1 THEN
      RETURN (brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;
END_FUNCTION;

FUNCTION normalise (arg : vector_or_direction) : vector_or_direction;
   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   IF NOT EXISTS (arg) THEN
     result := ?;
(* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'PART_204_BREP_PRODUCT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
        v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag > 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'PART_204_BREP_PRODUCT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);
END_FUNCTION;

FUNCTION open_shell_reversed ( a_shell : open_shell) :
                                        oriented_open_shell;
  LOCAL
    the_reverse : oriented_open_shell;
  END_LOCAL;
  IF ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_OPEN_SHELL'
                    IN TYPEOF (a_shell) ) THEN
    the_reverse := dummy_tri ||
                   connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                   open_shell () || oriented_open_shell(
                     a_shell\oriented_open_shell.open_shell_element,
                       (NOT (a_shell\oriented_open_shell.orientation)));
  ELSE
    the_reverse := dummy_tri ||
                   connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                   open_shell () ||  oriented_open_shell (a_shell, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;

FUNCTION orthogonal_complement(vec : direction) : direction;
  LOCAL
    result :  direction ;
  END_LOCAL;
  IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
    RETURN(?);
  ELSE
    result := dummy_gri || direction([-vec.direction_ratios[2],
                      vec.direction_ratios[1]]);
    RETURN(result);
  END_IF;
END_FUNCTION;

FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
   LOCAL
     n : INTEGER;
     p : BOOLEAN := TRUE;
   END_LOCAL;
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     RETURN (p);
END_FUNCTION;

FUNCTION path_reversed (a_path : path) : oriented_path;
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('PART_204_BREP_PRODUCT_SCHEMA.ORIENTED_PATH'
        IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                      NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
           path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;

FUNCTION scalar_times_vector (scalar : REAL; vec : vector_or_direction)
                                     : vector;
  LOCAL
    v      : direction;
    mag    : REAL;
    result : vector;
  END_LOCAL;

  IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
    RETURN (?) ;
   ELSE
    IF 'PART_204_BREP_PRODUCT_SCHEMA.VECTOR' IN TYPEOF (vec) THEN

      v   := dummy_gri || direction(vec.orientation.direction_ratios);
      mag := scalar * vec.magnitude;
    ELSE
      v   := dummy_gri || direction(vec.direction_ratios);
      mag := scalar;
    END_IF;
    IF (mag < 0.0 ) THEN
      REPEAT i := 1 TO SIZEOF(v.direction_ratios);
        v.direction_ratios[i] := -v.direction_ratios[i];
      END_REPEAT;
      mag := -mag;
    END_IF;
    result := dummy_gri || vector(normalise(v), mag);
  END_IF;
  RETURN (result);
END_FUNCTION;

FUNCTION second_proj_axis(z_axis, x_axis, arg: direction) : direction;
  LOCAL
    y_axis : vector;
    v      : direction;
    temp   : vector;
  END_LOCAL;
  
  IF NOT EXISTS(arg) THEN
    v := dummy_gri || direction([0.0,1.0,0.0]);
  ELSE
    v := arg;
  END_IF;
  
  temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
  y_axis := vector_difference(v, temp);
  temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
  y_axis := vector_difference(y_axis, temp);
  y_axis := normalise(y_axis);
  RETURN(y_axis.orientation);
END_FUNCTION;

FUNCTION set_of_topology_reversed
        (a_set : set_of_reversible_topology_item)
           : set_of_reversible_topology_item;
   LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
 RETURN (the_reverse);
END_FUNCTION;

FUNCTION shell_reversed (a_shell : shell) : shell;
  IF ('PART_204_BREP_PRODUCT_SCHEMA.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
    RETURN (open_shell_reversed (a_shell));
  ELSE
    IF ('PART_204_BREP_PRODUCT_SCHEMA.CLOSED_SHELL' IN
                            TYPEOF (a_shell) ) THEN
      RETURN (closed_shell_reversed (a_shell));
    ELSE
      RETURN (?);
    END_IF;
  END_IF;
END_FUNCTION;

FUNCTION surface_weights_positive(b: rational_b_spline_surface) :
                                                            BOOLEAN;
   LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] <= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);
END_FUNCTION;

FUNCTION topology_reversed (an_item : reversible_topology)
                                     : reversible_topology;

   IF ('PART_204_BREP_PRODUCT_SCHEMA.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;
   IF ('PART_204_BREP_PRODUCT_SCHEMA.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;
   IF ('PART_204_BREP_PRODUCT_SCHEMA.FACE_BOUND'
         IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
   IF ('PART_204_BREP_PRODUCT_SCHEMA.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;
   IF ('PART_204_BREP_PRODUCT_SCHEMA.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;
   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;
   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;
   RETURN (?);
END_FUNCTION;

FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('PART_204_BREP_PRODUCT_SCHEMA.REPRESENTATION_ITEM'
                                          IN TYPEOF(z)) OR
    ('PART_204_BREP_PRODUCT_SCHEMA.FOUNDED_ITEM'
          IN TYPEOF(z)));
      -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);
END_FUNCTION;

FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'PART_204_BREP_PRODUCT_SCHEMA.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
              'PART_204_BREP_PRODUCT_SCHEMA.REPRESENTATION.ITEMS');

      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);
END_FUNCTION;
 FUNCTION valid_units ( m : measure_with_unit ) : BOOLEAN ;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.LENGTH_MEASURE'
               IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
 dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.MASS_MEASURE' IN
         TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
   dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.TIME_MEASURE'
             IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
  dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
 IF 'PART_204_BREP_PRODUCT_SCHEMA.ELECTRIC_CURRENT_MEASURE'
          IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
 dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
   dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE'
      IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
  dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.LUMINOUS_INTENSITY_MEASURE'
       IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
  dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.PLANE_ANGLE_MEASURE'
              IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
  dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.SOLID_ANGLE_MEASURE'
        IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
   dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.AREA_MEASURE'
           IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
   dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.VOLUME_MEASURE'
             IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
   dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.RATIO_MEASURE'
         IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
   dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PART_204_BREP_PRODUCT_SCHEMA.POSITIVE_LENGTH_MEASURE'
       IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
   dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;

  IF 'PART_204_BREP_PRODUCT_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE'
         IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
   dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION vector_difference(arg1, arg2 : vector_or_direction) : vector;
  LOCAL
    result          : vector;
    res, vec1, vec2 : direction;
    mag, mag1, mag2 : REAL;
    ndim            : INTEGER;
  END_LOCAL;

  IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR
            (arg1.dim <> arg2.dim)
      THEN
    RETURN (?) ;
   ELSE
    BEGIN
      IF 'PART_204_BREP_PRODUCT_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
        mag1 := arg1.magnitude;
        vec1 := arg1.orientation;
      ELSE
        mag1 := 1.0;
        vec1 := arg1;
      END_IF;
      IF 'PART_204_BREP_PRODUCT_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN

        mag2 := arg2.magnitude;
        vec2 := arg2.orientation;
      ELSE
        mag2 := 1.0;
        vec2 := arg2;
      END_IF;
      vec1 := normalise (vec1);
      vec2 := normalise (vec2);
      ndim := SIZEOF(vec1.direction_ratios);
      mag := 0.0;
      res := dummy_gri || direction(vec1.direction_ratios);
      REPEAT i := 1 TO ndim;
        res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                    mag2*vec2.direction_ratios[i];
        mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
      END_REPEAT;
      IF (mag > 0.0 ) THEN
      result := dummy_gri || vector( res, SQRT(mag));
      ELSE
        result := dummy_gri || vector( vec1,  0.0);
      END_IF;
    END;
  END_IF;
  RETURN (result);
END_FUNCTION;

END_SCHEMA; -- part_204_brep_product_schema WG3 N1027
