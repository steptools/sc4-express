(*
  AIM EXPRESS long form for ISO/IS 10303-202
*)

SCHEMA associative_draughting;

  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     behind);
  END_TYPE; -- ahead_or_behind

  TYPE angle_relator = ENUMERATION OF
    (equal,
     large,
     small);
  END_TYPE; -- angle_relator

  TYPE approved_item = SELECT
    (drawing_revision,
     drawing_sheet_revision);
  END_TYPE; -- approved_item

  TYPE area_or_view = SELECT
    (presentation_area,
     presentation_view);
  END_TYPE; -- area_or_view

  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE; -- axis2_placement

  TYPE b_spline_curve_form = ENUMERATION OF
    (polyline_form,
     circular_arc,
     elliptic_arc,
     parabolic_arc,
     hyperbolic_arc,
     unspecified);
  END_TYPE; -- b_spline_curve_form

  TYPE b_spline_surface_form = ENUMERATION OF
    (plane_surf,
     cylindrical_surf,
     conical_surf,
     spherical_surf,
     toroidal_surf,
     surf_of_revolution,
     ruled_surf,
     generalised_cone,
     quadric_surf,
     surf_of_linear_extrusion,
     unspecified);
  END_TYPE; -- b_spline_surface_form

  TYPE boolean_operand = SELECT
    (solid_model);
  END_TYPE; -- boolean_operand

  TYPE box_characteristic_select = SELECT
    (box_height,
     box_width,
     box_slant_angle,
     box_rotate_angle);
  END_TYPE; -- box_characteristic_select

  TYPE box_height = positive_ratio_measure;
  END_TYPE; -- box_height

  TYPE box_rotate_angle = plane_angle_measure;
  END_TYPE; -- box_rotate_angle

  TYPE box_slant_angle = plane_angle_measure;
  END_TYPE; -- box_slant_angle

  TYPE box_width = positive_ratio_measure;
  END_TYPE; -- box_width

  TYPE central_or_parallel = ENUMERATION OF
    (central,
     parallel);
  END_TYPE; -- central_or_parallel

  TYPE character_spacing_select = SELECT
    (length_measure,
     ratio_measure,
     measure_with_unit);
  END_TYPE; -- character_spacing_select

  TYPE character_style_select = SELECT
    (text_style_for_defined_font);
  END_TYPE; -- character_style_select

  TYPE characterized_definition = SELECT
    (characterized_product_definition,
     shape_definition);
  END_TYPE; -- characterized_definition

  TYPE characterized_product_definition = SELECT
    (product_definition);
  END_TYPE; -- characterized_product_definition

  TYPE classified_item = SELECT
    (drawing_revision,
     drawing_sheet_revision);
  END_TYPE; -- classified_item

  TYPE contracted_item = SELECT
    (drawing_revision);
  END_TYPE; -- contracted_item

  TYPE curve_font_or_scaled_curve_font_select = SELECT
    (curve_style_font_select);
  END_TYPE; -- curve_font_or_scaled_curve_font_select

  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE; -- curve_on_surface

  TYPE curve_or_annotation_curve_occurrence = SELECT
    (curve,
     annotation_curve_occurrence);
  END_TYPE; -- curve_or_annotation_curve_occurrence

  TYPE curve_or_render = SELECT
    (curve_style);
  END_TYPE; -- curve_or_render

  TYPE curve_style_font_select = SELECT
    (curve_style_font,
     pre_defined_curve_font,
     externally_defined_curve_font);
  END_TYPE; -- curve_style_font_select

  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  END_TYPE; -- day_in_month_number

  TYPE defined_symbol_select = SELECT
    (pre_defined_symbol,
     externally_defined_symbol);
  END_TYPE; -- defined_symbol_select

  TYPE dimension_count = INTEGER;
  WHERE
    wr1: SELF > 0;
  END_TYPE; -- dimension_count

  TYPE dimension_extent_usage = ENUMERATION OF
    (origin,
     target);
  END_TYPE; -- dimension_extent_usage

  TYPE dimensional_characteristic = SELECT
    (dimensional_location,
     dimensional_size);
  END_TYPE; -- dimensional_characteristic

  TYPE draughting_callout_element = SELECT
    (annotation_text_occurrence,
     annotation_symbol_occurrence,
     annotation_curve_occurrence);
  END_TYPE; -- draughting_callout_element

  TYPE draughting_group_element = SELECT
    (annotation_occurrence,
     point,
     curve,
     surface);
  END_TYPE; -- draughting_group_element

  TYPE draughting_organization_item = SELECT
    (product_definition_formation,
     drawing_revision,
     drawing_sheet_revision);
  END_TYPE; -- draughting_organization_item

  TYPE draughting_presented_item_select = SELECT
    (product_definition_formation);
  END_TYPE; -- draughting_presented_item_select

  TYPE draughting_titled_item = SELECT
    (drawing_revision,
     drawing_sheet_revision);
  END_TYPE; -- draughting_titled_item

  TYPE fill_area_style_tile_shape_select = SELECT
    (fill_area_style_tile_symbol_with_style);
  END_TYPE; -- fill_area_style_tile_shape_select

  TYPE fill_style_select = SELECT
    (fill_area_style_colour,
     externally_defined_tile_style,
     fill_area_style_tiles,
     externally_defined_hatch_style,
     fill_area_style_hatching);
  END_TYPE; -- fill_style_select

  TYPE font_select = SELECT
    (pre_defined_text_font,
     externally_defined_text_font);
  END_TYPE; -- font_select

  TYPE geometric_set_select = SELECT
    (point,
     curve,
     surface);
  END_TYPE; -- geometric_set_select

  TYPE hiding_or_blanking_select = SELECT
    (presentation_area,
     presentation_view,
     annotation_fill_area);
  END_TYPE; -- hiding_or_blanking_select

  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: (0 <= SELF) AND (SELF < 24);
  END_TYPE; -- hour_in_day

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE invisibility_context = SELECT
    (presentation_layer_usage,
     presentation_representation,
     presentation_set);
  END_TYPE; -- invisibility_context

  TYPE invisible_item = SELECT
    (styled_item,
     presentation_layer_assignment,
     presentation_representation);
  END_TYPE; -- invisible_item

  TYPE knot_type = ENUMERATION OF
    (uniform_knots,
     unspecified,
     quasi_uniform_knots,
     piecewise_bezier_knots);
  END_TYPE; -- knot_type

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE layered_item = SELECT
    (presentation_representation,
     representation_item);
  END_TYPE; -- layered_item

  TYPE length_measure = REAL;
  END_TYPE; -- length_measure

  TYPE list_of_reversible_topology_item = LIST [0:?] OF
              reversible_topology_item;
  END_TYPE; -- list_of_reversible_topology_item

  TYPE marker_select = SELECT
    (pre_defined_marker);
  END_TYPE; -- marker_select

  TYPE measure_value = SELECT
    (length_measure,
     plane_angle_measure,
     solid_angle_measure,
     ratio_measure,
     parameter_value,
     positive_length_measure,
     positive_ratio_measure);
  END_TYPE; -- measure_value

  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: (0 <= SELF) AND (SELF <= 59);
  END_TYPE; -- minute_in_hour

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: (1 <= SELF) AND (SELF <= 12);
  END_TYPE; -- month_in_year_number

  TYPE null_style = ENUMERATION OF
    (null);
  END_TYPE; -- null_style

  TYPE parameter_value = REAL;
  END_TYPE; -- parameter_value

  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE; -- pcurve_or_surface

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE plane_angle_measure = REAL;
  END_TYPE; -- plane_angle_measure

  TYPE positive_length_measure = length_measure;
  WHERE
    wr1: SELF > 0;
  END_TYPE; -- positive_length_measure

  TYPE positive_ratio_measure = ratio_measure;
  WHERE
    wr1: SELF > 0;
  END_TYPE; -- positive_ratio_measure

  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (curve_3d,
     pcurve_s1,
     pcurve_s2);
  END_TYPE; -- preferred_surface_curve_representation

  TYPE presentable_text = STRING;
  END_TYPE; -- presentable_text

  TYPE presentation_representation_select = SELECT
    (presentation_representation,
     presentation_set);
  END_TYPE; -- presentation_representation_select

  TYPE presentation_size_assignment_select = SELECT
    (presentation_view,
     presentation_area,
     area_in_set);
  END_TYPE; -- presentation_size_assignment_select

  TYPE presentation_style_select = SELECT
    (curve_style,
     symbol_style,
     fill_area_style,
     text_style,
     null_style);
  END_TYPE; -- presentation_style_select

  TYPE ratio_measure = REAL;
  END_TYPE; -- ratio_measure

  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE; -- reversible_topology

  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE; -- reversible_topology_item

  TYPE second_in_minute = REAL;
  WHERE
    wr1: (0 <= SELF) AND (SELF < 60);
  END_TYPE; -- second_in_minute

  TYPE set_of_reversible_topology_item = SET [0:?] OF
              reversible_topology_item;
  END_TYPE; -- set_of_reversible_topology_item

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- shape_definition

  TYPE shell = SELECT
    (vertex_shell,
     wire_shell,
     open_shell,
     closed_shell);
  END_TYPE; -- shell

  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE; -- si_prefix

  TYPE si_unit_name = ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE; -- si_unit_name

  TYPE size_select = SELECT
    (positive_length_measure,
     measure_with_unit);
  END_TYPE; -- size_select

  TYPE solid_angle_measure = REAL;
  END_TYPE; -- solid_angle_measure

  TYPE source_item = SELECT
    (identifier);
  END_TYPE; -- source_item

  TYPE specified_item = SELECT
    (drawing_revision);
  END_TYPE; -- specified_item

  TYPE style_context_select = SELECT
    (representation,
     representation_item,
     presentation_set);
  END_TYPE; -- style_context_select

  TYPE surface_model = SELECT
    (shell_based_surface_model);
  END_TYPE; -- surface_model

  TYPE symbol_style_select = SELECT
    (symbol_colour);
  END_TYPE; -- symbol_style_select

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE text_alignment = label;
  END_TYPE; -- text_alignment

  TYPE text_delineation = label;
  END_TYPE; -- text_delineation

  TYPE text_or_character = SELECT
    (annotation_text,
     composite_text,
     text_literal);
  END_TYPE; -- text_or_character

  TYPE text_path = ENUMERATION OF
    (left,
     right,
     up,
     down);
  END_TYPE; -- text_path

  TYPE tolerance_method_definition = SELECT
    (tolerance_value);
  END_TYPE; -- tolerance_method_definition

  TYPE tolerance_select = SELECT
    (plus_minus_tolerance);
  END_TYPE; -- tolerance_select

  TYPE transformation = SELECT
    (functionally_defined_transformation);
  END_TYPE; -- transformation

  TYPE transition_code = ENUMERATION OF
    (discontinuous,
     continuous,
     cont_same_gradient,
     cont_same_gradient_same_curvature);
  END_TYPE; -- transition_code

  TYPE trimming_preference = ENUMERATION OF
    (cartesian,
     parameter,
     unspecified);
  END_TYPE; -- trimming_preference

  TYPE trimming_select = SELECT
    (cartesian_point,
     parameter_value);
  END_TYPE; -- trimming_select

  TYPE unit = SELECT
    (named_unit,
     derived_unit);
  END_TYPE; -- unit

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE; -- vector_or_direction

  TYPE wireframe_model = SELECT
    (shell_based_wireframe_model,
     edge_based_wireframe_model);
  END_TYPE; -- wireframe_model

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    WHERE
      wr1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number);
  END_ENTITY; -- address

  ENTITY advanced_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP',
               'ASSOCIATIVE_DRAUGHTING.FACETED_BREP',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
                1)) )) = 0;
      wr2: SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               > 0;
      wr3: SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
               'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh\
               connected_face_set.cfs_faces | (NOT (
               'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fcs))) )) =
                0)) )) = 0)) )) = 0;
      wr4: SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | ('ASSOCIATIVE_DRAUGHTING.ORIENTED_CLOSED_SHELL' IN 
               TYPEOF(msb\manifold_solid_brep.outer)) )) = 0;
      wr5: SIZEOF(QUERY ( brv <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | 
               (NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | csh\
               oriented_closed_shell.orientation )) = 0)) )) = 0;
      wr6: SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (
               'ASSOCIATIVE_DRAUGHTING.ADVANCED_BREP_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0;
  END_ENTITY; -- advanced_brep_shape_representation

  ENTITY advanced_face
    SUBTYPE OF (face_surface);
    WHERE
      wr1 : SIZEOF(['ASSOCIATIVE_DRAUGHTING.ELEMENTARY_SURFACE',
                'ASSOCIATIVE_DRAUGHTING.B_SPLINE_SURFACE',
                'ASSOCIATIVE_DRAUGHTING.SWEPT_SURFACE'] * TYPEOF(
                face_geometry)) = 1;
      wr2 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ('ASSOCIATIVE_DRAUGHTING.EDGE_CURVE' IN 
                TYPEOF(oe.edge_element))) )) = 0)) )) = 0;
      wr3 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (SIZEOF(['ASSOCIATIVE_DRAUGHTING.LINE',
                'ASSOCIATIVE_DRAUGHTING.CONIC',
                'ASSOCIATIVE_DRAUGHTING.POLYLINE',
                'ASSOCIATIVE_DRAUGHTING.SURFACE_CURVE',
                'ASSOCIATIVE_DRAUGHTING.B_SPLINE_CURVE'] * TYPEOF(oe.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0;
      wr4 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN
                 TYPEOF(oe.edge_start)) AND (
                'ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT' IN TYPEOF(oe.
                edge_start\vertex_point.vertex_geometry)) AND (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(oe.edge_end)) 
                AND ('ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT' IN TYPEOF(oe.
                edge_end\vertex_point.vertex_geometry)))) )) = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | ('ASSOCIATIVE_DRAUGHTING.ORIENTED_PATH' IN TYPEOF(
                elp_fbnds.bound)) )) = 0;
      wr6 : (NOT ('ASSOCIATIVE_DRAUGHTING.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (SIZEOF(['ASSOCIATIVE_DRAUGHTING.LINE',
                'ASSOCIATIVE_DRAUGHTING.CONIC',
                'ASSOCIATIVE_DRAUGHTING.POLYLINE',
                'ASSOCIATIVE_DRAUGHTING.B_SPLINE_CURVE'] * TYPEOF(
                face_geometry\swept_surface.swept_curve)) = 1);
      wr7 : SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND (
                'ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry)))) )) = 0;
      wr8 : SIZEOF(QUERY ( bnd <* SELF.bounds | (NOT (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP',
                'ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP'] * TYPEOF(bnd.bound)) 
                = 1)) )) = 0;
      wr9 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('ASSOCIATIVE_DRAUGHTING.SURFACE_CURVE' IN 
                TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND (NOT 
                (SIZEOF(QUERY ( sc_ag <* oe.edge_element\edge_curve.
                edge_geometry\surface_curve.associated_geometry | (NOT (
                'ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(sc_ag))) )) = 0))))) 
               = 0)) )) = 0;
      wr10: ((NOT ('ASSOCIATIVE_DRAUGHTING.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (NOT ('ASSOCIATIVE_DRAUGHTING.POLYLINE' 
                IN TYPEOF(face_geometry\swept_surface.swept_curve))) OR (
                SIZEOF(face_geometry\swept_surface.swept_curve\polyline.
                points) < 3)) AND (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* SELF.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('ASSOCIATIVE_DRAUGHTING.POLYLINE' IN TYPEOF(
                oe.edge_element\edge_curve.edge_geometry)) AND (NOT (
                SIZEOF(oe.edge_element\edge_curve.edge_geometry\polyline.
                points) < 3))) )) = 0)) )) = 0);
  END_ENTITY; -- advanced_face

  ENTITY angular_dimension
    SUBTYPE OF (dimension_curve_directed_callout);
  END_ENTITY; -- angular_dimension

  ENTITY angular_location
    SUBTYPE OF (dimensional_location);
      angle_selection : angle_relator;
  END_ENTITY; -- angular_location

  ENTITY annotation_curve_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.CURVE' IN TYPEOF(SELF\styled_item.item);
  END_ENTITY; -- annotation_curve_occurrence

  ENTITY annotation_fill_area
    SUBTYPE OF (geometric_representation_item);
      boundaries : SET [1:?] OF curve;
  END_ENTITY; -- annotation_fill_area

  ENTITY annotation_fill_area_occurrence
    SUBTYPE OF (annotation_occurrence);
      fill_style_target : point;
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.ANNOTATION_FILL_AREA' IN TYPEOF(SELF.
               item);
  END_ENTITY; -- annotation_fill_area_occurrence

  ENTITY annotation_occurrence
    SUPERTYPE OF (ONEOF (annotation_curve_occurrence,
        annotation_fill_area_occurrence,annotation_text_occurrence,
        annotation_symbol_occurrence))
    SUBTYPE OF (styled_item);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_REPRESENTATION_ITEM' IN 
               TYPEOF(SELF);
  END_ENTITY; -- annotation_occurrence

  ENTITY annotation_occurrence_associativity
    SUBTYPE OF (annotation_occurrence_relationship);
    WHERE
      wr1: SIZEOF(TYPEOF(SELF.related_annotation_occurrence) * [
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_FILL_AREA_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.PROJECTION_CURVE',
               'ASSOCIATIVE_DRAUGHTING.LEADER_CURVE']) = 1;
  END_ENTITY; -- annotation_occurrence_associativity

  ENTITY annotation_occurrence_relationship;
      name                           : label;
      description                    : text;
      relating_annotation_occurrence : annotation_occurrence;
      related_annotation_occurrence  : annotation_occurrence;
  END_ENTITY; -- annotation_occurrence_relationship

  ENTITY annotation_subfigure_occurrence
    SUBTYPE OF (annotation_symbol_occurrence);
    WHERE
      wr1: SIZEOF(QUERY ( sty <* SELF.styles | (NOT (SIZEOF(sty.styles) = 
               1)) )) = 0;
      wr2: SIZEOF(QUERY ( sty <* SELF.styles | (NOT (
               'ASSOCIATIVE_DRAUGHTING.NULL_STYLE' IN TYPEOF(sty.styles[1])))
)) 
               = 0;
      wr3: 'ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL' IN TYPEOF(SELF.item);
      wr4: 'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_SUBFIGURE_REPRESENTATION' IN
                TYPEOF(SELF.item\mapped_item.mapping_source.
               mapped_representation);
  END_ENTITY; -- annotation_subfigure_occurrence

  ENTITY annotation_symbol
    SUBTYPE OF (mapped_item);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.SYMBOL_REPRESENTATION_MAP' IN TYPEOF(
               SELF\mapped_item.mapping_source);
      wr2: 'ASSOCIATIVE_DRAUGHTING.SYMBOL_TARGET' IN TYPEOF(SELF\
               mapped_item.mapping_target);
      wr3: 'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_REPRESENTATION_ITEM' IN 
               TYPEOF(SELF);
  END_ENTITY; -- annotation_symbol

  ENTITY annotation_symbol_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1: SIZEOF(['ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL',
               'ASSOCIATIVE_DRAUGHTING.DEFINED_SYMBOL'] * TYPEOF(SELF\
               styled_item.item)) > 0;
  END_ENTITY; -- annotation_symbol_occurrence

  ENTITY annotation_text
    SUBTYPE OF (mapped_item);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT' IN TYPEOF(SELF\
               mapped_item.mapping_target);
      wr2: 'ASSOCIATIVE_DRAUGHTING.TEXT_STRING_REPRESENTATION' IN TYPEOF(
               SELF\mapped_item.mapping_source.mapped_representation);
      wr3: 'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_REPRESENTATION_ITEM' IN 
               TYPEOF(SELF);
  END_ENTITY; -- annotation_text

  ENTITY annotation_text_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1: SIZEOF(['ASSOCIATIVE_DRAUGHTING.TEXT_LITERAL',
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT',
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_CHARACTER',
               'ASSOCIATIVE_DRAUGHTING.DEFINED_CHARACTER_GLYPH',
               'ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT'] * TYPEOF(SELF\
               styled_item.item)) > 0;
  END_ENTITY; -- annotation_text_occurrence

  ENTITY application_context;
      application : text;
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (product_context,product_definition_context));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY; -- application_protocol_definition

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_role;
      role : label;
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY area_in_set;
      area   : presentation_area;
      in_set : presentation_set;
  END_ENTITY; -- area_in_set

  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),direction([0,0,1]));
    WHERE
      wr1: SELF\geometric_representation_item.dim = 3;
  END_ENTITY; -- axis1_placement

  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: SELF\geometric_representation_item.dim = 2;
  END_ENTITY; -- axis2_placement_2d

  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: SELF\placement.location.dim = 3;
      wr2: (NOT EXISTS(axis)) OR (axis.dim = 3);
      wr3: (NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3);
      wr4: (NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0);
  END_ENTITY; -- axis2_placement_3d

  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (uniform_curve,b_spline_curve_with_knots,
        quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve)
    SUBTYPE OF (bounded_curve);
      degree              : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form          : b_spline_curve_form;
      closed_curve        : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(
                                         control_points_list) - 1;
      control_points                : ARRAY [0:
                                         upper_index_on_control_points] OF
                                          cartesian_point := list_to_array(
                                         control_points_list,0,
                                         upper_index_on_control_points);
    WHERE
      wr1: ('ASSOCIATIVE_DRAUGHTING.UNIFORM_CURVE' IN TYPEOF(SELF)) OR (
               'ASSOCIATIVE_DRAUGHTING.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) 
               OR ('ASSOCIATIVE_DRAUGHTING.BEZIER_CURVE' IN TYPEOF(SELF)) 
               OR ('ASSOCIATIVE_DRAUGHTING.B_SPLINE_CURVE_WITH_KNOTS' IN 
               TYPEOF(SELF));
  END_ENTITY; -- b_spline_curve

  ENTITY b_spline_curve_with_knots
    SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots               : LIST [2:?] OF parameter_value;
      knot_spec           : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      wr1: constraints_param_b_spline(degree,upper_index_on_knots,
               upper_index_on_control_points,knot_multiplicities,knots);
      wr2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
  END_ENTITY; -- b_spline_curve_with_knots

  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,uniform_surface,
        quasi_uniform_surface,bezier_surface) ANDOR 
        rational_b_spline_surface)
    SUBTYPE OF (bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                           cartesian_point := make_array_of_array(
                          control_points_list,0,u_upper,0,v_upper);
    WHERE
      wr1: ('ASSOCIATIVE_DRAUGHTING.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR (
               'ASSOCIATIVE_DRAUGHTING.QUASI_UNIFORM_SURFACE' IN TYPEOF(
               SELF)) OR ('ASSOCIATIVE_DRAUGHTING.BEZIER_SURFACE' IN 
               TYPEOF(SELF)) OR (
               'ASSOCIATIVE_DRAUGHTING.B_SPLINE_SURFACE_WITH_KNOTS' IN 
               TYPEOF(SELF));
  END_ENTITY; -- b_spline_surface

  ENTITY b_spline_surface_with_knots
    SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
               v_knots);
      wr3: SIZEOF(u_multiplicities) = knot_u_upper;
      wr4: SIZEOF(v_multiplicities) = knot_v_upper;
  END_ENTITY; -- b_spline_surface_with_knots

  ENTITY bezier_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- bezier_curve

  ENTITY bezier_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- bezier_surface

  ENTITY boundary_curve
    SUBTYPE OF (composite_curve_on_surface);
    WHERE
      wr1: SELF\composite_curve.closed_curve;
  END_ENTITY; -- boundary_curve

  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (polyline,b_spline_curve,trimmed_curve,
        composite_curve))
    SUBTYPE OF (curve);
  END_ENTITY; -- bounded_curve

  ENTITY bounded_surface
    SUPERTYPE OF (ONEOF (b_spline_surface,rectangular_trimmed_surface,
        curve_bounded_surface,rectangular_composite_surface))
    SUBTYPE OF (surface);
  END_ENTITY; -- bounded_surface

  ENTITY brep_with_voids
    SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
  END_ENTITY; -- brep_with_voids

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY camera_image
    SUBTYPE OF (mapped_item);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.CAMERA_USAGE' IN TYPEOF(SELF\
               mapped_item.mapping_source);
      wr2: 'ASSOCIATIVE_DRAUGHTING.PLANAR_BOX' IN TYPEOF(SELF\mapped_item.
               mapping_target);
      wr3: 'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_REPRESENTATION_ITEM' IN 
               TYPEOF(SELF);
  END_ENTITY; -- camera_image

  ENTITY camera_image_2d_with_scale
    SUBTYPE OF (camera_image);
    DERIVE
      scale : positive_ratio_measure := SELF\mapped_item.mapping_target\
                 planar_extent.size_in_x / SELF\mapped_item.mapping_source.
                 mapping_origin\camera_model_d2.view_window.size_in_x;
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.CAMERA_MODEL_D2' IN TYPEOF(SELF\
               mapped_item.mapping_source.mapping_origin);
      wr2: aspect_ratio(SELF\mapped_item.mapping_target) = aspect_ratio(
               SELF\mapped_item.mapping_source.mapping_origin\
               camera_model_d2.view_window);
      wr3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d2.
               view_window_clipping;
  END_ENTITY; -- camera_image_2d_with_scale

  ENTITY camera_image_3d_with_scale
    SUBTYPE OF (camera_image);
    DERIVE
      scale : positive_ratio_measure := SELF\mapped_item.mapping_target\
                 planar_extent.size_in_x / SELF\mapped_item.mapping_source.
                 mapping_origin\camera_model_d3.perspective_of_volume.
                 view_window.size_in_x;
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.CAMERA_MODEL_D3' IN TYPEOF(SELF\
               mapped_item.mapping_source.mapping_origin);
      wr2: aspect_ratio(SELF\mapped_item.mapping_target) = aspect_ratio(
               SELF\mapped_item.mapping_source.mapping_origin\
               camera_model_d3.perspective_of_volume.view_window);
      wr3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
               perspective_of_volume.front_plane_clipping AND SELF\
               mapped_item.mapping_source.mapping_origin\camera_model_d3.
               perspective_of_volume.view_volume_sides_clipping;
  END_ENTITY; -- camera_image_3d_with_scale

  ENTITY camera_model
    SUPERTYPE OF (ONEOF (camera_model_d2,camera_model_d3))
    SUBTYPE OF (geometric_representation_item);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'ITEM_DEFINED_TRANSFORMATION.' + 'TRANSFORM_ITEM_1')) + 
               SIZEOF(USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'REPRESENTATION_MAP.MAPPING_ORIGIN'))) > 0;
      wr2: SIZEOF(USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'STYLED_ITEM.ITEM')) = 0;
  END_ENTITY; -- camera_model

  ENTITY camera_model_d2
    SUBTYPE OF (camera_model);
      view_window          : planar_box;
      view_window_clipping : BOOLEAN;
    WHERE
      wr1: SELF\geometric_representation_item.dim = 2;
  END_ENTITY; -- camera_model_d2

  ENTITY camera_model_d3
    SUBTYPE OF (camera_model);
      view_reference_system : axis2_placement_3d;
      perspective_of_volume : view_volume;
    WHERE
      wr1: (dot_product(SELF.view_reference_system.p[3],SELF.
               perspective_of_volume.view_window.placement.p[3]) = 1) AND (
               SELF.view_reference_system.location.coordinates[3] = SELF.
               perspective_of_volume.view_window.placement.location.
               coordinates[3]);
      wr2: SELF\geometric_representation_item.dim = 3;
  END_ENTITY; -- camera_model_d3

  ENTITY camera_model_d3_with_hlhsr
    SUBTYPE OF (camera_model_d3);
      hidden_line_surface_removal : BOOLEAN;
  END_ENTITY; -- camera_model_d3_with_hlhsr

  ENTITY camera_usage
    SUBTYPE OF (representation_map);
    WHERE
      wr1: NOT ('ASSOCIATIVE_DRAUGHTING.PRESENTATION_REPRESENTATION' IN 
               TYPEOF(SELF\representation_map.mapped_representation));
      wr2: 'ASSOCIATIVE_DRAUGHTING.CAMERA_MODEL' IN TYPEOF(SELF\
               representation_map.mapping_origin);
  END_ENTITY; -- camera_usage

  ENTITY cartesian_point
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY; -- cartesian_point

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d,
        cartesian_transformation_operator_3d))
    SUBTYPE OF (geometric_representation_item, 
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: scl > 0;
  END_ENTITY; -- cartesian_transformation_operator

  ENTITY cartesian_transformation_operator_2d
    SUBTYPE OF (cartesian_transformation_operator);
    DERIVE
      u : LIST [2:2] OF direction := base_axis(2,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,?);
    WHERE
      wr1: SELF\cartesian_transformation_operator.dim = 2;
  END_ENTITY; -- cartesian_transformation_operator_2d

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
      wr1: SELF\cartesian_transformation_operator.dim = 3;
  END_ENTITY; -- cartesian_transformation_operator_3d

  ENTITY centre_of_symmetry
    SUBTYPE OF (derived_shape_aspect);
    WHERE
      wr1: SIZEOF(QUERY ( sadr <* deriving_relationships | (NOT (
               'ASSOCIATIVE_DRAUGHTING.SYMMETRIC_SHAPE_ASPECT' IN TYPEOF(
               sadr.related_shape_aspect))) )) = 0;
  END_ENTITY; -- centre_of_symmetry

  ENTITY circle
    SUBTYPE OF (conic);
      radius : positive_length_measure;
  END_ENTITY; -- circle

  ENTITY closed_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- closed_shell

  ENTITY colour;
  END_ENTITY; -- colour

  ENTITY colour_rgb
    SUBTYPE OF (colour_specification);
      red   : REAL;
      green : REAL;
      blue  : REAL;
    WHERE
      wr1: (0 <= red) AND (red <= 1);
      wr2: (0 <= green) AND (green <= 1);
      wr3: (0 <= blue) AND (blue <= 1);
  END_ENTITY; -- colour_rgb

  ENTITY colour_specification
    SUBTYPE OF (colour);
      name : label;
  END_ENTITY; -- colour_specification

  ENTITY composite_curve
    SUBTYPE OF (bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments   : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> 
                        discontinuous;
    WHERE
      wr1: ((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | (
               temp.transition = discontinuous) )) = 1)) OR (closed_curve 
               AND (SIZEOF(QUERY ( temp <* segments | (temp.transition = 
               discontinuous) )) = 0));
  END_ENTITY; -- composite_curve

  ENTITY composite_curve_on_surface
    SUPERTYPE OF (boundary_curve)
    SUBTYPE OF (composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: SIZEOF(basis_surface) > 0;
      wr2: constraints_composite_curve_on_surface(SELF);
  END_ENTITY; -- composite_curve_on_surface

  ENTITY composite_curve_segment;
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE' IN TYPEOF(parent_curve);
  END_ENTITY; -- composite_curve_segment

  ENTITY composite_text
    SUBTYPE OF (geometric_representation_item);
      collected_text : SET [2:?] OF text_or_character;
    WHERE
      wr1: acyclic_composite_text(SELF,SELF.collected_text);
  END_ENTITY; -- composite_text

  ENTITY composite_text_with_associated_curves
    SUBTYPE OF (composite_text);
      associated_curves : SET [1:?] OF curve;
  END_ENTITY; -- composite_text_with_associated_curves

  ENTITY composite_text_with_blanking_box
    SUBTYPE OF (composite_text);
      blanking : planar_box;
  END_ENTITY; -- composite_text_with_blanking_box

  ENTITY composite_text_with_extent
    SUBTYPE OF (composite_text);
      extent : planar_extent;
  END_ENTITY; -- composite_text_with_extent

  ENTITY conic
    SUPERTYPE OF (ONEOF (circle,ellipse,hyperbola,parabola))
    SUBTYPE OF (curve);
      position : axis2_placement;
  END_ENTITY; -- conic

  ENTITY conical_surface
    SUBTYPE OF (elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: radius >= 0;
  END_ENTITY; -- conical_surface

  ENTITY connected_edge_set
    SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
  END_ENTITY; -- connected_edge_set

  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (closed_shell,open_shell))
    SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY; -- connected_face_set

  ENTITY context_dependent_invisibility
    SUBTYPE OF (invisibility);
      presentation_context : invisibility_context;
  END_ENTITY; -- context_dependent_invisibility

  ENTITY context_dependent_over_riding_styled_item
    SUBTYPE OF (over_riding_styled_item);
      style_context : SET [1:2] OF style_context_select;
    WHERE
      wr1: (SIZEOF(QUERY ( sc <* SELF.style_context | (
               'ASSOCIATIVE_DRAUGHTING.REPRESENTATION' IN TYPEOF(sc)) )) = 
               1) AND (SIZEOF(QUERY ( sc <* SELF.style_context | (
               'ASSOCIATIVE_DRAUGHTING.REPRESENTATION_ITEM' IN TYPEOF(sc)) )) 
               = 1);
  END_ENTITY; -- context_dependent_over_riding_styled_item

  ENTITY contract;
      name    : label;
      purpose : text;
      kind    : contract_type;
  END_ENTITY; -- contract

  ENTITY contract_assignment
    ABSTRACT SUPERTYPE;
      assigned_contract : contract;
  END_ENTITY; -- contract_assignment

  ENTITY contract_type;
      description : label;
  END_ENTITY; -- contract_type

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY; -- conversion_based_unit

  ENTITY coordinated_universal_time_offset;
      hour_offset   : hour_in_day;
      minute_offset : OPTIONAL minute_in_hour;
      sense         : ahead_or_behind;
  END_ENTITY; -- coordinated_universal_time_offset

  ENTITY curve
    SUPERTYPE OF (ONEOF (line,conic,pcurve,surface_curve,offset_curve_2d,
        offset_curve_3d,curve_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- curve

  ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
      basis_surface  : surface;
      boundaries     : SET [1:?] OF boundary_curve;
      implicit_outer : BOOLEAN;
    WHERE
      wr1: NOT (implicit_outer AND (
               'ASSOCIATIVE_DRAUGHTING.OUTER_BOUNDARY_CURVE' IN TYPEOF(
               boundaries)));
      wr2: (NOT implicit_outer) OR (
               'ASSOCIATIVE_DRAUGHTING.BOUNDED_SURFACE' IN TYPEOF(
               basis_surface));
      wr3: SIZEOF(QUERY ( temp <* boundaries | (
               'ASSOCIATIVE_DRAUGHTING.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))
)) 
               <= 1;
      wr4: SIZEOF(QUERY ( temp <* boundaries | (temp\
               composite_curve_on_surface.basis_surface[1] :<>: SELF.
               basis_surface) )) = 0;
  END_ENTITY; -- curve_bounded_surface

  ENTITY curve_dimension
    SUBTYPE OF (dimension_curve_directed_callout);
  END_ENTITY; -- curve_dimension

  ENTITY curve_replica
    SUBTYPE OF (curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: transformation.dim = parent_curve.dim;
      wr2: acyclic_curve_replica(SELF,parent_curve);
  END_ENTITY; -- curve_replica

  ENTITY curve_style;
      name         : label;
      curve_font   : curve_font_or_scaled_curve_font_select;
      curve_width  : size_select;
      curve_colour : colour;
  END_ENTITY; -- curve_style

  ENTITY curve_style_font;
      name         : label;
      pattern_list : LIST [1:?] OF curve_style_font_pattern;
  END_ENTITY; -- curve_style_font

  ENTITY curve_style_font_pattern;
      visible_segment_length   : positive_length_measure;
      invisible_segment_length : positive_length_measure;
  END_ENTITY; -- curve_style_font_pattern

  ENTITY cylindrical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- cylindrical_surface

  ENTITY date
    SUPERTYPE OF (calendar_date);
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY; -- date_and_time

  ENTITY datum_feature_callout
    SUBTYPE OF (draughting_callout);
  END_ENTITY; -- datum_feature_callout

  ENTITY datum_target_callout
    SUBTYPE OF (draughting_callout);
  END_ENTITY; -- datum_target_callout

  ENTITY defined_symbol
    SUBTYPE OF (geometric_representation_item);
      definition : defined_symbol_select;
      target     : symbol_target;
  END_ENTITY; -- defined_symbol

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.PARAMETRIC_REPRESENTATION_CONTEXT' IN 
               TYPEOF(SELF\representation.context_of_items);
  END_ENTITY; -- definitional_representation

  ENTITY degenerate_pcurve
    SUBTYPE OF (point);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: SIZEOF(reference_to_curve\representation.items) = 1;
      wr2: 'ASSOCIATIVE_DRAUGHTING.CURVE' IN TYPEOF(reference_to_curve\
               representation.items[1]);
      wr3: reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2;
  END_ENTITY; -- degenerate_pcurve

  ENTITY degenerate_toroidal_surface
    SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
    WHERE
      wr1: major_radius < minor_radius;
  END_ENTITY; -- degenerate_toroidal_surface

  ENTITY derived_shape_aspect
    SUPERTYPE OF (ONEOF (centre_of_symmetry,tangent))
    SUBTYPE OF (shape_aspect);
    INVERSE
      deriving_relationships : SET [1:?] OF
                                   shape_aspect_deriving_relationship FOR 
                                  relating_shape_aspect;
  END_ENTITY; -- derived_shape_aspect

  ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
    WHERE
      wr1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements
               [1].exponent <> 1));
  END_ENTITY; -- derived_unit

  ENTITY derived_unit_element;
      unit     : named_unit;
      exponent : REAL;
  END_ENTITY; -- derived_unit_element

  ENTITY diameter_dimension
    SUBTYPE OF (dimension_curve_directed_callout);
  END_ENTITY; -- diameter_dimension

  ENTITY dimension_callout_component_relationship
    SUBTYPE OF (draughting_callout_relationship);
    WHERE
      wr1: SELF.name IN ['prefix','suffix'];
      wr2: 'ASSOCIATIVE_DRAUGHTING.STRUCTURED_DIMENSION_CALLOUT' IN 
               TYPEOF(SELF.relating_draughting_callout);
      wr3: SIZEOF(TYPEOF(SELF.related_draughting_callout) * [
               'ASSOCIATIVE_DRAUGHTING.LEADER_DIRECTED_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.PROJECTION_DIRECTED_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.DIMENSION_CURVE_DIRECTED_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.STRUCTURED_DIMENSION_CALLOUT']) = 0;
      wr4: (SELF.related_draughting_callout.contents * SELF.
               relating_draughting_callout.contents) = SELF.
               related_draughting_callout.contents;
      wr5: (SELF.name = 'prefix') AND (SIZEOF(QUERY ( ato <* 
               QUERY ( con <* SELF.related_draughting_callout.contents | (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
               TYPEOF(con)) ) | (NOT (ato.name = 'prefix text')) )) = 0);
      wr6: (SELF.name = 'suffix') AND (SIZEOF(QUERY ( ato <* 
               QUERY ( con <* SELF.related_draughting_callout.contents | (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
               TYPEOF(con)) ) | (NOT (ato.name = 'suffix text')) )) = 0);
  END_ENTITY; -- dimension_callout_component_relationship

  ENTITY dimension_callout_relationship
    SUBTYPE OF (draughting_callout_relationship);
    WHERE
      wr1: SELF.name IN ['primary','secondary'];
      wr2: SIZEOF(TYPEOF(SELF.relating_draughting_callout) * [
               'ASSOCIATIVE_DRAUGHTING.ANGULAR_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.CURVE_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.DIAMETER_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.LEADER_DIRECTED_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.LINEAR_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.ORDINATE_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.RADIUS_DIMENSION']) = 1;
      wr3: SIZEOF(TYPEOF(SELF.related_draughting_callout) * [
               'ASSOCIATIVE_DRAUGHTING.DIMENSION_CURVE_DIRECTED_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.PROJECTION_DIRECTED_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.LEADER_DIRECTED_CALLOUT']) = 0;
      wr4: (SELF.related_draughting_callout.contents * SELF.
               relating_draughting_callout.contents) = SELF.
               related_draughting_callout.contents;
  END_ENTITY; -- dimension_callout_relationship

  ENTITY dimension_curve
    SUBTYPE OF (annotation_curve_occurrence);
    WHERE
      wr1: SIZEOF(USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'DIMENSION_CURVE_TERMINATOR.ANNOTATED_DIMENSION_CURVE')) 
               <= 2;
      wr2: SIZEOF(USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'DIMENSION_CURVE_DIRECTED_CALLOUT.CONTENTS')) >= 1;
      wr3: (SIZEOF(QUERY ( dct_1 <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'DIMENSION_CURVE_TERMINATOR.ANNOTATED_DIMENSION_CURVE') |
               (dct_1.role = origin) )) <= 1) AND (SIZEOF(
               QUERY ( dct_2 <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'DIMENSION_CURVE_TERMINATOR.ANNOTATED_DIMENSION_CURVE') | 
               (dct_2.role = target) )) <= 1);
  END_ENTITY; -- dimension_curve

  ENTITY dimension_curve_directed_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      wr1: SIZEOF(QUERY ( d_c <* SELF\draughting_callout.contents | (
               'ASSOCIATIVE_DRAUGHTING.DIMENSION_CURVE' IN TYPEOF(d_c)) )) 
               = 1;
      wr2: SIZEOF(SELF\draughting_callout.contents) >= 2;
  END_ENTITY; -- dimension_curve_directed_callout

  ENTITY dimension_curve_terminator
    SUBTYPE OF (terminator_symbol);
      role : dimension_extent_usage;
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.DIMENSION_CURVE' IN TYPEOF(SELF\
               terminator_symbol.annotated_curve);
  END_ENTITY; -- dimension_curve_terminator

  ENTITY dimension_pair
    SUBTYPE OF (draughting_callout_relationship);
    WHERE
      wr1: SELF.name IN ['chained','parallel'];
      wr2: SIZEOF(TYPEOF(SELF.relating_draughting_callout) * [
               'ASSOCIATIVE_DRAUGHTING.ANGULAR_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.CURVE_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.DIAMETER_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.LINEAR_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.ORDINATE_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.RADIUS_DIMENSION']) = 1;
      wr3: SIZEOF(TYPEOF(SELF.related_draughting_callout) * [
               'ASSOCIATIVE_DRAUGHTING.ANGULAR_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.CURVE_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.DIAMETER_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.LINEAR_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.ORDINATE_DIMENSION',
               'ASSOCIATIVE_DRAUGHTING.RADIUS_DIMENSION']) = 1;
  END_ENTITY; -- dimension_pair

  ENTITY dimension_text_associativity
    SUBTYPE OF (text_literal, mapped_item);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.SHAPE_DIMENSION_REPRESENTATION' IN 
               TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
      wr2: 'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_CALLOUT' IN TYPEOF(SELF\
               mapped_item.mapping_target);
      wr3: SIZEOF(QUERY ( ato <* QUERY ( si <* USEDIN(SELF,
               'ASSOCIATIVE_DRAUGHTING.STYLED_ITEM.ITEM') | (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
               TYPEOF(si)) ) | (NOT (SIZEOF(QUERY ( dc <* USEDIN(ato,
               'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_CALLOUT.' + 'CONTENTS')
                | ('ASSOCIATIVE_DRAUGHTING.DRAUGHTING_CALLOUT' IN TYPEOF(dc))
) 
               * [SELF\mapped_item.mapping_target]) = 1)) )) = 0;
  END_ENTITY; -- dimension_text_associativity

  ENTITY dimensional_characteristic_representation;
      dimension      : dimensional_characteristic;
      representation : shape_dimension_representation;
  END_ENTITY; -- dimensional_characteristic_representation

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY; -- dimensional_exponents

  ENTITY dimensional_location
    SUPERTYPE OF (ONEOF (angular_location,dimensional_location_with_path))
    SUBTYPE OF (shape_aspect_relationship);
  END_ENTITY; -- dimensional_location

  ENTITY dimensional_location_with_path
    SUBTYPE OF (dimensional_location);
      path : shape_aspect;
  END_ENTITY; -- dimensional_location_with_path

  ENTITY dimensional_size;
      applies_to : shape_aspect;
      name       : label;
    WHERE
      wr1: applies_to.product_definitional = TRUE;
  END_ENTITY; -- dimensional_size

  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0;
  END_ENTITY; -- direction

  ENTITY document;
      id          : identifier;
      name        : label;
      description : text;
      kind        : document_type;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- document

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
      assigned_document : document;
      source            : label;
  END_ENTITY; -- document_reference

  ENTITY document_type;
      product_data_type : label;
  END_ENTITY; -- document_type

  ENTITY draughting_annotation_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1 : (NOT ('ASSOCIATIVE_DRAUGHTING.ANNOTATION_CURVE_OCCURRENCE' IN 
                TYPEOF(SELF))) OR (SIZEOF(QUERY ( sty <* SELF.styles | (
                NOT ((SIZEOF(sty.styles) = 1) AND (
                'ASSOCIATIVE_DRAUGHTING.CURVE_STYLE' IN
                TYPEOF(sty.styles[1])))) )) 
                = 0);
      wr2 : (NOT ('ASSOCIATIVE_DRAUGHTING.ANNOTATION_FILL_AREA_OCCURRENCE' 
                IN TYPEOF(SELF))) OR (SIZEOF(QUERY ( sty <* SELF.styles | (
                NOT ((SIZEOF(sty.styles) = 1) AND (
                'ASSOCIATIVE_DRAUGHTING.FILL_AREA_STYLE' IN TYPEOF(sty.
                styles[1])))) )) = 0);
      wr3 : (NOT ('ASSOCIATIVE_DRAUGHTING.ANNOTATION_FILL_AREA_OCCURRENCE' 
                IN TYPEOF(SELF))) OR (SIZEOF(QUERY ( bound <* SELF.item\
                annotation_fill_area.boundaries | (NOT (SIZEOF(
                QUERY ( si <* USEDIN(bound,'ASSOCIATIVE_DRAUGHTING.' + 
                'STYLED_ITEM.ITEM') | (('ASSOCIATIVE_DRAUGHTING.' + 
                'ANNOTATION_CURVE_OCCURRENCE') IN TYPEOF(si)) )) > 0)) )) =
                 0);
      wr4 : (NOT ('ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL_OCCURRENCE' IN
                 TYPEOF(SELF))) OR (SIZEOF(QUERY ( sty <* SELF.styles | (
                NOT ((SIZEOF(sty.styles) = 1) AND (SIZEOF(TYPEOF(sty.styles
                [1]) * ['ASSOCIATIVE_DRAUGHTING.SYMBOL_STYLE',
                'ASSOCIATIVE_DRAUGHTING.NULL_STYLE']) = 1))) )) = 0);
      wr5 : (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL_OCCURRENCE' 
                IN TYPEOF(SELF)) AND (
                'ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL' IN TYPEOF(SELF.
                item)))) OR (SIZEOF(['ASSOCIATIVE_DRAUGHTING.' + 
                'DRAUGHTING_SYMBOL_REPRESENTATION',
                'ASSOCIATIVE_DRAUGHTING.' + 
                'DRAUGHTING_SUBFIGURE_REPRESENTATION'] * TYPEOF(SELF.item\
                mapped_item.mapping_source.mapped_representation)) = 1);
      wr6 : (NOT ('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF))) OR (SIZEOF(QUERY ( sty <* SELF.styles | (
                NOT ((SIZEOF(sty.styles) = 1) AND (
                'ASSOCIATIVE_DRAUGHTING.TEXT_STYLE' IN
                TYPEOF(sty.styles[1])))) )) 
                = 0);
      wr7 : NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND (SIZEOF(TYPEOF(SELF.item) * [
                'ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT',
                'ASSOCIATIVE_DRAUGHTING.TEXT_LITERAL']) = 1));
      wr8 : (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT' 
                IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( tl <* SELF.item\
                composite_text.collected_text | (NOT (
                'ASSOCIATIVE_DRAUGHTING.TEXT_LITERAL' IN TYPEOF(tl))) )) = 
                0);
      wr9 : (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('ASSOCIATIVE_DRAUGHTING.TEXT_LITERAL' IN
                 TYPEOF(SELF.item)))) OR (SELF.item\text_literal.alignment 
                IN ['baseline left','baseline centre','baseline right']);
      wr10: (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT' 
                IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( tl <* 
                QUERY ( text <* SELF.item\composite_text.collected_text | (
                'ASSOCIATIVE_DRAUGHTING.TEXT_LITERAL' IN TYPEOF(text)) ) | 
                (NOT (tl\text_literal.alignment IN ['baseline left',
                'baseline centre','baseline right'])) )) = 0);
      wr11: NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('ASSOCIATIVE_DRAUGHTING.TEXT_LITERAL' IN
                 TYPEOF(SELF.item)) AND EXISTS(SELF.item\text_literal.
                placement.ref_direction));
      wr12: (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT' 
                IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( tl <* 
                QUERY ( text <* SELF.item\composite_text.collected_text | (
                'ASSOCIATIVE_DRAUGHTING.TEXT_LITERAL' IN TYPEOF(text)) ) | 
                EXISTS(tl\text_literal.placement.ref_direction) )) = 0);
      wr13: (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT' 
                IN TYPEOF(SELF.item)))) OR check_text_alignment(SELF.item);
      wr14: (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT' 
                IN TYPEOF(SELF.item)))) OR check_text_font(SELF.item);
      wr15: (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT' 
                IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( tl <* 
                QUERY ( text <* SELF.item\composite_text.collected_text | (
                'ASSOCIATIVE_DRAUGHTING.TEXT_LITERAL' IN TYPEOF(text)) ) | 
                (NOT (SIZEOF(TYPEOF(tl) * ['ASSOCIATIVE_DRAUGHTING.' + 
                'TEXT_LITERAL_WITH_BLANKING_BOX','ASSOCIATIVE_DRAUGHTING.' 
                + 'TEXT_LITERAL_WITH_ASSOCIATED_CURVES']) = 0)) )) = 0);
      wr16: (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND
                ('ASSOCIATIVE_DRAUGHTING.TEXT_LITERAL_WITH_ASSOCIATED_CURVES' 
                IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( crv <* SELF.item
                \text_literal_with_associated_curves.associated_curves | (
                NOT (SIZEOF(QUERY ( si <* USEDIN(crv,
                'ASSOCIATIVE_DRAUGHTING.' + 'STYLED_ITEM.ITEM') | (
                'ASSOCIATIVE_DRAUGHTING.ANNOTATION_CURVE_OCCURRENCE' IN 
                TYPEOF(si)) )) > 0)) )) = 0);
      wr17: (NOT (('ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND
               ('ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES'
                IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( crv <* SELF.item
                \composite_text_with_associated_curves.associated_curves | 
                (NOT (SIZEOF(QUERY ( si <* USEDIN(crv,
                'ASSOCIATIVE_DRAUGHTING.' + 'STYLED_ITEM.ITEM') | (
                'ASSOCIATIVE_DRAUGHTING.ANNOTATION_CURVE_OCCURRENCE' IN 
                TYPEOF(si)) )) > 0)) )) = 0);
      wr18: SIZEOF(QUERY ( cs <* QUERY ( sty <* SELF.styles | (
                'ASSOCIATIVE_DRAUGHTING.CURVE_STYLE' IN TYPEOF(sty.styles[1]))
                 ) | (NOT (('ASSOCIATIVE_DRAUGHTING.LENGTH_MEASURE_WITH_UNIT' 
                IN TYPEOF(cs.styles[1]\curve_style.curve_width)) AND (
                'ASSOCIATIVE_DRAUGHTING.POSITIVE_LENGTH_MEASURE' IN TYPEOF(
                cs.styles[1]\curve_style.curve_width\measure_with_unit.
                value_component)))) )) = 0;
      wr19: SIZEOF(QUERY ( fas <* QUERY ( sty <* SELF.styles | (
                'ASSOCIATIVE_DRAUGHTING.FILL_AREA_STYLE' IN TYPEOF(sty.
                styles[1])) ) | (NOT ((SIZEOF(QUERY ( fs <* fas.styles[1]\
                fill_area_style.fill_styles | (
                'ASSOCIATIVE_DRAUGHTING.FILL_AREA_STYLE_TILES' IN TYPEOF(fs))
                )) <= 1) AND (SIZEOF(QUERY ( fst <* QUERY ( fs <*
                fas.styles[1]\fill_area_style.fill_styles | (
                'ASSOCIATIVE_DRAUGHTING.FILL_AREA_STYLE_TILES' IN TYPEOF(fs))
                ) | (NOT (SIZEOF(fst\fill_area_style_tiles.tiles) = 1)) )) =
                0))) )) = 0;
      wr20: SIZEOF(QUERY ( fas <* QUERY ( sty <* SELF.styles | (
                'ASSOCIATIVE_DRAUGHTING.FILL_AREA_STYLE' IN TYPEOF(sty.
                styles[1])) ) | (NOT (SIZEOF(QUERY ( fsh <* QUERY ( fs <* 
                fas.styles[1]\fill_area_style.fill_styles | (
                'ASSOCIATIVE_DRAUGHTING.FILL_AREA_STYLE_HATCHING' IN 
                TYPEOF(fs)) ) | (NOT (fsh\fill_area_style_hatching.
                point_of_reference_hatch_line :=: fsh\
                fill_area_style_hatching.pattern_start)) )) = 0)) )) = 0;
      wr21: SIZEOF(QUERY ( ts <* QUERY ( sty <* SELF.styles | (
                'ASSOCIATIVE_DRAUGHTING.TEXT_STYLE' IN TYPEOF(sty.styles[1]))
                ) | (NOT
                ('ASSOCIATIVE_DRAUGHTING.TEXT_STYLE_WITH_BOX_CHARACTERISTICS' 
                IN TYPEOF(ts.styles[1]))) )) = 0;
      wr22: SIZEOF(QUERY ( ts <* QUERY ( sty <* SELF.styles |
                ('ASSOCIATIVE_DRAUGHTING.TEXT_STYLE_WITH_BOX_CHARACTERISTICS' 
                IN TYPEOF(sty.styles[1])) ) | (NOT (SIZEOF(ts.styles[1]\
                text_style_with_box_characteristics.characteristics) = 4)) )) 
                = 0;
  END_ENTITY; -- draughting_annotation_occurrence

  ENTITY draughting_approval_assignment
    SUBTYPE OF (approval_assignment);
      approved_items : SET [1:?] OF approved_item;
    WHERE
      wr1: SIZEOF(QUERY ( item <* approved_items | (
               'ASSOCIATIVE_DRAUGHTING.DRAWING_REVISION' IN TYPEOF(item)) )) 
               <= 1;
  END_ENTITY; -- draughting_approval_assignment

  ENTITY draughting_callout
    SUBTYPE OF (geometric_representation_item);
      contents : SET [1:?] OF draughting_callout_element;
  END_ENTITY; -- draughting_callout

  ENTITY draughting_callout_relationship;
      name                        : label;
      description                 : text;
      relating_draughting_callout : draughting_callout;
      related_draughting_callout  : draughting_callout;
  END_ENTITY; -- draughting_callout_relationship

  ENTITY draughting_contract_assignment
    SUBTYPE OF (contract_assignment);
      items : SET [1:?] OF contracted_item;
  END_ENTITY; -- draughting_contract_assignment

  ENTITY draughting_drawing_revision
    SUBTYPE OF (drawing_revision);
    WHERE
      wr1 : (SIZEOF(USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET')) >= 1) AND (
                SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                'ASSOCIATIVE_DRAUGHTING.DRAWING_SHEET_REVISION' IN TYPEOF(
                ais.area))) )) = 0);
      wr2 : SIZEOF(QUERY ( app_ass <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.' + 
                'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') | (NOT (
                SIZEOF(USEDIN(app_ass.assigned_approval,
                'ASSOCIATIVE_DRAUGHTING.' + 
                'APPROVAL_DATE_TIME.DATED_APPROVAL')) = 1)) )) = 0;
      wr3 : SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( app_ass <* USEDIN(ais.area,
                'ASSOCIATIVE_DRAUGHTING.' + 
                'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') | (NOT (
                SIZEOF(USEDIN(app_ass.assigned_approval,
                'ASSOCIATIVE_DRAUGHTING.' + 
                'APPROVAL_DATE_TIME.DATED_APPROVAL')) = 1)) )) = 0)) )) = 0;
      wr4 : SIZEOF(QUERY ( app_ass <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.' + 
                'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') | (NOT (
                SIZEOF(USEDIN(app_ass.assigned_approval,
                'ASSOCIATIVE_DRAUGHTING.' + 
                'APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL')) >= 1)) ))

                = 0;
      wr5 : SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( app_ass <* USEDIN(ais.area,
                'ASSOCIATIVE_DRAUGHTING.' + 
                'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') | (NOT (
                SIZEOF(USEDIN(app_ass.assigned_approval,
                'ASSOCIATIVE_DRAUGHTING.' + 
                'APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL')) >= 1)) ))

                = 0)) )) = 0;
      wr6 : SIZEOF(USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
                'DRAUGHTING_TITLE.ITEMS')) <= 1;
      wr7 : SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(USEDIN(ais.area,'ASSOCIATIVE_DRAUGHTING.' + 
                'DRAUGHTING_TITLE.ITEMS')) <= 1)) )) = 0;
      wr8 : SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( item <* ais.area.items | (NOT (SIZEOF(
                TYPEOF(item) * ['ASSOCIATIVE_DRAUGHTING.STYLED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT',
                'ASSOCIATIVE_DRAUGHTING.PLANAR_BOX']) = 1)) )) = 0)) )) = 0;
      wr9 : SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( item <* ais.area.items | (SIZEOF(TYPEOF(item) 
                * ['ASSOCIATIVE_DRAUGHTING.STYLED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM']) = 1) )) > 0)) )) = 0;
      wr10: SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( p_b <* QUERY ( item <* ais.area.items | (
                'ASSOCIATIVE_DRAUGHTING.PLANAR_BOX' IN TYPEOF(item)) ) | (
                NOT (SIZEOF(USEDIN(p_b,'ASSOCIATIVE_DRAUGHTING.' + 
                'PRESENTATION_SIZE.SIZE')) = 1)) )) = 0)) )) 
                = 0;
      wr11: SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) ) | (
                NOT ('ASSOCIATIVE_DRAUGHTING.PRESENTATION_VIEW' IN TYPEOF(
                mi.mapping_source.mapped_representation))) )) = 0)) )) = 0;
      wr12: SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( a2p <* QUERY ( item <* ais.area.items | (
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT' IN TYPEOF(item)) )
                 | (NOT (SIZEOF(USEDIN(a2p,'ASSOCIATIVE_DRAUGHTING.' + 
                'MAPPED_ITEM.MAPPING_TARGET')) > 0)) )) = 0)) )) = 0;
      wr13: SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(ais.area.context_of_items.representations_in_context) 
                = 1)) )) = 0;
      wr14: SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) ) | (
                NOT (SIZEOF(USEDIN(mi.mapping_source.mapped_representation,
                'ASSOCIATIVE_DRAUGHTING.' + 
                'REPRESENTATION_MAP.MAPPED_REPRESENTATION')) = 1)) )) = 0)) )) 
               = 0;
      wr15: SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) ) | (
                NOT (SIZEOF(QUERY ( pv_item <* mi.mapping_source.
                mapped_representation.items | (NOT (SIZEOF(TYPEOF(pv_item) 
                * ['ASSOCIATIVE_DRAUGHTING.' + 'STYLED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.CAMERA_IMAGE',
                'ASSOCIATIVE_DRAUGHTING.' + 'AXIS2_PLACEMENT']) = 1)) )) = 
                0)) )) = 0)) )) = 0;
      wr16: SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) ) | (
                NOT (SIZEOF(QUERY ( pv_item <* mi.mapping_source.
                mapped_representation.items | (
                'ASSOCIATIVE_DRAUGHTING.CAMERA_IMAGE' IN TYPEOF(pv_item)) )) 
                = 1)) )) = 0)) )) = 0;
      wr17: SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) ) | (
                NOT (SIZEOF(QUERY ( a2p <* QUERY ( pv_item <* mi.
                mapping_source.mapped_representation.items | (
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT' IN TYPEOF(pv_item)) )
                 | (('ASSOCIATIVE_DRAUGHTING.' + 
                'MAPPING_SOURCE.MAPPING_ORIGIN') IN ROLESOF(a2p)) )) = 1)) )) 
                = 0)) )) = 0;
      wr18: SIZEOF(QUERY ( ais <* USEDIN(SELF,
                'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET.IN_SET') | (NOT (
                SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) ) | (
                NOT (SIZEOF(mi.mapping_source.mapped_representation.
                context_of_items.representations_in_context) = 1)) )) = 0)) )) 
               = 0;
  END_ENTITY; -- draughting_drawing_revision

  ENTITY draughting_elements
    SUBTYPE OF (draughting_callout);
    WHERE
      wr1: SIZEOF(QUERY ( l_c <* QUERY ( con <* SELF.contents | (
               'ASSOCIATIVE_DRAUGHTING.LEADER_CURVE' IN TYPEOF(con)) ) | (
               NOT (SIZEOF(QUERY ( ldc <* USEDIN(l_c,
               'ASSOCIATIVE_DRAUGHTING.' + 'DRAUGHTING_CALLOUT.CONTENTS')
                | ('ASSOCIATIVE_DRAUGHTING.LEADER_DIRECTED_CALLOUT' IN 
               TYPEOF(ldc)) )) <= 1)) )) = 0;
      wr2: (NOT ('ASSOCIATIVE_DRAUGHTING.DIMENSION_CURVE_DIRECTED_CALLOUT' 
               IN TYPEOF(SELF))) OR (SIZEOF(QUERY ( con <* SELF.contents | 
               ('ASSOCIATIVE_DRAUGHTING.PROJECTION_CURVE' IN TYPEOF(con)) )) 
               <= 2);
      wr3: SIZEOF(QUERY ( rc <* USEDIN(SELF,
               'ASSOCIATIVE_DRAUGHTING.DIMENSION_CALLOUT_' + 
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') | (rc.name = 
               'primary') )) <= 1;
      wr4: SIZEOF(QUERY ( rc <* USEDIN(SELF,
               'ASSOCIATIVE_DRAUGHTING.DIMENSION_CALLOUT_' + 
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') | (rc.name = 
               'secondary') )) <= 1;
      wr5: SIZEOF(QUERY ( sec <* QUERY ( rc <* USEDIN(SELF,
               'ASSOCIATIVE_DRAUGHTING.DIMENSION_CALLOUT_' + 
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') | (rc.name = 
               'secondary') ) | (NOT (SIZEOF(QUERY ( prim <* USEDIN(SELF,
               'ASSOCIATIVE_DRAUGHTING.DIMENSION_CALLOUT_' + 
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') | (prim.name = 
               'primary') )) = 1)) )) = 0;
  END_ENTITY; -- draughting_elements

  ENTITY draughting_group_elements_assignment
    SUBTYPE OF (group_assignment);
      items : SET [1:?] OF draughting_group_element;
  END_ENTITY; -- draughting_group_elements_assignment

  ENTITY draughting_model
    SUBTYPE OF (representation);
    UNIQUE
      ur1 : name;
    WHERE
      wr1: SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
               'ASSOCIATIVE_DRAUGHTING.STYLED_ITEM',
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT'] * TYPEOF(it)) = 1))
               )) = 0;
      wr2: SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(['ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION',
               'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_MODEL'] * TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation)) = 1)) )) 
               = 0;
      wr3: SIZEOF(QUERY ( smi <* QUERY ( si <* QUERY ( it <* SELF.items | 
               ('ASSOCIATIVE_DRAUGHTING.STYLED_ITEM' IN TYPEOF(it)) ) | (
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(si\
               styled_item.item)) ) | (NOT ((
               'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION' IN TYPEOF(smi\
               styled_item.item\mapped_item.mapping_source.
               mapped_representation)) AND (SIZEOF(QUERY ( sty <* smi\
               styled_item.styles | (NOT (SIZEOF(QUERY ( psa <* sty.styles
                | (NOT ('ASSOCIATIVE_DRAUGHTING.CURVE_STYLE' IN TYPEOF(psa)))
               )) = 1)) )) = 1)) ))) = 0;
  END_ENTITY; -- draughting_model

  ENTITY draughting_organization_assignment
    SUBTYPE OF (organization_assignment);
      assigned_items : SET [1:?] OF draughting_organization_item;
  END_ENTITY; -- draughting_organization_assignment

  ENTITY draughting_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      assigned_items : SET [1:?] OF draughting_organization_item;
  END_ENTITY; -- draughting_person_and_organization_assignment

  ENTITY draughting_person_assignment
    SUBTYPE OF (person_assignment);
      assigned_items : SET [1:?] OF draughting_organization_item;
  END_ENTITY; -- draughting_person_assignment

  ENTITY draughting_pre_defined_colour
    SUBTYPE OF (pre_defined_colour);
    WHERE
      wr1: SELF.name IN ['black','red','green','blue','yellow','magenta',
               'cyan','white'];
  END_ENTITY; -- draughting_pre_defined_colour

  ENTITY draughting_pre_defined_curve_font
    SUBTYPE OF (pre_defined_curve_font);
    WHERE
      wr1: SELF.name IN ['continuous','chain','chain double dash','dashed',
               'dotted'];
  END_ENTITY; -- draughting_pre_defined_curve_font

  ENTITY draughting_pre_defined_text_font
    SUBTYPE OF (pre_defined_text_font);
    WHERE
      wr1: SELF.name IN ['ISO 3098-1 font A','ISO 3098-1 font B'];
  END_ENTITY; -- draughting_pre_defined_text_font

  ENTITY draughting_presented_item
    SUBTYPE OF (presented_item);
      items : SET [1:?] OF draughting_presented_item_select;
    WHERE
      wr1: SIZEOF(QUERY ( pir <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'PRESENTED_ITEM_REPRESENTATION.ITEM') | (NOT (
               'ASSOCIATIVE_DRAUGHTING.DRAWING_REVISION' IN TYPEOF(pir.
               presentation))) )) = 0;
  END_ENTITY; -- draughting_presented_item

  ENTITY draughting_security_classification_assignment
    SUBTYPE OF (security_classification_assignment);
      assigned_items : SET [1:?] OF classified_item;
  END_ENTITY; -- draughting_security_classification_assignment

  ENTITY draughting_specification_reference
    SUBTYPE OF (document_reference);
      specified_items : SET [1:?] OF specified_item;
    WHERE
      wr1: SELF.assigned_document.kind.product_data_type = 
               'draughting specification';
  END_ENTITY; -- draughting_specification_reference

  ENTITY draughting_subfigure_representation
    SUBTYPE OF (symbol_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF\representation.items | (NOT (
               SIZEOF(['ASSOCIATIVE_DRAUGHTING.ANNOTATION_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT'] * TYPEOF(item)) = 
               1)) )) = 0;
      wr2: SIZEOF(QUERY ( item <* SELF\representation.items | (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_CALLOUT'] * TYPEOF(item)) 
               = 1) )) >= 1;
      wr3: SIZEOF(QUERY ( srm <* QUERY ( rm <* USEDIN(SELF,
               'ASSOCIATIVE_DRAUGHTING.' + 
               'REPRESENTATION_MAP.MAPPED_REPRESENTATION') | (
               'ASSOCIATIVE_DRAUGHTING.SYMBOL_REPRESENTATION_MAP' IN 
               TYPEOF(rm)) ) | (NOT (SIZEOF(QUERY ( a_s <* QUERY ( mi <* 
               srm.map_usage | ('ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL' 
               IN TYPEOF(mi)) ) | (NOT (SIZEOF(QUERY ( aso <* USEDIN(a_s,
               'ASSOCIATIVE_DRAUGHTING.STYLED_ITEM.ITEM') | (NOT (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_SUBFIGURE_OCCURRENCE' IN 
               TYPEOF(aso))) )) = 0)) )) = 0)) )) > 0;
      wr4: NOT acyclic_mapped_item_usage(SELF);
      wr5: SIZEOF(SELF.context_of_items.representations_in_context) = 1;
  END_ENTITY; -- draughting_subfigure_representation

  ENTITY draughting_symbol_representation
    SUBTYPE OF (symbol_representation);
    UNIQUE
      ur1 : name;
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF\representation.items | (NOT (
               SIZEOF(TYPEOF(item) * [
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_CURVE_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_FILL_AREA_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT']) = 1)) )) = 0;
      wr2: SIZEOF(QUERY ( item <* SELF\representation.items | (SIZEOF(
               TYPEOF(item) * [
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_CURVE_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_FILL_AREA_OCCURRENCE',
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE']) = 1) )) 
               >= 1;
      wr3: SIZEOF(QUERY ( item <* SELF\representation.items | (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_SUBFIGURE_OCCURRENCE' IN 
               TYPEOF(item)) )) = 0;
      wr4: SIZEOF(QUERY ( srm <* QUERY ( rm <* USEDIN(SELF,
               'ASSOCIATIVE_DRAUGHTING.' + 
               'REPRESENTATION_MAP.MAPPED_REPRESENTATION') | (
               'ASSOCIATIVE_DRAUGHTING.SYMBOL_REPRESENTATION_MAP' IN 
               TYPEOF(rm)) ) | (NOT (SIZEOF(QUERY ( a_s <* QUERY ( mi <* 
               srm.map_usage | ('ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL' 
               IN TYPEOF(mi)) ) | (NOT (SIZEOF(QUERY ( aso <* USEDIN(a_s,
               'ASSOCIATIVE_DRAUGHTING.STYLED_ITEM.ITEM') | (NOT (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_SYMBOL_OCCURRENCE' IN 
               TYPEOF(aso))) )) = 0)) )) = 0)) )) > 0;
      wr5: NOT acyclic_mapped_item_usage(SELF);
      wr6: SIZEOF(SELF.context_of_items.representations_in_context) = 1;
  END_ENTITY; -- draughting_symbol_representation

  ENTITY draughting_text_literal_with_delineation
    SUBTYPE OF (text_literal_with_delineation);
    WHERE
      wr1: SELF.delineation IN ['underline','overline'];
  END_ENTITY; -- draughting_text_literal_with_delineation

  ENTITY draughting_title;
      items    : SET [1:?] OF draughting_titled_item;
      language : label;
      contents : text;
  END_ENTITY; -- draughting_title

  ENTITY drawing_definition;
      drawing_number : identifier;
      drawing_type   : OPTIONAL label;
  END_ENTITY; -- drawing_definition

  ENTITY drawing_revision
    SUBTYPE OF (presentation_set);
      revision_identifier : identifier;
      drawing_identifier  : drawing_definition;
      intended_scale      : OPTIONAL text;
    UNIQUE
      ur1 : revision_identifier, drawing_identifier;
  END_ENTITY; -- drawing_revision

  ENTITY drawing_sheet_layout
    SUBTYPE OF (draughting_symbol_representation);
  END_ENTITY; -- drawing_sheet_layout

  ENTITY drawing_sheet_revision
    SUBTYPE OF (presentation_area);
      revision_identifier : identifier;
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) AND (
               'ASSOCIATIVE_DRAUGHTING.DRAWING_SHEET_REVISION' IN TYPEOF(
               item\mapped_item.mapping_source.mapped_representation))) )) 
               = 0;
  END_ENTITY; -- drawing_sheet_revision

  ENTITY drawing_sheet_revision_usage
    SUBTYPE OF (area_in_set);
      sheet_number : identifier;
    UNIQUE
      ur1 : sheet_number, in_set;
    WHERE
      wr1: ('ASSOCIATIVE_DRAUGHTING.DRAWING_SHEET_REVISION' IN TYPEOF(
               SELF\area_in_set.area)) AND 
               ('ASSOCIATIVE_DRAUGHTING.DRAWING_REVISION' IN TYPEOF(SELF\
               area_in_set.in_set));
  END_ENTITY; -- drawing_sheet_revision_usage

  ENTITY edge
    SUPERTYPE OF (ONEOF (edge_curve,oriented_edge))
    SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY; -- edge

  ENTITY edge_based_2d_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : SIZEOF(QUERY ( it <* SELF\representation.items | (NOT (SIZEOF(
                ['ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_2D'] * TYPEOF(it)) 
                = 1)) )) = 0;
      wr2 : SIZEOF(QUERY ( it <* SELF\representation.items | (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                >= 1;
      wr3 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( edges <* eb.ces_edges | (NOT (
                'ASSOCIATIVE_DRAUGHTING.EDGE_CURVE' IN TYPEOF(edges))) )) =
                 0)) )) = 0)) )) = 0;
      wr4 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( pline_edges <* QUERY ( edges <* eb.ces_edges | (
                'ASSOCIATIVE_DRAUGHTING.POLYLINE' IN TYPEOF(edges\
                edge_curve.edge_geometry)) ) | (NOT (SIZEOF(pline_edges\
                edge_curve.edge_geometry\polyline.points) > 2)) )) = 0)) )) 
                = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( edges <* eb.ces_edges | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(edges.
                edge_start)) AND ('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN 
                TYPEOF(edges.edge_end)))) )) = 0)) )) = 0)) )) = 0;
      wr6 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( edges <* eb.ces_edges | (NOT 
                valid_2d_wireframe_edge_curve(edges\edge_curve.
                edge_geometry,'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0)) )) 
                = 0;
      wr7 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( edges <* eb.ces_edges | (NOT (
                valid_wireframe_vertex_point(edges.edge_start\vertex_point.
                vertex_geometry,'ASSOCIATIVE_DRAUGHTING') AND 
                valid_wireframe_vertex_point(edges.edge_end\vertex_point.
                vertex_geometry,'ASSOCIATIVE_DRAUGHTING'))) )) = 0)) )) = 0))
                )) = 0;
      wr8 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( con_edges <* QUERY ( edges <* eb.ces_edges | (
                'ASSOCIATIVE_DRAUGHTING.CONIC' IN TYPEOF(edges\edge_curve.
                edge_geometry)) ) | (NOT (
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_2D' IN TYPEOF(
                con_edges\edge_curve.edge_geometry\conic.position))) )) = 0))
                )) = 0)) )) = 0;
      wr9 : SIZEOF(QUERY ( mi <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) )
                 | (NOT (('ASSOCIATIVE_DRAUGHTING.' + 
                'EDGE_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(
                mi\mapped_item.mapping_source.mapped_representation))) )) =
                 0;
      wr10: SELF\representation.context_of_items\
                geometric_representation_context.coordinate_space_dimension 
                = 2;
  END_ENTITY; -- edge_based_2d_wireframe_shape_representation

  ENTITY edge_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
  END_ENTITY; -- edge_based_wireframe_model

  ENTITY edge_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
                = 1)) )) = 0;
      wr2 : SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                >= 1;
      wr3 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( edges <* eb.ces_edges | (NOT (
                'ASSOCIATIVE_DRAUGHTING.EDGE_CURVE' IN TYPEOF(edges))) )) =
                 0)) )) = 0)) )) = 0;
      wr4 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( pline_edges <* QUERY ( edges <* eb.ces_edges | (
                'ASSOCIATIVE_DRAUGHTING.POLYLINE' IN TYPEOF(edges\
                edge_curve.edge_geometry)) ) | (NOT (SIZEOF(pline_edges\
                edge_curve.edge_geometry\polyline.points) > 2)) )) = 0)) )) 
                = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( edges <* eb.ces_edges | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(edges.
                edge_start)) AND ('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN 
                TYPEOF(edges.edge_end)))) )) = 0)) )) = 0)) )) = 0;
      wr6 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( edges <* eb.ces_edges | (NOT 
                valid_wireframe_edge_curve(edges\edge_curve.edge_geometry,
                'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0)) )) = 0;
      wr7 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( edges <* eb.ces_edges | (NOT (
                valid_wireframe_vertex_point(edges.edge_start\vertex_point.
                vertex_geometry,'ASSOCIATIVE_DRAUGHTING') AND 
                valid_wireframe_vertex_point(edges.edge_end\vertex_point.
                vertex_geometry,'ASSOCIATIVE_DRAUGHTING'))) )) = 0)) )) =
                 0)) )) = 0;
      wr8 : SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
                edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
                QUERY ( con_edges <* QUERY ( edges <* eb.ces_edges | (
                'ASSOCIATIVE_DRAUGHTING.CONIC' IN TYPEOF(edges\edge_curve.
                edge_geometry)) ) | (NOT (
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D' IN TYPEOF(
                con_edges\edge_curve.edge_geometry\conic.position))) )) = 0))
                )) = 0)) )) = 0;
      wr9 : SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) ) | (
                NOT (('ASSOCIATIVE_DRAUGHTING.' + 
                'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
                mapped_item.mapping_source.mapped_representation))) )) = 0;
      wr10: SELF.context_of_items\geometric_representation_context.
                coordinate_space_dimension = 3;
  END_ENTITY; -- edge_based_wireframe_shape_representation

  ENTITY edge_curve
    SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense    : BOOLEAN;
  END_ENTITY; -- edge_curve

  ENTITY edge_loop
    SUBTYPE OF (loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].
               edge_end;
  END_ENTITY; -- edge_loop

  ENTITY elementary_2d_geometric_curve_set_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SELF\representation.context_of_items\
               geometric_representation_context.coordinate_space_dimension 
               = 2;
      wr2: SIZEOF(QUERY ( item <* SELF\representation.items | (NOT (
               SIZEOF(['ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_2D'] * TYPEOF(item)) 
               = 1)) )) = 0;
      wr3: SIZEOF(QUERY ( item <* SELF\representation.items | (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
               >= 1;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF\representation.items
                | ('ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) )
                | (NOT (('ASSOCIATIVE_DRAUGHTING.' + 
               'ELEMENTARY_2D_GEOMETRIC_CURVE_SET_SHAPE_REPRESENTATION') IN
                TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))
                )) = 0;
      wr5: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF\representation.items
                | ('ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(
               item)) ) | (NOT (SIZEOF(QUERY ( elem <* gcs\geometric_set.
               elements | (NOT (SIZEOF(TYPEOF(elem) * [
               'ASSOCIATIVE_DRAUGHTING.CIRCLE',
               'ASSOCIATIVE_DRAUGHTING.COMPOSITE_CURVE',
               'ASSOCIATIVE_DRAUGHTING.ELLIPSE',
               'ASSOCIATIVE_DRAUGHTING.POINT',
               'ASSOCIATIVE_DRAUGHTING.POLYLINE',
               'ASSOCIATIVE_DRAUGHTING.TRIMMED_CURVE']) = 1)) )) = 0)) )) =
                0;
      wr6: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF\representation.items
                | ('ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(
               item)) ) | (NOT (SIZEOF(QUERY ( tc <* QUERY ( elem <* gcs\
               geometric_set.elements | (
               'ASSOCIATIVE_DRAUGHTING.TRIMMED_CURVE' IN TYPEOF(elem)) ) | 
               (NOT valid_elementary_trimmed_curves_in_set(tc\trimmed_curve
               .basis_curve,'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0;
      wr7: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF\representation.items
                | ('ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(
               item)) ) | (NOT (SIZEOF(QUERY ( pnt <* QUERY ( elem <* gcs\
               geometric_set.elements | ('ASSOCIATIVE_DRAUGHTING.POINT' IN 
               TYPEOF(elem)) ) | (NOT (SIZEOF(TYPEOF(pnt) * [
               'ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT',
               'ASSOCIATIVE_DRAUGHTING.POINT_ON_CURVE']) = 1)) )) = 0)) )) 
               = 0;
      wr8: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF\representation.items
                | ('ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(
               item)) ) | (NOT (SIZEOF(QUERY ( pl <* QUERY ( elem <* gcs\
               geometric_set.elements | ('ASSOCIATIVE_DRAUGHTING.POLYLINE' 
               IN TYPEOF(elem)) ) | (NOT (SIZEOF(pl\polyline.points) > 2)) )) 
               = 0)) )) = 0;
  END_ENTITY; -- elementary_2d_geometric_curve_set_shape_representation

  ENTITY elementary_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP',
                'ASSOCIATIVE_DRAUGHTING.FACETED_BREP',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
                = 1)) )) = 0;
      wr2 : SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                > 0;
      wr3 : SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
                'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh.
                cfs_faces | (NOT ('ASSOCIATIVE_DRAUGHTING.FACE_SURFACE' IN 
                TYPEOF(fcs))) )) = 0)) )) = 0)) )) = 0;
      wr4 : SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
                'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh\
                connected_face_set.cfs_faces | (NOT (
                'ASSOCIATIVE_DRAUGHTING.ELEMENTARY_SURFACE' IN TYPEOF(fcs\
                face_surface.face_geometry))) )) = 0)) )) = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
                'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh\
                connected_face_set.cfs_faces | (NOT (SIZEOF(
                QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ('ASSOCIATIVE_DRAUGHTING.EDGE_CURVE' IN 
                TYPEOF(oe.edge_element))) )) = 0)) )) = 0)) )) = 0)) )) = 0))
                )) = 0;
      wr6 : SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
                'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh\
                connected_face_set.cfs_faces | (NOT (SIZEOF(
                QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (SIZEOF(['ASSOCIATIVE_DRAUGHTING.LINE',
                'ASSOCIATIVE_DRAUGHTING.CONIC',
                'ASSOCIATIVE_DRAUGHTING.POLYLINE'] * TYPEOF(oe.edge_element
                \edge_curve.edge_geometry)) = 1)) )) = 0)) )) = 0)) )) = 0))
                )) = 0)) )) = 0;
      wr7 : SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
                'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh\
                connected_face_set.cfs_faces | (NOT (SIZEOF(
                QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN
                 TYPEOF(oe.edge_start)) AND (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end)))) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr8 : SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
                'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh\
                connected_face_set.cfs_faces | (NOT (SIZEOF(
                QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | ('ASSOCIATIVE_DRAUGHTING.ORIENTED_PATH' IN TYPEOF(
                elp_fbnds.bound)) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr9 : SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                 | ('ASSOCIATIVE_DRAUGHTING.ORIENTED_CLOSED_SHELL' IN 
                TYPEOF(msb\manifold_solid_brep.outer)) )) = 0;
      wr10: SIZEOF(QUERY ( brv <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.BREP_WITH_VOIDS' IN TYPEOF(it)) )
                 | (NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | 
                csh\oriented_closed_shell.orientation )) = 0)) )) = 0;
      wr11: SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) ) | (
                NOT
               ('ASSOCIATIVE_DRAUGHTING.ELEMENTARY_BREP_SHAPE_REPRESENTATION' 
                IN TYPEOF(mi\mapped_item.mapping_source.
                mapped_representation))) )) = 0;
      wr12: SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
                'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh\
                connected_face_set.cfs_faces | (NOT (SIZEOF(
                QUERY ( vlp_fbnds <* QUERY ( bnds <* fcs.bounds | (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND (
                'ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry)))) )) = 0)) )) = 0)) )) = 0)) )) 
               = 0;
  END_ENTITY; -- elementary_brep_shape_representation

  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (plane,cylindrical_surface,conical_surface,
        spherical_surface,toroidal_surface))
    SUBTYPE OF (surface);
      position : axis2_placement_3d;
  END_ENTITY; -- elementary_surface

  ENTITY ellipse
    SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY; -- ellipse

  ENTITY evaluated_degenerate_pcurve
    SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
  END_ENTITY; -- evaluated_degenerate_pcurve

  ENTITY external_source;
      source_id : source_item;
  END_ENTITY; -- external_source

  ENTITY externally_defined_curve_font
    SUBTYPE OF (externally_defined_item);
  END_ENTITY; -- externally_defined_curve_font

  ENTITY externally_defined_hatch_style
    SUBTYPE OF (externally_defined_item, geometric_representation_item);
  END_ENTITY; -- externally_defined_hatch_style

  ENTITY externally_defined_item;
      item_id : source_item;
      source  : external_source;
  END_ENTITY; -- externally_defined_item

  ENTITY externally_defined_symbol
    SUBTYPE OF (externally_defined_item);
  END_ENTITY; -- externally_defined_symbol

  ENTITY externally_defined_text_font
    SUBTYPE OF (externally_defined_item);
  END_ENTITY; -- externally_defined_text_font

  ENTITY externally_defined_tile_style
    SUBTYPE OF (externally_defined_item, geometric_representation_item);
  END_ENTITY; -- externally_defined_tile_style

  ENTITY face
    SUPERTYPE OF (ONEOF (face_surface,oriented_face))
    SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      wr1: NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)));
      wr2: SIZEOF(QUERY ( temp <* bounds | (
               'ASSOCIATIVE_DRAUGHTING.FACE_OUTER_BOUND' IN TYPEOF(temp)) )) 
               <= 1;
  END_ENTITY; -- face

  ENTITY face_bound
    SUBTYPE OF (topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY; -- face_bound

  ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
  END_ENTITY; -- face_outer_bound

  ENTITY face_surface
    SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense    : BOOLEAN;
  END_ENTITY; -- face_surface

  ENTITY faceted_brep
    SUBTYPE OF (manifold_solid_brep);
  END_ENTITY; -- faceted_brep

  ENTITY faceted_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.FACETED_BREP',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
                1)) )) = 0;
      wr2: SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.FACETED_BREP',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               > 0;
      wr3: SIZEOF(QUERY ( fbrep <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.FACETED_BREP' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( csh <* msb_shells(fbrep,
               'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh.
               cfs_faces | (NOT (('ASSOCIATIVE_DRAUGHTING.FACE_SURFACE' IN 
               TYPEOF(fcs)) AND ('ASSOCIATIVE_DRAUGHTING.PLANE' IN TYPEOF(
               fcs\face_surface.face_geometry)) AND (
               'ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT' IN TYPEOF(fcs\
               face_surface.face_geometry\elementary_surface.position.
               location)))) )) = 0)) )) = 0)) )) = 0;
      wr4: SIZEOF(QUERY ( fbrep <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.FACETED_BREP' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( csh <* msb_shells(fbrep,
               'ASSOCIATIVE_DRAUGHTING') | (NOT (SIZEOF(QUERY ( fcs <* csh.
               cfs_faces | (NOT (SIZEOF(QUERY ( bnds <* fcs.bounds | (
               'ASSOCIATIVE_DRAUGHTING.FACE_OUTER_BOUND' IN TYPEOF(bnds)) )) 
               = 1)) )) = 0)) )) = 0)) )) = 0;
      wr5: SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | ('ASSOCIATIVE_DRAUGHTING.ORIENTED_CLOSED_SHELL' IN 
               TYPEOF(msb\manifold_solid_brep.outer)) )) = 0;
      wr6: SIZEOF(QUERY ( brv <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | 
               (NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | csh\
               oriented_closed_shell.orientation )) = 0)) )) = 0;
      wr7: SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (
               'ASSOCIATIVE_DRAUGHTING.FACETED_BREP_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0;
  END_ENTITY; -- faceted_brep_shape_representation

  ENTITY fill_area_style;
      name        : label;
      fill_styles : SET [1:?] OF fill_style_select;
    WHERE
      wr1: SIZEOF(QUERY ( fill_style <* SELF.fill_styles | ((
               'ASSOCIATIVE_DRAUGHTING.' + 'FILL_AREA_STYLE_COLOUR') IN 
               TYPEOF(fill_style)) )) <= 1;
  END_ENTITY; -- fill_area_style

  ENTITY fill_area_style_colour;
      name        : label;
      fill_colour : colour;
  END_ENTITY; -- fill_area_style_colour

  ENTITY fill_area_style_hatching
    SUBTYPE OF (geometric_representation_item);
      hatch_line_appearance         : curve_style;
      start_of_next_hatch_line      : one_direction_repeat_factor;
      point_of_reference_hatch_line : cartesian_point;
      pattern_start                 : cartesian_point;
      hatch_line_angle              : plane_angle_measure;
  END_ENTITY; -- fill_area_style_hatching

  ENTITY fill_area_style_tile_symbol_with_style
    SUBTYPE OF (geometric_representation_item);
      symbol : annotation_symbol_occurrence;
  END_ENTITY; -- fill_area_style_tile_symbol_with_style

  ENTITY fill_area_style_tiles
    SUBTYPE OF (geometric_representation_item);
      tiling_pattern : two_direction_repeat_factor;
      tiles          : SET [1:?] OF fill_area_style_tile_shape_select;
      tiling_scale   : positive_ratio_measure;
  END_ENTITY; -- fill_area_style_tiles

  ENTITY functionally_defined_transformation;
      name        : label;
      description : text;
  END_ENTITY; -- functionally_defined_transformation

  ENTITY geometric_curve_set
    SUBTYPE OF (geometric_set);
    WHERE
      wr1: SIZEOF(QUERY ( temp <* SELF\geometric_set.elements | (
               'ASSOCIATIVE_DRAUGHTING.SURFACE' IN TYPEOF(temp)) )) = 0;
  END_ENTITY; -- geometric_curve_set

  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY; -- geometric_representation_context

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (point,direction,vector,placement,
        cartesian_transformation_operator,curve,surface,edge_curve,
        face_surface,poly_loop,vertex_point,solid_model,
        shell_based_surface_model,shell_based_wireframe_model,
        edge_based_wireframe_model,geometric_set))
    SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (NOT 
               ('ASSOCIATIVE_DRAUGHTING.GEOMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(using_rep.context_of_items))) )) = 0;
  END_ENTITY; -- geometric_representation_item

  ENTITY geometric_set
    SUPERTYPE OF (geometric_curve_set)
    SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY; -- geometric_set

  ENTITY geometrical_tolerance_callout
    SUBTYPE OF (draughting_callout);
  END_ENTITY; -- geometrical_tolerance_callout

  ENTITY geometrically_bounded_2d_wireframe_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 2;
      wr2: SIZEOF(QUERY ( item <* SELF.items | (NOT (SIZEOF(TYPEOF(item) *
                ['ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET',
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_2D',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM']) = 1)) )) = 0;
      wr3: SIZEOF(QUERY ( item <* SELF.items | (SIZEOF(TYPEOF(item) * [
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM']) = 1) )) >= 1;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (('ASSOCIATIVE_DRAUGHTING.' + 
               'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))
               )) = 0;
      wr5: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(item)) )
                | (NOT (SIZEOF(QUERY ( elem <* gcs\geometric_set.elements
                | (NOT (SIZEOF(TYPEOF(elem) * [
               'ASSOCIATIVE_DRAUGHTING.B_SPLINE_CURVE',
               'ASSOCIATIVE_DRAUGHTING.CIRCLE',
               'ASSOCIATIVE_DRAUGHTING.COMPOSITE_CURVE',
               'ASSOCIATIVE_DRAUGHTING.ELLIPSE',
               'ASSOCIATIVE_DRAUGHTING.OFFSET_CURVE_2D',
               'ASSOCIATIVE_DRAUGHTING.POINT',
               'ASSOCIATIVE_DRAUGHTING.POLYLINE',
               'ASSOCIATIVE_DRAUGHTING.TRIMMED_CURVE']) = 1)) )) = 0)) )) =
                0;
      wr6: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(item)) )
                | (NOT (SIZEOF(QUERY ( crv <* QUERY ( elem <* gcs\
               geometric_set.elements | ('ASSOCIATIVE_DRAUGHTING.CURVE' IN 
               TYPEOF(elem)) ) | (NOT valid_basis_curve_in_2d_wireframe(crv,
               'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0;
      wr7: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(item)) )
                | (NOT (SIZEOF(QUERY ( pnt <* QUERY ( elem <* gcs\
               geometric_set.elements | ('ASSOCIATIVE_DRAUGHTING.POINT' IN 
               TYPEOF(elem)) ) | (NOT (SIZEOF(TYPEOF(pnt) * [
               'ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT',
               'ASSOCIATIVE_DRAUGHTING.POINT_ON_CURVE']) = 1)) )) = 0)) )) 
               = 0;
      wr8: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(item)) )
                | (NOT (SIZEOF(QUERY ( pl <* QUERY ( elem <* gcs\
               geometric_set.elements | ('ASSOCIATIVE_DRAUGHTING.POLYLINE' 
               IN TYPEOF(elem)) ) | (NOT (SIZEOF(pl\polyline.points) > 2)) )) 
               = 0)) )) = 0;
  END_ENTITY; -- geometrically_bounded_2d_wireframe_representation

  ENTITY geometrically_bounded_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_SET',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
                1)) )) = 0;
      wr2: SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_SET',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               > 0;
      wr3: SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (('ASSOCIATIVE_DRAUGHTING.' + 
               'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))
               )) = 0;
      wr4: SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_SET' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( pnt <* QUERY ( gsel <* gs\geometric_set.
               elements | ('ASSOCIATIVE_DRAUGHTING.POINT' IN TYPEOF(gsel)) )
                | (NOT gbsf_check_point(pnt)) )) = 0)) )) = 0;
      wr5: SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_SET' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( cv <* QUERY ( gsel <* gs\geometric_set.
               elements | ('ASSOCIATIVE_DRAUGHTING.CURVE' IN TYPEOF(gsel)) )
                | (NOT gbsf_check_curve(cv)) )) = 0)) )) = 0;
      wr6: SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_SET' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( sf <* QUERY ( gsel <* gs\geometric_set.
               elements | ('ASSOCIATIVE_DRAUGHTING.SURFACE' IN TYPEOF(gsel)) )
                | (NOT gbsf_check_surface(sf)) )) = 0)) )) = 0;
  END_ENTITY; -- geometrically_bounded_surface_shape_representation

  ENTITY geometrically_bounded_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(TYPEOF(it) * [
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET',
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM']) = 1)) )) = 0;
      wr2: SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(TYPEOF(it) * [
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET',
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM']) = 1) )) >= 1;
      wr3: SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( crv <* QUERY ( elem <* gcs\
               geometric_set.elements | ('ASSOCIATIVE_DRAUGHTING.CURVE' IN 
               TYPEOF(elem)) ) | (NOT valid_geometrically_bounded_wf_curve(
               crv,'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0;
      wr4: SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( pnts <* QUERY ( elem <* gcs\
               geometric_set.elements | ('ASSOCIATIVE_DRAUGHTING.POINT' IN 
               TYPEOF(elem)) ) | (NOT valid_geometrically_bounded_wf_point(
               pnts,'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0;
      wr5: SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( cnc <* QUERY ( elem <* gcs\
               geometric_set.elements | ('ASSOCIATIVE_DRAUGHTING.CONIC' IN 
               TYPEOF(elem)) ) | (NOT (
               'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D' IN TYPEOF(cnc\
               conic.position))) )) = 0)) )) = 0;
      wr6: SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( pline <* QUERY ( elem <* gcs\
               geometric_set.elements | ('ASSOCIATIVE_DRAUGHTING.POLYLINE' 
               IN TYPEOF(elem)) ) | (NOT (SIZEOF(pline\polyline.points) > 2))
               )) = 0)) )) = 0;
      wr7: SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (('ASSOCIATIVE_DRAUGHTING.' + 
               'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))
               )) = 0;
      wr8: SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3;
  END_ENTITY; -- geometrically_bounded_wireframe_shape_representation

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY; -- global_uncertainty_assigned_context

  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY; -- global_unit_assigned_context

  ENTITY group;
      name        : label;
      description : text;
  END_ENTITY; -- group

  ENTITY group_assignment
    ABSTRACT SUPERTYPE;
      assigned_group : group;
  END_ENTITY; -- group_assignment

  ENTITY group_relationship;
      name           : label;
      description    : text;
      relating_group : group;
      related_group  : group;
  END_ENTITY; -- group_relationship

  ENTITY hyperbola
    SUBTYPE OF (conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY; -- hyperbola

  ENTITY intersection_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      wr2: associated_surface(SELF\surface_curve.associated_geometry[1]) 
               <> associated_surface(SELF\surface_curve.associated_geometry
               [2]);
  END_ENTITY; -- intersection_curve

  ENTITY invisibility;
      invisible_items : SET [1:?] OF invisible_item;
  END_ENTITY; -- invisibility

  ENTITY leader_curve
    SUBTYPE OF (annotation_curve_occurrence);
    WHERE
      wr1: SIZEOF(USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'LEADER_DIRECTED_CALLOUT.CONTENTS')) >= 1;
  END_ENTITY; -- leader_curve

  ENTITY leader_directed_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      wr1: SIZEOF(QUERY ( l_1 <* SELF\draughting_callout.contents | (
               'ASSOCIATIVE_DRAUGHTING.LEADER_CURVE' IN TYPEOF(l_1)) )) >= 
               1;
      wr2: SIZEOF(SELF\draughting_callout.contents) >= 2;
  END_ENTITY; -- leader_directed_callout

  ENTITY leader_directed_dimension
    SUBTYPE OF (leader_directed_callout);
    WHERE
      wr1: SIZEOF(QUERY ( con <* SELF.contents | (
               'ASSOCIATIVE_DRAUGHTING.LEADER_CURVE' IN TYPEOF(con)) )) = 1;
  END_ENTITY; -- leader_directed_dimension

  ENTITY leader_terminator
    SUBTYPE OF (terminator_symbol);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.LEADER_CURVE' IN TYPEOF(SELF\
               terminator_symbol.annotated_curve);
  END_ENTITY; -- leader_terminator

  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.LENGTH_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component);
  END_ENTITY; -- length_measure_with_unit

  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: (SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0);
  END_ENTITY; -- length_unit

  ENTITY line
    SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      wr1: dir.dim = pnt.dim;
  END_ENTITY; -- line

  ENTITY linear_dimension
    SUBTYPE OF (dimension_curve_directed_callout);
  END_ENTITY; -- linear_dimension

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY; -- local_time

  ENTITY loop
    SUPERTYPE OF (ONEOF (vertex_loop,edge_loop,poly_loop))
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- loop

  ENTITY manifold_solid_brep
    SUBTYPE OF (solid_model);
      outer : closed_shell;
  END_ENTITY; -- manifold_solid_brep

  ENTITY manifold_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
                = 1)) )) = 0;
      wr2 : SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                > 0;
      wr3 : SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) ) | (
                NOT
              ('ASSOCIATIVE_DRAUGHTING.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' 
                IN TYPEOF(mi\mapped_item.mapping_source.
                mapped_representation))) )) = 0;
      wr4 : SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( sh <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.OPEN_SHELL',
                'ASSOCIATIVE_DRAUGHTING.CLOSED_SHELL'] * TYPEOF(sh)) = 1)) )) 
                = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (
                SIZEOF(['ASSOCIATIVE_DRAUGHTING.FACE_SURFACE',
                'ASSOCIATIVE_DRAUGHTING.ORIENTED_FACE'] * TYPEOF(fa)) = 1)) ))

                = 0)) )) = 0)) )) = 0;
      wr6 : SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( f_sf <* QUERY ( fa <* cfs\connected_face_set.
                cfs_faces | ('ASSOCIATIVE_DRAUGHTING.FACE_SURFACE' IN 
                TYPEOF(fa)) ) | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(f_sf)) OR 
                (SIZEOF(['ASSOCIATIVE_DRAUGHTING.OFFSET_SURFACE',
                'ASSOCIATIVE_DRAUGHTING.SURFACE_REPLICA'] * TYPEOF(f_sf\
                face_surface.face_geometry)) = 1))) )) = 0)) )) = 0)) )) = 
                0;
      wr7 : SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                basis_surface_check(fa\face_surface.face_geometry))) )) = 0))
                )) = 0)) )) = 0;
      wr8 : SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( bnds <* fa.bounds | (NOT (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP',
                'ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP'] * TYPEOF(bnds.bound)) 
                = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0;
      wr9 : SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds)) ) | (
                NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.edge_list | 
                (NOT ('ASSOCIATIVE_DRAUGHTING.EDGE_CURVE' IN TYPEOF(oe.
                edge_element))) )) = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0;
      wr10: SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe_cv <* QUERY ( oe <* elp_fbnds.
                bound\path.edge_list | ('ASSOCIATIVE_DRAUGHTING.EDGE_CURVE' 
                IN TYPEOF(oe.edge_element)) ) | (NOT (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.CURVE_REPLICA',
                'ASSOCIATIVE_DRAUGHTING.OFFSET_CURVE_3D',
                'ASSOCIATIVE_DRAUGHTING.PCURVE'] * TYPEOF(oe_cv.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0))) )) = 0)) )) = 0)) )) = 0;
      wr11: SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT basis_curve_check(oe.edge_element\
                edge_curve.edge_geometry)) )) = 0)) )) = 0))) )) = 0)) )) =
                 0)) )) = 0;
      wr12: SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds)) ) | (
                NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.edge_list | 
                (NOT (('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_start)) AND (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_end)))) )) = 0)) )) = 0))) )) = 0)) )) = 
                0)) )) = 0;
      wr13: SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ((SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT',
                'ASSOCIATIVE_DRAUGHTING.DEGENERATE_PCURVE',
                'ASSOCIATIVE_DRAUGHTING.POINT_ON_CURVE',
                'ASSOCIATIVE_DRAUGHTING.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_start\vertex_point.vertex_geometry)) = 1) 
                AND (SIZEOF(['ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT',
                'ASSOCIATIVE_DRAUGHTING.DEGENERATE_PCURVE',
                'ASSOCIATIVE_DRAUGHTING.POINT_ON_CURVE',
                'ASSOCIATIVE_DRAUGHTING.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_end\vertex_point.vertex_geometry)) = 1))) )) 
               = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0;
      wr14: SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT ('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds.bound\vertex_loop.loop_vertex))) )) = 0))) )) = 0))
                )) = 0)) )) = 0;
      wr15: SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'ASSOCIATIVE_DRAUGHTING.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(['ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT',
                'ASSOCIATIVE_DRAUGHTING.DEGENERATE_PCURVE',
                'ASSOCIATIVE_DRAUGHTING.POINT_ON_CURVE',
                'ASSOCIATIVE_DRAUGHTING.POINT_ON_SURFACE'] * TYPEOF(
                vlp_fbnds.bound\vertex_loop.loop_vertex\vertex_point.
                vertex_geometry)) = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0;
  END_ENTITY; -- manifold_surface_shape_representation

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]);
  END_ENTITY; -- mapped_item

  ENTITY measure_representation_item
    SUBTYPE OF (representation_item, measure_with_unit);
  END_ENTITY; -- measure_representation_item

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (length_measure_with_unit,
        plane_angle_measure_with_unit,solid_angle_measure_with_unit));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY; -- measure_with_unit

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (si_unit,conversion_based_unit) ANDOR ONEOF (
        length_unit,plane_angle_unit,solid_angle_unit));
      dimensions : dimensional_exponents;
  END_ENTITY; -- named_unit

  ENTITY offset_curve_2d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
    WHERE
      wr1: basis_curve.dim = 2;
  END_ENTITY; -- offset_curve_2d

  ENTITY offset_curve_3d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
      ref_direction  : direction;
    WHERE
      wr1: (basis_curve.dim = 3) AND (ref_direction.dim = 3);
  END_ENTITY; -- offset_curve_3d

  ENTITY offset_surface
    SUBTYPE OF (surface);
      basis_surface  : surface;
      distance       : length_measure;
      self_intersect : LOGICAL;
  END_ENTITY; -- offset_surface

  ENTITY one_direction_repeat_factor
    SUBTYPE OF (geometric_representation_item);
      repeat_factor : vector;
  END_ENTITY; -- one_direction_repeat_factor

  ENTITY open_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- open_shell

  ENTITY ordinate_dimension
    SUBTYPE OF (projection_directed_callout);
  END_ENTITY; -- ordinate_dimension

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : text;
  END_ENTITY; -- organization

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role                  : organization_role;
  END_ENTITY; -- organization_assignment

  ENTITY organization_role;
      name : label;
  END_ENTITY; -- organization_role

  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : text;
  END_ENTITY; -- organizational_address

  ENTITY oriented_closed_shell
    SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation          : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             closed_shell_element.cfs_faces);
    WHERE
      wr1: NOT ('ASSOCIATIVE_DRAUGHTING.ORIENTED_CLOSED_SHELL' IN TYPEOF(
               SELF.closed_shell_element));
  END_ENTITY; -- oriented_closed_shell

  ENTITY oriented_edge
    SUBTYPE OF (edge);
      edge_element : edge;
      orientation  : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_start,SELF.
                                edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_end,SELF.
                                edge_element.edge_start);
    WHERE
      wr1: NOT ('ASSOCIATIVE_DRAUGHTING.ORIENTED_EDGE' IN TYPEOF(SELF.
               edge_element));
  END_ENTITY; -- oriented_edge

  ENTITY oriented_face
    SUBTYPE OF (face);
      face_element : face;
      orientation  : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(
                            SELF.orientation,SELF.face_element.bounds);
    WHERE
      wr1: NOT ('ASSOCIATIVE_DRAUGHTING.ORIENTED_FACE' IN TYPEOF(SELF.
               face_element));
  END_ENTITY; -- oriented_face

  ENTITY oriented_open_shell
    SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation        : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             open_shell_element.cfs_faces);
    WHERE
      wr1: NOT ('ASSOCIATIVE_DRAUGHTING.ORIENTED_OPEN_SHELL' IN TYPEOF(
               SELF.open_shell_element));
  END_ENTITY; -- oriented_open_shell

  ENTITY oriented_path
    SUBTYPE OF (path);
      path_element : path;
      orientation  : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := 
                               conditional_reverse(SELF.orientation,SELF.
                               path_element.edge_list);
    WHERE
      wr1: NOT ('ASSOCIATIVE_DRAUGHTING.ORIENTED_PATH' IN TYPEOF(SELF.
               path_element));
  END_ENTITY; -- oriented_path

  ENTITY outer_boundary_curve
    SUBTYPE OF (boundary_curve);
  END_ENTITY; -- outer_boundary_curve

  ENTITY over_riding_styled_item
    SUBTYPE OF (styled_item);
      over_ridden_style : styled_item;
  END_ENTITY; -- over_riding_styled_item

  ENTITY parabola
    SUBTYPE OF (conic);
      focal_dist : length_measure;
    WHERE
      wr1: focal_dist <> 0;
  END_ENTITY; -- parabola

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY; -- parametric_representation_context

  ENTITY path
    SUPERTYPE OF (ONEOF (edge_loop,oriented_path))
    SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
    WHERE
      wr1: path_head_to_tail(SELF);
  END_ENTITY; -- path

  ENTITY pcurve
    SUBTYPE OF (curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: SIZEOF(reference_to_curve\representation.items) = 1;
      wr2: 'ASSOCIATIVE_DRAUGHTING.CURVE' IN TYPEOF(reference_to_curve\
               representation.items[1]);
      wr3: reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2;
  END_ENTITY; -- pcurve

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    UNIQUE
      ur1 : id;
    WHERE
      wr1: EXISTS(last_name) OR EXISTS(first_name);
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
  END_ENTITY; -- person_and_organization_role

  ENTITY person_assignment
    ABSTRACT SUPERTYPE;
      assigned_person : person;
      role            : person_role;
  END_ENTITY; -- person_assignment

  ENTITY person_role;
      name : label;
  END_ENTITY; -- person_role

  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : text;
  END_ENTITY; -- personal_address

  ENTITY placement
    SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d,
        axis2_placement_3d))
    SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY; -- placement

  ENTITY planar_box
    SUBTYPE OF (planar_extent);
      placement : axis2_placement;
  END_ENTITY; -- planar_box

  ENTITY planar_extent
    SUBTYPE OF (geometric_representation_item);
      size_in_x : length_measure;
      size_in_y : length_measure;
  END_ENTITY; -- planar_extent

  ENTITY plane
    SUBTYPE OF (elementary_surface);
  END_ENTITY; -- plane

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component);
  END_ENTITY; -- plane_angle_measure_with_unit

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: (SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0);
  END_ENTITY; -- plane_angle_unit

  ENTITY plus_minus_tolerance;
      range                : tolerance_method_definition;
      toleranced_dimension : dimensional_characteristic;
    UNIQUE
      ur1 : toleranced_dimension;
  END_ENTITY; -- plus_minus_tolerance

  ENTITY point
    SUPERTYPE OF (ONEOF (cartesian_point,point_on_curve,point_on_surface,
        point_replica,degenerate_pcurve))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- point

  ENTITY point_on_curve
    SUBTYPE OF (point);
      basis_curve     : curve;
      point_parameter : parameter_value;
  END_ENTITY; -- point_on_curve

  ENTITY point_on_surface
    SUBTYPE OF (point);
      basis_surface     : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
  END_ENTITY; -- point_on_surface

  ENTITY point_replica
    SUBTYPE OF (point);
      parent_pt      : point;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: transformation.dim = parent_pt.dim;
      wr2: acyclic_point_replica(SELF,parent_pt);
  END_ENTITY; -- point_replica

  ENTITY poly_loop
    SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY; -- poly_loop

  ENTITY polyline
    SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY; -- polyline

  ENTITY pre_defined_colour
    SUBTYPE OF (pre_defined_item, colour);
  END_ENTITY; -- pre_defined_colour

  ENTITY pre_defined_curve_font
    SUBTYPE OF (pre_defined_item);
  END_ENTITY; -- pre_defined_curve_font

  ENTITY pre_defined_dimension_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      wr1: SELF.name IN ['arc length','conical taper','counterbore',
               'countersink','depth','diameter','plus minus','radius',
               'slope','spherical diameter','spherical radius','square'];
  END_ENTITY; -- pre_defined_dimension_symbol

  ENTITY pre_defined_geometrical_tolerance_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      wr1: SELF.name IN ['angularity','circular runout','circularity',
               'concentricity','cylindricity','diameter','flatness',
               'least material condition','maximum material condition',
               'parallelism','perpendicularity','position',
               'profile of a line','profile of a surface',
               'projected tolerance zone','regardless of feature size',
               'straightness','symmetry','target point','total runout'];
  END_ENTITY; -- pre_defined_geometrical_tolerance_symbol

  ENTITY pre_defined_item;
      name : label;
  END_ENTITY; -- pre_defined_item

  ENTITY pre_defined_marker
    SUBTYPE OF (pre_defined_item);
  END_ENTITY; -- pre_defined_marker

  ENTITY pre_defined_point_marker_symbol
    SUBTYPE OF (pre_defined_symbol, pre_defined_marker);
    WHERE
      wr1: SELF.name IN ['asterisk','circle','dot','plus','square',
               'triangle','x'];
  END_ENTITY; -- pre_defined_point_marker_symbol

  ENTITY pre_defined_symbol
    SUBTYPE OF (pre_defined_item);
  END_ENTITY; -- pre_defined_symbol

  ENTITY pre_defined_terminator_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      wr1: SELF.name IN ['blanked arrow','blanked box','blanked dot',
               'dimension origin','filled arrow','filled box','filled dot',
               'integral symbol','open arrow','slash','unfilled arrow'];
  END_ENTITY; -- pre_defined_terminator_symbol

  ENTITY pre_defined_text_font
    SUBTYPE OF (pre_defined_item);
  END_ENTITY; -- pre_defined_text_font

  ENTITY presentation_area
    SUBTYPE OF (presentation_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( ais <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'AREA_IN_SET.AREA') | (SIZEOF(USEDIN(ais,
               'ASSOCIATIVE_DRAUGHTING.' + 'PRESENTATION_SIZE.UNIT')) = 1) )) 
               > 0) OR (SIZEOF(USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'PRESENTATION_SIZE.UNIT')) = 1);
  END_ENTITY; -- presentation_area

  ENTITY presentation_layer_assignment;
      name           : label;
      description    : text;
      assigned_items : SET [1:?] OF layered_item;
  END_ENTITY; -- presentation_layer_assignment

  ENTITY presentation_layer_usage;
      assignment   : presentation_layer_assignment;
      presentation : presentation_representation;
    UNIQUE
      ur1 : assignment, presentation;
  END_ENTITY; -- presentation_layer_usage

  ENTITY presentation_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: SELF\representation.context_of_items\
               geometric_representation_context.coordinate_space_dimension 
               = 2;
      wr2: 'ASSOCIATIVE_DRAUGHTING.GEOMETRIC_REPRESENTATION_CONTEXT' IN 
               TYPEOF(SELF\representation.context_of_items);
  END_ENTITY; -- presentation_representation

  ENTITY presentation_set;
    INVERSE
      areas : SET [1:?] OF area_in_set FOR in_set;
  END_ENTITY; -- presentation_set

  ENTITY presentation_size;
      unit : presentation_size_assignment_select;
      size : planar_box;
    WHERE
      wr1: (('ASSOCIATIVE_DRAUGHTING.PRESENTATION_REPRESENTATION' IN 
               TYPEOF(SELF.unit)) AND item_in_context(SELF.size,SELF.unit\
               representation.context_of_items)) OR ((
               'ASSOCIATIVE_DRAUGHTING.AREA_IN_SET' IN TYPEOF(SELF.unit)) 
               AND (SIZEOF(QUERY ( ais <* SELF.unit\area_in_set.in_set.
               areas | (NOT item_in_context(SELF.size,ais.area\
               representation.context_of_items)) )) = 0));
  END_ENTITY; -- presentation_size

  ENTITY presentation_style_assignment;
      styles : SET [1:?] OF presentation_style_select;
    WHERE
      wr1: SIZEOF(QUERY ( style1 <* SELF.styles | (NOT (SIZEOF(
               QUERY ( style2 <* (SELF.styles - style1) | (NOT ((TYPEOF(
               style1) <> TYPEOF(style2)) OR (SIZEOF([
               'ASSOCIATIVE_DRAUGHTING.' + 'SURFACE_STYLE_USAGE',
               'ASSOCIATIVE_DRAUGHTING.' + 'EXTERNALLY_DEFINED_STYLE'] * 
               TYPEOF(style1)) = 1))) )) = 0)) )) = 0;
      wr2: SIZEOF(QUERY ( style1 <* SELF.styles | (
               'ASSOCIATIVE_DRAUGHTING.SURFACE_STYLE_USAGE' IN TYPEOF(
               style1)) )) <= 2;
  END_ENTITY; -- presentation_style_assignment

  ENTITY presentation_style_by_context
    SUBTYPE OF (presentation_style_assignment);
      style_context : style_context_select;
  END_ENTITY; -- presentation_style_by_context

  ENTITY presentation_view
    SUBTYPE OF (presentation_representation);
  END_ENTITY; -- presentation_view

  ENTITY presented_item
    ABSTRACT SUPERTYPE;
  END_ENTITY; -- presented_item

  ENTITY presented_item_representation;
      presentation : presentation_representation_select;
      item         : presented_item;
  END_ENTITY; -- presented_item_representation

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : text;
      frame_of_reference : SET [1:?] OF product_context;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- product

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition;
      id                 : identifier;
      description        : text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
  END_ENTITY; -- product_definition

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY; -- product_definition_context

  ENTITY product_definition_formation;
      id          : identifier;
      description : text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : definition;
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.CHARACTERIZED_PRODUCT_DEFINITION' IN 
               TYPEOF(SELF\property_definition.definition);
  END_ENTITY; -- product_definition_shape

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
  END_ENTITY; -- product_definition_with_associated_documents

  ENTITY projection_curve
    SUBTYPE OF (annotation_curve_occurrence);
  END_ENTITY; -- projection_curve

  ENTITY projection_directed_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      wr1: SIZEOF(QUERY ( p_1 <* SELF\draughting_callout.contents | (
               'ASSOCIATIVE_DRAUGHTING.PROJECTION_CURVE' IN TYPEOF(p_1)) )) 
               = 1;
      wr2: SIZEOF(SELF\draughting_callout.contents) >= 2;
  END_ENTITY; -- projection_directed_callout

  ENTITY property_definition;
      name        : label;
      description : text;
      definition  : characterized_definition;
  END_ENTITY; -- property_definition

  ENTITY property_definition_representation;
      definition          : property_definition;
      used_representation : representation;
  END_ENTITY; -- property_definition_representation

  ENTITY quasi_uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- quasi_uniform_curve

  ENTITY quasi_uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- quasi_uniform_surface

  ENTITY radius_dimension
    SUBTYPE OF (dimension_curve_directed_callout);
    WHERE
      wr1: SIZEOF(QUERY ( con <* SELF.contents | (
               'ASSOCIATIVE_DRAUGHTING.PROJECTION_CURVE' IN TYPEOF(con)) )) 
               <= 1;
  END_ENTITY; -- radius_dimension

  ENTITY rational_b_spline_curve
    SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := 
                   list_to_array(weights_data,0,
                   upper_index_on_control_points);
    WHERE
      wr1: SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
               control_points_list);
      wr2: curve_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_curve

  ENTITY rational_b_spline_surface
    SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := 
                   make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_surface.control_points_list[1]));
      wr2: surface_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_surface

  ENTITY rectangular_composite_surface
    SUBTYPE OF (bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
    DERIVE
      n_u : INTEGER := SIZEOF(segments);
      n_v : INTEGER := SIZEOF(segments[1]);
    WHERE
      wr1: [] = QUERY ( s <* segments | (n_v <> SIZEOF(s)) );
      wr2: constraints_rectangular_composite_surface(SELF);
  END_ENTITY; -- rectangular_composite_surface

  ENTITY rectangular_trimmed_surface
    SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      u1            : parameter_value;
      u2            : parameter_value;
      v1            : parameter_value;
      v2            : parameter_value;
      usense        : BOOLEAN;
      vsense        : BOOLEAN;
    WHERE
      wr1: u1 <> u2;
      wr2: v1 <> v2;
      wr3: (('ASSOCIATIVE_DRAUGHTING.ELEMENTARY_SURFACE' IN TYPEOF(
               basis_surface)) AND (NOT ('ASSOCIATIVE_DRAUGHTING.PLANE' IN 
               TYPEOF(basis_surface)))) OR (
               'ASSOCIATIVE_DRAUGHTING.SURFACE_OF_REVOLUTION' IN TYPEOF(
               basis_surface)) OR (usense = (u2 > u1));
      wr4: ('ASSOCIATIVE_DRAUGHTING.SPHERICAL_SURFACE' IN TYPEOF(
               basis_surface)) OR (
               'ASSOCIATIVE_DRAUGHTING.TOROIDAL_SURFACE' IN TYPEOF(
               basis_surface)) OR (vsense = (v2 > v1));
  END_ENTITY; -- rectangular_trimmed_surface

  ENTITY reparametrised_composite_curve_segment
    SUBTYPE OF (composite_curve_segment);
      param_length : parameter_value;
    WHERE
      wr1: param_length > 0;
  END_ENTITY; -- reparametrised_composite_curve_segment

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
  END_ENTITY; -- representation

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR 
                                      context_of_items;
  END_ENTITY; -- representation_context

  ENTITY representation_item;
      name : label;
    WHERE
      wr1: SIZEOF(using_representations(SELF)) > 0;
  END_ENTITY; -- representation_item

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY; -- representation_map

  ENTITY seam_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      wr2: associated_surface(SELF\surface_curve.associated_geometry[1]) =
                associated_surface(SELF\surface_curve.associated_geometry[2]);
      wr3: 'ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(SELF\surface_curve.
               associated_geometry[1]);
      wr4: 'ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(SELF\surface_curve.
               associated_geometry[2]);
  END_ENTITY; -- seam_curve

  ENTITY security_classification;
      name           : label;
      purpose        : text;
      security_level : security_classification_level;
  END_ENTITY; -- security_classification

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
  END_ENTITY; -- security_classification_assignment

  ENTITY security_classification_level;
      name : label;
  END_ENTITY; -- security_classification_level

  ENTITY shape_aspect;
      name                 : label;
      description          : text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
  END_ENTITY; -- shape_aspect

  ENTITY shape_aspect_associativity
    SUBTYPE OF (shape_aspect_relationship);
    WHERE
      wr1: SELF.relating_shape_aspect.product_definitional;
      wr2: NOT SELF.related_shape_aspect.product_definitional;
      wr3: SIZEOF(QUERY ( pd <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sdr <* QUERY ( pdr <* USEDIN(pd,
               'ASSOCIATIVE_DRAUGHTING.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (
               'ASSOCIATIVE_DRAUGHTING.SHAPE_DEFINITION_REPRESENTATION' IN 
               TYPEOF(pdr)) ) | (NOT (SIZEOF(QUERY ( it <* sdr.
               used_representation.items | ((NOT (
               'ASSOCIATIVE_DRAUGHTING.CURVE' IN TYPEOF(it))) AND ((SIZEOF(
               QUERY ( aco <* USEDIN(it,
               'ASSOCIATIVE_DRAUGHTING.STYLED_ITEM.ITEM') | (SIZEOF(TYPEOF(
               aco) * ['ASSOCIATIVE_DRAUGHTING.LEADER_CURVE',
               'ASSOCIATIVE_DRAUGHTING.PROJECTION_CURVE']) = 1) )) + 
               SIZEOF(USEDIN(it,'ASSOCIATIVE_DRAUGHTING.' + 
               'ANNOTATION_FILL_AREA.BOUNDARIES'))) >= 1)) )) = 1)) )) = 0))
               )) = 0;
      wr4: SIZEOF(QUERY ( pd <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sdr <* QUERY ( pdr <* USEDIN(pd,
               'ASSOCIATIVE_DRAUGHTING.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (
               'ASSOCIATIVE_DRAUGHTING.SHAPE_DEFINITION_REPRESENTATION' IN 
               TYPEOF(pdr)) ) | (NOT check_associative_shape_aspects(sdr)) )) 
               = 0)) )) = 0;
  END_ENTITY; -- shape_aspect_associativity

  ENTITY shape_aspect_deriving_relationship
    SUBTYPE OF (shape_aspect_relationship);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.DERIVED_SHAPE_ASPECT' IN TYPEOF(SELF\
               shape_aspect_relationship.relating_shape_aspect);
  END_ENTITY; -- shape_aspect_deriving_relationship

  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
  END_ENTITY; -- shape_aspect_relationship

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: ('ASSOCIATIVE_DRAUGHTING.SHAPE_DEFINITION' IN TYPEOF(SELF.
               definition.definition)) OR (
               'ASSOCIATIVE_DRAUGHTING.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               SELF.definition));
      wr2: 'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION' IN TYPEOF(SELF.
               used_representation);
  END_ENTITY; -- shape_definition_representation

  ENTITY shape_dimension_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( temp <* SELF.items | NOT 
               ('ASSOCIATIVE_DRAUGHTING.MEASURE_REPRESENTATION_ITEM' IN 
               TYPEOF(temp)) )) = 0;
      wr2: SIZEOF(SELF.items) <= 2;
      wr3: SIZEOF(QUERY ( pos_mri <* QUERY ( real_mri <* SELF.items | (
               'REAL' IN TYPEOF(real_mri\measure_with_unit.value_component)) )
                | (NOT (pos_mri\measure_with_unit.value_component > 0)) )) 
               = 0;
  END_ENTITY; -- shape_dimension_representation

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- shape_representation

  ENTITY shell_based_2d_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : SIZEOF(QUERY ( it <* SELF\representation.items | (NOT (SIZEOF(
                ['ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_2D'] * TYPEOF(it)) 
                = 1)) )) = 0;
      wr2 : SIZEOF(QUERY ( it <* SELF\representation.items | (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                >= 1;
      wr3 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT ('ASSOCIATIVE_DRAUGHTING.EDGE_CURVE' IN 
                TYPEOF(el.edge_element))) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr4 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( pline_el <* 
                QUERY ( el <* eloop\path.edge_list | (
                'ASSOCIATIVE_DRAUGHTING.POLYLINE' IN TYPEOF(el.edge_element
                \edge_curve.edge_geometry)) ) | (NOT (SIZEOF(pline_el.
                edge_element\edge_curve.edge_geometry\polyline.points) > 2))
                )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT valid_2d_wireframe_edge_curve(el.
                edge_element\edge_curve.edge_geometry,
                'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0)) )) = 0)) )) = 
                0;
      wr6 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT (('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN
                 TYPEOF(el.edge_element.edge_start)) AND (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(el.
                edge_element.edge_end)))) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr7 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT (valid_wireframe_vertex_point(el.
                edge_element.edge_start\vertex_point.vertex_geometry,
                'ASSOCIATIVE_DRAUGHTING') AND valid_wireframe_vertex_point(
                el.edge_element.edge_end\vertex_point.vertex_geometry,
                'ASSOCIATIVE_DRAUGHTING'))) )) = 0)) )) = 0)) )) = 0)) )) =
                 0;
      wr8 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( con_edges <* 
                QUERY ( el <* eloop\path.edge_list | (
                'ASSOCIATIVE_DRAUGHTING.CONIC' IN TYPEOF(el.edge_element\
                edge_curve.edge_geometry)) ) | (NOT (
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_2D' IN TYPEOF(
                con_edges.edge_element\edge_curve.edge_geometry\conic.
                position))) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr9 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(vloop\
                vertex_loop.loop_vertex))) )) = 0)) )) = 0)) )) = 0;
      wr10: SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT valid_wireframe_vertex_point(vloop
                \vertex_loop.loop_vertex\vertex_point.vertex_geometry,
                'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0)) )) = 0;
      wr11: SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_SHELL' IN TYPEOF(sb)) ) | (
                NOT ('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(vs\
                vertex_shell.vertex_shell_extent.loop_vertex))) )) = 0)) )) 
                = 0;
      wr12: SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN
                 TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_SHELL' IN TYPEOF(sb)) ) | (
                NOT valid_wireframe_vertex_point(vs\vertex_shell.
                vertex_shell_extent.loop_vertex\vertex_point.
                vertex_geometry,'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0;
      wr13: SIZEOF(QUERY ( mi <* QUERY ( it <* SELF\representation.items
                 | ('ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) )
                 | (NOT (('ASSOCIATIVE_DRAUGHTING.' + 
                'SHELL_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(
                mi\mapped_item.mapping_source.mapped_representation))) )) =
                 0;
      wr14: SELF.context_of_items\geometric_representation_context.
                coordinate_space_dimension = 2;
  END_ENTITY; -- shell_based_2d_wireframe_shape_representation

  ENTITY shell_based_surface_model
    SUBTYPE OF (geometric_representation_item);
      sbsm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_surface_model(SELF);
  END_ENTITY; -- shell_based_surface_model

  ENTITY shell_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      sbwm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_wireframe_model(SELF);
  END_ENTITY; -- shell_based_wireframe_model

  ENTITY shell_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM',
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
                = 1)) )) = 0;
      wr2 : SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL',
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                >= 1;
      wr3 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT ('ASSOCIATIVE_DRAUGHTING.EDGE_CURVE' IN 
                TYPEOF(el.edge_element))) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr4 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( pline_el <* 
                QUERY ( el <* eloop\path.edge_list | (
                'ASSOCIATIVE_DRAUGHTING.POLYLINE' IN TYPEOF(el.edge_element
                \edge_curve.edge_geometry)) ) | (NOT (SIZEOF(pline_el.
                edge_element\edge_curve.edge_geometry\polyline.points) > 2))
                )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT valid_wireframe_edge_curve(el.edge_element
                \edge_curve.edge_geometry,'ASSOCIATIVE_DRAUGHTING')) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0;
      wr6 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT (('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN
                 TYPEOF(el.edge_element.edge_start)) AND (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(el.
                edge_element.edge_end)))) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr7 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT (valid_wireframe_vertex_point(el.
                edge_element.edge_start\vertex_point.vertex_geometry,
                'ASSOCIATIVE_DRAUGHTING') AND 
                valid_wireframe_vertex_point(el.edge_element.edge_end\
                vertex_point.vertex_geometry,'ASSOCIATIVE_DRAUGHTING'))) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0;
      wr8 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.EDGE_LOOP' IN 
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( con_edges <* 
                QUERY ( el <* eloop\path.edge_list | (
                'ASSOCIATIVE_DRAUGHTING.CONIC' IN TYPEOF(el.edge_element\
                edge_curve.edge_geometry)) ) | (NOT (
                'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D' IN TYPEOF(
                con_edges.edge_element\edge_curve.edge_geometry\conic.
                position))) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr9 : SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(vloop\
                vertex_loop.loop_vertex))) )) = 0)) )) = 0)) )) = 0;
      wr10: SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(sb)) ) | (
                NOT (SIZEOF(QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('ASSOCIATIVE_DRAUGHTING.VERTEX_LOOP' 
                IN TYPEOF(wsb)) ) | (NOT valid_wireframe_vertex_point(vloop
                \vertex_loop.loop_vertex\vertex_point.vertex_geometry,
                'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) = 0)) )) = 0;
      wr11: SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_SHELL' IN TYPEOF(sb)) ) | (
                NOT ('ASSOCIATIVE_DRAUGHTING.VERTEX_POINT' IN TYPEOF(vs\
                vertex_shell.vertex_shell_extent.loop_vertex))) )) = 0)) )) 
                = 0;
      wr12: SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.SHELL_BASED_WIREFRAME_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* QUERY ( sb <* 
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'ASSOCIATIVE_DRAUGHTING.VERTEX_SHELL' IN TYPEOF(sb)) ) | (
                NOT valid_wireframe_vertex_point(vs\vertex_shell.
                vertex_shell_extent.loop_vertex\vertex_point.
                vertex_geometry,'ASSOCIATIVE_DRAUGHTING')) )) = 0)) )) =
                 0;
      wr13: SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(it)) ) | (
                NOT (('ASSOCIATIVE_DRAUGHTING.' + 
                'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
                mapped_item.mapping_source.mapped_representation))) )) = 0;
      wr14: SELF.context_of_items\geometric_representation_context.
                coordinate_space_dimension = 3;
  END_ENTITY; -- shell_based_wireframe_shape_representation

  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := 
                                      dimensions_for_si_unit(SELF.name);
  END_ENTITY; -- si_unit

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component);
  END_ENTITY; -- solid_angle_measure_with_unit

  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: (SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0);
  END_ENTITY; -- solid_angle_unit

  ENTITY solid_model
    SUPERTYPE OF (manifold_solid_brep)
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- solid_model

  ENTITY spherical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- spherical_surface

  ENTITY structured_dimension_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      wr1: SIZEOF(TYPEOF(SELF) * [
               'ASSOCIATIVE_DRAUGHTING.DATUM_FEATURE_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.DATUM_TARGET_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.GEOMETRICAL_TOLERANCE_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.LEADER_DIRECTED_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.PROJECTION_DIRECTED_CALLOUT',
               'ASSOCIATIVE_DRAUGHTING.DIMENSION_CURVE_DIRECTED_CALLOUT']) 
               = 0;
      wr2: SIZEOF(QUERY ( ato <* QUERY ( con <* SELF.contents | (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
               TYPEOF(con)) ) | (NOT (ato.name IN ['dimension value',
               'tolerance value','unit text','prefix text','suffix text'])) ))

               = 0;
      wr3: SIZEOF(QUERY ( ato <* QUERY ( con <* SELF.contents | (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
               TYPEOF(con)) ) | (ato.name = 'dimension value') )) >= 1;
      wr4: SIZEOF(QUERY ( dcr <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP.' + 
               'RELATING_DRAUGHTING_CALLOUT') | (dcr.name = 'prefix') )) <=
                1;
      wr5: SIZEOF(QUERY ( dcr <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' + 
               'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP.' + 
               'RELATING_DRAUGHTING_CALLOUT') | (dcr.name = 'suffix') )) <=
                1;
      wr6: (SIZEOF(QUERY ( ato <* QUERY ( con <* SELF.contents | (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
               TYPEOF(con)) ) | (ato.name = 'prefix text') )) > 0) AND (
               SIZEOF(QUERY ( dcr <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' 
               + 'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP.' + 
               'RELATING_DRAUGHTING_CALLOUT') | (dcr.name = 'prefix') )) = 
               1);
      wr7: (SIZEOF(QUERY ( ato <* QUERY ( con <* SELF.contents | (
               'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT_OCCURRENCE' IN 
               TYPEOF(con)) ) | (ato.name = 'suffix text') )) > 0) AND (
               SIZEOF(QUERY ( dcr <* USEDIN(SELF,'ASSOCIATIVE_DRAUGHTING.' 
               + 'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP.' + 
               'RELATING_DRAUGHTING_CALLOUT') | (dcr.name = 'suffix') )) = 
               1);
  END_ENTITY; -- structured_dimension_callout

  ENTITY styled_item
    SUBTYPE OF (representation_item);
      styles : SET [1:?] OF presentation_style_assignment;
      item   : representation_item;
    WHERE
      wr1: (SIZEOF(SELF.styles) = 1) XOR (SIZEOF(QUERY ( pres_style <* 
               SELF.styles | (NOT (('ASSOCIATIVE_DRAUGHTING.' + 
               'PRESENTATION_STYLE_BY_CONTEXT') IN TYPEOF(pres_style))) )) 
               = 0);
  END_ENTITY; -- styled_item

  ENTITY surface
    SUPERTYPE OF (ONEOF (elementary_surface,swept_surface,bounded_surface,
        offset_surface,surface_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- surface

  ENTITY surface_curve
    SUPERTYPE OF (ONEOF (intersection_curve,seam_curve))
    SUBTYPE OF (curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: curve_3d.dim = 3;
      wr2: ('ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(associated_geometry[
               1])) OR (master_representation <> pcurve_s1);
      wr3: ('ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(associated_geometry[
               2])) OR (master_representation <> pcurve_s2);
      wr4: NOT ('ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(curve_3d));
  END_ENTITY; -- surface_curve

  ENTITY surface_of_linear_extrusion
    SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
  END_ENTITY; -- surface_of_linear_extrusion

  ENTITY surface_of_revolution
    SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
    DERIVE
      axis_line : line := line(axis_position.location,vector(axis_position
                     .z,1));
  END_ENTITY; -- surface_of_revolution

  ENTITY surface_patch;
      parent_surface : bounded_surface;
      u_transition   : transition_code;
      v_transition   : transition_code;
      u_sense        : BOOLEAN;
      v_sense        : BOOLEAN;
    INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR 
                          segments;
    WHERE
      wr1: NOT ('ASSOCIATIVE_DRAUGHTING.CURVE_BOUNDED_SURFACE' IN TYPEOF(
               parent_surface));
  END_ENTITY; -- surface_patch

  ENTITY surface_replica
    SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_surface_replica(SELF,parent_surface);
  END_ENTITY; -- surface_replica

  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,surface_of_revolution))
    SUBTYPE OF (surface);
      swept_curve : curve;
  END_ENTITY; -- swept_surface

  ENTITY symbol_colour;
      colour_of_symbol : colour;
  END_ENTITY; -- symbol_colour

  ENTITY symbol_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- symbol_representation

  ENTITY symbol_representation_map
    SUBTYPE OF (representation_map);
    WHERE
      wr1: 'ASSOCIATIVE_DRAUGHTING.SYMBOL_REPRESENTATION' IN TYPEOF(SELF\
               representation_map.mapped_representation);
      wr2: 'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT' IN TYPEOF(SELF\
               representation_map.mapping_origin);
  END_ENTITY; -- symbol_representation_map

  ENTITY symbol_style;
      name            : label;
      style_of_symbol : symbol_style_select;
  END_ENTITY; -- symbol_style

  ENTITY symbol_target
    SUBTYPE OF (geometric_representation_item);
      placement : axis2_placement;
      x_scale   : positive_ratio_measure;
      y_scale   : positive_ratio_measure;
  END_ENTITY; -- symbol_target

  ENTITY tangent
    SUBTYPE OF (derived_shape_aspect);
    WHERE
      wr1: SIZEOF(SELF\derived_shape_aspect.deriving_relationships) = 1;
  END_ENTITY; -- tangent

  ENTITY terminator_symbol
    SUBTYPE OF (annotation_symbol_occurrence);
      annotated_curve : annotation_curve_occurrence;
  END_ENTITY; -- terminator_symbol

  ENTITY text_literal
    SUBTYPE OF (geometric_representation_item);
      literal   : presentable_text;
      placement : axis2_placement;
      alignment : text_alignment;
      path      : text_path;
      font      : font_select;
  END_ENTITY; -- text_literal

  ENTITY text_literal_with_associated_curves
    SUBTYPE OF (text_literal);
      associated_curves : SET [1:?] OF curve;
  END_ENTITY; -- text_literal_with_associated_curves

  ENTITY text_literal_with_blanking_box
    SUBTYPE OF (text_literal);
      blanking : planar_box;
  END_ENTITY; -- text_literal_with_blanking_box

  ENTITY text_literal_with_delineation
    SUBTYPE OF (text_literal);
      delineation : text_delineation;
  END_ENTITY; -- text_literal_with_delineation

  ENTITY text_literal_with_extent
    SUBTYPE OF (text_literal);
      extent : planar_extent;
  END_ENTITY; -- text_literal_with_extent

  ENTITY text_style;
      name                 : label;
      character_appearance : character_style_select;
  END_ENTITY; -- text_style

  ENTITY text_style_for_defined_font;
      text_colour : colour;
  END_ENTITY; -- text_style_for_defined_font

  ENTITY text_style_with_box_characteristics
    SUBTYPE OF (text_style);
      characteristics : SET [1:4] OF box_characteristic_select;
    WHERE
      wr1: SIZEOF(QUERY ( c1 <* SELF.characteristics | (SIZEOF(
               QUERY ( c2 <* (SELF.characteristics - c1) | (TYPEOF(c1) = 
               TYPEOF(c2)) )) > 0) )) = 0;
  END_ENTITY; -- text_style_with_box_characteristics

  ENTITY text_style_with_mirror
    SUBTYPE OF (text_style);
      mirror_placement : axis2_placement;
  END_ENTITY; -- text_style_with_mirror

  ENTITY text_style_with_spacing
    SUBTYPE OF (text_style);
      character_spacing : character_spacing_select;
  END_ENTITY; -- text_style_with_spacing

  ENTITY tolerance_value;
      lower_bound : measure_with_unit;
      upper_bound : measure_with_unit;
    WHERE
      wr1: upper_bound.value_component > lower_bound.value_component;
      wr2: upper_bound.unit_component = lower_bound.unit_component;
  END_ENTITY; -- tolerance_value

  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (vertex,edge,face_bound,face,vertex_shell,
        wire_shell,connected_edge_set,connected_face_set,loop ANDOR path))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- topological_representation_item

  ENTITY toroidal_surface
    SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY; -- toroidal_surface

  ENTITY trimmed_curve
    SUBTYPE OF (bounded_curve);
      basis_curve           : curve;
      trim_1                : SET [1:2] OF trimming_select;
      trim_2                : SET [1:2] OF trimming_select;
      sense_agreement       : BOOLEAN;
      master_representation : trimming_preference;
    WHERE
      wr1: (HIINDEX(trim_1) = 1) XOR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
      wr2: (HIINDEX(trim_2) = 1) XOR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
  END_ENTITY; -- trimmed_curve

  ENTITY two_direction_repeat_factor
    SUBTYPE OF (one_direction_repeat_factor);
      second_repeat_factor : vector;
  END_ENTITY; -- two_direction_repeat_factor

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : text;
    WHERE
      wr1: (NOT ('NUMBER' IN TYPEOF(SELF\measure_with_unit.value_component))) 
               OR (SELF\measure_with_unit.value_component >= 0);
  END_ENTITY; -- uncertainty_measure_with_unit

  ENTITY uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- uniform_curve

  ENTITY uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- uniform_surface

  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: magnitude >= 0;
  END_ENTITY; -- vector

  ENTITY vertex
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- vertex

  ENTITY vertex_loop
    SUBTYPE OF (loop);
      loop_vertex : vertex;
  END_ENTITY; -- vertex_loop

  ENTITY vertex_point
    SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
  END_ENTITY; -- vertex_point

  ENTITY vertex_shell
    SUBTYPE OF (topological_representation_item);
      vertex_shell_extent : vertex_loop;
  END_ENTITY; -- vertex_shell

  ENTITY view_volume;
      projection_type            : central_or_parallel;
      projection_point           : cartesian_point;
      view_plane_distance        : length_measure;
      front_plane_distance       : length_measure;
      front_plane_clipping       : BOOLEAN;
      back_plane_distance        : length_measure;
      back_plane_clipping        : BOOLEAN;
      view_volume_sides_clipping : BOOLEAN;
      view_window                : planar_box;
  END_ENTITY; -- view_volume

  ENTITY wire_shell
    SUBTYPE OF (topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
    WHERE
      wr1: NOT mixed_loop_type_set(wire_shell_extent);
  END_ENTITY; -- wire_shell

  RULE application_context_requires_ap_definition FOR (application_context, 
               application_protocol_definition);

  WHERE
    wr1: SIZEOF(QUERY ( ac <* application_context | (NOT (SIZEOF(
             QUERY ( apd <* application_protocol_definition | ((ac :=: apd.
             application) AND (apd.
             application_interpreted_model_schema_name = 
             'ASSOCIATIVE_DRAUGHTING') AND (ac.application = 'draughting')) ))

             = 1)) )) = 0;

  END_RULE; -- application_context_requires_ap_definition

  RULE approval_date_time_constraints FOR (approval_date_time);

  WHERE
    wr1: SIZEOF(QUERY ( adt <* approval_date_time | (NOT (SIZEOF(TYPEOF(
             adt.date_time) * ['ASSOCIATIVE_DRAUGHTING.DATE_AND_TIME',
             'ASSOCIATIVE_DRAUGHTING.DATE']) = 1)) )) = 0;

  END_RULE; -- approval_date_time_constraints

  RULE approvals_are_assigned FOR (approval);

  WHERE
    wr1: SIZEOF(QUERY ( a <* approval | (NOT (SIZEOF(USEDIN(a,
             'ASSOCIATIVE_DRAUGHTING.' + 'APPROVAL_ASSIGNMENT.' + 
             'ASSIGNED_APPROVAL')) >= 1)) )) = 0;

  END_RULE; -- approvals_are_assigned

  RULE calendar_date_instantiation FOR (calendar_date);

  WHERE
    wr1: SIZEOF(QUERY ( each <* calendar_date | (NOT (SIZEOF(USEDIN(each,
             '')) >= 1)) )) = 0;

  END_RULE; -- calendar_date_instantiation

  RULE camera_usage_mapped_representation FOR (camera_usage);

  WHERE
    wr1: SIZEOF(QUERY ( cu <* camera_usage | (NOT (
             'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_MODEL' IN TYPEOF(cu.
             mapped_representation))) )) = 0;

  END_RULE; -- camera_usage_mapped_representation

  RULE colour_rgb_instantiation FOR (colour_rgb);

  WHERE
    wr1: SIZEOF(QUERY ( each <* colour_rgb | (NOT (SIZEOF(USEDIN(each,'')) 
             >= 1)) )) = 0;

  END_RULE; -- colour_rgb_instantiation

  RULE compatible_dimension FOR (cartesian_point, direction, 
             representation_context, geometric_representation_context);

  WHERE
    wr1: SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 
             0) )) = 0;
    wr2: SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) 
             > 0) )) = 0;

  END_RULE; -- compatible_dimension

  RULE curve_font_usage FOR (curve_style_font, pre_defined_curve_font, 
             externally_defined_curve_font);

  WHERE
    wr1: SIZEOF(QUERY ( csf <* curve_style_font | (NOT (SIZEOF(USEDIN(csf,
             'ASSOCIATIVE_DRAUGHTING.' + 'CURVE_STYLE.CURVE_FONT')) >= 1)) )) 
             = 0;
    wr2: SIZEOF(QUERY ( pdcf <* pre_defined_curve_font | (NOT (SIZEOF(
             USEDIN(pdcf,'ASSOCIATIVE_DRAUGHTING.' + 
             'CURVE_STYLE.CURVE_FONT')) >= 1)) )) = 0;
    wr3: SIZEOF(QUERY ( edcf <* externally_defined_curve_font | (NOT (
             SIZEOF(USEDIN(edcf,'ASSOCIATIVE_DRAUGHTING.' + 
             'CURVE_STYLE.CURVE_FONT')) >= 1)) )) = 0;

  END_RULE; -- curve_font_usage

  RULE curve_style_instantiation FOR (curve_style);

  WHERE
    wr1: SIZEOF(QUERY ( each <* curve_style | (NOT (SIZEOF(USEDIN(each,'')) 
             >= 1)) )) = 0;

  END_RULE; -- curve_style_instantiation

  RULE derived_unit_instantiation FOR (derived_unit);

  WHERE
    wr1: SIZEOF(QUERY ( du <* derived_unit | (NOT (SIZEOF(USEDIN(du,'')) 
             >= 1)) )) = 0;

  END_RULE; -- derived_unit_instantiation

  RULE dimensional_size_instantiation FOR (dimensional_size);

  WHERE
    wr1: SIZEOF(QUERY ( each <* dimensional_size | (NOT (SIZEOF(USEDIN(
             each,'')) >= 1)) )) = 0;

  END_RULE; -- dimensional_size_instantiation

  RULE dimensionality_is_two_or_three FOR (
             geometric_representation_context);

  WHERE
    wr1: SIZEOF(QUERY ( g <* geometric_representation_context | (NOT ((g.
             coordinate_space_dimension = 2) OR (g.
             coordinate_space_dimension = 3))) )) = 0;

  END_RULE; -- dimensionality_is_two_or_three

  RULE dimensions_are_represented FOR (dimensional_location, 
             dimensional_size);

  WHERE
    wr1: SIZEOF(QUERY ( dl <* dimensional_location | (NOT ((SIZEOF(USEDIN(
             dl,'ASSOCIATIVE_DRAUGHTING.' + 
             'DIMENSIONAL_CHARACTERISTIC_REPRESENTATION.DIMENSION')) >= 1) 
             AND (SIZEOF(QUERY ( pd <* USEDIN(dl,'ASSOCIATIVE_DRAUGHTING.' 
             + 'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
             QUERY ( sdr <* USEDIN(pd,'ASSOCIATIVE_DRAUGHTING.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (
             'SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(sdr)) )) = 1)) )) 
             = 0))) )) = 0;
    wr2: SIZEOF(QUERY ( ds <* dimensional_size | (NOT ((SIZEOF(USEDIN(ds,
             'ASSOCIATIVE_DRAUGHTING.' + 
             'DIMENSIONAL_CHARACTERISTIC_REPRESENTATION.DIMENSION')) >= 1) 
             AND (SIZEOF(QUERY ( pd <* USEDIN(ds.applies_to,
             'ASSOCIATIVE_DRAUGHTING.PROPERTY_DEFINITION.DEFINITION') | (
             NOT (SIZEOF(QUERY ( sdr <* USEDIN(pd,'ASSOCIATIVE_DRAUGHTING.' 
             + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (
             'SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(sdr)) )) = 1)) )) 
             = 0))) )) = 0;

  END_RULE; -- dimensions_are_represented

  RULE draughting_model_annotation_layers FOR (draughting_model);

  WHERE
    wr1: SIZEOF(QUERY ( dm <* draughting_model | (NOT (SIZEOF(
             QUERY ( ao <* QUERY ( it <* dm\representation.items | (
             'ASSOCIATIVE_DRAUGHTING.ANNOTATION_OCCURRENCE' IN TYPEOF(it)) )
              | (NOT (SIZEOF(USEDIN(ao,'ASSOCIATIVE_DRAUGHTING.' + 
             'PRESENTATION_LAYER_ASSIGNMENT.' + 'ASSIGNED_ITEMS')) >= 1)) )) 
             = 0)) )) = 0;

  END_RULE; -- draughting_model_annotation_layers

  RULE draughting_sub_model_mapped_item FOR (mapped_item);

  WHERE
    wr1: SIZEOF(QUERY ( sr <* QUERY ( mi <* mapped_item | ((
             'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION' IN TYPEOF(mi.
             mapping_source.mapped_representation)) AND (NOT (
             'ASSOCIATIVE_DRAUGHTING.SHAPE_DIMENSION_REPRESENTATION' IN 
             TYPEOF(mi.mapping_source.mapped_representation)))) ) | (NOT (
             SIZEOF(USEDIN(sr,'')) = SIZEOF(QUERY ( mr <* USEDIN(sr,
             'ASSOCIATIVE_DRAUGHTING.' + 'REPRESENTATION.ITEMS') | (SIZEOF(
             ['ASSOCIATIVE_DRAUGHTING.DRAUGHTING_MODEL',
             'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION'] * TYPEOF(mr)) =
              1) )))) )) = 0;

  END_RULE; -- draughting_sub_model_mapped_item

  RULE draughting_subfigure_representation_layers FOR (
             draughting_subfigure_representation);

  WHERE
    wr1: SIZEOF(QUERY ( dsr <* draughting_subfigure_representation | (NOT 
             (SIZEOF(QUERY ( item <* dsr\representation.items | ((
             'ASSOCIATIVE_DRAUGHTING.ANNOTATION_OCCURRENCE' IN TYPEOF(item)) 
             AND (SIZEOF(USEDIN(item,'ASSOCIATIVE_DRAUGHTING.' + 
             'PRESENTATION_LAYER_ASSIGNMENT.' + 'ASSIGNED_ITEMS')) = 0)) )) 
             = 0)) )) = 0;

  END_RULE; -- draughting_subfigure_representation_layers

  RULE drawing_sheet_annotation_layers FOR (drawing_sheet_revision);

  WHERE
    wr1: SIZEOF(QUERY ( dsr <* drawing_sheet_revision | (NOT (SIZEOF(
             QUERY ( ao <* QUERY ( it <* dsr\representation.items | (
             'ASSOCIATIVE_DRAUGHTING.ANNOTATION_OCCURRENCE' IN TYPEOF(it)) )
              | (NOT (SIZEOF(USEDIN(ao,'ASSOCIATIVE_DRAUGHTING.' + 
             'PRESENTATION_LAYER_ASSIGNMENT.' + 'ASSIGNED_ITEMS')) >= 1)) )) 
             = 0)) )) = 0;

  END_RULE; -- drawing_sheet_annotation_layers

  RULE drawing_sheet_layout_usage FOR (mapped_item);

  WHERE
    wr1: SIZEOF(QUERY ( dsl <* QUERY ( mi <* mapped_item | (
             'ASSOCIATIVE_DRAUGHTING.DRAWING_SHEET_LAYOUT' IN TYPEOF(mi.
             mapping_source.mapped_representation)) ) | (NOT (SIZEOF(
             USEDIN(dsl,'')) = SIZEOF(QUERY ( dsr <* USEDIN(dsl,
             'ASSOCIATIVE_DRAUGHTING.' + 'REPRESENTATION.ITEMS') | (
             'ASSOCIATIVE_DRAUGHTING.DRAWING_SHEET_REVISION' IN TYPEOF(dsr))
)))) )) 
             = 0;

  END_RULE; -- drawing_sheet_layout_usage

  RULE drawing_view_annotation_layers FOR (presentation_view);

  WHERE
    wr1: SIZEOF(QUERY ( pv <* presentation_view | (NOT (SIZEOF(
             QUERY ( ao <* QUERY ( it <* pv\representation.items | (
             'ASSOCIATIVE_DRAUGHTING.ANNOTATION_OCCURRENCE' IN TYPEOF(it)) )
              | (NOT (SIZEOF(USEDIN(ao,'ASSOCIATIVE_DRAUGHTING.' + 
             'PRESENTATION_LAYER_ASSIGNMENT.' + 'ASSIGNED_ITEMS')) >= 1)) )) 
             = 0)) )) = 0;

  END_RULE; -- drawing_view_annotation_layers

  RULE externally_defined_symbol_instantiation FOR (
             externally_defined_symbol);

  WHERE
    wr1: SIZEOF(QUERY ( each <* externally_defined_symbol | (NOT (SIZEOF(
             USEDIN(each,'')) >= 1)) )) = 0;

  END_RULE; -- externally_defined_symbol_instantiation

  RULE fill_area_style_colour_instantiation FOR (fill_area_style_colour);

  WHERE
    wr1: SIZEOF(QUERY ( each <* fill_area_style_colour | (NOT (SIZEOF(
             USEDIN(each,'')) >= 1)) )) = 0;

  END_RULE; -- fill_area_style_colour_instantiation

  RULE fill_area_style_instantiation FOR (fill_area_style);

  WHERE
    wr1: SIZEOF(QUERY ( each <* fill_area_style | (NOT (SIZEOF(USEDIN(each,
             '')) >= 1)) )) = 0;

  END_RULE; -- fill_area_style_instantiation

  RULE fill_area_style_tile_symbol_constraint FOR (
             fill_area_style_tile_symbol_with_style);

  WHERE
    wr1: SIZEOF(QUERY ( fast <* fill_area_style_tile_symbol_with_style | (
             ('ASSOCIATIVE_DRAUGHTING.DEFINED_SYMBOL' IN TYPEOF(fast.symbol
             \styled_item.item)) AND (NOT (
             'ASSOCIATIVE_DRAUGHTING.EXTERNALLY_DEFINED_SYMBOL' IN TYPEOF(
             fast.symbol\styled_item.item\defined_symbol.definition)))) )) 
             = 0;

  END_RULE; -- fill_area_style_tile_symbol_constraint

  RULE geometric_elements_belong_to_layers FOR (point, curve, surface);

  WHERE
    wr1: SIZEOF(QUERY ( geo_pt <* QUERY ( pt <* point | (SIZEOF(
             QUERY ( rep <* USEDIN(pt,'ASSOCIATIVE_DRAUGHTING.' + 
             'REPRESENTATION.ITEMS') | (
             'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION' IN TYPEOF(rep)) )) 
             > 0) ) | (NOT (SIZEOF(USEDIN(geo_pt,'ASSOCIATIVE_DRAUGHTING.' 
             + 'PRESENTATION_LAYER_ASSIGNMENT.ASSIGNED_ITEMS')) >= 1)) )) =
              0;
    wr2: SIZEOF(QUERY ( geo_cv <* QUERY ( cv <* curve | (SIZEOF(
             QUERY ( rep <* USEDIN(cv,'ASSOCIATIVE_DRAUGHTING.' + 
             'REPRESENTATION.ITEMS') | (
             'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION' IN TYPEOF(rep)) )) 
             > 0) ) | (NOT (SIZEOF(USEDIN(geo_cv,'ASSOCIATIVE_DRAUGHTING.' 
             + 'PRESENTATION_LAYER_ASSIGNMENT.ASSIGNED_ITEMS')) >= 1)) )) =
              0;
    wr3: SIZEOF(QUERY ( geo_sf <* QUERY ( sf <* surface | (SIZEOF(
             QUERY ( rep <* USEDIN(sf,'ASSOCIATIVE_DRAUGHTING.' + 
             'REPRESENTATION.ITEMS') | (
             'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION' IN TYPEOF(rep)) )) 
             > 0) ) | (NOT (SIZEOF(USEDIN(geo_sf,'ASSOCIATIVE_DRAUGHTING.' 
             + 'PRESENTATION_LAYER_ASSIGNMENT.ASSIGNED_ITEMS')) >= 1)) )) =
              0;

  END_RULE; -- geometric_elements_belong_to_layers

  RULE global_length_and_angle_units_2d_or_3d FOR (
             global_unit_assigned_context);

  WHERE
    wr1: SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT (
             SIZEOF(guac.units) <= 3)) )) = 0;
    wr2: SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT ((
             SIZEOF(QUERY ( x <* guac.units | (
             'ASSOCIATIVE_DRAUGHTING.LENGTH_UNIT' IN TYPEOF(x)) )) = 1) AND
              (SIZEOF(QUERY ( x <* guac.units | (
             'ASSOCIATIVE_DRAUGHTING.PLANE_ANGLE_UNIT' IN TYPEOF(x)) )) = 1) 
             AND (SIZEOF(QUERY ( x <* guac.units | (
             'ASSOCIATIVE_DRAUGHTING.SOLID_ANGLE_UNIT' IN TYPEOF(x)) )) <= 
             1))) )) = 0;

  END_RULE; -- global_length_and_angle_units_2d_or_3d

  RULE groups_contain_elements FOR (group, group_assignment, 
             group_relationship);

  WHERE
    wr1: SIZEOF(QUERY ( g <* group | (NOT ((SIZEOF(QUERY ( ga <* 
             group_assignment | (g :=: ga.assigned_group) )) = 1) OR ((
             SIZEOF(QUERY ( ga <* group_assignment | (g :=: ga.
             assigned_group) )) = 0) AND (SIZEOF(QUERY ( gr <* 
             group_relationship | (g :=: gr.relating_group) )) >= 1)))) )) 
             = 0;

  END_RULE; -- groups_contain_elements

  RULE measure_with_unit_instantiation FOR (measure_with_unit);

  WHERE
    wr1: SIZEOF(QUERY ( m <* measure_with_unit | (NOT (SIZEOF(USEDIN(m,'')) 
             >= 1)) )) = 0;
    wr2: SIZEOF(QUERY ( m <* measure_with_unit | (NOT (SIZEOF(TYPEOF(m) * 
             ['ASSOCIATIVE_DRAUGHTING.LENGTH_MEASURE_WITH_UNIT',
             'ASSOCIATIVE_DRAUGHTING.PLANE_ANGLE_MEASURE_WITH_UNIT',
             'ASSOCIATIVE_DRAUGHTING.SOLID_ANGLE_MEASURE_WITH_UNIT']) = 1)) ))

             = 0;

  END_RULE; -- measure_with_unit_instantiation

  RULE named_unit_instantiation FOR (named_unit);

  WHERE
    wr1: SIZEOF(QUERY ( n <* named_unit | (NOT (SIZEOF(USEDIN(n,'')) >= 1)) ))

             = 0;
    wr2: SIZEOF(QUERY ( n <* named_unit | (NOT (SIZEOF(TYPEOF(n) * [
             'ASSOCIATIVE_DRAUGHTING.CONVERSION_BASED_UNIT',
             'ASSOCIATIVE_DRAUGHTING.LENGTH_UNIT',
             'ASSOCIATIVE_DRAUGHTING.PLANE_ANGLE_UNIT',
             'ASSOCIATIVE_DRAUGHTING.SOLID_ANGLE_UNIT',
             'ASSOCIATIVE_DRAUGHTING.SI_UNIT']) = 2)) )) = 0;

  END_RULE; -- named_unit_instantiation

  RULE pre_defined_colour_instantiation FOR (pre_defined_colour);

  WHERE
    wr1: SIZEOF(QUERY ( each <* pre_defined_colour | (NOT (SIZEOF(USEDIN(
             each,'')) >= 1)) )) = 0;

  END_RULE; -- pre_defined_colour_instantiation

  RULE pre_defined_symbol_instantiation FOR (pre_defined_symbol);

  WHERE
    wr1: SIZEOF(QUERY ( each <* pre_defined_symbol | (NOT (SIZEOF(USEDIN(
             each,'')) >= 1)) )) = 0;

  END_RULE; -- pre_defined_symbol_instantiation

  RULE presentation_layer_assignment_constraint_2d_or_3d FOR (
             presentation_layer_assignment);

  WHERE
    wr1: SIZEOF(QUERY ( pla <* presentation_layer_assignment | (NOT (
             SIZEOF(QUERY ( item <* pla.assigned_items | (NOT (SIZEOF(
             TYPEOF(item) * ['ASSOCIATIVE_DRAUGHTING.POINT',
             'ASSOCIATIVE_DRAUGHTING.CURVE',
             'ASSOCIATIVE_DRAUGHTING.SURFACE',
             'ASSOCIATIVE_DRAUGHTING.ANNOTATION_OCCURRENCE']) = 1)) )) = 0)))) 
            = 0;
    wr2: SIZEOF(QUERY ( pla <* presentation_layer_assignment | (NOT (
             SIZEOF(QUERY ( pnt <* QUERY ( item <* pla.assigned_items | (
             'ASSOCIATIVE_DRAUGHTING.POINT' IN TYPEOF(item)) ) | (NOT (
             SIZEOF(QUERY ( rep <* USEDIN(pnt,
             'ASSOCIATIVE_DRAUGHTING.REPRESENTATION.ITEMS') | (
             'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION' IN TYPEOF(rep)) )) 
             = 0)) )) = 0)) )) = 0;
    wr3: SIZEOF(QUERY ( pla <* presentation_layer_assignment | (NOT (
             SIZEOF(QUERY ( crv <* QUERY ( item <* pla.assigned_items | (
             'ASSOCIATIVE_DRAUGHTING.CURVE' IN TYPEOF(item)) ) | (NOT (
             SIZEOF(QUERY ( rep <* USEDIN(crv,
             'ASSOCIATIVE_DRAUGHTING.REPRESENTATION.ITEMS') | (
             'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION' IN TYPEOF(rep)) )) 
             = 0)) )) = 0)) )) = 0;
    wr4: SIZEOF(QUERY ( pla <* presentation_layer_assignment | (NOT (
             SIZEOF(QUERY ( srf <* QUERY ( item <* pla.assigned_items | (
             'ASSOCIATIVE_DRAUGHTING.SURFACE' IN TYPEOF(item)) ) | (NOT (
             SIZEOF(QUERY ( rep <* USEDIN(srf,
             'ASSOCIATIVE_DRAUGHTING.REPRESENTATION.ITEMS') | (
             'ASSOCIATIVE_DRAUGHTING.SHAPE_REPRESENTATION' IN TYPEOF(rep)) )) 
             = 0)) )) = 0)) )) = 0;
    wr5: SIZEOF(QUERY ( pla <* presentation_layer_assignment | (NOT (
             SIZEOF(QUERY ( ao <* QUERY ( item <* pla.assigned_items | (
             'ASSOCIATIVE_DRAUGHTING.ANNOTATION_OCCURRENCE' IN TYPEOF(item)) )
              | (NOT (SIZEOF(QUERY ( ur <* using_representations(ao) | (
             NOT (SIZEOF(TYPEOF(ur) * ['ASSOCIATIVE_DRAUGHTING.' + 
             'DRAUGHTING_SUBFIGURE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_MODEL',
             'ASSOCIATIVE_DRAUGHTING.DRAWING_SHEET_REVISION',
             'ASSOCIATIVE_DRAUGHTING.PRESENTATION_VIEW']) = 1)) )) = 0)) )) 
             = 0)) )) = 0;

  END_RULE; -- presentation_layer_assignment_constraint_2d_or_3d

  RULE presentation_layer_assignment_requires_usage FOR (
             presentation_layer_assignment, presentation_layer_usage);

  WHERE
    wr1: SIZEOF(QUERY ( e <* presentation_layer_assignment | (NOT (SIZEOF(
             QUERY ( s <* presentation_layer_usage | (e :=: s.assignment) )) 
             = 1)) )) = 0;

  END_RULE; -- presentation_layer_assignment_requires_usage

  RULE presentation_of_product_definition_formation FOR (
             product_definition_formation);

  WHERE
    wr1: SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT ((
             SIZEOF(USEDIN(pdf,'ASSOCIATIVE_DRAUGHTING.' + 
             'DRAUGHTING_PRESENTED_ITEM.ITEMS')) >= 1) OR (SIZEOF(
             QUERY ( pd <* USEDIN(pdf,'ASSOCIATIVE_DRAUGHTING.' + 
             'PRODUCT_DEFINITION.FORMATION') | (NOT (SIZEOF(QUERY ( pds <* 
             QUERY ( prop_def <* USEDIN(pd,'ASSOCIATIVE_DRAUGHTING.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (
             'ASSOCIATIVE_DRAUGHTING.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
             prop_def)) ) | (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pds,
             'ASSOCIATIVE_DRAUGHTING.PROPERTY_' + 
             'DEFINITION_REPRESENTATION.DEFINITION') | (
             'ASSOCIATIVE_DRAUGHTING.SHAPE_DEFINITION_REPRESENTATION' IN 
             TYPEOF(pdr)) )) >= 1)) )) = 0)) )) = 0))) )) = 0;

  END_RULE; -- presentation_of_product_definition_formation

  RULE presentation_size_constraint FOR (presentation_size);

  WHERE
    wr1: SIZEOF(QUERY ( ps <* presentation_size | (NOT ((
             'ASSOCIATIVE_DRAUGHTING.' + 'DRAWING_SHEET_REVISION') IN 
             TYPEOF(ps.unit))) )) = 0;

  END_RULE; -- presentation_size_constraint

  RULE presentation_style_by_context_constraint FOR (
             presentation_style_by_context);

  WHERE
    wr1: SIZEOF(QUERY ( psbc <* presentation_style_by_context | (NOT (
             'ASSOCIATIVE_DRAUGHTING.PRESENTATION_VIEW' IN TYPEOF(psbc.
             style_context))) )) = 0;
    wr2: SIZEOF(QUERY ( psbc <* presentation_style_by_context | (NOT (
             SIZEOF(psbc\presentation_style_assignment.styles) = 1)) )) = 0;

  END_RULE; -- presentation_style_by_context_constraint

  RULE presentation_style_by_context_instantiation FOR (
             presentation_style_by_context);

  WHERE
    wr1: SIZEOF(QUERY ( each <* presentation_style_by_context | (NOT (
             SIZEOF(USEDIN(each,'')) >= 1)) )) = 0;

  END_RULE; -- presentation_style_by_context_instantiation

  RULE presentation_view_presented_once FOR (presentation_view, 
             drawing_sheet_revision);

  WHERE
    wr1: SIZEOF(QUERY ( pv <* presentation_view | (NOT (SIZEOF(
             QUERY ( rm <* USEDIN(pv,'ASSOCIATIVE_DRAUGHTING.' + 
             'REPRESENTATION_MAP.MAPPED_REPRESENTATION') | (NOT (SIZEOF(
             QUERY ( mi <* rm.map_usage | (NOT (SIZEOF(QUERY ( dsr <* 
             drawing_sheet_revision | (mi IN dsr\representation.items) )) =
              1)) )) = 0)) )) = 0)) )) = 0;

  END_RULE; -- presentation_view_presented_once

  RULE product_definition_has_one_shape FOR (product_definition);

  WHERE
    wr1: SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
             QUERY ( prop_def <* USEDIN(pd,'ASSOCIATIVE_DRAUGHTING.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
             QUERY ( pdr <* USEDIN(prop_def,'ASSOCIATIVE_DRAUGHTING.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (
             'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_MODEL' IN TYPEOF(pdr.
             used_representation)) )) <= 1)) )) = 0)) )) = 0;

  END_RULE; -- product_definition_has_one_shape

  RULE product_definition_instantiation FOR (product_definition);

  WHERE
    wr1: SIZEOF(QUERY ( each <* product_definition | (NOT (SIZEOF(USEDIN(
             each,'')) >= 1)) )) = 0;

  END_RULE; -- product_definition_instantiation

  RULE product_requires_version FOR (product, product_definition_formation);

  WHERE
    wr1: SIZEOF(QUERY ( e <* product | (NOT (SIZEOF(QUERY ( s <* 
             product_definition_formation | (e :=: s.of_product) )) >= 1)) )) 
             = 0;

  END_RULE; -- product_requires_version

  RULE product_shape_has_representations FOR (product_definition_shape);

  WHERE
    wr1: SIZEOF(QUERY ( pds <* product_definition_shape | (NOT (SIZEOF(
             USEDIN(pds,'ASSOCIATIVE_DRAUGHTING.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION')) >= 1)) )) 
             = 0;

  END_RULE; -- product_shape_has_representations

  RULE product_version_requires_definition FOR (
             product_definition_formation, product_definition);

  WHERE
    wr1: SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( pd <* product_definition | (pdf :=: pd.
             formation) )) >= 1)) )) = 0;

  END_RULE; -- product_version_requires_definition

  RULE representation_context_global_units FOR (representation_context);

  WHERE
    wr1: SIZEOF(QUERY ( rc <* representation_context | (NOT ((
             'ASSOCIATIVE_DRAUGHTING.' + 'GLOBAL_UNIT_ASSIGNED_CONTEXT') IN
              TYPEOF(rc))) )) = 0;

  END_RULE; -- representation_context_global_units

  RULE representation_instantiation FOR (representation);

  WHERE
    wr1: SIZEOF(QUERY ( each <* representation | (NOT (SIZEOF(USEDIN(each,
             '')) >= 1)) )) = 0;

  END_RULE; -- representation_instantiation

  RULE restrict_product_definition_document_type FOR (
             product_definition_with_associated_documents);

  WHERE
    wr1: SIZEOF(QUERY ( pd <* product_definition_with_associated_documents
              | (NOT (SIZEOF(QUERY ( doc <* pd.documentation_ids | (NOT ((
             doc.kind.product_data_type = 'CAD filename') OR (doc.kind.
             product_data_type = 'drawing'))) )) = 0)) )) = 0;

  END_RULE; -- restrict_product_definition_document_type

  RULE shape_aspect_instantiation FOR (shape_aspect);

  WHERE
    wr1: SIZEOF(QUERY ( each <* shape_aspect | (NOT (SIZEOF(USEDIN(each,'')) 
             >= 1)) )) = 0;

  END_RULE; -- shape_aspect_instantiation

  RULE sheets_belong_to_one_drawing FOR (drawing_sheet_revision, 
             drawing_sheet_revision_usage);

  WHERE
    wr1: SIZEOF(QUERY ( dsr <* drawing_sheet_revision | (NOT (SIZEOF(
             QUERY ( usage <* drawing_sheet_revision_usage | (dsr :=: usage
             .area) )) = 1)) )) = 0;

  END_RULE; -- sheets_belong_to_one_drawing

  RULE styled_curve FOR (styled_item);

  WHERE
    wr1: SIZEOF(QUERY ( crv <* QUERY ( si <* styled_item | (
             'ASSOCIATIVE_DRAUGHTING.CURVE' IN TYPEOF(si.item)) ) | (NOT (
             SIZEOF(QUERY ( sty <* crv.styles | (NOT ((SIZEOF(sty.styles) =
              1) AND ('ASSOCIATIVE_DRAUGHTING.CURVE_STYLE' IN TYPEOF(sty.
             styles[1])))) )) = 0)) )) = 0;

  END_RULE; -- styled_curve

  RULE subtype_mandatory_annotation_occurrence FOR (annotation_occurrence);

  WHERE
    wr1: SIZEOF(QUERY ( ao <* annotation_occurrence | (NOT (
             'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_ANNOTATION_OCCURRENCE' IN 
             TYPEOF(ao))) )) = 0;

  END_RULE; -- subtype_mandatory_annotation_occurrence

  RULE subtype_mandatory_camera_image_2d_or_3d FOR (camera_image);

  WHERE
    wr1: SIZEOF(QUERY ( ci <* camera_image | (NOT (SIZEOF(TYPEOF(ci) * [
             'ASSOCIATIVE_DRAUGHTING.CAMERA_IMAGE_2D_WITH_SCALE',
             'ASSOCIATIVE_DRAUGHTING.CAMERA_IMAGE_3D_WITH_SCALE']) = 1)) )) 
             = 0;

  END_RULE; -- subtype_mandatory_camera_image_2d_or_3d

  RULE subtype_mandatory_camera_model_2d_or_3d FOR (camera_model);

  WHERE
    wr1: SIZEOF(QUERY ( cm <* camera_model | (NOT (SIZEOF(TYPEOF(cm) * [
             'ASSOCIATIVE_DRAUGHTING.CAMERA_MODEL_D2',
             'ASSOCIATIVE_DRAUGHTING.CAMERA_MODEL_D3']) = 1)) )) = 0;

  END_RULE; -- subtype_mandatory_camera_model_2d_or_3d

  RULE subtype_mandatory_draughting_callout FOR (draughting_callout);

  WHERE
    wr1: SIZEOF(QUERY ( dc <* draughting_callout | (NOT (
             'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_ELEMENTS' IN TYPEOF(dc))) )) 
             = 0;

  END_RULE; -- subtype_mandatory_draughting_callout

  RULE subtype_mandatory_drawing_revision FOR (drawing_revision);

  WHERE
    wr1: SIZEOF(QUERY ( dr <* drawing_revision | (NOT (
             'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_DRAWING_REVISION' IN 
             TYPEOF(dr))) )) = 0;

  END_RULE; -- subtype_mandatory_drawing_revision

  RULE subtype_mandatory_pre_defined_colour FOR (pre_defined_colour);

  WHERE
    wr1: SIZEOF(QUERY ( pdc <* pre_defined_colour | (NOT (
             'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_PRE_DEFINED_COLOUR' IN 
             TYPEOF(pdc))) )) = 0;

  END_RULE; -- subtype_mandatory_pre_defined_colour

  RULE subtype_mandatory_pre_defined_curve_font FOR (
             pre_defined_curve_font);

  WHERE
    wr1: SIZEOF(QUERY ( pdcf <* pre_defined_curve_font | (NOT (
             'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_PRE_DEFINED_CURVE_FONT' IN 
             TYPEOF(pdcf))) )) = 0;

  END_RULE; -- subtype_mandatory_pre_defined_curve_font

  RULE subtype_mandatory_pre_defined_symbol FOR (pre_defined_symbol);

  WHERE
    wr1: SIZEOF(QUERY ( pds <* pre_defined_symbol | (NOT (SIZEOF(TYPEOF(
             pds) * ['ASSOCIATIVE_DRAUGHTING.' + 
             'PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL',
             'ASSOCIATIVE_DRAUGHTING.' + 'PRE_DEFINED_DIMENSION_SYMBOL',
             'ASSOCIATIVE_DRAUGHTING.' + 'PRE_DEFINED_POINT_MARKER_SYMBOL',
             'ASSOCIATIVE_DRAUGHTING.' + 'PRE_DEFINED_TERMINATOR_SYMBOL']) 
             = 1)) )) = 0;

  END_RULE; -- subtype_mandatory_pre_defined_symbol

  RULE subtype_mandatory_pre_defined_text_font FOR (pre_defined_text_font);

  WHERE
    wr1: SIZEOF(QUERY ( pdtf <* pre_defined_text_font | (NOT (
             'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_PRE_DEFINED_TEXT_FONT' IN 
             TYPEOF(pdtf))) )) = 0;

  END_RULE; -- subtype_mandatory_pre_defined_text_font

  RULE subtype_mandatory_shape_representation_2d_or_3d FOR (
             shape_representation);

  WHERE
    wr1: SIZEOF(QUERY ( sr <* shape_representation | (NOT ((SIZEOF(TYPEOF(
             sr) * ['ASSOCIATIVE_DRAUGHTING.' + 
             'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.' + 
             'ELEMENTARY_2D_GEOMETRIC_CURVE_SET_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.' + 
             'EDGE_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.' + 
             'SHELL_BASED_2D_WIREFRAME_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.' + 
             'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.' + 
             'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.' + 
             'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.' + 
             'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.' + 
             'MANIFOLD_SURFACE_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.ADVANCED_BREP_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.ELEMENTARY_BREP_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.FACETED_BREP_SHAPE_REPRESENTATION',
             'ASSOCIATIVE_DRAUGHTING.SHAPE_DIMENSION_REPRESENTATION']) = 1) 
             OR (SIZEOF(QUERY ( it <* sr\representation.items | (NOT (
             SIZEOF(TYPEOF(it) * [
             'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_2D',
             'ASSOCIATIVE_DRAUGHTING.AXIS2_PLACEMENT_3D']) = 1)) )) = 0) OR
              (SIZEOF(QUERY ( pdr <* USEDIN(sr,'ASSOCIATIVE_DRAUGHTING.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | (
             NOT (SIZEOF(TYPEOF(pdr\property_definition_representation.
             definition.definition) * [
             'ASSOCIATIVE_DRAUGHTING.SHAPE_ASPECT_RELATIONSHIP',
             'ASSOCIATIVE_DRAUGHTING.SHAPE_ASPECT']) = 1)) )) = 0))) )) = 0;

  END_RULE; -- subtype_mandatory_shape_representation_2d_or_3d

  RULE symbol_colour_instantiation FOR (symbol_colour);

  WHERE
    wr1: SIZEOF(QUERY ( each <* symbol_colour | (NOT (SIZEOF(USEDIN(each,
             '')) >= 1)) )) = 0;

  END_RULE; -- symbol_colour_instantiation

  RULE terminator_symbol_constraint FOR (terminator_symbol);

  WHERE
    wr1: SIZEOF(QUERY ( ts <* terminator_symbol | ((
             'ASSOCIATIVE_DRAUGHTING.DEFINED_SYMBOL' IN TYPEOF(ts.item)) 
             AND (NOT (
             'ASSOCIATIVE_DRAUGHTING.PRE_DEFINED_TERMINATOR_SYMBOL' IN 
             TYPEOF(ts.item\defined_symbol.definition)))) )) = 0;

  END_RULE; -- terminator_symbol_constraint

  RULE text_font_usage FOR (pre_defined_text_font, 
             externally_defined_text_font);

  WHERE
    wr1: SIZEOF(QUERY ( pdtf <* pre_defined_text_font | (NOT (SIZEOF(
             USEDIN(pdtf,'ASSOCIATIVE_DRAUGHTING.' + 'TEXT_LITERAL.FONT')) 
             >= 1)) )) = 0;
    wr2: SIZEOF(QUERY ( edtf <* externally_defined_text_font | (NOT (
             SIZEOF(USEDIN(edtf,'ASSOCIATIVE_DRAUGHTING.' + 
             'TEXT_LITERAL.FONT')) >= 1)) )) = 0;

  END_RULE; -- text_font_usage

  RULE text_style_for_defined_font_instantiation FOR (
             text_style_for_defined_font);

  WHERE
    wr1: SIZEOF(QUERY ( each <* text_style_for_defined_font | (NOT (
             SIZEOF(USEDIN(each,'')) >= 1)) )) = 0;

  END_RULE; -- text_style_for_defined_font_instantiation

  RULE text_style_instantiation FOR (text_style);

  WHERE
    wr1: SIZEOF(QUERY ( each <* text_style | (NOT (SIZEOF(USEDIN(each,'')) 
             >= 1)) )) = 0;

  END_RULE; -- text_style_instantiation

  RULE tolerance_value_instantiation FOR (tolerance_value);

  WHERE
    wr1: SIZEOF(QUERY ( each <* tolerance_value | (NOT (SIZEOF(USEDIN(each,
             '')) >= 1)) )) = 0;

  END_RULE; -- tolerance_value_instantiation

  RULE units_name_and_prefix_constraint FOR (si_unit);

  WHERE
    wr1: SIZEOF(QUERY ( su <* si_unit | (NOT ((su.name = 'metre') XOR (su.
             name = 'radian') XOR (su.name = 'steradian'))) )) = 0;
    wr2: SIZEOF(QUERY ( lu <* QUERY ( su <* si_unit | (su.name = 'metre') )
              | (NOT ((NOT EXISTS(lu.prefix)) XOR (lu.prefix = 'micro') XOR
              (lu.prefix = 'milli') XOR (lu.prefix = 'centi') XOR (lu.
             prefix = 'kilo'))) )) = 0;
    wr3: SIZEOF(QUERY ( pau <* QUERY ( su <* si_unit | (su.name = 'radian') )
              | EXISTS(pau.prefix) )) = 0;
    wr4: SIZEOF(QUERY ( sau <* QUERY ( su <* si_unit | (su.name = 
             'steradian') ) | EXISTS(sau.prefix) )) = 0;

  END_RULE; -- units_name_and_prefix_constraint

  FUNCTION acyclic_composite_text(
               start_composite: composite_text;
               child_text: SET [1:?] OF text_or_character
      ): LOGICAL;
    LOCAL
      i                     : INTEGER;
      local_annotation_text : SET [0:?] OF annotation_text;
      local_composite_text  : SET [0:?] OF composite_text;
      local_children        : SET [0:?] OF text_or_character;
    END_LOCAL;
    local_composite_text := QUERY ( child <* child_text | (
        'ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT' IN TYPEOF(child)) );
    IF SIZEOF(local_composite_text) > 0 THEN
      REPEAT i := 1 TO HIINDEX(local_composite_text) BY 1;
        IF start_composite :=: local_composite_text[i] THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    local_children := child_text;
    IF SIZEOF(local_composite_text) > 0 THEN
      REPEAT i := 1 TO HIINDEX(local_composite_text) BY 1;
        local_children := local_children + local_composite_text[i].
            collected_text;
      END_REPEAT;
    END_IF;
    local_annotation_text := QUERY ( child <* child_text | (
        'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT' IN TYPEOF(child)) );
    IF SIZEOF(local_annotation_text) > 0 THEN
      REPEAT i := 1 TO HIINDEX(local_annotation_text) BY 1;
        local_children := local_children + QUERY ( item <* 
            local_annotation_text[i]\mapped_item.mapping_source.
            mapped_representation.items | (SIZEOF([
            'ASSOCIATIVE_DRAUGHTING.ANNOTATION_TEXT',
            'ASSOCIATIVE_DRAUGHTING.COMPOSITE_TEXT'] * TYPEOF(item)) > 0) );
      END_REPEAT;
    END_IF;
    IF local_children :<>: child_text THEN
      RETURN(acyclic_composite_text(start_composite,local_children));
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- acyclic_composite_text

  FUNCTION acyclic_curve_replica(
               rep: curve_replica;
               parent: curve
      ): BOOLEAN;
    IF NOT ('ASSOCIATIVE_DRAUGHTING.CURVE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;

  END_FUNCTION; -- acyclic_curve_replica

  FUNCTION acyclic_mapped_item_usage(
               rep: representation
      ): BOOLEAN;
    LOCAL
      i     : INTEGER;
      items : SET OF representation_item;
    END_LOCAL;
    items := QUERY ( item <* rep.items | (
        'ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' IN TYPEOF(item)) );
    IF SIZEOF(items) = 0 THEN
      RETURN(FALSE);
    ELSE
      REPEAT i := 1 TO HIINDEX(items) BY 1;
        IF items[i]\mapped_item.mapping_source.mapped_representation :=: 
            rep THEN
          RETURN(TRUE);
        ELSE
          RETURN(acyclic_mapped_item_usage(items[i]\mapped_item.
              mapping_source.mapped_representation));
        END_IF;
      END_REPEAT;
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- acyclic_mapped_item_usage

  FUNCTION acyclic_mapped_representation(
               parent_set: SET OF representation;
               children_set: SET OF representation_item
      ): BOOLEAN;
    LOCAL
      i : INTEGER;
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | ('ASSOCIATIVE_DRAUGHTING.MAPPED_ITEM' 
        IN TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
            'ASSOCIATIVE_DRAUGHTING.REPRESENTATION_ITEM' IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_mapped_representation

  FUNCTION acyclic_point_replica(
               rep: point_replica;
               parent: point
      ): BOOLEAN;
    IF NOT ('ASSOCIATIVE_DRAUGHTING.POINT_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
    END_IF;

  END_FUNCTION; -- acyclic_point_replica

  FUNCTION acyclic_surface_replica(
               rep: surface_replica;
               parent: surface
      ): BOOLEAN;
    IF NOT ('ASSOCIATIVE_DRAUGHTING.SURFACE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_surface_replica(rep,parent\surface_replica.
          parent_surface));
    END_IF;

  END_FUNCTION; -- acyclic_surface_replica

  FUNCTION aspect_ratio(
               p: planar_box
      ): positive_ratio_measure;
    RETURN(p.size_in_x / p.size_in_y);

  END_FUNCTION; -- aspect_ratio

  FUNCTION associated_surface(
               arg: pcurve_or_surface
      ): surface;
    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(arg) THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);

  END_FUNCTION; -- associated_surface

  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;
    LOCAL
      i       : INTEGER;
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

  END_FUNCTION; -- bag_to_set

  FUNCTION base_axis(
               dim: INTEGER;
               axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;
    LOCAL
      u      : LIST [2:3] OF direction;
      vec    : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      u[3] := NVL(normalise(axis3),direction([0,0,1]));
      u[1] := first_proj_axis(u[3],axis1);
      u[2] := second_proj_axis(u[3],u[1],axis2);
    ELSE
      u[3] := ?;
      IF EXISTS(axis1) THEN
        u[1] := normalise(axis1);
        u[2] := orthogonal_complement(u[1]);
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          u[2] := normalise(axis2);
          u[1] := orthogonal_complement(u[2]);
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u[1].direction_ratios[1] := 1;
          u[1].direction_ratios[2] := 0;
          u[2].direction_ratios[1] := 0;
          u[2].direction_ratios[2] := 1;
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

  END_FUNCTION; -- base_axis

  FUNCTION basis_curve_check(
               cv: curve
      ): BOOLEAN;
    IF ('ASSOCIATIVE_DRAUGHTING.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\
        b_spline_curve.self_intersect = FALSE) THEN
      RETURN(TRUE);
    ELSE
      IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
          'ASSOCIATIVE_DRAUGHTING.CONIC','ASSOCIATIVE_DRAUGHTING.LINE'] * 
          TYPEOF(cv)) = 1 THEN
        RETURN(TRUE);
      ELSE
        IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
            'ASSOCIATIVE_DRAUGHTING.CURVE_REPLICA'] * TYPEOF(cv)) = 1 THEN
          RETURN(basis_curve_check(cv\curve_replica.parent_curve));
        ELSE
          IF (SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
              'ASSOCIATIVE_DRAUGHTING.OFFSET_CURVE_3D'] * TYPEOF(cv)) = 1) 
              AND (cv\offset_curve_3d.self_intersect = FALSE) THEN
            RETURN(basis_curve_check(cv\offset_curve_3d.basis_curve));
          ELSE
            IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
                'ASSOCIATIVE_DRAUGHTING.PCURVE'] * TYPEOF(cv)) = 1 THEN
              RETURN(basis_curve_check(cv\pcurve.reference_to_curve\
                  representation.items[1]) AND basis_surface_check(cv\
                  pcurve.basis_surface));
            ELSE
              IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
                  'ASSOCIATIVE_DRAUGHTING.SURFACE_CURVE'] * TYPEOF(cv)) = 1
                   THEN
                IF basis_curve_check(cv\surface_curve.curve_3d) THEN
                  REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                      associated_geometry) BY 1;
                    IF 'ASSOCIATIVE_DRAUGHTING.SURFACE' IN TYPEOF(cv\
                        surface_curve.associated_geometry[i]) THEN
                      IF NOT basis_surface_check(cv\surface_curve.
                          associated_geometry[i]) THEN
                        RETURN(FALSE);
                      END_IF;
                    ELSE
                      IF 'ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(cv\
                          surface_curve.associated_geometry[i]) THEN
                        IF NOT basis_curve_check(cv\surface_curve.
                            associated_geometry[i]) THEN
                          RETURN(FALSE);
                        END_IF;
                      END_IF;
                    END_IF;
                  END_REPEAT;
                  RETURN(TRUE);
                END_IF;
              ELSE
                IF 'ASSOCIATIVE_DRAUGHTING.POLYLINE' IN TYPEOF(cv) THEN
                  IF SIZEOF(cv\polyline.points) >= 3 THEN
                    RETURN(TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- basis_curve_check

  FUNCTION basis_surface_check(
               surf: surface
      ): BOOLEAN;
    IF 'ASSOCIATIVE_DRAUGHTING.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
      RETURN(TRUE);
    ELSE
      IF 'ASSOCIATIVE_DRAUGHTING.SWEPT_SURFACE' IN TYPEOF(surf) THEN
        RETURN(basis_curve_check(surf\swept_surface.swept_curve));
      ELSE
        IF ('ASSOCIATIVE_DRAUGHTING.OFFSET_SURFACE' IN TYPEOF(surf)) AND (
            surf\offset_surface.self_intersect = FALSE) THEN
          RETURN(basis_surface_check(surf\offset_surface.basis_surface));
        ELSE
          IF 'ASSOCIATIVE_DRAUGHTING.SURFACE REPLICA' IN TYPEOF(surf)
               THEN
            RETURN(basis_surface_check(surf\surface_replica.parent_surface));
          ELSE
            IF ('ASSOCIATIVE_DRAUGHTING.B_SPLINE_SURFACE' IN TYPEOF(surf)) 
                AND (surf\b_spline_surface.self_intersect = FALSE) THEN
              RETURN(TRUE);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- basis_surface_check

  FUNCTION boolean_choose(
               b: BOOLEAN;
               choice1, choice2: GENERIC:item
      ): GENERIC:item;
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;

  END_FUNCTION; -- boolean_choose

  FUNCTION build_2axes(
               ref_direction: direction
      ): LIST [2:2] OF direction;
    LOCAL
      u : LIST [2:2] OF direction;
    END_LOCAL;
    u[1] := NVL(normalise(ref_direction),direction([1,0]));
    u[2] := orthogonal_complement(u[1]);
    RETURN(u);

  END_FUNCTION; -- build_2axes

  FUNCTION build_axes(
               axis, ref_direction: direction
      ): LIST [3:3] OF direction;
    LOCAL
      u : LIST [3:3] OF direction;
    END_LOCAL;
    u[3] := NVL(normalise(axis),direction([0,0,1]));
    u[1] := first_proj_axis(u[3],ref_direction);
    u[2] := normalise(cross_product(u[3],u[1])).orientation;
    RETURN(u);

  END_FUNCTION; -- build_axes

  FUNCTION check_associative_shape_aspects(
               sdr: shape_definition_representation
      ): BOOLEAN;
    LOCAL
      sr1 : SET OF representation;
      sr2 : SET OF representation;
      i   : INTEGER;
      j   : INTEGER;
      k   : INTEGER;
      dm  : SET OF representation;
      pv  : SET OF representation;
    END_LOCAL;
    IF SIZEOF(sdr.used_representation.items) <> 2 THEN
      RETURN(FALSE);
    END_IF;
    sr1 := using_representations(sdr.used_representation.items[1]);
    sr2 := using_representations(sdr.used_representation.items[2]);
    REPEAT i := 1 TO HIINDEX(sr1) BY 1;
      dm := representations_mapped_into(sr1[i]);
      REPEAT j := 1 TO HIINDEX(dm) BY 1;
        IF 'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_MODEL' IN TYPEOF(dm[j])
             THEN
          IF dm[j] IN sr2 THEN
            RETURN(TRUE);
          END_IF;
          pv := representations_mapped_into(dm[j]);
          REPEAT k := 1 TO HIINDEX(pv) BY 1;
            IF 'ASSOCIATIVE_DRAUGHTING.PRESENTATION_VIEW' IN TYPEOF(pv[k])
                 THEN
              IF pv[k] IN sr2 THEN
                RETURN(TRUE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(sr2) BY 1;
      dm := representations_mapped_into(sr2[i]);
      REPEAT j := 1 TO HIINDEX(dm) BY 1;
        IF 'ASSOCIATIVE_DRAUGHTING.DRAUGHTING_MODEL' IN TYPEOF(dm[j])
             THEN
          IF dm[j] IN sr1 THEN
            RETURN(TRUE);
          END_IF;
          pv := representations_mapped_into(dm[j]);
          REPEAT k := 1 TO HIINDEX(pv) BY 1;
            IF 'ASSOCIATIVE_DRAUGHTING.PRESENTATION_VIEW' IN TYPEOF(pv[k])
                 THEN
              IF pv[k] IN sr1 THEN
                RETURN(TRUE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(FALSE);

  END_FUNCTION; -- check_associative_shape_aspects

  FUNCTION check_text_alignment(
               ct: composite_text
      ): BOOLEAN;
    LOCAL
      a : SET OF text_alignment := [];
      i : INTEGER;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(ct.collected_text) BY 1;
      a := a + [ct.collected_text[i]\text_literal.alignment];
    END_REPEAT;
    RETURN(SIZEOF(a) = 1);

  END_FUNCTION; -- check_text_alignment

  FUNCTION check_text_font(
               ct: composite_text
      ): BOOLEAN;
    LOCAL
      f : SET OF font_select := [];
      i : INTEGER;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(ct.collected_text) BY 1;
      f := f + [ct.collected_text[i]\text_literal.font];
    END_REPEAT;
    RETURN(SIZEOF(f) <= 1);

  END_FUNCTION; -- check_text_font

  FUNCTION conditional_reverse(
               p: BOOLEAN;
               an_item: reversible_topology
      ): reversible_topology;
    IF p THEN
      RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;

  END_FUNCTION; -- conditional_reverse

  FUNCTION constraints_composite_curve_on_surface(
               c: composite_curve_on_surface
      ): BOOLEAN;
    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(c\composite_curve
          .segments[k].parent_curve))) AND (NOT (
          'ASSOCIATIVE_DRAUGHTING.SURFACE_CURVE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) AND (NOT (
          'ASSOCIATIVE_DRAUGHTING.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_composite_curve_on_surface

  FUNCTION constraints_geometry_shell_based_surface_model(
               m: shell_based_surface_model
      ): BOOLEAN;
    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
      IF (NOT ('ASSOCIATIVE_DRAUGHTING.OPEN_SHELL' IN TYPEOF(m.
          sbsm_boundary[j]))) AND (NOT (
          'ASSOCIATIVE_DRAUGHTING.CLOSED_SHELL' IN
TYPEOF(m.sbsm_boundary[j])))
           THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_geometry_shell_based_surface_model

  FUNCTION constraints_geometry_shell_based_wireframe_model(
               m: shell_based_wireframe_model
      ): BOOLEAN;
    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
      IF (NOT ('ASSOCIATIVE_DRAUGHTING.WIRE_SHELL' IN TYPEOF(m.
          sbwm_boundary[j]))) AND (NOT (
          'ASSOCIATIVE_DRAUGHTING.VERTEX_SHELL' IN
TYPEOF(m.sbwm_boundary[j])))
           THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

  FUNCTION constraints_param_b_spline(
               degree, up_knots, up_cp: INTEGER;
               knot_mult: LIST OF INTEGER;
               knots: LIST OF parameter_value
      ): BOOLEAN;
    LOCAL
      k      : INTEGER;
      l      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (
        degree + up_cp + 2)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k < 1) OR (k > (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i < up_knots) AND (k > degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k > (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_param_b_spline

  FUNCTION constraints_rectangular_composite_surface(
               s: rectangular_composite_surface
      ): BOOLEAN;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF NOT (('ASSOCIATIVE_DRAUGHTING.B_SPLINE_SURFACE' IN TYPEOF(s.
            segments[i][j].parent_surface)) OR (
            'ASSOCIATIVE_DRAUGHTING.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(
            s.segments[i][j].parent_surface))) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u - 1 BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF s.segments[i][j].u_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v - 1 BY 1;
        IF s.segments[i][j].v_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_rectangular_composite_surface

  FUNCTION cross_product(
               arg1, arg2: direction
      ): vector;
    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res.direction_ratios[1] := (v1[2] * v2[3]) - (v1[3] * v2[2]);
        res.direction_ratios[2] := (v1[3] * v2[1]) - (v1[1] * v2[3]);
        res.direction_ratios[3] := (v1[1] * v2[2]) - (v1[2] * v2[1]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result.orientation := res;
          result.magnitude := SQRT(mag);
        ELSE
          result.orientation := arg1;
          result.magnitude := 0;
        END_IF;
        RETURN(result);
      END;
    END_IF;

  END_FUNCTION; -- cross_product

  FUNCTION curve_weights_positive(
               b: rational_b_spline_curve
      ): BOOLEAN;
    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] <= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- curve_weights_positive

  FUNCTION derive_dimensional_exponents(
               x: unit
      ): dimensional_exponents;
    LOCAL
      i      : INTEGER;
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'ASSOCIATIVE_DRAUGHTING.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- derive_dimensional_exponents

  FUNCTION dimension_of(
               item: geometric_representation_item
      ): dimension_count;
    LOCAL
      x : SET OF representation;
      y : representation_context;
    END_LOCAL;
    x := using_representations(item);
    y := x[1].context_of_items;
    RETURN(y\geometric_representation_context.coordinate_space_dimension);

  END_FUNCTION; -- dimension_of

  FUNCTION dimensions_for_si_unit(
               n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      END_CASE;

  END_FUNCTION; -- dimensions_for_si_unit

  FUNCTION dot_product(
               arg1, arg2: direction
      ): REAL;
    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);

  END_FUNCTION; -- dot_product

  FUNCTION edge_reversed(
               an_edge: edge
      ): edge;
    LOCAL
      the_reverse : edge;
    END_LOCAL;
    IF 'ASSOCIATIVE_DRAUGHTING.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
      the_reverse := oriented_edge(an_edge\oriented_edge.edge_element,NOT 
          an_edge\oriented_edge.orientation);
    ELSE
      the_reverse := oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- edge_reversed

  FUNCTION face_bound_reversed(
               a_face_bound: face_bound
      ): face_bound;
    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'ASSOCIATIVE_DRAUGHTING.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
         THEN
      the_reverse := face_bound(a_face_bound\face_bound.bound,NOT 
          a_face_bound\face_bound.orientation);
    ELSE
      the_reverse := face_bound(a_face_bound.bound,NOT a_face_bound.
          orientation);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_bound_reversed

  FUNCTION face_reversed(
               a_face: face
      ): face;
    LOCAL
      the_reverse : face;
    END_LOCAL;
    IF 'ASSOCIATIVE_DRAUGHTING.ORIENTED_FACE' IN TYPEOF(a_face) THEN
      the_reverse := oriented_face(a_face\oriented_face.face_element,NOT 
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_reversed

  FUNCTION first_proj_axis(
               z_axis, arg: direction
      ): direction;
    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF (NOT EXISTS(z_axis)) OR (NOT EXISTS(arg)) OR (arg.dim <> 3) THEN
      x_axis := ?;
    ELSE
      z_axis := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z_axis <> direction([1,0,0]) THEN
          v := direction([1,0,0]);
        ELSE
          v := direction([0,1,0]);
        END_IF;
      ELSE
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z_axis);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

  END_FUNCTION; -- first_proj_axis

  FUNCTION gbsf_check_curve(
               cv: curve
      ): BOOLEAN;
    IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
        'ASSOCIATIVE_DRAUGHTING.CIRCLE','ASSOCIATIVE_DRAUGHTING.ELLIPSE'] *
         TYPEOF(cv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF ('ASSOCIATIVE_DRAUGHTING.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\
          b_spline_curve.self_intersect = FALSE) THEN
        RETURN(TRUE);
      ELSE
        IF ('ASSOCIATIVE_DRAUGHTING.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (
            cv\composite_curve.self_intersect = FALSE) THEN
          RETURN(SIZEOF(QUERY ( seg <* cv\composite_curve.segments | (NOT 
              gbsf_check_curve(seg.parent_curve)) )) = 0);
        ELSE
          IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
              'ASSOCIATIVE_DRAUGHTING.CURVE_REPLICA'] * TYPEOF(cv)) = 1
               THEN
            RETURN(gbsf_check_curve(cv\curve_replica.parent_curve));
          ELSE
            IF (SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
                'ASSOCIATIVE_DRAUGHTING.OFFSET_CURVE_3D'] * TYPEOF(cv)) = 1) 
                AND (cv\offset_curve_3d.self_intersect = FALSE) THEN
              RETURN(gbsf_check_curve(cv\offset_curve_3d.basis_curve));
            ELSE
              IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
                  'ASSOCIATIVE_DRAUGHTING.PCURVE'] * TYPEOF(cv)) = 1 THEN
                RETURN(gbsf_check_curve(cv\pcurve.reference_to_curve.items
                    [1]) AND gbsf_check_surface(cv\pcurve.basis_surface));
              ELSE
                IF 'ASSOCIATIVE_DRAUGHTING.POLYLINE' IN TYPEOF(cv) THEN
                  IF (SIZEOF(cv\polyline.points) >= 3) AND (SIZEOF(
                      bag_to_set(USEDIN(cv,'')) - bag_to_set(USEDIN(cv,
                      'ASSOCIATIVE_DRAUGHTING.INTERSECTION_CURVE.CURVE_3D')))
=
                       0) THEN
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
                      'ASSOCIATIVE_DRAUGHTING.SURFACE_CURVE'] * TYPEOF(cv)) 
                      = 1 THEN
                    IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                      REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                          associated_geometry) BY 1;
                        IF 'ASSOCIATIVE_DRAUGHTING.SURFACE' IN TYPEOF(cv\
                            surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_surface(cv\surface_curve.
                              associated_geometry[i]) THEN
                            RETURN(FALSE);
                          END_IF;
                        ELSE
                          IF 'ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(cv\
                              surface_curve.associated_geometry[i]) THEN
                            IF NOT gbsf_check_curve(cv\surface_curve.
                                associated_geometry[i]) THEN
                              RETURN(FALSE);
                            END_IF;
                          END_IF;
                        END_IF;
                      END_REPEAT;
                      RETURN(TRUE);
                    END_IF;
                  ELSE
                    IF 'ASSOCIATIVE_DRAUGHTING.TRIMMED_CURVE' IN TYPEOF(cv)
                         THEN
                      IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.BOUNDED_CURVE',
                          'ASSOCIATIVE_DRAUGHTING.LINE',
                          'ASSOCIATIVE_DRAUGHTING.PARABOLA',
                          'ASSOCIATIVE_DRAUGHTING.HYPERBOLA'] * TYPEOF(cv\
                          trimmed_curve.basis_curve)) = 1 THEN
                        RETURN(TRUE);
                      ELSE
                        RETURN(gbsf_check_curve(cv\trimmed_curve.
                            basis_curve));
                      END_IF;
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- gbsf_check_curve

  FUNCTION gbsf_check_point(
               pnt: point
      ): BOOLEAN;
    IF 'ASSOCIATIVE_DRAUGHTING.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'ASSOCIATIVE_DRAUGHTING.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
        RETURN(gbsf_check_curve(pnt\point_on_curve.basis_curve));
      ELSE
        IF 'ASSOCIATIVE_DRAUGHTING.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
          RETURN(gbsf_check_surface(pnt\point_on_surface.basis_surface));
        ELSE
          IF 'ASSOCIATIVE_DRAUGHTING.DEGENERATE_PCURVE' IN TYPEOF(pnt)
               THEN
            RETURN(gbsf_check_curve(pnt\degenerate_pcurve.
                reference_to_curve.items[1]) AND gbsf_check_surface(pnt\
                degenerate_pcurve.basis_surface));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- gbsf_check_point

  FUNCTION gbsf_check_surface(
               sf: surface
      ): BOOLEAN;
    IF ('ASSOCIATIVE_DRAUGHTING.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\
        b_spline_surface.self_intersect = FALSE) THEN
      RETURN(TRUE);
    ELSE
      IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.SPHERICAL_SURFACE',
          'ASSOCIATIVE_DRAUGHTING.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 1
           THEN
        RETURN(TRUE);
      ELSE
        IF 'ASSOCIATIVE_DRAUGHTING.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf)
             THEN
          IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.CONICAL_SURFACE',
              'ASSOCIATIVE_DRAUGHTING.CYLINDRICAL_SURFACE',
              'ASSOCIATIVE_DRAUGHTING.PLANE'] * TYPEOF(sf\
              curve_bounded_surface.basis_surface)) = 1 THEN
            RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
                boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
          ELSE
            IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface)
                 THEN
              RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
                  boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
            END_IF;
          END_IF;
        ELSE
          IF ('ASSOCIATIVE_DRAUGHTING.OFFSET_SURFACE' IN TYPEOF(sf)) AND (
              sf\offset_surface.self_intersect = FALSE) THEN
            RETURN(gbsf_check_surface(sf\offset_surface.basis_surface));
          ELSE
            IF 'ASSOCIATIVE_DRAUGHTING.RECTANGULAR_COMPOSITE_SURFACE' IN 
                TYPEOF(sf) THEN
              REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.
                  segments) BY 1;
                REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.
                    segments[i]) BY 1;
                  IF NOT gbsf_check_surface(sf\
                      rectangular_composite_surface.segments[i][j].
                      parent_surface) THEN
                    RETURN(FALSE);
                  END_IF;
                END_REPEAT;
              END_REPEAT;
              RETURN(TRUE);
            ELSE
              IF 'ASSOCIATIVE_DRAUGHTING.RECTANGULAR_TRIMMED_SURFACE' IN 
                  TYPEOF(sf) THEN
                IF SIZEOF(['ASSOCIATIVE_DRAUGHTING.CONICAL_SURFACE',
                    'ASSOCIATIVE_DRAUGHTING.CYLINDRICAL_SURFACE',
                    'ASSOCIATIVE_DRAUGHTING.PLANE'] * TYPEOF(sf\
                    rectangular_trimmed_surface.basis_surface)) = 1 THEN
                  RETURN(TRUE);
                ELSE
                  RETURN(gbsf_check_surface(sf\rectangular_trimmed_surface
                      .basis_surface));
                END_IF;
              ELSE
                IF 'ASSOCIATIVE_DRAUGHTING.SURFACE_REPLICA' IN TYPEOF(sf)
                     THEN
                  RETURN(gbsf_check_surface(sf\surface_replica.
                      parent_surface));
                ELSE
                  IF 'ASSOCIATIVE_DRAUGHTING.SWEPT_SURFACE' IN TYPEOF(sf)
                       THEN
                    RETURN(gbsf_check_curve(sf\swept_surface.swept_curve));
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- gbsf_check_surface

  FUNCTION get_basis_surface(
               c: curve_on_surface
      ): SET [0:2] OF surface;
    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'ASSOCIATIVE_DRAUGHTING.PCURVE' IN TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'ASSOCIATIVE_DRAUGHTING.SURFACE_CURVE' IN TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
         THEN
      n := SIZEOF(c\composite_curve_on_surface.segments);
      surfs := get_basis_surface(c\composite_curve_on_surface.segments[1].
          parent_curve);
      IF n > 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve_on_surface.
              segments[i].parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);

  END_FUNCTION; -- get_basis_surface

  FUNCTION item_in_context(
               item: representation_item;
               cntxt: representation_context
      ): BOOLEAN;
    LOCAL
      i : INTEGER;
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'ASSOCIATIVE_DRAUGHTING.REPRESENTATION.ITEMS') *
         cntxt.representations_in_context) > 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | (
          'ASSOCIATIVE_DRAUGHTING.REPRESENTATION_ITEM' IN TYPEOF(z)) );
      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- item_in_context

  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- leap_year

  FUNCTION list_face_loops(
               f: face
      ): LIST [0:?] OF loop;
    LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);

  END_FUNCTION; -- list_face_loops

  FUNCTION list_of_topology_reversed(
               a_list: list_of_reversible_topology_item
      ): list_of_reversible_topology_item;
    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- list_of_topology_reversed

  FUNCTION list_to_array(
               lis: LIST [0:?] OF GENERIC:t;
               low, u: INTEGER
      ): ARRAY [low:u] OF GENERIC:t;
    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n <> ((u - low) + 1) THEN
      RETURN(?);
    ELSE
      REPEAT i := 1 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;

  END_FUNCTION; -- list_to_array

  FUNCTION list_to_set(
               l: LIST [0:?] OF GENERIC:t
      ): SET OF GENERIC:t;
    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);

  END_FUNCTION; -- list_to_set

  FUNCTION make_array_of_array(
               lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1, u1, low2, u2: INTEGER
      ): ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
    LOCAL
      n2   : INTEGER;
      n1   : INTEGER;
      res  : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
      resl : LIST [1:?] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    n1 := SIZEOF(lis);
    n2 := SIZEOF(lis[1]);
    IF (n1 <> ((u1 - low1) + 1)) AND (n2 <> ((u2 - low2) + 1)) THEN
      RETURN(?);
    END_IF;
    REPEAT i := 1 TO n1 BY 1;
      IF SIZEOF(lis[i]) <> n2 THEN
        RETURN(?);
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO n1 BY 1;
      resl[i] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    res := list_to_array(resl,low1,u1);
    RETURN(res);

  END_FUNCTION; -- make_array_of_array

  FUNCTION mixed_loop_type_set(
               l: SET [0:?] OF loop
      ): LOGICAL;
    LOCAL
      i              : INTEGER;
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) <= 1 THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := 'ASSOCIATIVE_DRAUGHTING.POLY_LOOP' IN TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('ASSOCIATIVE_DRAUGHTING.POLY_LOOP' IN TYPEOF(l[i])) <> 
          poly_loop_type THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);

  END_FUNCTION; -- mixed_loop_type_set

  FUNCTION msb_shells(
               brep: manifold_solid_brep;
               schema_name: STRING
      ): SET [1:?] OF closed_shell;
    IF (schema_name + '.BREP_WITH_VOIDS') IN TYPEOF(brep) THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;

  END_FUNCTION; -- msb_shells

  FUNCTION normalise(
               arg: vector_or_direction
      ): vector_or_direction;
    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      result := ?;
    ELSE
      ndim := arg.dim;
      IF 'ASSOCIATIVE_DRAUGHTING.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          vec := arg;
          v := arg.orientation;
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec.magnitude := 1;
          END_IF;
        END;
      ELSE
        v := arg;
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'ASSOCIATIVE_DRAUGHTING.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- normalise

  FUNCTION orthogonal_complement(
               vec: direction
      ): direction;
    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result.direction_ratios[1] := -vec.direction_ratios[2];
      result.direction_ratios[2] := vec.direction_ratios[1];
      RETURN(result);
    END_IF;

  END_FUNCTION; -- orthogonal_complement

  FUNCTION path_head_to_tail(
               a_path: path
      ): LOGICAL;
    LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);

  END_FUNCTION; -- path_head_to_tail

  FUNCTION path_reversed(
               a_path: path
      ): path;
    LOCAL
      the_reverse : path;
    END_LOCAL;
    IF 'ASSOCIATIVE_DRAUGHTING.ORIENTED_PATH' IN TYPEOF(a_path) THEN
      the_reverse := oriented_path(a_path\oriented_path.path_element,NOT 
          a_path\oriented_path.orientation);
    ELSE
      the_reverse := oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- path_reversed

  FUNCTION representations_mapped_into(
               rep: representation
      ): SET OF representation;
    LOCAL
      results : SET OF representation := [];
      i       : INTEGER;
      j       : INTEGER;
      mi      : SET OF mapped_item;
      rm      : SET OF representation_map;
    END_LOCAL;
    rm := USEDIN(rep,'ASSOCIATIVE_DRAUGHTING.' + 
        'REPRESENTATION_MAP.MAPPED_REPRESENTATION');
    REPEAT i := 1 TO HIINDEX(rm) BY 1;
      mi := mi + rm[i].map_usage;
    END_REPEAT;
    REPEAT j := 1 TO HIINDEX(mi) BY 1;
      results := results + USEDIN(mi[j],'ASSOCIATIVE_DRAUGHTING.' + 
          'REPRESENTATION.ITEMS');
    END_REPEAT;
    RETURN(results);

  END_FUNCTION; -- representations_mapped_into

  FUNCTION scalar_times_vector(
               scalar: REAL;
               vec: vector_or_direction
      ): vector;
    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      result := ?;
    ELSE
      IF 'ASSOCIATIVE_DRAUGHTING.VECTOR' IN TYPEOF(vec) THEN
        v := vec.orientation;
        mag := scalar * vec.magnitude;
      ELSE
        v := vec;
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result.orientation := normalise(v);
      result.magnitude := mag;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- scalar_times_vector

  FUNCTION second_proj_axis(
               z_axis, x_axis, arg: direction
      ): direction;
    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

  END_FUNCTION; -- second_proj_axis

  FUNCTION set_of_topology_reversed(
               a_set: set_of_reversible_topology_item
      ): set_of_reversible_topology_item;
    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- set_of_topology_reversed

  FUNCTION shell_reversed(
               a_shell: shell
      ): shell;
    LOCAL
      the_reverse : shell;
    END_LOCAL;
    IF 'ASSOCIATIVE_DRAUGHTING.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      IF 'ASSOCIATIVE_DRAUGHTING.OPEN_SHELL' IN TYPEOF(a_shell) THEN
        the_reverse := oriented_open_shell(a_shell,FALSE);
      ELSE
        IF 'ASSOCIATIVE_DRAUGHTING.ORIENTED_CLOSED_SHELL' IN TYPEOF(
            a_shell) THEN
          the_reverse := oriented_closed_shell(a_shell\
              oriented_closed_shell.closed_shell_element,NOT a_shell\
              oriented_closed_shell.orientation);
        ELSE
          IF 'ASSOCIATIVE_DRAUGHTING.CLOSED_SHELL' IN TYPEOF(a_shell)
               THEN
            the_reverse := oriented_closed_shell(a_shell,FALSE);
          ELSE
            the_reverse := ?;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- shell_reversed

  FUNCTION surface_weights_positive(
               b: rational_b_spline_surface
      ): BOOLEAN;
    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] <= 0 THEN
          result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- surface_weights_positive

  FUNCTION topology_reversed(
               an_item: reversible_topology
      ): reversible_topology;
    IF 'ASSOCIATIVE_DRAUGHTING.EDGE' IN TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.PATH' IN TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.FACE_BOUND' IN TYPEOF(an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.FACE' IN TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.SHELL' IN TYPEOF(an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);

  END_FUNCTION; -- topology_reversed

  FUNCTION using_representations(
               item: representation_item
      ): SET OF representation;
    LOCAL
      results            : SET OF representation;
      i                  : INTEGER;
      intermediate_items : SET OF representation_item;
      result_bag         : BAG OF representation;
    END_LOCAL;
    result_bag := USEDIN(item,
        'ASSOCIATIVE_DRAUGHTING.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | (
        'ASSOCIATIVE_DRAUGHTING.REPRESENTATION_ITEM' IN TYPEOF(z)) );
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        results := results + using_representations(intermediate_items[i]);
      END_REPEAT;
    END_IF;
    RETURN(results);

  END_FUNCTION; -- using_representations

  FUNCTION valid_2d_wireframe_edge_curve(
               crv: curve;
               schma: STRING
      ): BOOLEAN;
    IF SIZEOF([schma + '.LINE',schma + '.B_SPLINE_CURVE',schma + '.CIRCLE',
        schma + '.HYPERBOLA',schma + '.ELLIPSE',schma + '.PARABOLA',schma +
         '.POLYLINE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv) THEN
        RETURN(valid_2d_wireframe_edge_curve(crv\curve_replica.
            parent_curve,schma));
      ELSE
        IF (schma + '.OFFSET_CURVE_2D') IN TYPEOF(crv) THEN
          RETURN(valid_2d_wireframe_edge_curve(crv\offset_curve_2d.
              basis_curve,schma));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_2d_wireframe_edge_curve

  FUNCTION valid_basis_curve_in_2d_wireframe(
               crv: curve;
               schma: STRING
      ): BOOLEAN;
    IF (schma + '.TRIMMED_CURVE') IN TYPEOF(crv) THEN
      RETURN(valid_basis_curve_in_2d_wireframe(crv\trimmed_curve.
          basis_curve,schma));
    ELSE
      IF (schma + '.COMPOSITE_CURVE') IN TYPEOF(crv) THEN
        RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments | (NOT 
            valid_basis_curve_in_2d_wireframe(ccs.parent_curve,schma)) )) =
             0);
      ELSE
        IF (schma + '.OFFSET_CURVE_2D') IN TYPEOF(crv) THEN
          RETURN(valid_basis_curve_in_2d_wireframe(crv\offset_curve_2d.
              basis_curve,schma));
        ELSE
          IF SIZEOF([schma + '.LINE',schma + '.B_SPLINE_CURVE',schma + 
              '.CIRCLE',schma + '.ELLIPSE',schma + '.HYPERBOLA',schma + 
              '.PARABOLA',schma + '.POLYLINE'] * TYPEOF(crv)) = 1 THEN
            RETURN(TRUE);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_basis_curve_in_2d_wireframe

  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    IF NOT ((1 <= date.day_component) AND (date.day_component <= 31))
         THEN
      RETURN(FALSE);
    END_IF;
    CASE date.month_component OF
      4 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      6 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      9 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      11  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      2 :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      END_CASE;

  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_elementary_trimmed_curves_in_set(
               crv: curve;
               schma: STRING
      ): BOOLEAN;
    IF (schma + '.TRIMMED_CURVE') IN TYPEOF(crv) THEN
      RETURN(valid_elementary_trimmed_curves_in_set(crv\trimmed_curve.
          basis_curve,schma));
    ELSE
      IF (schma + '.COMPOSITE_CURVE') IN TYPEOF(crv) THEN
        RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments | (NOT 
            valid_elementary_trimmed_curves_in_set(ccs.parent_curve,schma)) )) 
           = 0);
      ELSE
        IF SIZEOF([schma + '.LINE',schma + '.CIRCLE',schma + '.ELLIPSE',
            schma + '.PARABOLA',schma + '.HYPERBOLA',schma + '.POLYLINE'] *
             TYPEOF(crv)) = 1 THEN
          RETURN(TRUE);
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_elementary_trimmed_curves_in_set

  FUNCTION valid_geometrically_bounded_wf_curve(
               crv: curve;
               schma: STRING
      ): BOOLEAN;
    IF SIZEOF([schma + '.POLYLINE',schma + '.B_SPLINE_CURVE',schma + 
        '.ELLIPSE',schma + '.CIRCLE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.TRIMMED_CURVE') IN TYPEOF(crv) THEN
        IF SIZEOF([schma + '.LINE',schma + '.PARABOLA',schma + 
            '.HYPERBOLA'] * TYPEOF(crv\trimmed_curve.basis_curve)) = 1
             THEN
          RETURN(TRUE);
        ELSE
          RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.
              basis_curve,schma));
        END_IF;
      ELSE
        IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF(crv) THEN
          RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.
              basis_curve,schma));
        ELSE
          IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv) THEN
            RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.
                parent_curve,schma));
          ELSE
            IF (schma + '.COMPOSITE_CURVE') IN TYPEOF(crv) THEN
              RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments | 
                  (NOT valid_geometrically_bounded_wf_curve(ccs.
                  parent_curve,schma)) )) = 0);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_geometrically_bounded_wf_curve

  FUNCTION valid_geometrically_bounded_wf_point(
               pnt: point;
               schma: STRING
      ): BOOLEAN;
    IF (schma + '.CARTESIAN_POINT') IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.POINT_ON_CURVE') IN TYPEOF(pnt) THEN
        RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.
            basis_curve,schma));
      ELSE
        IF (schma + '.POINT_REPLICA') IN TYPEOF(pnt) THEN
          RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.
              parent_pt,schma));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_geometrically_bounded_wf_point

  FUNCTION valid_time(
               time: local_time
      ): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- valid_time

  FUNCTION valid_units(
               m: measure_with_unit
      ): BOOLEAN;
    IF 'ASSOCIATIVE_DRAUGHTING.LENGTH_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.MASS_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.TIME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.THERMODYNAMIC_TEMPERATURE_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.AREA_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.VOLUME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.RATIO_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'ASSOCIATIVE_DRAUGHTING.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- valid_units

  FUNCTION valid_wireframe_edge_curve(
               crv: curve;
               schma: STRING
      ): BOOLEAN;
    IF SIZEOF([schma + '.LINE',schma + '.CIRCLE',schma + '.ELLIPSE',schma 
        + '.PARABOLA',schma + '.HYPERBOLA',schma + '.B_SPLINE_CURVE',schma 
        + '.POLYLINE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv) THEN
        RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve,
            schma));
      ELSE
        IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF(crv) THEN
          RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.
              basis_curve,schma));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_edge_curve

  FUNCTION valid_wireframe_vertex_point(
               pnt: point;
               schma: STRING
      ): BOOLEAN;
    IF (schma + '.CARTESIAN_POINT') IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.POINT_REPLICA') IN TYPEOF(pnt) THEN
        RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt,
            schma));
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_vertex_point

  FUNCTION vector_difference(
               arg1, arg2: vector_or_direction
      ): vector;
    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      result := ?;
    ELSE
      BEGIN
        IF 'ASSOCIATIVE_DRAUGHTING.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'ASSOCIATIVE_DRAUGHTING.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) - (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result.magnitude := SQRT(mag);
          result.orientation := res;
        ELSE
          result.magnitude := 0;
          result.orientation := vec1;
        END_IF;
      END;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- vector_difference

END_SCHEMA; -- associative_draughting

SCHEMA aic_edge_based_wireframe;

USE FROM geometric_model_schema                   -- ISO 10303-42
  (edge_based_wireframe_model);

USE FROM geometry_schema                          -- ISO 10303-42
  (axis2_placement_3d,
   b_spline_curve_with_knots,
   bezier_curve,
   cartesian_transformation_operator_3d,
   circle,
   conic,
   curve,
   curve_replica,
   ellipse,
   geometric_representation_context,
   hyperbola,
   line,
   offset_curve_3d,
   parabola,
   point,
   point_on_curve,
   point_replica,
   polyline,
   quasi_uniform_curve,
   rational_b_spline_curve,
   uniform_curve);

USE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation);

USE FROM representation_schema                    -- ISO 10303-43
  (mapped_item);

USE FROM topology_schema                          -- ISO 10303-42
  (edge_curve,
   edge_loop,
   vertex_loop,
   vertex_point);

ENTITY edge_based_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
         NOT (SIZEOF(['AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL',
                      'AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM',
                      'AIC_EDGE_BASED_WIREFRAME.AXIS2_PLACEMENT_3D'] *
             TYPEOF (it)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL',
                 'AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM'] * TYPEOF (it)) = 1
       )) >= 1;
  WR3: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items |
         ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
             IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                   ebwm_boundary |
           NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
              NOT ('AIC_EDGE_BASED_WIREFRAME.EDGE_CURVE'
                      IN TYPEOF (edges)))) = 0
       ))) = 0))) = 0;
  WR4: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items |
          ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                   ebwm_boundary |
           NOT (SIZEOF (QUERY (pline_edges <* QUERY (edges <* eb.ces_edges |
              ('AIC_EDGE_BASED_WIREFRAME.POLYLINE' IN
                  TYPEOF (edges\edge_curve.edge_geometry))) |
              NOT (SIZEOF (pline_edges\edge_curve.
                           edge_geometry\polyline.points) > 2))) = 0
       ))) = 0))) = 0;
  WR5: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items |
          ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                   ebwm_boundary |
           NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
              NOT (('AIC_EDGE_BASED_WIREFRAME.VERTEX_POINT'
                       IN TYPEOF (edges.edge_start)) AND
                   ('AIC_EDGE_BASED_WIREFRAME.VERTEX_POINT'
                       IN TYPEOF (edges.edge_end))))) = 0
       ))) = 0))) = 0;
  WR6: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items |
          ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
               IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                   ebwm_boundary |
           NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
             NOT (valid_wireframe_edge_curve
                 (edges\edge_curve.edge_geometry, 'AIC_EDGE_BASED_WIREFRAME'))
        )) = 0))) = 0))) = 0;
  WR7: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items|
          ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
               IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                   ebwm_boundary |
           NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
             NOT ((valid_wireframe_vertex_point
                   (edges.edge_start\vertex_point.vertex_geometry,
                    'AIC_EDGE_BASED_WIREFRAME')) AND
                  (valid_wireframe_vertex_point
                   (edges.edge_end\vertex_point.vertex_geometry,
                    'AIC_EDGE_BASED_WIREFRAME'))) )) = 0
           ))) = 0))) = 0;
  WR8: SIZEOF (QUERY (ebwm <* QUERY (it <* SELF.items |
          ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (eb <* ebwm\edge_based_wireframe_model.
                                   ebwm_boundary |
           NOT (SIZEOF (QUERY (con_edges <* QUERY (edges <* eb.ces_edges |
              ('AIC_EDGE_BASED_WIREFRAME.CONIC'
                  IN TYPEOF (edges\edge_curve.edge_geometry))) |
             NOT ('AIC_EDGE_BASED_WIREFRAME.AXIS2_PLACEMENT_3D'
                     IN TYPEOF (con_edges\edge_curve.
                                edge_geometry\conic.position)))) = 0
        ))) = 0))) = 0;
  WR9: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
           ('AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it))) |
          NOT ('AIC_EDGE_BASED_WIREFRAME.' +
               'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION'
            IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)
        ))) = 0;
  WR10: SELF.context_of_items\geometric_representation_context.
             coordinate_space_dimension = 3;
END_ENTITY;

FUNCTION valid_wireframe_edge_curve (crv   : curve;
                                     schma : STRING) : BOOLEAN;
  -- check for valid basic curve types

  IF SIZEOF ([schma + '.LINE',
              schma + '.CIRCLE',
              schma + '.ELLIPSE',
              schma + '.PARABOLA',
              schma + '.HYPERBOLA',
              schma + '.B_SPLINE_CURVE',
              schma + '.POLYLINE'] * TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
  -- recursively check for valid basic curves for curve_replica
    IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv)
      THEN RETURN (valid_wireframe_edge_curve
                         (crv\curve_replica.parent_curve, schma));
    ELSE
      -- recursively check for valid basis curves for offset_curve
      IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv)
        THEN RETURN (valid_wireframe_edge_curve
                           (crv\offset_curve_3d.basis_curve, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;


FUNCTION valid_wireframe_vertex_point (pnt   : point;
                                       schma : STRING) : BOOLEAN;
  -- check for valid basic point types
  IF (schma + '.CARTESIAN_POINT' IN TYPEOF (pnt))
    THEN RETURN (TRUE);
  ELSE
    -- recursively check for valid basic point types as parents for a
    -- point_replica

    IF (schma + '.POINT_REPLICA') IN TYPEOF (pnt)
      THEN RETURN (valid_wireframe_vertex_point
                         (pnt\point_replica.parent_pt, schma));
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

END_SCHEMA;

SCHEMA aic_shell_based_wireframe;

USE FROM geometric_model_schema                   -- ISO 10303-42
  (shell_based_wireframe_model);

USE FROM geometry_schema                          -- ISO 10303-42
  (axis2_placement_3d,
   b_spline_curve_with_knots,
   bezier_curve,
   cartesian_transformation_operator_3d,
   circle,
   conic,
   curve,
   curve_replica,
   ellipse,
   geometric_representation_context,
   hyperbola,
   line,
   offset_curve_3d,
   parabola,
   point,
   point_on_curve,
   point_replica,
   polyline,
   quasi_uniform_curve,
   rational_b_spline_curve,
   uniform_curve);

USE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation);

USE FROM representation_schema                    -- ISO 10303-43
  (mapped_item);

USE FROM topology_schema                          -- ISO 10303-42
  (edge_curve,
   edge_loop,
   path,
   vertex_loop,
   vertex_point,
   vertex_shell,
   wire_shell);

ENTITY shell_based_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF(['AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL',
                    'AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM',
                    'AIC_SHELL_BASED_WIREFRAME.AXIS2_PLACEMENT_3D'] *
            TYPEOF (it)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF(['AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL',
               'AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM'] * TYPEOF (it)) = 1
       )) >= 1;
  WR3: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
         ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                               ws\wire_shell.wire_shell_extent |
                ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
             NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
               NOT ('AIC_SHELL_BASED_WIREFRAME.EDGE_CURVE' IN
                       TYPEOF (el.edge_element)))) = 0)
           )) = 0)
         )) = 0)
       )) = 0;
  WR4: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
         ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                               ws\wire_shell.wire_shell_extent |
               ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
             NOT (SIZEOF (QUERY (pline_el <*
                          QUERY (el <* eloop\path.edge_list |
                    ('AIC_SHELL_BASED_WIREFRAME.POLYLINE' IN
                        TYPEOF (el.edge_element\edge_curve.edge_geometry))) |
               NOT (SIZEOF (pline_el.edge_element\edge_curve.
                            edge_geometry\polyline.points) >2)
             )) = 0)
           )) = 0)
         )) = 0)
       )) = 0;
  WR5: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
         ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                                ws\wire_shell.wire_shell_extent |
                 ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
               NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
                  NOT (valid_wireframe_edge_curve
                         (el.edge_element\edge_curve.edge_geometry,
                         'AIC_SHELL_BASED_WIREFRAME')))) =0)
           )) = 0)
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
               IN TYPEOF(it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                               ws\wire_shell.wire_shell_extent |
                   ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
             NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
               NOT (('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN
                        TYPEOF (el.edge_element.edge_start))
                AND
                    ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN
                        TYPEOF (el.edge_element.edge_end))) )) = 0)
           )) = 0)
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
         ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                                ws\wire_shell.wire_shell_extent |
               ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
             NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
                    NOT ((valid_wireframe_vertex_point
                          (el.edge_element.
                           edge_start\vertex_point.vertex_geometry,
                           'AIC_SHELL_BASED_WIREFRAME'))
                 AND
                   (valid_wireframe_vertex_point
                 (el.edge_element.edge_end\vertex_point.vertex_geometry,
                         'AIC_SHELL_BASED_WIREFRAME')))
             )) = 0)
           )) = 0)
         )) = 0)
       )) = 0;
  WR8: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
         ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                             sbwm\shell_based_wireframe_model.sbwm_boundary |
                   ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
           NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <*
                               ws\wire_shell.wire_shell_extent |
               ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb))) |
             NOT (SIZEOF (QUERY (con_edges <* QUERY (el <*
                                 eloop\path.edge_list |
               ('AIC_SHELL_BASED_WIREFRAME.CONIC' IN
                   TYPEOF (el.edge_element\edge_curve.edge_geometry))) |
               NOT ('AIC_SHELL_BASED_WIREFRAME.AXIS2_PLACEMENT_3D' IN
                    TYPEOF (con_edges.edge_element\edge_curve.
                            edge_geometry\conic.position))
             )) = 0)
           )) = 0)
         )) = 0)
       )) = 0;
  WR9: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF(it))) |
          NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                              sbwm\shell_based_wireframe_model.sbwm_boundary |
                    ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
            NOT (SIZEOF (QUERY (vloop <* QUERY (wsb <*
                                ws\wire_shell.wire_shell_extent |
                  ('AIC_SHELL_BASED_WIREFRAME.VERTEX_LOOP' IN TYPEOF (wsb))) |
              NOT ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN
                      TYPEOF (vloop\vertex_loop.loop_vertex))
            )) = 0)
          )) = 0)
        )) = 0;
  WR10: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF(it))) |
          NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
                              sbwm\shell_based_wireframe_model.sbwm_boundary |
                    ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb))) |
            NOT (SIZEOF (QUERY (vloop <* QUERY (wsb <*
                                ws\wire_shell.wire_shell_extent |
                  ('AIC_SHELL_BASED_WIREFRAME.VERTEX_LOOP' IN TYPEOF (wsb))) |
              NOT (valid_wireframe_vertex_point (vloop\vertex_loop.
                    loop_vertex\vertex_point.vertex_geometry,
                    'AIC_SHELL_BASED_WIREFRAME'))
            )) = 0)
          )) = 0)
        )) = 0;
  WR11: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF(it))) |
          NOT (SIZEOF (QUERY (vs <* QUERY (sb <*
                              sbwm\shell_based_wireframe_model.sbwm_boundary |
                  ('AIC_SHELL_BASED_WIREFRAME.VERTEX_SHELL' IN TYPEOF (sb))) |
            NOT ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN
                    TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex))
          )) = 0)
        )) = 0;
  WR12: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF.items |
          ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL'
              IN TYPEOF(it))) |
          NOT (SIZEOF (QUERY (vs <* QUERY (sb <*
                              sbwm\shell_based_wireframe_model.sbwm_boundary |
                  ('AIC_SHELL_BASED_WIREFRAME.VERTEX_SHELL' IN TYPEOF (sb))) |
            NOT (valid_wireframe_vertex_point (vs\vertex_shell.
                   vertex_shell_extent.loop_vertex\vertex_point.
                   vertex_geometry,'AIC_SHELL_BASED_WIREFRAME'))
          )) = 0)
        )) = 0;
  WR13: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
           ('AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it))) |
         NOT ('AIC_SHELL_BASED_WIREFRAME.' +
                 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN
           TYPEOF (mi\mapped_item.mapping_source.mapped_representation)
        ))) = 0;
  WR14: SELF.context_of_items\geometric_representation_context.
             coordinate_space_dimension = 3;
END_ENTITY;

FUNCTION valid_wireframe_edge_curve (crv   : curve;
                                     schma : STRING) : BOOLEAN;
  -- check for valid basic curve types

  IF SIZEOF ([schma + '.LINE',
              schma + '.CIRCLE',
              schma + '.ELLIPSE',
              schma + '.PARABOLA',
              schma + '.HYPERBOLA',
              schma + '.B_SPLINE_CURVE',
              schma + '.POLYLINE'] * TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
  -- recursively check for valid basic curves for curve_replica
    IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv)
      THEN RETURN (valid_wireframe_edge_curve
                         (crv\curve_replica.parent_curve, schma));
    ELSE
      -- recursively check for valid basis curves for offset_curve
      IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv)
        THEN RETURN (valid_wireframe_edge_curve
                           (crv\offset_curve_3d.basis_curve, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_wireframe_vertex_point (pnt   : point;
                                       schma : STRING) : BOOLEAN;
  -- check for valid basic point types
  IF (schma + '.CARTESIAN_POINT' IN TYPEOF (pnt))
    THEN RETURN (TRUE);
  ELSE
    -- recursively check for valid basic point types as parents for a
    -- point_replica

    IF (schma + '.POINT_REPLICA') IN TYPEOF (pnt)
      THEN RETURN (valid_wireframe_vertex_point
                         (pnt\point_replica.parent_pt, schma));
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

END_SCHEMA;

SCHEMA aic_geometrically_bounded_2d_wireframe;

USE FROM geometric_model_schema                   -- ISO 10303-42
    (geometric_curve_set,
     geometric_set);

USE FROM geometry_schema                          -- ISO 10303-42
   (axis2_placement_2d,
    b_spline_curve_with_knots,
    bezier_curve,
    circle,
    composite_curve,
    curve,
    ellipse,
    geometric_representation_context,
    hyperbola,
    line,
    offset_curve_2d,
    parabola,
    point_on_curve,
    polyline,
    quasi_uniform_curve,
    rational_b_spline_curve,
    trimmed_curve,
    uniform_curve);

USE FROM product_property_representation_schema   -- ISO 10303-41
   (shape_representation);

USE FROM representation_schema                    -- ISO 10303-43
   (mapped_item);

ENTITY geometrically_bounded_2d_wireframe_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: SIZEOF (QUERY (item <* SELF.items |
         NOT (SIZEOF (TYPEOF (item) *
           ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.AXIS2_PLACEMENT_2D',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1)
       )) = 0;
  WR3: SIZEOF (QUERY (item <* SELF.items |
         SIZEOF (TYPEOF (item) *
           ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1
       )) >= 1;
  WR4: SIZEOF (QUERY (mi <* QUERY (item <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM'
           IN TYPEOF (item))) |
         NOT ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.' +
              'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION'
           IN TYPEOF
              (mi\mapped_item.mapping_source.mapped_representation))
       )) = 0;
  WR5: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (elem <* gcs\geometric_set.elements |
           NOT (SIZEOF (TYPEOF (elem) *
             ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE']) = 1)
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (crv <* 
           QUERY (elem <* gcs\geometric_set.elements |
              ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE'
                   IN TYPEOF (elem))) |
           NOT (valid_basis_curve_in_2d_wireframe
              (crv,'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME'))
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pnt <*
           QUERY (elem <* gcs\geometric_set.elements |
             ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT'
                  IN TYPEOF(elem))) |
             NOT (SIZEOF (TYPEOF (pnt) *
               ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CARTESIAN_POINT',
                'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT_ON_CURVE']) = 1)
         )) = 0)
       )) = 0;
  WR8: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
           IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pl <* 
           QUERY (elem <* gcs\geometric_set.elements |
             ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE'
                  IN TYPEOF (elem))) |
             NOT (SIZEOF (pl\polyline.points) > 2)
         )) = 0)
       )) = 0;
END_ENTITY;


FUNCTION valid_basis_curve_in_2d_wireframe
  (crv   : curve; schma : STRING) : BOOLEAN;

  -- recursively check for valid basis curves for trimmed_curves
  IF (schma + '.TRIMMED_CURVE') IN TYPEOF (crv) THEN
    RETURN (valid_basis_curve_in_2d_wireframe
                  (crv\trimmed_curve.basis_curve, schma));
  ELSE
    -- recursively check for valid basis curves for composite_curves
    IF (schma + '.COMPOSITE_CURVE') IN TYPEOF (crv) THEN
      RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                NOT (valid_basis_curve_in_2d_wireframe
                      (ccs.parent_curve, schma)))) = 0);
    ELSE
    -- recursively check for valid basis curves for offset_curves
      IF (schma + '.OFFSET_CURVE_2D') IN TYPEOF (crv) THEN
        RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\offset_curve_2d.basis_curve, schma));
      ELSE
        IF SIZEOF ([schma + '.LINE',
                    schma + '.B_SPLINE_CURVE',
                    schma + '.CIRCLE',
                    schma + '.ELLIPSE',
                    schma + '.HYPERBOLA',
                    schma + '.PARABOLA',
                    schma + '.POLYLINE'] * TYPEOF (crv)) = 1
        THEN RETURN (TRUE);
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

END_SCHEMA;

SCHEMA aic_draughting_annotation;

USE FROM draughting_element_schema               -- ISO 10303-101
  (draughting_callout,
   terminator_symbol);

USE FROM geometry_schema                          -- ISO 10303-42
  (axis2_placement_2d,
   geometric_representation_context);

USE FROM measure_schema                           -- ISO 10303-41
  (conversion_based_unit,
   global_unit_assigned_context,
   length_measure_with_unit,
   length_unit,
   measure_with_unit,
   named_unit,
   plane_angle_unit,
   plane_angle_measure_with_unit,
   si_unit);

USE FROM presentation_appearance_schema           -- ISO 10303-46
  (box_height,
   box_rotate_angle,
   box_slant_angle,
   box_width,
   context_dependent_invisibility,
   curve_style,
   curve_style_font,
   externally_defined_curve_font,
   externally_defined_hatch_style,
   externally_defined_tile_style,
   fill_area_style,
   fill_area_style_colour,
   fill_area_style_hatching,
   fill_area_style_tile_symbol_with_style,
   fill_area_style_tiles,
   null_style,
   pre_defined_curve_font,
   presentation_style_by_context,
   symbol_colour,
   symbol_style,
   text_style,
   text_style_for_defined_font,
   text_style_with_box_characteristics,
   text_style_with_mirror,
   text_style_with_spacing);

USE FROM presentation_definition_schema           -- ISO 10303-46
  (annotation_curve_occurrence,
   annotation_fill_area,
   annotation_fill_area_occurrence,
   annotation_occurrence,
   annotation_symbol,
   annotation_symbol_occurrence,
   annotation_text_occurrence,
   composite_text,
   composite_text_with_associated_curves,
   composite_text_with_blanking_box,
   composite_text_with_extent,
   defined_symbol,
   externally_defined_symbol,
   pre_defined_symbol,
   symbol_representation,
   symbol_representation_map,
   text_alignment,
   text_literal,
   text_literal_with_associated_curves,
   text_literal_with_blanking_box,
   text_literal_with_delineation,
   text_literal_with_extent);

USE FROM presentation_resource_schema             -- ISO 10303-46
  (colour_rgb,
   externally_defined_text_font,
   font_select,
   pre_defined_colour,
   pre_defined_text_font);

USE FROM representation_schema                    -- ISO 10303-43
  (mapped_item,
   representation,
   representation_item);

ENTITY annotation_subfigure_occurrence
  SUBTYPE OF (annotation_symbol_occurrence);
WHERE
  WR1: SIZEOF (QUERY (sty <* SELF.styles |
         NOT (SIZEOF (sty.styles) = 1)
       )) = 0;
  WR2: SIZEOF (QUERY (sty <* SELF.styles |
         NOT ('AIC_DRAUGHTING_ANNOTATION.NULL_STYLE'
               IN TYPEOF (sty.styles[1]))
       ))=0;
  WR3: ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL'
           IN TYPEOF (SELF.item));
  WR4: ('AIC_DRAUGHTING_ANNOTATION.DRAUGHTING_SUBFIGURE_REPRESENTATION'
           IN TYPEOF
           (SELF.item\mapped_item.mapping_source.mapped_representation));
END_ENTITY;

ENTITY draughting_annotation_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1:                                  -- curve_has_curve_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
         AND ('AIC_DRAUGHTING_ANNOTATION.CURVE_STYLE'
                 IN TYPEOF (sty.styles[1])))
    )) = 0);
  WR2:                               -- fill_area_has_fill_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
      NOT ((SIZEOF (sty.styles) = 1)
        AND ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE'
                IN TYPEOF (sty.styles[1])))
    )) = 0);
  WR3:                                 -- styled_fill_boundaries:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (bound <*
                     SELF.item\annotation_fill_area.boundaries |
       NOT (SIZEOF (QUERY (si <*
                   USEDIN (bound, 'AIC_DRAUGHTING_ANNOTATION.' +
                                  'STYLED_ITEM.ITEM') |
         ('AIC_DRAUGHTING_ANNOTATION.' +
             'ANNOTATION_CURVE_OCCURRENCE' IN TYPEOF (si)))) > 0)
    )) = 0);
  WR4:                                -- symbol_has_symbol_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
           AND
            (SIZEOF (TYPEOF (sty.styles[1]) *
                ['AIC_DRAUGHTING_ANNOTATION.SYMBOL_STYLE',
                 'AIC_DRAUGHTING_ANNOTATION.NULL_STYLE']) = 1))
    )) = 0);
  WR5:                       -- allowable_symbol_representations:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL'
             IN TYPEOF(SELF.item)))) OR
    (SIZEOF (['AIC_DRAUGHTING_ANNOTATION.' +
              'DRAUGHTING_SYMBOL_REPRESENTATION',
              'AIC_DRAUGHTING_ANNOTATION.' +
              'DRAUGHTING_SUBFIGURE_REPRESENTATION'] *
       TYPEOF (SELF.item\mapped_item.mapping_source.
               mapped_representation)) = 1);
  WR6:                                    -- text_has_text_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
        AND ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE'
                IN TYPEOF (sty.styles[1])))
    )) = 0);
  WR7:                                         -- allowable_text:
    NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         (SIZEOF (TYPEOF(SELF.item) *
             ['AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT',
              'AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL']) = 1));
  WR8:                                        -- text_not_nested:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (tl <*
                   SELF.item\composite_text.collected_text |
        NOT ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' IN TYPEOF (tl))
    )) = 0);
  WR9:                                -- text_alignment_literals:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL'
             IN TYPEOF (SELF.item)))) OR
    (SELF.item\text_literal.alignment IN
         ['baseline left', 'baseline centre', 'baseline right']);
  WR10:                             -- text_alignment_composites:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (tl <* QUERY (text <* SELF.
                                        item\composite_text.collected_text |
            ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' IN TYPEOF(text))) |
      NOT (tl\text_literal.alignment IN
         ['baseline left', 'baseline centre', 'baseline right'])
    )) = 0);
  WR11:                              -- text_literal_not_rotated:
    NOT ((('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
          ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL'
              IN TYPEOF (SELF.item))) AND
       (EXISTS (SELF.item\text_literal.placement.ref_direction)));
  WR12:                    -- literals_in_composites_not_rotated:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
          ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
              IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (tl <* QUERY (text <*
                   SELF.item\composite_text.collected_text |
               ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' IN TYPEOF (text))) |
       EXISTS (tl\text_literal.placement.ref_direction)
    )) = 0);
  WR13:                                 -- single_text_alignment:
    NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR
    check_text_alignment(SELF.item);
  WR14:                                      -- single_text_font:
    NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR
    check_text_font(SELF.item);
  WR15:                               -- allowable_text_literals:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
               IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (tl <* QUERY (text <*
                   SELF.item\composite_text.collected_text |
              ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' IN TYPEOF (text))) |
      NOT (SIZEOF (TYPEOF(tl) *
                  ['AIC_DRAUGHTING_ANNOTATION.' +
                   'TEXT_LITERAL_WITH_BLANKING_BOX',
                   'AIC_DRAUGHTING_ANNOTATION.' +
                   'TEXT_LITERAL_WITH_ASSOCIATED_CURVES']) = 0)
    )) = 0);
  WR16:                            -- styled_text_literal_curves:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (crv <*
                   SELF.item\text_literal_with_associated_curves.
                   associated_curves |
      NOT (SIZEOF (QUERY (si <*  USEDIN (crv, 'AIC_DRAUGHTING_ANNOTATION.' +
                                              'STYLED_ITEM.ITEM') |
        ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (si))
      )) > 0)
    )) = 0);
  WR17:                          -- styled_composite_text_curves:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (crv <*
                SELF.item\composite_text_with_associated_curves.
                associated_curves |
      NOT (SIZEOF (QUERY (si <*  USEDIN (crv, 'AIC_DRAUGHTING_ANNOTATION.' +
                                              'STYLED_ITEM.ITEM') |
        ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (si))
      )) > 0)
    )) = 0);
  WR18:                                 -- curve_style_has_width:
    SIZEOF (QUERY (cs <* QUERY (sty <* SELF.styles |
      ('AIC_DRAUGHTING_ANNOTATION.CURVE_STYLE' IN TYPEOF (sty.styles[1]))) |
      NOT (('AIC_DRAUGHTING_ANNOTATION.LENGTH_MEASURE_WITH_UNIT'
               IN TYPEOF (cs.styles[1]\curve_style.curve_width)) AND
           ('AIC_DRAUGHTING_ANNOTATION.POSITIVE_LENGTH_MEASURE'
               IN TYPEOF (cs.styles[1]\curve_style.
                          curve_width\measure_with_unit.value_component)))
    )) = 0;
  WR19:                                    -- tiling_constraints:
    SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
      ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE'
          IN TYPEOF (sty.styles[1]))) |
      NOT ((SIZEOF (QUERY (fs <* fas.styles[1]\fill_area_style.fill_styles |
              ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE_TILES'
                  IN TYPEOF (fs)))) <= 1)
       AND (SIZEOF (QUERY (fst <* QUERY (fs <*
                           fas.styles[1]\fill_area_style.fill_styles |
              ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE_TILES'
                  IN TYPEOF (fs))) |
                 NOT (SIZEOF (fst\fill_area_style_tiles.tiles) = 1)
           )) = 0))
    )) = 0;
  WR20:                                  -- hatching_constraints:
    SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
          ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE' IN
               TYPEOF (sty.styles[1]))) |
      NOT (SIZEOF (QUERY (fsh <* QUERY (fs <*
                          fas.styles[1]\fill_area_style.fill_styles |
             ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE_HATCHING'
                      IN TYPEOF (fs))) |
        NOT (fsh\fill_area_style_hatching.point_of_reference_hatch_line :=:
             fsh\fill_area_style_hatching.pattern_start)
      )) = 0)
    )) = 0;
  WR21:                                 -- text_style_constraint:
    SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE' IN TYPEOF (sty.styles[1]))) |
      NOT ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE_WITH_BOX_CHARACTERISTICS'
              IN TYPEOF (ts.styles[1]))
    )) = 0;
  WR22:                            -- text_style_characteristics:
    SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE_WITH_BOX_CHARACTERISTICS'
             IN TYPEOF (sty.styles[1]))) |
      NOT (SIZEOF (ts.styles[1]\text_style_with_box_characteristics.
                   characteristics) = 4)
    )) = 0;
END_ENTITY;

ENTITY draughting_subfigure_representation
  SUBTYPE OF (symbol_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
         NOT (SIZEOF (['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_OCCURRENCE',
              'AIC_DRAUGHTING_ANNOTATION.DRAUGHTING_CALLOUT',
              'AIC_DRAUGHTING_ANNOTATION.AXIS2_PLACEMENT']
               * TYPEOF (item)) = 1)
       )) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items |
         SIZEOF (['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_OCCURRENCE',
                  'AIC_DRAUGHTING_ANNOTATION.DRAUGHTING_CALLOUT'] *
           TYPEOF (item)) = 1
       )) >= 1;
  WR3: SIZEOF (QUERY (srm <* QUERY (rm <*
          USEDIN (SELF, 'AIC_DRAUGHTING_ANNOTATION.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          ('AIC_DRAUGHTING_ANNOTATION.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm))) |
         NOT (SIZEOF (QUERY (a_s <* QUERY (mi <* srm.map_usage |
            ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL' IN TYPEOF(mi))) |
           NOT (SIZEOF (QUERY (aso <*
             USEDIN (a_s, 'AIC_DRAUGHTING_ANNOTATION.STYLED_ITEM.ITEM') |
             NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SUBFIGURE_OCCURRENCE'
                  IN TYPEOF(aso))
           )) = 0)
         )) = 0)
       )) > 0;
  WR4: NOT (acyclic_mapped_item_usage (SELF));
  WR5: SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;

ENTITY draughting_symbol_representation
  SUBTYPE of (symbol_representation);
UNIQUE
  UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
         NOT (SIZEOF (TYPEOF (item) *
            ['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.AXIS2_PLACEMENT']) = 1)
       )) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items |
         (SIZEOF (TYPEOF (item) *
            ['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE']) = 1)
       )) >= 1;
  WR3: SIZEOF (QUERY (item <* SELF\representation.items |
         'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SUBFIGURE_OCCURRENCE'
          IN TYPEOF (item)
       )) = 0;
  WR4: SIZEOF (QUERY (srm <* QUERY (rm <*
          USEDIN (SELF, 'AIC_DRAUGHTING_ANNOTATION.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          ('AIC_DRAUGHTING_ANNOTATION.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm))) |
         NOT (SIZEOF (QUERY (a_s <* QUERY (mi <* srm.map_usage |
            ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL' IN TYPEOF(mi))) |
           NOT (SIZEOF (QUERY(aso <*
             USEDIN(a_s, 'AIC_DRAUGHTING_ANNOTATION.STYLED_ITEM.ITEM') |
             NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE'
                  IN TYPEOF(aso))
           )) = 0)
         )) = 0)
       )) > 0;
  WR5: NOT (acyclic_mapped_item_usage (SELF));
  WR6: SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;

ENTITY draughting_text_literal_with_delineation
  SUBTYPE OF (text_literal_with_delineation);
WHERE
  WR1: SELF.delineation IN ['underline', 'overline'];
END_ENTITY;

FUNCTION acyclic_mapped_item_usage (rep: representation) : BOOLEAN;
-- returns TRUE if the representation contains one or more mapped_items
-- that are a mapping of the representation itself
  LOCAL
    items : SET OF representation_item;
    i     : INTEGER;
  END_LOCAL;

  items := QUERY (item <* rep.items |
           'AIC_DRAUGHTING_ANNOTATION.MAPPED_ITEM' IN TYPEOF (item));
  IF SIZEOF (items) = 0
  THEN RETURN (FALSE);
  ELSE REPEAT i := 1 TO HIINDEX (items);
    IF items[i]\mapped_item.mapping_source.mapped_representation :=: rep
    THEN RETURN (TRUE);
    ELSE RETURN (acyclic_mapped_item_usage
                (items[i]\mapped_item.mapping_source.mapped_representation));
    END_IF;
    END_REPEAT;
  RETURN (FALSE);
  END_IF;
END_FUNCTION;

FUNCTION check_text_alignment (ct : composite_text) : BOOLEAN;

  LOCAL
    a : SET OF text_alignment := [];
    i : INTEGER;
  END_LOCAL;

  -- create a set of all the alignments
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    a := a + [ct.collected_text[i]\text_literal.alignment];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all alignments were the same
  RETURN (SIZEOF (a)=1);
END_FUNCTION;

FUNCTION check_text_font (ct : composite_text) : BOOLEAN;

  LOCAL
    f : SET OF font_select := [];
    i : INTEGER;
  END_LOCAL;

  -- build a set of all the fonts
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    f := f + [ct.collected_text[i]\text_literal.font];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all fonts were the same
  RETURN (SIZEOF (f) <= 1);
END_FUNCTION;

END_SCHEMA;

SCHEMA aic_drawing_structure_and_administration;

USE FROM approval_schema                          -- ISO 10303-41
  (approval,
   approval_date_time,
   approval_person_organization);

USE FROM date_time_schema                         -- ISO 10303-41
  (calendar_date);

USE FROM drawing_definition_schema               -- ISO 10303-101
  (draughting_title,
   drawing_revision,
   drawing_sheet_revision,
   drawing_sheet_revision_usage);

USE FROM geometry_schema                          -- ISO 10303-42
  (axis2_placement_2d);

USE FROM management_resources_schema              -- ISO 10303-41
  (approval_assignment,
   contract_assignment,
   document_reference,
   organization_assignment,
   person_and_organization_assignment,
   person_assignment,
   security_classification_assignment);

USE FROM person_organization_schema               -- ISO 10303-41
  (organizational_address,
   personal_address);

USE FROM presentation_definition_schema           -- ISO 10303-46
  (annotation_occurrence);

USE FROM presentation_organization_schema         -- ISO 10303-46
  (camera_image,
   presentation_size,
   presentation_view,
   presented_item,
   presented_item_representation);

USE FROM product_definition_schema                -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation);

TYPE approved_item = SELECT
  (drawing_revision,
   drawing_sheet_revision);
END_TYPE;

TYPE classified_item = SELECT
  (drawing_revision,
   drawing_sheet_revision);
END_TYPE;

TYPE contracted_item = SELECT
  (drawing_revision);
END_TYPE;

TYPE draughting_organization_item = SELECT
  (product_definition_formation,
   drawing_revision,
   drawing_sheet_revision);
END_TYPE;

TYPE draughting_presented_item_select = SELECT
  (product_definition_formation);
END_TYPE;

TYPE specified_item = SELECT
  (drawing_revision);
END_TYPE;

ENTITY draughting_approval_assignment
  SUBTYPE OF (approval_assignment);
  approved_items : SET [1:?] OF approved_item;
WHERE
  WR1: SIZEOF (QUERY (item <* approved_items |
       'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.DRAWING_REVISION'
          IN TYPEOF (item)))<=1;
END_ENTITY;

ENTITY draughting_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contracted_item;
END_ENTITY;

ENTITY draughting_drawing_revision
  SUBTYPE OF (drawing_revision);
WHERE
  WR1:                                -- drawing_requires_sheets:
    (SIZEOF (USEDIN (SELF,
       'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET')) >= 1)
    AND
    (SIZEOF (QUERY (ais <* USEDIN (SELF,
             'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.DRAWING_SHEET_REVISION'
              IN TYPEOF (ais.area))
    )) = 0);
  WR2:                              -- drawing_approval_has_date:
    SIZEOF (QUERY (app_ass <* USEDIN (SELF,
                         'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                         'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |
       NOT (SIZEOF (USEDIN (app_ass.assigned_approval,
          'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
          'APPROVAL_DATE_TIME.DATED_APPROVAL')) = 1)
    )) = 0;
  WR3:                                -- sheet_approval_has_date:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (app_ass <* USEDIN (ais.area,
          'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
          'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |
        NOT (SIZEOF (USEDIN (app_ass.assigned_approval,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
            'APPROVAL_DATE_TIME.DATED_APPROVAL')) = 1)
      )) = 0)
    )) = 0;
  WR4:                     -- drawing_approval_has_authorization:
    SIZEOF (QUERY (app_ass <* USEDIN (SELF,
                         'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                         'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |
       NOT (SIZEOF (USEDIN (app_ass.assigned_approval,
           'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
           'APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL')) >= 1)
    )) = 0;
  WR5:                       -- sheet_approval_has_authorization:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (app_ass <* USEDIN (ais.area,
          'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
          'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |
        NOT (SIZEOF (USEDIN (app_ass.assigned_approval,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
            'APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL')) >= 1)
      )) = 0)
    )) = 0;
  WR6:                                          -- drawing_title:
    SIZEOF (USEDIN (SELF, 'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                          'DRAUGHTING_TITLE.ITEMS')) <= 1;
  WR7:                                            -- sheet_title:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (USEDIN (ais.area,
                          'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                          'DRAUGHTING_TITLE.ITEMS')) <= 1)
    )) = 0;
  WR8:                               -- allowable_items_of_sheet:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (item <* ais.area.items |
        NOT (SIZEOF (TYPEOF(item) *
           ['AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.STYLED_ITEM',
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM',
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AXIS2_PLACEMENT',
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.PLANAR_BOX']) = 1)
      )) = 0)
    )) = 0;
  WR9:                      -- sheet_contains_view_or_annotation:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (item <* ais.area.items |
        (SIZEOF (TYPEOF(item) *
           ['AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.STYLED_ITEM',
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM']) = 1)
      )) > 0)
    )) = 0;
  WR10:                                   -- planar_box_in_sheet:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (p_b <* 
        QUERY (item <* ais.area.items |
           ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.PLANAR_BOX' 
               IN TYPEOF(item))) |
           NOT (SIZEOF (USEDIN (p_b, 'AIC_DRAWING_STRUCTURE_AND_' +
                                     'ADMINISTRATION.PRESENTATION_SIZE.SIZE')
           ) = 1)
      )) = 0)
    )) = 0;
  WR11:                                  -- sheets_contain_views:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
             ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'
                     IN TYPEOF(item))) |
        NOT ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.PRESENTATION_VIEW' IN
                TYPEOF(mi.mapping_source.mapped_representation))
      )) = 0)
    )) = 0;
  WR12:                             -- sheets_contain_placements:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (a2p <* QUERY (item <*
                                         ais.area.items |
             ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AXIS2_PLACEMENT'
                  IN TYPEOF(item))) |
        NOT (SIZEOF (USEDIN (a2p,
                                'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                                'MAPPED_ITEM.MAPPING_TARGET')) > 0)
      )) = 0)
    )) = 0;
  WR13:                            -- sheets_have_unique_context:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (ais.area.context_of_items.
                       representations_in_context) = 1)
    )) = 0;
  WR14:                                  -- views_presented_once:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
           'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
             ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'
                 IN TYPEOF(item))) |
        NOT (SIZEOF (USEDIN (mi.mapping_source.mapped_representation,
                        'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION')) = 1)
      )) = 0)
    )) = 0;
  WR15:                               -- allowable_items_of_view:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
             ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'
                 IN TYPEOF(item))) |
        NOT (SIZEOF (QUERY (pv_item <* mi.mapping_source.
                            mapped_representation.items |
          NOT (SIZEOF (TYPEOF(pv_item) *
                    ['AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                     'STYLED_ITEM',
                     'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.CAMERA_IMAGE',
                     'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                     'AXIS2_PLACEMENT']) = 1)
        )) = 0)
      )) = 0)
    )) = 0;
  WR16:                          -- views_contain_one_projection:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
             ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'
                  IN TYPEOF(item))) |
        NOT (SIZEOF (QUERY (pv_item <* mi.mapping_source.
                             mapped_representation.items |
            ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.CAMERA_IMAGE'
                IN TYPEOF(pv_item))
        )) = 1)
      )) = 0)
    )) = 0;
  WR17:                           -- views_contain_one_placement:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
              ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'
                  IN TYPEOF(item))) |
        NOT (SIZEOF (QUERY (a2p <* QUERY (pv_item <* mi.mapping_source.
                             mapped_representation.items |
              ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AXIS2_PLACEMENT'
                    IN TYPEOF(pv_item))) |
          ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
           'MAPPING_SOURCE.MAPPING_ORIGIN' IN ROLESOF (a2p))
        )) = 1)
      )) = 0)
    )) = 0;
  WR18:                             -- views_have_unique_context:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
             ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'
                  IN TYPEOF(item))) |
        NOT (SIZEOF (mi.mapping_source.
                        mapped_representation.context_of_items.
                        representations_in_context) = 1)
      )) = 0)
    )) = 0;
END_ENTITY;

ENTITY draughting_organization_assignment
  SUBTYPE OF (organization_assignment);
  assigned_items : SET [1:?] OF draughting_organization_item;
END_ENTITY;

ENTITY draughting_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  assigned_items : SET [1:?] OF draughting_organization_item;
END_ENTITY;

ENTITY draughting_person_assignment
  SUBTYPE OF (person_assignment);
  assigned_items : SET [1:?] OF draughting_organization_item;
END_ENTITY;

ENTITY draughting_presented_item
  SUBTYPE OF (presented_item);
  items        : SET [1:?] OF draughting_presented_item_select;
WHERE
  WR1:                            -- presented_item_presentation:
      SIZEOF (QUERY (pir <* USEDIN (SELF,
                            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                            'PRESENTED_ITEM_REPRESENTATION.ITEM') |
         NOT ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.DRAWING_REVISION'
                 IN TYPEOF (pir.presentation))
       )) = 0;
END_ENTITY;

ENTITY draughting_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  assigned_items : SET [1:?] OF classified_item;
END_ENTITY;

ENTITY draughting_specification_reference
  SUBTYPE OF (document_reference);
  specified_items : SET [1:?] OF specified_item;
WHERE
  WR1: (SELF.assigned_document.kind.product_data_type =
           'draughting specification');
END_ENTITY;

END_SCHEMA;

SCHEMA aic_draughting_elements;

USE FROM draughting_element_schema               -- ISO 10303-101
  (dimension_curve,
   dimension_curve_directed_callout,
   dimension_curve_terminator,
   draughting_callout,
   draughting_callout_relationship,
   leader_curve,
   leader_directed_callout,
   leader_terminator,
   projection_curve,
   projection_directed_callout);

USE FROM presentation_definition_schema           -- ISO 10303-46
  (annotation_text_occurrence);

ENTITY angular_dimension
  SUBTYPE of (dimension_curve_directed_callout);
END_ENTITY;

ENTITY curve_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY datum_feature_callout
  SUBTYPE of (draughting_callout);
END_ENTITY;

ENTITY datum_target_callout
  SUBTYPE of (draughting_callout);
END_ENTITY;

ENTITY diameter_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY dimension_callout_component_relationship
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: SELF.name IN ['prefix', 'suffix'];
  WR2: 'AIC_DRAUGHTING_ELEMENTS.STRUCTURED_DIMENSION_CALLOUT'
           IN TYPEOF (SELF.relating_draughting_callout);
  WR3: SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.PROJECTION_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.STRUCTURED_DIMENSION_CALLOUT']) = 0;
  WR4: SELF.related_draughting_callout.contents *
       SELF.relating_draughting_callout.contents =
       SELF.related_draughting_callout.contents;
  WR5: ((SELF.name = 'prefix') AND
       (SIZEOF (QUERY (ato <* QUERY (con <*
                 SELF.related_draughting_callout.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         NOT (ato.name = 'prefix text')
       )) = 0));
  WR6: ((SELF.name = 'suffix') AND
       (SIZEOF (QUERY (ato <* QUERY (con <*
                 SELF.related_draughting_callout.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         NOT (ato.name = 'suffix text')
       )) = 0));
END_ENTITY;

ENTITY dimension_callout_relationship
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: SELF.name IN ['primary', 'secondary'];
  WR2: SIZEOF (TYPEOF (SELF.relating_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.ANGULAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.CURVE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.DIAMETER_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LINEAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.ORDINATE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.RADIUS_DIMENSION'])=1;
  WR3: SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.PROJECTION_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT']) = 0;
  WR4: SELF.related_draughting_callout.contents *
       SELF.relating_draughting_callout.contents =
       SELF.related_draughting_callout.contents;
END_ENTITY;

ENTITY dimension_pair
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: SELF.name IN ['chained', 'parallel'];
  WR2: SIZEOF (TYPEOF (SELF.relating_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.ANGULAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.CURVE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.DIAMETER_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LINEAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.ORDINATE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.RADIUS_DIMENSION'])=1;
  WR3: SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.ANGULAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.CURVE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.DIAMETER_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LINEAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.ORDINATE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.RADIUS_DIMENSION'])=1;
END_ENTITY;

ENTITY draughting_elements
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: SIZEOF (QUERY (l_c <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.LEADER_CURVE' IN TYPEOF(con))) |
         NOT (SIZEOF (QUERY (ldc <* USEDIN (l_c, 'AIC_DRAUGHTING_ELEMENTS.' +
                                             'DRAUGHTING_CALLOUT.CONTENTS') |
           ('AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT'
                IN TYPEOF (ldc)))) <= 1)
       ))=0;
  WR2: NOT ('AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT'
             IN TYPEOF(SELF)) OR
            (SIZEOF (QUERY (con <* SELF.contents |
              ('AIC_DRAUGHTING_ELEMENTS.PROJECTION_CURVE' IN
               TYPEOF (con)))) <= 2);
  WR3: SIZEOF (QUERY (rc <* USEDIN (SELF,
              'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CALLOUT_' +
              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               rc.name = 'primary')) <= 1;
  WR4: SIZEOF (QUERY (rc <* USEDIN (SELF,
              'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CALLOUT_' +
              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               rc.name = 'secondary')) <= 1;
  WR5: SIZEOF (QUERY (sec <* QUERY (rc <* USEDIN (SELF,
               'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CALLOUT_' +
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
            rc.name = 'secondary') |
         NOT (SIZEOF (QUERY (prim <* USEDIN (SELF,
               'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CALLOUT_' +
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
             prim.name = 'primary')) = 1)
       )) = 0;
END_ENTITY;

ENTITY geometrical_tolerance_callout
  SUBTYPE OF (draughting_callout);
END_ENTITY;

ENTITY leader_directed_dimension
  SUBTYPE OF (leader_directed_callout);
WHERE
  WR1: SIZEOF (QUERY (con <* SELF.contents |
       'AIC_DRAUGHTING_ELEMENTS.LEADER_CURVE' IN TYPEOF (con)))=1;
END_ENTITY;

ENTITY linear_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY ordinate_dimension
  SUBTYPE OF (projection_directed_callout);
END_ENTITY;

ENTITY radius_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
WHERE
  WR1: SIZEOF (QUERY (con <* SELF.contents |
       'AIC_DRAUGHTING_ELEMENTS.PROJECTION_CURVE' IN TYPEOF (con)))<=1;
END_ENTITY;

ENTITY structured_dimension_callout
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: SIZEOF (TYPEOF (SELF) *
       ['AIC_DRAUGHTING_ELEMENTS.DATUM_FEATURE_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.DATUM_TARGET_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.GEOMETRICAL_TOLERANCE_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.PROJECTION_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT']) = 0;
  WR2: SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (con))) |
         NOT (ato.name IN
             ['dimension value', 'tolerance value', 'unit text',
              'prefix text', 'suffix text']))) = 0;
  WR3: SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (con))) |
         (ato.name = 'dimension value')
       )) >= 1;
  WR4: SIZEOF (QUERY (dcr <* USEDIN (SELF, 'AIC_DRAUGHTING_ELEMENTS.' +
         'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP.' +
                             'RELATING_DRAUGHTING_CALLOUT') |
         dcr.name = 'prefix')) <= 1;
  WR5: SIZEOF (QUERY (dcr <* USEDIN (SELF, 'AIC_DRAUGHTING_ELEMENTS.' +
         'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP.' +
                             'RELATING_DRAUGHTING_CALLOUT') |
         dcr.name = 'suffix')) <= 1;
  WR6: ((SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         (ato.name = 'prefix text')
       )) > 0) AND
       (SIZEOF (QUERY (dcr <* USEDIN (SELF, 'AIC_DRAUGHTING_ELEMENTS.' +
                               'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP.' +
                               'RELATING_DRAUGHTING_CALLOUT') |
         dcr.name = 'prefix')) = 1));
  WR7: ((SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         (ato.name = 'suffix text')
       )) > 0) AND
       (SIZEOF (QUERY (dcr <* USEDIN (SELF, 'AIC_DRAUGHTING_ELEMENTS.' +
                               'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP.' +
                               'RELATING_DRAUGHTING_CALLOUT') |
         dcr.name = 'suffix')) = 1));
END_ENTITY;

END_SCHEMA;

SCHEMA aic_geometrically_bounded_surface;

USE FROM geometric_model_schema (geometric_set);  -- ISO 10303-42

USE FROM geometry_schema                          -- ISO 10303-42
   (point,
    cartesian_point,
    point_on_curve,
    point_on_surface,
    degenerate_pcurve,
    evaluated_degenerate_pcurve,
    direction,
    vector,
    axis1_placement,
    axis2_placement_2d,
    axis2_placement_3d,
    cartesian_transformation_operator_3d,
    curve,
    line,
    circle,
    ellipse,
    hyperbola,
    parabola,
    polyline,
    b_spline_curve,
    b_spline_curve_with_knots,
    uniform_curve,
    quasi_uniform_curve,
    bezier_curve,
    rational_b_spline_curve,
    trimmed_curve,
    composite_curve,
    composite_curve_segment,
    reparametrised_composite_curve_segment,
    pcurve,
    surface_curve,
    intersection_curve,
    seam_curve,
    composite_curve_on_surface,
    offset_curve_3d,
    curve_replica,
    surface,
    plane,
    cylindrical_surface,
    conical_surface,
    spherical_surface,
    toroidal_surface,
    degenerate_toroidal_surface,
    swept_surface,
    surface_of_linear_extrusion,
    surface_of_revolution,
    b_spline_surface,
    b_spline_surface_with_knots,
    uniform_surface,
    quasi_uniform_surface,
    bezier_surface,
    rational_b_spline_surface,
    rectangular_trimmed_surface,
    curve_bounded_surface,
    boundary_curve,
    outer_boundary_curve,
    rectangular_composite_surface,
    surface_patch,
    offset_surface,
    surface_replica);

  USE FROM product_property_representation_schema -- ISO 10303-41
   (shape_representation);

  USE FROM representation_schema                  -- ISO 10303-43
   (definitional_representation,
    mapped_item,
    parametric_representation_context);


ENTITY geometrically_bounded_surface_shape_representation 
   SUBTYPE OF (shape_representation);  
WHERE 
  WR1 : SIZEOF (QUERY (it <* SELF.items |
        NOT (SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET',
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM',
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF
        (it)) = 1))) = 0;
  WR2 : SIZEOF (QUERY (it <* SELF.items |
        SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET',
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM'] * TYPEOF
        (it)) = 1)) > 0;
  WR3 : SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM' IN TYPEOF (it)) |
        NOT ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.' +
        'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION'
        IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))
        = 0;
  WR4 : SIZEOF (QUERY (gs <* QUERY (it <* SELF.items |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (pnt <* QUERY (gsel <*
        gs\geometric_set.elements |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT' IN TYPEOF (gsel)) |
        NOT (gbsf_check_point(pnt)))) = 0))) = 0;
  WR5 : SIZEOF (QUERY (gs <* QUERY (it <* SELF.items |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (cv <* QUERY (gsel <*
        gs\geometric_set.elements |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE' IN TYPEOF (gsel)) |
        NOT (gbsf_check_curve(cv)))) = 0))) = 0;
  WR6 : SIZEOF (QUERY (gs <* QUERY (it <* SELF.items |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (sf <* QUERY (gsel <*
        gs\geometric_set.elements |
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF (gsel)) |
        NOT (gbsf_check_surface(sf)))) = 0))) = 0;
END_ENTITY;

FUNCTION gbsf_check_point (pnt : point) : BOOLEAN;  
 
  -- check whether the input has the right type;
  -- a cartesian_point is valid and has no further references
 
  IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (pnt) THEN  
    RETURN(TRUE);  
  ELSE  
 
  -- a point_on_curve needs to be checked for the validity of its curve;  
  -- further references down the tree are taken care of by the function  
  -- gbsf_check_curve  
 
    IF 'GEOMETRY_SCHEMA.POINT_ON_CURVE' IN TYPEOF (pnt) THEN  
      RETURN (gbsf_check_curve 
      (pnt\point_on_curve.basis_curve));  
    ELSE  
 
    -- a point_on_surface needs to be checked for the validity of its surface;
    -- further references down the tree are taken care of by the function     
    -- gbsf_check_surface  
 
      IF 'GEOMETRY_SCHEMA.POINT_ON_SURFACE' IN TYPEOF (pnt) THEN  
        RETURN(gbsf_check_surface
        (pnt\point_on_surface.basis_surface));  
      ELSE  
 
      -- a degenerate_pcurve needs to be checked for the validity of its   
      -- defining geometry; further references down the tree are taken care  
      -- of by the functions gbsf_check_curve and gbsf_check_surface; 
      -- both return true for valid points
 
        IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF (pnt) THEN  
          RETURN
          ((gbsf_check_curve  
          (pnt\degenerate_pcurve.reference_to_curve.items[1]))  
          AND (gbsf_check_surface (pnt\degenerate_pcurve.basis_surface)));  
        END_IF;  
      END_IF;
    END_IF;  
  END_IF;  
  RETURN(FALSE);  
END_FUNCTION;

FUNCTION gbsf_check_curve (cv : curve) : BOOLEAN;  
 
  -- check whether the input has the right type;
 
  -- let those types pass that do not have any further references  
  -- respectively rules to be applied; ensure that complex entities
  -- with bounded_curve do not pass
 
  IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 'GEOMETRY_SCHEMA.CIRCLE', 
    'GEOMETRY_SCHEMA.ELLIPSE'] * TYPEOF(cv)) = 1 THEN RETURN(TRUE);  
  ELSE  
 
    -- the b_spline_curve shall not self intersect  
 
    IF (('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF(cv)) AND
      (cv\b_spline_curve.self_intersect = FALSE))
    THEN RETURN(TRUE); 
    ELSE  
 
      -- if the curve is a composite_curve, all of its segments shall be valid
 
      IF (('GEOMETRY_SCHEMA.COMPOSITE_CURVE' IN TYPEOF(cv)) AND
        (cv\composite_curve.self_intersect = FALSE)) THEN  
        RETURN (SIZEOF (QUERY (seg <* cv\composite_curve.segments |
        NOT (gbsf_check_curve(seg.parent_curve)))) = 0); 
      ELSE  
 
        -- the curve_replica references other curves that need to be checked  

        IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
          'GEOMETRY_SCHEMA.CURVE_REPLICA'] * TYPEOF(cv)) = 1 THEN 
          RETURN (gbsf_check_curve (cv\curve_replica.parent_curve)); 
        ELSE 
 
          -- offset_curve_3d references a curve and shall not self intersect

          IF ((SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
            'GEOMETRY_SCHEMA.OFFSET_CURVE_3D'] * TYPEOF(cv)) = 1) AND
            (cv\offset_curve_3d.self_intersect = FALSE)) THEN 
            RETURN (gbsf_check_curve (cv\offset_curve_3d.basis_curve));
          ELSE  
 
            -- pcurve references a curve - indirectly, and a basis_surface 
 
            IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
              'GEOMETRY_SCHEMA.PCURVE'] * TYPEOF(cv)) = 1 THEN 
              RETURN ((gbsf_check_curve 
              (cv\pcurve.reference_to_curve.items[1])) AND  
              (gbsf_check_surface (cv\pcurve.basis_surface)));  
            ELSE  
 
              -- polyline shall have at least 3 points and shall only  
              -- be used to represent an intersection_curve  
 
              IF 'GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN  
                IF (SIZEOF (cv\polyline.points) >= 3)  AND 
                  (SIZEOF ((bag_to_set (USEDIN (cv,'')) - 
                  bag_to_set (USEDIN (cv,  
                  'GEOMETRY_SCHEMA.INTERSECTION_CURVE.BASIS_CURVE')))) = 0) 
                  THEN RETURN (TRUE);  
                END_IF;  
              ELSE  
 
                -- surface_curve references a curve_3d and one or two  
                -- pcurves or one or two surface_curves or one of each  
 
                IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
                  'GEOMETRY_SCHEMA.SURFACE_CURVE'] * TYPEOF(cv)) = 1 THEN  
 
                  -- if the curve reference is correct, check also the rest 

                  IF gbsf_check_curve (cv\surface_curve.curve_3d) THEN  
                    REPEAT i := 1 TO SIZEOF 
                    (cv\surface_curve.associated_geometry);  
 
                    -- do for one or two associated_geometrys:  
 
                    IF 'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      IF NOT gbsf_check_surface
                        (cv\surface_curve.associated_geometry[i]) THEN  
                        RETURN(FALSE);  
                      END_IF;  
                    ELSE 
                      IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF  
                        (cv\surface_curve.associated_geometry[i]) THEN  
                        IF NOT gbsf_check_curve 
                          (cv\surface_curve.associated_geometry[i]) THEN  
                          RETURN(FALSE);  
                        END_IF;  
                      END_IF;  
                    END_IF;  
                  END_REPEAT;  
                  RETURN(TRUE);  
                END_IF;  
              ELSE  
 
                -- if the curve is a trimmed_curve  
                                                         
                IF ('GEOMETRY_SCHEMA.TRIMMED_CURVE') IN TYPEOF (cv) THEN  
   
                -- if a line, parabola or hyperbola is being trimmed,  
                -- then valid  
 
                  IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
                  'GEOMETRY_SCHEMA.LINE', 
                  'GEOMETRY_SCHEMA.PARABOLA', 
                  'GEOMETRY_SCHEMA.HYPERBOLA'] *
                  TYPEOF (cv\trimmed_curve.basis_curve)) = 1 
                  THEN RETURN (TRUE); 

                    -- otherwise, recursively check the basis curve  
   
                    ELSE RETURN (gbsf_check_curve 
                      (cv\trimmed_curve.basis_curve));
                    END_IF; 
                  END_IF;  
                END_IF;  
              END_IF;  
            END_IF;  
          END_IF;   
        END_IF;  
      END_IF;  
    END_IF;  
  END_IF;  
  RETURN(FALSE);  
END_FUNCTION;

FUNCTION gbsf_check_surface (sf : surface) : BOOLEAN;  
 
  -- check whether the input has the right type and for some whether
  -- attribute restrictions are fulfilled (self-intersect e.g.)

  -- b_spline_surface has a self_intersect attribute that shall be false  
 
  IF (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND
    (sf\b_spline_surface.self_intersect = FALSE)) THEN
    RETURN(TRUE);
  ELSE  
 
    -- basis surface types return true 
 
    IF SIZEOF (['GEOMETRY_SCHEMA.SPHERICAL_SURFACE',  
      'GEOMETRY_SCHEMA.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 1 THEN
      RETURN(TRUE);  
    ELSE  
  
      IF 'GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf) THEN  
 
      -- if there is a simple basis_surface, check the curves  
 
        IF SIZEOF (['GEOMETRY_SCHEMA.CONICAL_SURFACE',  
          'GEOMETRY_SCHEMA.CYLINDRICAL_SURFACE',  
          'GEOMETRY_SCHEMA.PLANE'] 
          * TYPEOF(sf\curve_bounded_surface.basis_surface)) = 1 THEN   
          RETURN(SIZEOF (QUERY (bcurve <*  
          sf\curve_bounded_surface.boundaries |
          NOT (gbsf_check_curve(bcurve)))) = 0);
           
        ELSE  
 
        -- recursively check the basis_surface and then the curves 
 
          IF gbsf_check_surface
          (sf\curve_bounded_surface.basis_surface) THEN  
            RETURN(SIZEOF (QUERY (bcurve <*
            sf\curve_bounded_surface.boundaries | 
            NOT (gbsf_check_curve(bcurve)))) = 0);
          END_IF;  
        END_IF;  
      ELSE  
 
        -- offset_surface references a surface and shall not self intersect 
 
        IF (('GEOMETRY_SCHEMA.OFFSET_SURFACE' IN TYPEOF(sf)) AND
          (sf\offset_surface.self_intersect = FALSE)) THEN
          RETURN (gbsf_check_surface (sf\offset_surface.basis_surface));
        ELSE  
 
          -- rectangular_composite_surface references a matrix of surfaces  
 
          IF 'GEOMETRY_SCHEMA.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) 
          THEN
            REPEAT i := 1 TO SIZEOF
              (sf\rectangular_composite_surface.segments);  
              REPEAT j := 1 TO SIZEOF
                (sf\rectangular_composite_surface.segments[i]);  
                IF NOT (gbsf_check_surface
                  (sf\rectangular_composite_surface.segments[i][j].
                  parent_surface))
                  THEN RETURN (FALSE);  
                END_IF;  
              END_REPEAT;  
            END_REPEAT;  
            RETURN(TRUE);  
          ELSE  
 
            -- rectangular_trimmed_surface has a basis_surface  
 
            IF 'GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(sf) 
            THEN
              IF  SIZEOF (['GEOMETRY_SCHEMA.CONICAL_SURFACE',  
                'GEOMETRY_SCHEMA.CYLINDRICAL_SURFACE',  
                'GEOMETRY_SCHEMA.PLANE'] * TYPEOF
                (sf\rectangular_trimmed_surface.basis_surface)) = 1 THEN 
                RETURN (TRUE); 
              ELSE 
                RETURN(gbsf_check_surface
                (sf\rectangular_trimmed_surface.basis_surface)); 
              END_IF;  
            ELSE  
 
              -- parent_surfaces need to be checked for their validity 
  
              IF 'GEOMETRY_SCHEMA.SURFACE_REPLICA' IN TYPEOF (sf) THEN 
                RETURN (gbsf_check_surface 
                (sf\surface_replica.parent_surface)); 
              ELSE  
 
                -- and the swept_surface must have a valid swept_curve  

                IF 'GEOMETRY_SCHEMA.SWEPT_SURFACE' IN TYPEOF(sf) THEN  
                  RETURN(gbsf_check_curve (sf\swept_surface.swept_curve)); 
                END_IF;    
              END_IF;    
            END_IF;     
          END_IF;  
        END_IF;  
      END_IF;  
    END_IF;  
  END_IF;  
  RETURN(FALSE);  
END_FUNCTION;

FUNCTION bag_to_set (the_bag : BAG OF GENERIC : intype) : 
                     SET OF GENERIC : intype;

  LOCAL
    the_set: SET OF GENERIC : intype := [];
    i      : INTEGER;
  END_LOCAL;

  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 to HIINDEX (the_bag);
      the_set := the_set + the_bag [i];
    END_REPEAT;
  END_IF;

  RETURN (the_set);

END_FUNCTION;

END_SCHEMA; -- aic_geometrically_bounded_surface

SCHEMA aic_manifold_surface;

  USE FROM aic_topologically_bounded_surface;          -- Annex F

  USE FROM geometric_model_schema (shell_based_surface_model);-- ISO 10303-42

  USE FROM geometry_schema (                      -- ISO 10303-42
      point_on_curve,
      point_on_surface,
      degenerate_pcurve,
      evaluated_degenerate_pcurve,
      axis2_placement_2d,
      cartesian_transformation_operator_3d,
      curve,
      intersection_curve,
      seam_curve,
      offset_curve_3d,
      curve_replica,
      surface,
      offset_surface,
      surface_replica);

  USE FROM product_property_representation_schema -- ISO 10303-41
       (shape_representation);

  USE FROM representation_schema (                -- ISO 10303-43
      definitional_representation,
      parametric_representation_context);

  USE FROM topology_schema (                      -- ISO 10303-42
      oriented_face,
      connected_face_set,
      open_shell,
      closed_shell);


ENTITY manifold_surface_shape_representation 
   SUBTYPE OF (shape_representation); 
WHERE 
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL',
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM',
       'AIC_MANIFOLD_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL',
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT ('AIC_MANIFOLD_SURFACE.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))
       = 0;
  WR4: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sh <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.OPEN_SHELL',
       'AIC_MANIFOLD_SURFACE.CLOSED_SHELL']
       * TYPEOF (sh)) = 1))) = 0))) = 0;
  WR5: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.FACE_SURFACE',
       'AIC_MANIFOLD_SURFACE.ORIENTED_FACE'] * TYPEOF (fa)) = 1))) = 0)))
       = 0))) = 0;
  WR6: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (f_sf <* QUERY (fa <* 
       cfs\connected_face_set.cfs_faces |
       'AIC_MANIFOLD_SURFACE.FACE_SURFACE' IN TYPEOF (fa)) |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (f_sf))
       OR
       (SIZEOF (['AIC_MANIFOLD_SURFACE.OFFSET_SURFACE',
       'AIC_MANIFOLD_SURFACE.SURFACE_REPLICA'] * TYPEOF
       (f_sf\face_surface.face_geometry)) = 1)))) = 0))) = 0))) = 0; 
  WR7: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (basis_surface_check(fa\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
  WR8: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.EDGE_LOOP',
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items|
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
       NOT ('AIC_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds.bound\path.edge_list |
       'AIC_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.CURVE_REPLICA',
       'AIC_MANIFOLD_SURFACE.OFFSET_CURVE_3D',
       'AIC_MANIFOLD_SURFACE.PCURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
       NOT (basis_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY(sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list|
       NOT (('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR13: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
       NOT ((SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR14: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds.bound\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
 WR15: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
      = 1))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY;

FUNCTION basis_curve_check (cv: curve) : BOOLEAN; 
 
  -- let those types pass that do reference curves or surfaces and
  -- that do not have any additional constraints

  IF (('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
    (cv\b_spline_curve.self_intersect = FALSE))
  THEN RETURN(TRUE);
  ELSE

    -- avoid line and conic to be in complex entities with bounded_curves, 
    -- but else they are valid

    IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 'GEOMETRY_SCHEMA.CONIC',
      'GEOMETRY_SCHEMA.LINE'] * TYPEOF (cv)) = 1 THEN
      RETURN(TRUE);
    ELSE

      -- check in case curve_replica is the type of the input curve 
 
      IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
        'GEOMETRY_SCHEMA.CURVE_REPLICA'] * TYPEOF (cv)) = 1 THEN
        RETURN (basis_curve_check(cv\curve_replica.parent_curve)); 
      ELSE 
 
        -- check in case offset_curve_3d is the type of the input curve;
        -- attribute self_intersect shall be false
 
        IF ((SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
          'GEOMETRY_SCHEMA.OFFSET_CURVE_3D'] * TYPEOF (cv)) = 1) AND
          (cv\offset_curve_3d.self_intersect = FALSE)) THEN
          RETURN (basis_curve_check (cv\offset_curve_3d.basis_curve)); 
        ELSE 
 
          -- check in case pcurve is the type of the input curve 
 
          IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
            'GEOMETRY_SCHEMA.PCURVE'] * TYPEOF(cv)) = 1 THEN 
            RETURN ((basis_curve_check
            (cv\pcurve.reference_to_curve\representation.items[1])) AND
            (basis_surface_check (cv\pcurve.basis_surface)));

          ELSE 
 
            -- check in case surface_curve is the type of the input curve 
 
            IF SIZEOF (['GEOMETRY_SCHEMA.BOUNDED_CURVE', 
              'GEOMETRY_SCHEMA.SURFACE_CURVE'] * TYPEOF(cv)) = 1 THEN 

              -- if the curve reference is correct, check also the rest

              IF basis_curve_check (cv\surface_curve.curve_3d) THEN
                REPEAT i := 1 TO SIZEOF
                (cv\surface_curve.associated_geometry);

                  -- do for one or two associated_geometrys:
 
                  IF 'GEOMETRY_SCHEMA.SURFACE' IN 
                    TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT basis_surface_check
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      RETURN(FALSE);  
                    END_IF;  
                  ELSE  
                    IF 'GEOMETRY_SCHEMA.PCURVE' IN
                      TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                      IF NOT basis_curve_check
                        (cv\surface_curve.associated_geometry[i]) THEN 
                        RETURN(FALSE);  
                      END_IF;  
                    END_IF;  
                  END_IF; 
                END_REPEAT;  
                RETURN(TRUE);
              END_IF; 
            ELSE

              -- check in case polyline is the type of the input curve;
              -- polyline shall have at least 3 points (as required for
              -- advanced_face)

              IF 'GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
                END_IF;
              END_IF;
            END_IF; 
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN (FALSE); 
END_FUNCTION;

FUNCTION basis_surface_check (surf : surface) : BOOLEAN;
 
-- let those types pass that do not reference curves or surfaces 
 
  IF 'GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

      -- check the swept_curve in case the input surface is a swept_surface

    IF 'GEOMETRY_SCHEMA.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (basis_curve_check (surf\swept_surface.swept_curve));  
    ELSE 
 
      -- check in case offset_surface is the type of the input surface;
      -- attribute self_intersect shall be false
 
      IF (('GEOMETRY_SCHEMA.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE)) THEN
        RETURN (basis_surface_check (surf\offset_surface.basis_surface));
      ELSE 
 
        -- check in case surface_replica is the type of the input surface 
 
        IF 'GEOMETRY_SCHEMA.SURFACE REPLICA' IN TYPEOF(surf) THEN 
          RETURN(basis_surface_check (surf\surface_replica.parent_surface)); 
        ELSE

          -- check for self_intersection flag in case b_spline_surface

          IF (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND
            (surf\b_spline_surface.self_intersect = FALSE)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE); 
END_FUNCTION;

END_SCHEMA; -- aic_manifold_surface

SCHEMA aic_geometrically_bounded_wireframe;

  USE FROM geometric_model_schema                 -- ISO 10303-42
    (geometric_curve_set,
     geometric_set);

  USE FROM geometry_schema                        -- ISO 10303-42
    (axis1_placement,
     axis2_placement_3d,
     b_spline_curve_with_knots,
     bezier_curve,
     cartesian_transformation_operator_3d,
     circle,
     composite_curve,
     curve,
     curve_replica,
     ellipse,
     geometric_representation_context,
     hyperbola,
     line,
     offset_curve_3d,
     parabola,
     point,
     point_on_curve,
     point_replica,
     polyline,
     quasi_uniform_curve,
     rational_b_spline_curve,
     reparametrised_composite_curve_segment,
     trimmed_curve,
     uniform_curve);

  USE FROM product_property_representation_schema -- ISO 10303-41
    (shape_representation);

  USE FROM representation_schema                  -- ISO 10303-43
    (mapped_item);

ENTITY geometrically_bounded_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
         NOT (SIZEOF (TYPEOF(it) *
           ['AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.AXIS2_PLACEMENT_3D',
            'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM']) = 1)
       )) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF (TYPEOF (it) *
           ['AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM']) = 1
       )) >= 1;
  WR3: SIZEOF (QUERY (gcs <* QUERY (it <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (crv <*
           QUERY (elem <* gcs\geometric_set.elements |
              ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CURVE' IN TYPEOF (elem))) |
           NOT (valid_geometrically_bounded_wf_curve
                  (crv, 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME'))
         )) = 0)
       )) = 0;
  WR4: SIZEOF (QUERY (gcs <* QUERY (it <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (pnts <*
           QUERY (elem <* gcs\geometric_set.elements |
              ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POINT' IN TYPEOF (elem))) |
           NOT (valid_geometrically_bounded_wf_point
                  (pnts, 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME'))
         )) = 0)
       )) = 0;
  WR5: SIZEOF (QUERY (gcs <* QUERY (it <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (cnc <*
           QUERY (elem <* gcs\geometric_set.elements |
              ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CONIC' IN TYPEOF (elem))) |
           NOT ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.AXIS2_PLACEMENT_3D'
             IN TYPEOF (cnc\conic.position))
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (gcs <* QUERY (it <* SELF.items |
         ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET'
              IN TYPEOF (it))) |
         NOT (SIZEOF (QUERY (pline <*
           QUERY (elem <* gcs\geometric_set.elements |
              ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POLYLINE'
                  IN TYPEOF (elem))) |
           NOT (SIZEOF (pline\polyline.points) > 2)
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
          ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM'
               IN TYPEOF (it))) |
           NOT ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.' +
                'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'
             IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       )) = 0;
  WR8: SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 3;
END_ENTITY;

FUNCTION valid_geometrically_bounded_wf_curve
   (crv   : curve; schma : STRING) : BOOLEAN;

  -- check for valid basic curve types
  IF SIZEOF ([schma + '.POLYLINE',
              schma + '.B_SPLINE_CURVE',
              schma + '.ELLIPSE',
              schma + '.CIRCLE'] * TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
    -- if the curve is a trimmed_curve
    IF ((schma + '.TRIMMED_CURVE') IN TYPEOF (crv)) THEN
      -- if a line, parabola, or hyperbola is being trimmed, then valid
      IF SIZEOF ([schma + '.LINE',
                  schma + '.PARABOLA',
                  schma + '.HYPERBOLA'] *
           TYPEOF(crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);

      -- otherwise, recursively check basis_curve
      ELSE RETURN (valid_geometrically_bounded_wf_curve
                         (crv\trimmed_curve.basis_curve, schma));
      END_IF;
    ELSE
      -- recursively check the offset_curve basis curve
      IF ((schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv))
        THEN RETURN (valid_geometrically_bounded_wf_curve
                           (crv\offset_curve_3d.basis_curve, schma));
      ELSE
        -- recursively check the curve_replica parent curve
        IF ((schma + '.CURVE_REPLICA') IN TYPEOF (crv))
          THEN RETURN (valid_geometrically_bounded_wf_curve
                         (crv\curve_replica.parent_curve, schma));
        ELSE
          -- recursively check the composite_curve segments
          IF ((schma + '.COMPOSITE_CURVE') IN TYPEOF (crv)) THEN
            RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                      NOT (valid_geometrically_bounded_wf_curve
                             (ccs.parent_curve, schma)))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_geometrically_bounded_wf_point
   (pnt : point; schma : STRING) : BOOLEAN;

  -- check for valid basis types
  IF ((schma + '.CARTESIAN_POINT') IN TYPEOF (pnt))
    THEN RETURN (TRUE);
  ELSE
    -- if the input type is a point_on_curve then check for a valid
    -- geometrically bounded curve type as the basis
    IF ((schma + '.POINT_ON_CURVE') IN TYPEOF (pnt))
      THEN RETURN (valid_geometrically_bounded_wf_curve
                     (pnt\point_on_curve.basis_curve, schma));

    ELSE
      -- if the input type is a point_replica check for a valid parent point
      IF ((schma + '.POINT_REPLICA') IN TYPEOF (pnt))
        THEN RETURN (valid_geometrically_bounded_wf_point
                         (pnt\point_replica.parent_pt, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

END_SCHEMA; -- aic_geometrically_bounded_wireframe

SCHEMA aic_topologically_bounded_surface;

  USE FROM geometry_schema (                      -- ISO 10303-42
    axis2_placement_2d,
    axis2_placement_3d,
    bezier_curve,
    bezier_surface,
    b_spline_curve_with_knots,
    b_spline_surface_with_knots,
    cartesian_point,
    circle,
    conical_surface,
    cylindrical_surface,
    degenerate_toroidal_surface,
    direction,
    ellipse,
    hyperbola,
    line,
    parabola,
    pcurve,
    plane,
    polyline,
    quasi_uniform_curve,
    quasi_uniform_surface,
    rational_b_spline_curve,
    rational_b_spline_surface,
    spherical_surface,
    surface_curve,
    surface_of_linear_extrusion,
    surface_of_revolution,
    swept_surface,
    toroidal_surface,
    uniform_curve,
    uniform_surface,
    vector);

  USE FROM topology_schema(                       -- ISO 10303-42
    edge_curve,
    edge_loop,
    face_bound,
    face_outer_bound,
    face_surface,
    path,
    vertex_loop,
    vertex_point);

  USE FROM representation_schema(                 -- ISO 10303-43
    definitional_representation,
    parametric_representation_context);

  USE FROM measure_schema                         -- ISO 10303-41
   (parameter_value);


ENTITY advanced_face
  SUBTYPE OF (face_surface);
WHERE
  WR1 : SIZEOF
        (['AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ELEMENTARY_SURFACE',
          'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE',
          'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE'] *
            TYPEOF(face_geometry)) = 1;
  WR2 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
           'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                          TYPEOF(bnds.bound)) |
          NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
              NOT('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_CURVE' IN
              TYPEOF(oe.edge_element)))) = 0))) = 0;
  WR3 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
          'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                            TYPEOF(bnds.bound)) |
           NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
           NOT (SIZEOF (['AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE',
                        'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC',
                        'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE',
                        'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE',
                        'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE'] *
              TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
                )) = 0))) = 0;
  WR4 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
           'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                             TYPEOF(bnds.bound)) |
            NOT(SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list |
             NOT(((('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN
                 TYPEOF(oe.edge_start)) AND
            ( 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN
             TYPEOF(oe.edge_start\vertex_point.vertex_geometry)))) AND
                 (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN
                    TYPEOF(oe.edge_end)) AND
                   ( 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN
                     TYPEOF(oe.edge_end\vertex_point.vertex_geometry)))
              ))) = 0))) = 0;
  WR5 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
         'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                           TYPEOF(bnds.bound)) |
            'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ORIENTED_PATH' IN
             TYPEOF(elp_fbnds.bound))) = 0;
  WR6 : (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN
                                              TYPEOF(face_geometry))) OR
             (SIZEOF (['AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE',
                       'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC',
                       'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE',
                       'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE'] *
                  TYPEOF(face_geometry\swept_surface.swept_curve)) = 1);
  WR7 : SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* SELF.bounds |
           'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' IN
                                               TYPEOF(bnds.bound)) |
             NOT(('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN
               TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                  ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN
                     TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                     loop_vertex\vertex_point.vertex_geometry))
              ))) = 0;
  WR8 : SIZEOF (QUERY (bnd <* SELF.bounds |
        NOT (SIZEOF(['AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP',
         'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP'] * TYPEOF(bnd.bound))
                                = 1))) = 0;
  WR9 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
          'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN
                                             TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND 
            (NOT (SIZEOF (QUERY (sc_ag <* 
            oe.edge_element\edge_curve.edge_geometry\
            surface_curve.associated_geometry |
            NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN
            TYPEOF(sc_ag)))) = 0)))) = 0))) = 0;
  WR10 : ((NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN
         TYPEOF(face_geometry))) OR
         ((NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN
         TYPEOF(face_geometry\swept_surface.swept_curve))) OR
         (SIZEOF(face_geometry\swept_surface.swept_curve\polyline.points)
         < 3))) AND
         (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* SELF.bounds |
         'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound))
|
         NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
         ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN
         TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND 
         (NOT (SIZEOF (oe.edge_element\edge_curve.edge_geometry\
         polyline.points) < 3)))) = 0))) = 0);
 END_ENTITY;

END_SCHEMA; -- end AIC_TOPOLOGICALLY_BOUNDED_SURFACE SCHEMA

SCHEMA aic_faceted_brep;

  USE FROM geometry_schema(                       -- ISO 10303-42
     cartesian_point, 
     axis2_placement_3d,
     cartesian_transformation_operator_3d,
     elementary_surface, 
     plane);

  USE FROM topology_schema(                       -- ISO 10303-42
     poly_loop, 
     face_surface,
     face_bound, 
     face_outer_bound,
     closed_shell, 
     oriented_closed_shell);

  USE FROM geometric_model_schema(                -- ISO 10303-42
     brep_with_voids, 
     manifold_solid_brep,
     faceted_brep);

  USE FROM representation_schema                  -- ISO 10303-43
    (mapped_item);

  USE FROM product_property_representation_schema -- ISO 10303-41
    (shape_representation);


ENTITY faceted_brep_shape_representation
 SUBTYPE OF (shape_representation);
 WHERE
 WR1 : SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF(['AIC_FACETED_BREP.FACETED_BREP',
            'AIC_FACETED_BREP.MAPPED_ITEM',
            'AIC_FACETED_BREP.AXIS2_PLACEMENT_3D'] *
             TYPEOF(it)) = 1))) = 0;
 WR2 : SIZEOF (QUERY (it <* SELF.items |
          SIZEOF(['AIC_FACETED_BREP.FACETED_BREP',
          'AIC_FACETED_BREP.MAPPED_ITEM'] * TYPEOF(it)) = 1)) > 0;
 WR3 : SIZEOF (QUERY (fbrep <* QUERY ( it <* SELF.items |
          'AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* msb_shells(fbrep, 'AIC_FACETED_BREP') |
           NOT (SIZEOF (QUERY (fcs <* csh.cfs_faces |
          NOT (('AIC_FACETED_BREP.FACE_SURFACE' IN TYPEOF (fcs)) AND
          (('AIC_FACETED_BREP.PLANE' IN TYPEOF
               (fcs\face_surface.face_geometry)) AND
          ('AIC_FACETED_BREP.CARTESIAN_POINT' IN TYPEOF (
               fcs\face_surface.face_geometry\
                    elementary_surface.position.location))))))
                      = 0))) = 0))) = 0;
   WR4 : SIZEOF (QUERY (fbrep <* QUERY ( it <* SELF.items |
          'AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* msb_shells(fbrep, 'AIC_FACETED_BREP') |
          NOT (SIZEOF (QUERY (fcs <* csh.cfs_faces |
          NOT (SIZEOF (QUERY (bnds <* fcs.bounds |
           'AIC_FACETED_BREP.FACE_OUTER_BOUND' IN TYPEOF(bnds)))
              = 1))) = 0))) = 0))) = 0;
   WR5 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
          'AIC_FACETED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
          'AIC_FACETED_BREP.ORIENTED_CLOSED_SHELL' IN
              TYPEOF (msb\manifold_solid_brep.outer))) = 0;
   WR6 : SIZEOF (QUERY (brv <* QUERY (it <* SELF.items |
          'AIC_FACETED_BREP.BREP_WITH_VOIDS' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
           csh\oriented_closed_shell.orientation)) = 0))) = 0;
   WR7 : SIZEOF (QUERY (mi <*  QUERY (it <* SELF.items |
                 'AIC_FACETED_BREP.MAPPED_ITEM' IN TYPEOF(it)) |
          NOT ('AIC_FACETED_BREP.FACETED_BREP_SHAPE_REPRESENTATION' IN
            TYPEOF(mi\mapped_item.mapping_source.mapped_representation))))
                = 0;
END_ENTITY;

FUNCTION msb_shells (brep: manifold_solid_brep;
                        schema_name : STRING) :
                        SET [1:?] OF  closed_shell;
     IF (schema_name + '.BREP_WITH_VOIDS' IN TYPEOF (brep)) THEN
       RETURN (brep\brep_with_voids.voids + brep.outer);
     ELSE
       RETURN([brep.outer]);
     END_IF;
END_FUNCTION;

END_SCHEMA; -- end AIC FACETED BREP SCHEMA

SCHEMA aic_elementary_brep;

  USE FROM geometry_schema(                       -- ISO 10303-42
    axis2_placement_3d,
    cartesian_point,
    cartesian_transformation_operator_3d,
    circle,
    conical_surface,
    cylindrical_surface,
    degenerate_toroidal_surface,
    direction,
    ellipse,
    hyperbola,
    line,
    parabola,
    plane,
    polyline,
    spherical_surface,
    toroidal_surface,
    vector);

  USE FROM geometric_model_schema(                -- ISO 10303-42
    manifold_solid_brep,
    brep_with_voids);

  USE FROM topology_schema(                       -- ISO 10303-42
    closed_shell,
    connected_face_set,
    edge_curve,
    edge_loop,
    face_bound,
    face_outer_bound,
    face_surface,
    oriented_closed_shell,
    vertex_loop,
    vertex_point);

  USE FROM representation_schema                  -- ISO 10303-43
    (mapped_item);

  USE FROM product_property_representation_schema -- ISO 10303-41
    (shape_representation);


ENTITY elementary_brep_shape_representation
SUBTYPE OF (shape_representation);
WHERE
   WR1 : SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP',
                'AIC_ELEMENTARY_BREP.FACETED_BREP',
                'AIC_ELEMENTARY_BREP.MAPPED_ITEM',
                'AIC_ELEMENTARY_BREP.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;

   WR2 : SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP',
         'AIC_ELEMENTARY_BREP.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR3 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb, 'AIC_ELEMENTARY_BREP') |
            NOT (SIZEOF (QUERY(fcs <* csh.cfs_faces |
              NOT('AIC_ELEMENTARY_BREP.FACE_SURFACE' IN TYPEOF(fcs)))) = 0
                 ))) = 0
                   ))) = 0;
   WR4 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb, 'AIC_ELEMENTARY_BREP') |
            NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
              NOT(('AIC_ELEMENTARY_BREP.ELEMENTARY_SURFACE' IN
                   TYPEOF(fcs\face_surface.face_geometry))
             ))) = 0
                 ))) = 0
                   ))) = 0;
   WR5 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb, 'AIC_ELEMENTARY_BREP') |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT('AIC_ELEMENTARY_BREP.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)))) = 0
                   ))) = 0
                 ))) = 0
               ))) = 0
             ))) = 0;
   WR6 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb, 'AIC_ELEMENTARY_BREP') |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['AIC_ELEMENTARY_BREP.LINE',
                         'AIC_ELEMENTARY_BREP.CONIC',
                         'AIC_ELEMENTARY_BREP.POLYLINE'] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
   WR7 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb, 'AIC_ELEMENTARY_BREP') |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            NOT(('AIC_ELEMENTARY_BREP.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('AIC_ELEMENTARY_BREP.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0;
   WR8 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb, 'AIC_ELEMENTARY_BREP') |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
            'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            'AIC_ELEMENTARY_BREP.ORIENTED_PATH' IN TYPEOF
              (elp_fbnds.bound))) = 0
                ))) = 0
                 ))) = 0
                   ))) = 0;
   WR9 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
          'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
          'AIC_ELEMENTARY_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF
              (msb\manifold_solid_brep.outer)))
             = 0;
   WR10 : SIZEOF (QUERY (brv <* QUERY (it <* SELF.items |
          'AIC_ELEMENTARY_BREP.BREP_WITH_VOIDS' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
           csh\oriented_closed_shell.orientation)) = 0))) = 0;
   WR11 : SIZEOF (QUERY (mi <*  QUERY (it <* SELF.items |
                 'AIC_ELEMENTARY_BREP.MAPPED_ITEM' IN TYPEOF(it)) |
          NOT
          ('AIC_ELEMENTARY_BREP.ELEMENTARY_BREP_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR12 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb, 'AIC_ELEMENTARY_BREP') |
              NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.VERTEX_LOOP' IN TYPEOF(bnds.bound)) |
           NOT(('AIC_ELEMENTARY_BREP.VERTEX_POINT' IN
               TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                ('AIC_ELEMENTARY_BREP.CARTESIAN_POINT' IN
                   TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                     loop_vertex\vertex_point.vertex_geometry))
            ))) = 0))) = 0))) = 0))) =0;
 END_ENTITY;

FUNCTION msb_shells (brep: manifold_solid_brep;
                        schema_name : STRING) :
                        SET [1:?] OF  closed_shell;
     IF (schema_name + '.BREP_WITH_VOIDS' IN TYPEOF (brep)) THEN
       RETURN (brep\brep_with_voids.voids + brep.outer);
     ELSE
       RETURN([brep.outer]);
     END_IF;
END_FUNCTION;

END_SCHEMA; -- end AIC_ELEMENTARY_BREP SCHEMA

SCHEMA aic_advanced_brep;

  USE FROM aic_topologically_bounded_surface;          -- Annex F

  USE FROM geometry_schema(                       -- ISO 10303-42
    cartesian_transformation_operator_3d,
    geometric_representation_context);

  USE FROM geometric_model_schema(                -- ISO 10303-42
    manifold_solid_brep,
    brep_with_voids);

  USE FROM topology_schema(                       -- ISO 10303-42
    closed_shell,
    connected_face_set,
    oriented_closed_shell);

  USE FROM representation_schema                  -- ISO 10303-43
    (mapped_item);

  USE FROM product_property_representation_schema -- ISO 10303-41
    (shape_representation);


ENTITY advanced_brep_shape_representation
  SUBTYPE OF (shape_representation);
  WHERE
     WR1: SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
              'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP',
              'AIC_ADVANCED_BREP.FACETED_BREP',
              'AIC_ADVANCED_BREP.MAPPED_ITEM',
              'AIC_ADVANCED_BREP.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)) ))
              = 0;
     WR2: SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
              'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP',
              'AIC_ADVANCED_BREP.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) > 0;
     WR3: SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items |
              ('AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) ) |
             ( NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
              'AIC_ADVANCED_BREP') | (NOT (SIZEOF(QUERY ( fcs <* csh\
              connected_face_set.cfs_faces | (NOT (
              'AIC_ADVANCED_BREP.ADVANCED_FACE' IN TYPEOF(fcs))) )) = 0)) ))
              = 0)) )) = 0;
     WR4: SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items |
            ( 'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) ) |
            (  'AIC_ADVANCED_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb\
              manifold_solid_brep.outer)) )) = 0;
     WR5: SIZEOF(QUERY ( brv <* QUERY ( it <* SELF.items |
           ( 'AIC_ADVANCED_BREP.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | (NOT
              (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids |
              ( csh\oriented_closed_shell.orientation)))  = 0)) ))
              = 0;
     WR6: SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items |
            ( 'AIC_ADVANCED_BREP.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT
            ( 'AIC_ADVANCED_BREP.ADVANCED_BREP_SHAPE_REPRESENTATION' IN
              TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) ))
              = 0;
END_ENTITY;

FUNCTION msb_shells (brep: manifold_solid_brep;
                        schema_name : STRING) :
                        SET [1:?] OF  closed_shell;
     IF (schema_name + '.BREP_WITH_VOIDS' IN TYPEOF (brep)) THEN
       RETURN (brep\brep_with_voids.voids + brep.outer);
     ELSE
       RETURN([brep.outer]);
     END_IF;
END_FUNCTION;

END_SCHEMA; -- end AIC_ADVANCED_BREP SCHEMA
