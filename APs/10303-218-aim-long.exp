(* 
AIM long form for ISO/IS 10303-218
Len Slovensky
2003-06-17
ISO TC184/SC4/WG3 N1342
*)

(* This file was generated by exppp (an EXPRESS Pretty Printer)
written at the National Institute of Standards and Technology
by Don Libes, February 19, 1993.

WARNING: If you modify this file and want to save the changes,
delete this comment block or else the file will be rewritten
the next time exppp processes this schema. *)

SCHEMA ship_structures_schema;

  CONSTANT
  dummy_gri : geometric_representation_item := representation_item('') || 
                 geometric_representation_item();
  dummy_tri : topological_representation_item := representation_item('') 
                 || topological_representation_item();
  END_CONSTANT;

  TYPE action_request_item = SELECT
    (action,
     executed_action,
     group,
     product,
     product_definition,
     product_definition_relationship,
     product_definition_shape,
     property_definition);
  END_TYPE; -- action_request_item

  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     exact,
     behind);
  END_TYPE; -- ahead_or_behind

  TYPE amount_of_substance_measure = REAL;
  END_TYPE; -- amount_of_substance_measure

  TYPE approval_item = SELECT
    (product_definition_shape,
     product_definition,
     property_definition);
  END_TYPE; -- approval_item

  TYPE area_measure = REAL;
  END_TYPE; -- area_measure

  TYPE attribute_type = SELECT
    (label,
     text);
  END_TYPE; -- attribute_type

  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE; -- axis2_placement

  TYPE b_spline_curve_form = ENUMERATION OF
    (polyline_form,
     circular_arc,
     elliptic_arc,
     parabolic_arc,
     hyperbolic_arc,
     unspecified);
  END_TYPE; -- b_spline_curve_form

  TYPE b_spline_surface_form = ENUMERATION OF
    (plane_surf,
     cylindrical_surf,
     conical_surf,
     spherical_surf,
     toroidal_surf,
     surf_of_revolution,
     ruled_surf,
     generalised_cone,
     quadric_surf,
     surf_of_linear_extrusion,
     unspecified);
  END_TYPE; -- b_spline_surface_form

  TYPE boolean_operand = SELECT
    (solid_model);
  END_TYPE; -- boolean_operand

  TYPE celsius_temperature_measure = REAL;
  END_TYPE; -- celsius_temperature_measure

  TYPE characterized_action_definition = SELECT
    (action,
     action_method);
  END_TYPE; -- characterized_action_definition

  TYPE characterized_definition = SELECT
    (characterized_object,
     characterized_product_definition,
     shape_definition);
  END_TYPE; -- characterized_definition

  TYPE characterized_product_definition = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE; -- characterized_product_definition

  TYPE classification_item = SELECT
    (action,
     action_request_solution,
     compound_representation_item,
     group,
     product,
     product_definition,
     product_definition_with_associated_documents,
     product_definition_relationship,
     product_definition_shape,
     product_related_product_category,
     property_definition,
     property_definition_relationship,
     representation,
     shape_aspect,
     shape_aspect_relationship,
     versioned_action_request);
  END_TYPE; -- classification_item

  TYPE compound_item_definition = SELECT
    (list_representation_item,
     set_representation_item);
  END_TYPE; -- compound_item_definition

  TYPE configuration_design_item = SELECT
    (product_definition,
     product_definition_formation);
  END_TYPE; -- configuration_design_item

  TYPE context_dependent_measure = REAL;
  END_TYPE; -- context_dependent_measure

  TYPE count_measure = NUMBER;
  END_TYPE; -- count_measure

  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE; -- curve_on_surface

  TYPE date_and_time_item = SELECT
    (action,
     action_request_solution,
     product_definition,
     versioned_action_request);
  END_TYPE; -- date_and_time_item

  TYPE date_time_or_event_occurrence = SELECT
    (date_time_select);
  END_TYPE; -- date_time_or_event_occurrence

  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 31));
  END_TYPE; -- day_in_month_number

  TYPE day_in_week_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 7));
  END_TYPE; -- day_in_week_number

  TYPE day_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 366));
  END_TYPE; -- day_in_year_number

  TYPE derived_property_select = SELECT
    (property_definition);
  END_TYPE; -- derived_property_select

  TYPE description_attribute_select = SELECT
    (action_request_solution,
     application_context,
     approval_role,
     date_time_role,
     external_source,
     organization_role,
     person_and_organization_role,
     person_and_organization,
     person_role,
     property_definition_representation,
     representation);
  END_TYPE; -- description_attribute_select

  TYPE dimension_count = INTEGER;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- dimension_count

  TYPE document_reference_item = SELECT
    (group,
     property_definition);
  END_TYPE; -- document_reference_item

  TYPE electric_current_measure = REAL;
  END_TYPE; -- electric_current_measure

  TYPE external_identification_item = SELECT
    (document,
     document_reference,
     product,
     product_definition,
     product_definition_shape,
     property_definition,
     shape_aspect);
  END_TYPE; -- external_identification_item

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE; -- founded_item_select

  TYPE geometric_set_select = SELECT
    (point,
     curve,
     surface);
  END_TYPE; -- geometric_set_select

  TYPE group_item = SELECT
    (approval,
     product_definition,
     product_definition_shape,
     product_definition_with_associated_documents,
     product_definition_relationship,
     representation,
     shape_aspect);
  END_TYPE; -- group_item

  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 24));
  END_TYPE; -- hour_in_day

  TYPE id_attribute_select = SELECT
    (action,
     address,
     product_category,
     property_definition,
     shape_aspect,
     shape_aspect_relationship,
     application_context,
     group,
     organizational_project,
     representation);
  END_TYPE; -- id_attribute_select

  TYPE identification_item = SELECT
    (action_request_solution,
     executed_action,
     externally_defined_general_property,
     externally_defined_class,
     group,
     product,
     product_definition,
     product_definition_shape,
     product_definition_relationship,
     product_related_product_category,
     property_definition_relationship,
     property_definition,
     representation,
     shape_aspect,
     shape_aspect_relationship,
     versioned_action_request);
  END_TYPE; -- identification_item

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE knot_type = ENUMERATION OF
    (uniform_knots,
     quasi_uniform_knots,
     piecewise_bezier_knots,
     unspecified);
  END_TYPE; -- knot_type

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE length_measure = REAL;
  END_TYPE; -- length_measure

  TYPE list_of_reversible_topology_item = LIST [0:?] OF
              reversible_topology_item;
  END_TYPE; -- list_of_reversible_topology_item

  TYPE list_representation_item = LIST [1:?] OF representation_item;
  END_TYPE; -- list_representation_item

  TYPE luminous_intensity_measure = REAL;
  END_TYPE; -- luminous_intensity_measure

  TYPE mass_measure = REAL;
  END_TYPE; -- mass_measure

  TYPE measure_value = SELECT
    (length_measure,
     mass_measure,
     time_measure,
     electric_current_measure,
     thermodynamic_temperature_measure,
     celsius_temperature_measure,
     amount_of_substance_measure,
     luminous_intensity_measure,
     plane_angle_measure,
     solid_angle_measure,
     area_measure,
     volume_measure,
     ratio_measure,
     parameter_value,
     context_dependent_measure,
     positive_length_measure,
     positive_plane_angle_measure,
     count_measure);
  END_TYPE; -- measure_value

  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 59));
  END_TYPE; -- minute_in_hour

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 12));
  END_TYPE; -- month_in_year_number

  TYPE name_attribute_select = SELECT
    (action_request_solution,
     address,
     derived_unit,
     person_and_organization,
     product_definition,
     property_definition_representation);
  END_TYPE; -- name_attribute_select

  TYPE organization_item = SELECT
    (externally_defined_class,
     document,
     known_source,
     product_definition,
     property_definition);
  END_TYPE; -- organization_item

  TYPE parameter_value = REAL;
  END_TYPE; -- parameter_value

  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE; -- pcurve_or_surface

  TYPE person_and_organization_item = SELECT
    (action_request_solution,
     executed_action,
     document,
     versioned_action_request);
  END_TYPE; -- person_and_organization_item

  TYPE person_item = SELECT
    (action_request_solution,
     document,
     executed_action,
     versioned_action_request);
  END_TYPE; -- person_item

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE plane_angle_measure = REAL;
  END_TYPE; -- plane_angle_measure

  TYPE positive_length_measure = length_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_length_measure

  TYPE positive_plane_angle_measure = plane_angle_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_plane_angle_measure

  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (curve_3d,
     pcurve_s1,
     pcurve_s2);
  END_TYPE; -- preferred_surface_curve_representation

  TYPE product_or_formation_or_definition = SELECT
    (product,
     product_definition_formation,
     product_definition);
  END_TYPE; -- product_or_formation_or_definition

  TYPE property_or_shape_select = SELECT
    (property_definition,
     shape_definition);
  END_TYPE; -- property_or_shape_select

  TYPE ratio_measure = REAL;
  END_TYPE; -- ratio_measure

  TYPE represented_definition = SELECT
    (general_property,
     property_definition,
     property_definition_relationship,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- represented_definition

  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE; -- reversible_topology

  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE; -- reversible_topology_item

  TYPE role_select = SELECT
    (action_request_assignment,
     approval_assignment,
     approval_date_time,
     document_reference,
     group_assignment);
  END_TYPE; -- role_select

  TYPE second_in_minute = REAL;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 60));
  END_TYPE; -- second_in_minute

  TYPE set_of_reversible_topology_item = SET [0:?] OF
              reversible_topology_item;
  END_TYPE; -- set_of_reversible_topology_item

  TYPE set_representation_item = SET [1:?] OF representation_item;
  END_TYPE; -- set_representation_item

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- shape_definition

  TYPE shell = SELECT
    (open_shell,
     closed_shell);
  END_TYPE; -- shell

  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE; -- si_prefix

  TYPE si_unit_name = ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE; -- si_unit_name

  TYPE solid_angle_measure = REAL;
  END_TYPE; -- solid_angle_measure

  TYPE source_item = SELECT
    (identifier);
  END_TYPE; -- source_item

  TYPE supported_item = SELECT
    (action,
     action_method);
  END_TYPE; -- supported_item

  TYPE surface_boundary = SELECT
    (degenerate_pcurve);
  END_TYPE; -- surface_boundary

  TYPE surface_model = SELECT
    (face_based_surface_model);
  END_TYPE; -- surface_model

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE; -- thermodynamic_temperature_measure

  TYPE time_measure = REAL;
  END_TYPE; -- time_measure

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE; -- transformation

  TYPE transition_code = ENUMERATION OF
    (discontinuous,
     continuous,
     cont_same_gradient,
     cont_same_gradient_same_curvature);
  END_TYPE; -- transition_code

  TYPE trimming_preference = ENUMERATION OF
    (cartesian,
     parameter,
     unspecified);
  END_TYPE; -- trimming_preference

  TYPE trimming_select = SELECT
    (cartesian_point,
     parameter_value);
  END_TYPE; -- trimming_select

  TYPE unit = SELECT
    (named_unit,
     derived_unit);
  END_TYPE; -- unit

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE; -- vector_or_direction

  TYPE volume_measure = REAL;
  END_TYPE; -- volume_measure

  TYPE week_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 53));
  END_TYPE; -- week_in_year_number

  TYPE wireframe_model = SELECT
    (edge_based_wireframe_model);
  END_TYPE; -- wireframe_model

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY action;
      name          : label;
      description   : OPTIONAL text;
      chosen_method : action_method;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- action

  ENTITY action_method;
      name        : label;
      description : OPTIONAL text;
      consequence : text;
      purpose     : text;
  END_ENTITY; -- action_method

  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- action_request_assignment

  ENTITY action_request_solution;
      method  : action_method;
      request : versioned_action_request;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- action_request_solution

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    DERIVE
      name : label := get_name_value(SELF);
      url  : identifier := get_id_value(SELF);
    WHERE
      wr1: (EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number));
  END_ENTITY; -- address

  ENTITY advanced_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'SHIP_STRUCTURES_SCHEMA.MANIFOLD_SOLID_BREP',
               'SHIP_STRUCTURES_SCHEMA.FACETED_BREP',
               'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM',
               'SHIP_STRUCTURES_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
                1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'SHIP_STRUCTURES_SCHEMA.MANIFOLD_SOLID_BREP',
               'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               > 0);
      wr3: (SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
               SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
               NOT ('SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(fcs))) )) 
               = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( msb <* QUERY ( it <* items | (
               'SHIP_STRUCTURES_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | ('SHIP_STRUCTURES_SCHEMA.ORIENTED_CLOSED_SHELL' IN 
               TYPEOF(msb\manifold_solid_brep.outer)) )) = 0);
      wr5: (SIZEOF(QUERY ( brv <* QUERY ( it <* items | (
               'SHIP_STRUCTURES_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | 
               (NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | csh\
               oriented_closed_shell.orientation )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
               'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (
               'SHIP_STRUCTURES_SCHEMA.ADVANCED_BREP_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0);
  END_ENTITY; -- advanced_brep_shape_representation

  ENTITY advanced_face
    SUBTYPE OF (face_surface);
    WHERE
      wr1 : (SIZEOF(['SHIP_STRUCTURES_SCHEMA.ELEMENTARY_SURFACE',
                'SHIP_STRUCTURES_SCHEMA.B_SPLINE_SURFACE',
                'SHIP_STRUCTURES_SCHEMA.SWEPT_SURFACE'] * TYPEOF(
                face_geometry)) = 1);
      wr2 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ('SHIP_STRUCTURES_SCHEMA.EDGE_CURVE' IN 
                TYPEOF(oe\oriented_edge.edge_element))) )) = 0)) )) = 0);
      wr3 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (SIZEOF(['SHIP_STRUCTURES_SCHEMA.LINE',
                'SHIP_STRUCTURES_SCHEMA.CONIC',
                'SHIP_STRUCTURES_SCHEMA.POLYLINE',
                'SHIP_STRUCTURES_SCHEMA.SURFACE_CURVE',
                'SHIP_STRUCTURES_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(oe.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0);
      wr4 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (('SHIP_STRUCTURES_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(oe\edge.edge_start)) AND (
                'SHIP_STRUCTURES_SCHEMA.CARTESIAN_POINT' IN TYPEOF(oe\edge.
                edge_start\vertex_point.vertex_geometry)) AND (
                'SHIP_STRUCTURES_SCHEMA.VERTEX_POINT' IN TYPEOF(oe\edge.
                edge_end)) AND ('SHIP_STRUCTURES_SCHEMA.CARTESIAN_POINT' IN
                 TYPEOF(oe\edge.edge_end\vertex_point.vertex_geometry)))) )) 
                = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | ('SHIP_STRUCTURES_SCHEMA.ORIENTED_PATH' IN TYPEOF(
                elp_fbnds.bound)) )) = 0);
      wr6 : ((NOT ('SHIP_STRUCTURES_SCHEMA.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (SIZEOF(['SHIP_STRUCTURES_SCHEMA.LINE',
                'SHIP_STRUCTURES_SCHEMA.CONIC',
                'SHIP_STRUCTURES_SCHEMA.POLYLINE',
                'SHIP_STRUCTURES_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(
                face_geometry\swept_surface.swept_curve)) = 1));
      wr7 : (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_STRUCTURES_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (('SHIP_STRUCTURES_SCHEMA.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND (
                'SHIP_STRUCTURES_SCHEMA.CARTESIAN_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry)))) )) = 0);
      wr8 : (SIZEOF(QUERY ( bnd <* bounds | (NOT (SIZEOF([
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP',
                'SHIP_STRUCTURES_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnd.bound)) 
                = 1)) )) = 0);
      wr9 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('SHIP_STRUCTURES_SCHEMA.SURFACE_CURVE' IN 
                TYPEOF(oe\oriented_edge.edge_element\edge_curve.
                edge_geometry)) AND (NOT (SIZEOF(QUERY ( sc_ag <* oe.
                edge_element\edge_curve.edge_geometry\surface_curve.
                associated_geometry | (NOT ('SHIP_STRUCTURES_SCHEMA.PCURVE' 
                IN TYPEOF(sc_ag))) )) = 0))) )) = 0)) )) = 0);
      wr10: (((NOT ('SHIP_STRUCTURES_SCHEMA.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (NOT ('SHIP_STRUCTURES_SCHEMA.POLYLINE' 
                IN TYPEOF(face_geometry\swept_surface.swept_curve))) OR (
                SIZEOF(face_geometry\swept_surface.swept_curve\polyline.
                points) >= 3)) AND (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('SHIP_STRUCTURES_SCHEMA.POLYLINE' IN TYPEOF(
                oe\oriented_edge.edge_element\edge_curve.edge_geometry)) 
                AND (NOT (SIZEOF(oe\oriented_edge.edge_element\edge_curve.
                edge_geometry\polyline.points) >= 3))) )) = 0)) )) = 0));
  END_ENTITY; -- advanced_face

  ENTITY application_context;
      application : label;
    DERIVE
      description : text := get_description_value(SELF);
      id          : identifier := get_id_value(SELF);
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (product_context,product_definition_context));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY; -- application_protocol_definition

  ENTITY applied_action_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF action_request_item;
  END_ENTITY; -- applied_action_request_assignment

  ENTITY applied_approval_assignment
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
    WHERE
      wr1: ((NOT (SELF\approval_assignment.role.name = 
               'proposed alternative')) OR (SIZEOF(QUERY ( app <* USEDIN(
               SELF\approval_assignment.assigned_approval,'SHIP_STRUCTURES_SCHEMA.APPROVAL_ASSIGNMENT.ASSIGNED_APPROVAL')
                | (('SHIP_STRUCTURES_SCHEMA.APPLIED_APPROVAL_ASSIGNMENT' IN
                TYPEOF(app)) AND (app\approval_assignment.role.name = 
               'subject')) )) = 1));
  END_ENTITY; -- applied_approval_assignment

  ENTITY applied_classification_assignment
    SUBTYPE OF (classification_assignment);
      items : SET [1:?] OF classification_item;
  END_ENTITY; -- applied_classification_assignment

  ENTITY applied_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_item;
  END_ENTITY; -- applied_date_and_time_assignment

  ENTITY applied_document_reference
    SUBTYPE OF (document_reference);
      items : SET [1:?] OF document_reference_item;
  END_ENTITY; -- applied_document_reference

  ENTITY applied_external_identification_assignment
    SUBTYPE OF (external_identification_assignment);
      items : SET [1:?] OF external_identification_item;
  END_ENTITY; -- applied_external_identification_assignment

  ENTITY applied_group_assignment
    SUBTYPE OF (group_assignment);
      items : SET [1:?] OF group_item;
  END_ENTITY; -- applied_group_assignment

  ENTITY applied_identification_assignment
    SUBTYPE OF (identification_assignment);
      items : SET [1:?] OF identification_item;
  END_ENTITY; -- applied_identification_assignment

  ENTITY applied_organization_assignment
    SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_item;
  END_ENTITY; -- applied_organization_assignment

  ENTITY applied_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_item;
  END_ENTITY; -- applied_person_and_organization_assignment

  ENTITY applied_person_assignment
    SUBTYPE OF (person_assignment);
      items : SET [1:?] OF person_item;
  END_ENTITY; -- applied_person_assignment

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_role;
      role : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- axis1_placement

  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- axis2_placement_2d

  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: (SELF\placement.location.dim = 3);
      wr2: ((NOT EXISTS(axis)) OR (axis.dim = 3));
      wr3: ((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3));
      wr4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0));
  END_ENTITY; -- axis2_placement_3d

  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (uniform_curve,b_spline_curve_with_knots,
        quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve)
    SUBTYPE OF (bounded_curve);
      degree              : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form          : b_spline_curve_form;
      closed_curve        : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(
                                         control_points_list) - 1;
      control_points                : ARRAY [0:
                                         upper_index_on_control_points] OF
                                          cartesian_point := list_to_array(
                                         control_points_list,0,
                                         upper_index_on_control_points);
    WHERE
      wr1: (('SHIP_STRUCTURES_SCHEMA.UNIFORM_CURVE' IN TYPEOF(SELF)) OR (
               'SHIP_STRUCTURES_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) 
               OR ('SHIP_STRUCTURES_SCHEMA.BEZIER_CURVE' IN TYPEOF(SELF)) 
               OR ('SHIP_STRUCTURES_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN 
               TYPEOF(SELF)));
  END_ENTITY; -- b_spline_curve

  ENTITY b_spline_curve_with_knots
    SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots               : LIST [2:?] OF parameter_value;
      knot_spec           : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      wr1: constraints_param_b_spline(degree,upper_index_on_knots,
               upper_index_on_control_points,knot_multiplicities,knots);
      wr2: (SIZEOF(knot_multiplicities) = upper_index_on_knots);
  END_ENTITY; -- b_spline_curve_with_knots

  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,uniform_surface,
        quasi_uniform_surface,bezier_surface) ANDOR 
        rational_b_spline_surface)
    SUBTYPE OF (bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                           cartesian_point := make_array_of_array(
                          control_points_list,0,u_upper,0,v_upper);
    WHERE
      wr1: (('SHIP_STRUCTURES_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR 
               ('SHIP_STRUCTURES_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(
               SELF)) OR ('SHIP_STRUCTURES_SCHEMA.BEZIER_SURFACE' IN 
               TYPEOF(SELF)) OR (
               'SHIP_STRUCTURES_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN 
               TYPEOF(SELF)));
  END_ENTITY; -- b_spline_surface

  ENTITY b_spline_surface_with_knots
    SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
               v_knots);
      wr3: (SIZEOF(u_multiplicities) = knot_u_upper);
      wr4: (SIZEOF(v_multiplicities) = knot_v_upper);
  END_ENTITY; -- b_spline_surface_with_knots

  ENTITY bezier_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- bezier_curve

  ENTITY bezier_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- bezier_surface

  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (polyline,b_spline_curve,trimmed_curve,
        bounded_pcurve,bounded_surface_curve,composite_curve))
    SUBTYPE OF (curve);
  END_ENTITY; -- bounded_curve

  ENTITY bounded_pcurve
    SUBTYPE OF (pcurve, bounded_curve);
    WHERE
      wr1: ('SHIP_STRUCTURES_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.
               reference_to_curve.items[1]));
  END_ENTITY; -- bounded_pcurve

  ENTITY bounded_surface
    SUPERTYPE OF (b_spline_surface)
    SUBTYPE OF (surface);
  END_ENTITY; -- bounded_surface

  ENTITY bounded_surface_curve
    SUBTYPE OF (surface_curve, bounded_curve);
    WHERE
      wr1: ('SHIP_STRUCTURES_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\
               surface_curve.curve_3d));
  END_ENTITY; -- bounded_surface_curve

  ENTITY brep_with_voids
    SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
  END_ENTITY; -- brep_with_voids

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY cartesian_point
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY; -- cartesian_point

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (cartesian_transformation_operator_3d)
    SUBTYPE OF (geometric_representation_item, 
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: (scl > 0);
  END_ENTITY; -- cartesian_transformation_operator

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- cartesian_transformation_operator_3d

  ENTITY characterized_object;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- characterized_object

  ENTITY circle
    SUBTYPE OF (conic);
      radius : positive_length_measure;
  END_ENTITY; -- circle

  ENTITY class
    SUBTYPE OF (group);
    WHERE
      wr1: (SIZEOF(QUERY ( oa <* USEDIN(SELF,
               'SHIP_STRUCTURES_SCHEMA.GROUP_ASSIGNMENT.ASSIGNED_GROUP') | 
               (NOT ('SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT' IN 
               TYPEOF(oa))) )) = 0);
  END_ENTITY; -- class

  ENTITY classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_class : group;
      role           : classification_role;
  END_ENTITY; -- classification_assignment

  ENTITY classification_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- classification_role

  ENTITY closed_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- closed_shell

  ENTITY composite_curve
    SUBTYPE OF (bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments   : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> 
                        discontinuous;
    WHERE
      wr1: (((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | (
               temp.transition = discontinuous) )) = 1)) OR (closed_curve 
               AND (SIZEOF(QUERY ( temp <* segments | (temp.transition = 
               discontinuous) )) = 0)));
  END_ENTITY; -- composite_curve

  ENTITY composite_curve_on_surface
    SUBTYPE OF (composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (SIZEOF(basis_surface) > 0);
      wr2: constraints_composite_curve_on_surface(SELF);
  END_ENTITY; -- composite_curve_on_surface

  ENTITY composite_curve_segment
    SUBTYPE OF (founded_item);
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      wr1: ('SHIP_STRUCTURES_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve));
  END_ENTITY; -- composite_curve_segment

  ENTITY compound_representation_item
    SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
  END_ENTITY; -- compound_representation_item

  ENTITY conic
    SUPERTYPE OF (ONEOF (circle,ellipse,hyperbola,parabola))
    SUBTYPE OF (curve);
      position : axis2_placement;
  END_ENTITY; -- conic

  ENTITY conical_surface
    SUBTYPE OF (elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: (radius >= 0);
  END_ENTITY; -- conical_surface

  ENTITY connected_edge_set
    SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
  END_ENTITY; -- connected_edge_set

  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (closed_shell,open_shell))
    SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY; -- connected_face_set

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
      name : label;
  END_ENTITY; -- context_dependent_unit

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY; -- conversion_based_unit

  ENTITY coordinated_universal_time_offset;
      hour_offset   : INTEGER;
      minute_offset : OPTIONAL INTEGER;
      sense         : ahead_or_behind;
    DERIVE
      actual_minute_offset : INTEGER := NVL(minute_offset,0);
    WHERE
      wr1: ((0 <= hour_offset) AND (hour_offset < 24));
      wr2: ((0 <= actual_minute_offset) AND (actual_minute_offset <= 59));
      wr3: (NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (
               sense = exact)));
  END_ENTITY; -- coordinated_universal_time_offset

  ENTITY curve
    SUPERTYPE OF (ONEOF (line,conic,pcurve,surface_curve,offset_curve_3d,
        curve_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- curve

  ENTITY curve_replica
    SUBTYPE OF (curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_curve.dim);
      wr2: acyclic_curve_replica(SELF,parent_curve);
  END_ENTITY; -- curve_replica

  ENTITY cylindrical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- cylindrical_surface

  ENTITY date
    SUPERTYPE OF (ONEOF (calendar_date,ordinal_date,
        week_of_year_and_day_date));
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY; -- date_and_time

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role                   : date_time_role;
  END_ENTITY; -- date_and_time_assignment

  ENTITY date_time_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- date_time_role

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: ('SHIP_STRUCTURES_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN 
               TYPEOF(SELF\representation.context_of_items));
  END_ENTITY; -- definitional_representation

  ENTITY degenerate_pcurve
    SUBTYPE OF (point);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('SHIP_STRUCTURES_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\
               representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- degenerate_pcurve

  ENTITY degenerate_toroidal_surface
    SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
    WHERE
      wr1: (major_radius < minor_radius);
  END_ENTITY; -- degenerate_toroidal_surface

  ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: ((SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (
               elements[1].exponent <> 1)));
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- derived_unit

  ENTITY derived_unit_element;
      unit     : named_unit;
      exponent : REAL;
  END_ENTITY; -- derived_unit_element

  ENTITY description_attribute;
      attribute_value : text;
      described_item  : description_attribute_select;
  END_ENTITY; -- description_attribute

  ENTITY descriptive_representation_item
    SUBTYPE OF (representation_item);
      description : text;
  END_ENTITY; -- descriptive_representation_item

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY; -- dimensional_exponents

  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0);
  END_ENTITY; -- direction

  ENTITY document;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      kind        : document_type;
    INVERSE
      representation_types : SET [0:?] OF document_representation_type FOR 
                                represented_document;
  END_ENTITY; -- document

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
      assigned_document : document;
      source            : label;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- document_reference

  ENTITY document_representation_type;
      name                 : label;
      represented_document : document;
  END_ENTITY; -- document_representation_type

  ENTITY document_type;
      product_data_type : label;
  END_ENTITY; -- document_type

  ENTITY document_usage_constraint;
      source                : document;
      subject_element       : label;
      subject_element_value : text;
  END_ENTITY; -- document_usage_constraint

  ENTITY edge
    SUPERTYPE OF (ONEOF (edge_curve,oriented_edge))
    SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY; -- edge

  ENTITY edge_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
  END_ENTITY; -- edge_based_wireframe_model

  ENTITY edge_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'SHIP_STRUCTURES_SCHEMA.EDGE_BASED_WIREFRAME_MODEL',
               'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM',
               'SHIP_STRUCTURES_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
                1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'SHIP_STRUCTURES_SCHEMA.EDGE_BASED_WIREFRAME_MODEL',
               'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               >= 1);
      wr3: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               'SHIP_STRUCTURES_SCHEMA.EDGE_CURVE' IN TYPEOF(edges))) )) = 
               0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( pline_edges <* QUERY ( edges <* eb.ces_edges | (
               'SHIP_STRUCTURES_SCHEMA.POLYLINE' IN TYPEOF(edges\edge_curve
               .edge_geometry)) ) | (NOT (SIZEOF(pline_edges\edge_curve.
               edge_geometry\polyline.points) > 2)) )) = 0)) )) = 0)) )) = 
               0);
      wr5: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT ((
               'SHIP_STRUCTURES_SCHEMA.VERTEX_POINT' IN TYPEOF(edges.
               edge_start)) AND ('SHIP_STRUCTURES_SCHEMA.VERTEX_POINT' IN 
               TYPEOF(edges.edge_end)))) )) = 0)) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT 
               valid_wireframe_edge_curve(edges\edge_curve.edge_geometry)) )) 
               = 0)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               valid_wireframe_vertex_point(edges.edge_start\vertex_point.
               vertex_geometry) AND valid_wireframe_vertex_point(edges.
               edge_end\vertex_point.vertex_geometry))) )) = 0)) )) = 0)) )) 
               = 0);
      wr8: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (('SHIP_STRUCTURES_SCHEMA.' + 
               'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0);
      wr9: (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3);
  END_ENTITY; -- edge_based_wireframe_shape_representation

  ENTITY edge_curve
    SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense    : BOOLEAN;
  END_ENTITY; -- edge_curve

  ENTITY edge_loop
    SUBTYPE OF (loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: (SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].
               edge_end);
  END_ENTITY; -- edge_loop

  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (plane,cylindrical_surface,conical_surface,
        spherical_surface,toroidal_surface))
    SUBTYPE OF (surface);
      position : axis2_placement_3d;
  END_ENTITY; -- elementary_surface

  ENTITY ellipse
    SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY; -- ellipse

  ENTITY evaluated_degenerate_pcurve
    SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
  END_ENTITY; -- evaluated_degenerate_pcurve

  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY; -- executed_action

  ENTITY external_identification_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (identification_assignment);
      source : external_source;
  END_ENTITY; -- external_identification_assignment

  ENTITY external_source;
      source_id : source_item;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- external_source

  ENTITY external_source_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_source : external_source;
      related_source  : external_source;
  END_ENTITY; -- external_source_relationship

  ENTITY externally_defined_class
    SUBTYPE OF (class, externally_defined_item);
  END_ENTITY; -- externally_defined_class

  ENTITY externally_defined_general_property
    SUBTYPE OF (general_property, externally_defined_item);
  END_ENTITY; -- externally_defined_general_property

  ENTITY externally_defined_item;
      item_id : source_item;
      source  : external_source;
  END_ENTITY; -- externally_defined_item

  ENTITY face
    SUPERTYPE OF (ONEOF (face_surface,oriented_face))
    SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      wr1: (NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
      wr2: (SIZEOF(QUERY ( temp <* bounds | (
               'SHIP_STRUCTURES_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp)) )) 
               <= 1);
  END_ENTITY; -- face

  ENTITY face_based_surface_model
    SUBTYPE OF (geometric_representation_item);
      fbsm_faces : SET [1:?] OF connected_face_set;
  END_ENTITY; -- face_based_surface_model

  ENTITY face_bound
    SUBTYPE OF (topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY; -- face_bound

  ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
  END_ENTITY; -- face_outer_bound

  ENTITY face_surface
    SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense    : BOOLEAN;
    WHERE
      wr1: (NOT ('SHIP_STRUCTURES_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(
               face_geometry)));
  END_ENTITY; -- face_surface

  ENTITY faceted_brep
    SUBTYPE OF (manifold_solid_brep);
  END_ENTITY; -- faceted_brep

  ENTITY founded_item;
  END_ENTITY; -- founded_item

  ENTITY functionally_defined_transformation;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- functionally_defined_transformation

  ENTITY general_property;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- general_property

  ENTITY geometric_curve_set
    SUBTYPE OF (geometric_set);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF\geometric_set.elements | (
               'SHIP_STRUCTURES_SCHEMA.SURFACE' IN TYPEOF(temp)) )) = 0);
  END_ENTITY; -- geometric_curve_set

  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY; -- geometric_representation_context

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (point,direction,vector,placement,
        cartesian_transformation_operator,curve,surface,edge_curve,
        face_surface,poly_loop,vertex_point,solid_model,
        face_based_surface_model,edge_based_wireframe_model,geometric_set))
    SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: (SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (
               NOT (
               'SHIP_STRUCTURES_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN
                TYPEOF(using_rep.context_of_items))) )) = 0);
  END_ENTITY; -- geometric_representation_item

  ENTITY geometric_set
    SUPERTYPE OF (geometric_curve_set)
    SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY; -- geometric_set

  ENTITY geometrically_bounded_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(TYPEOF(it) * [
               'SHIP_STRUCTURES_SCHEMA.GEOMETRIC_CURVE_SET',
               'SHIP_STRUCTURES_SCHEMA.AXIS2_PLACEMENT_3D',
               'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM']) = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(TYPEOF(it) * [
               'SHIP_STRUCTURES_SCHEMA.GEOMETRIC_CURVE_SET',
               'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM']) = 1) )) >= 1);
      wr3: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( crv <* QUERY ( elem <* gcs\
               geometric_set.elements | ('SHIP_STRUCTURES_SCHEMA.CURVE' IN 
               TYPEOF(elem)) ) | (NOT valid_geometrically_bounded_wf_curve(
               crv)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( pnts <* QUERY ( elem <* gcs\
               geometric_set.elements | ('SHIP_STRUCTURES_SCHEMA.POINT' IN 
               TYPEOF(elem)) ) | (NOT valid_geometrically_bounded_wf_point(
               pnts)) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( cnc <* QUERY ( elem <* gcs\
               geometric_set.elements | ('SHIP_STRUCTURES_SCHEMA.CONIC' IN 
               TYPEOF(elem)) ) | (NOT (
               'SHIP_STRUCTURES_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(cnc\
               conic.position))) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( pline <* QUERY ( elem <* gcs\
               geometric_set.elements | ('SHIP_STRUCTURES_SCHEMA.POLYLINE' 
               IN TYPEOF(elem)) ) | (NOT (SIZEOF(pline\polyline.points) > 2)) )) 
               = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (('SHIP_STRUCTURES_SCHEMA.' + 
               'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
               = 0);
  END_ENTITY; -- geometrically_bounded_wireframe_shape_representation

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY; -- global_uncertainty_assigned_context

  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY; -- global_unit_assigned_context

  ENTITY group;
      name        : label;
      description : OPTIONAL text;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- group

  ENTITY group_assignment
    ABSTRACT SUPERTYPE;
      assigned_group : group;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- group_assignment

  ENTITY group_relationship;
      name           : label;
      description    : OPTIONAL text;
      relating_group : group;
      related_group  : group;
  END_ENTITY; -- group_relationship

  ENTITY hyperbola
    SUBTYPE OF (conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY; -- hyperbola

  ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
  END_ENTITY; -- id_attribute

  ENTITY identification_assignment
    ABSTRACT SUPERTYPE;
      assigned_id : identifier;
      role        : identification_role;
  END_ENTITY; -- identification_assignment

  ENTITY identification_assignment_relationship;
      name                               : label;
      description                        : OPTIONAL text;
      relating_identification_assignment : identification_assignment;
      related_identification_assignment  : identification_assignment;
  END_ENTITY; -- identification_assignment_relationship

  ENTITY identification_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- identification_role

  ENTITY intersection_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               <> associated_surface(SELF\surface_curve.associated_geometry
               [2]));
  END_ENTITY; -- intersection_curve

  ENTITY item_defined_transformation;
      name             : label;
      description      : OPTIONAL text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
  END_ENTITY; -- item_defined_transformation

  ENTITY known_source
    SUBTYPE OF (pre_defined_item, external_source);
    WHERE
      wr1: (SELF\pre_defined_item.name = 'ISO 13584 library');
      wr2: (SIZEOF(QUERY ( oa <* USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
                | ((NOT ('SHIP_STRUCTURES_SCHEMA.ORGANIZATION_ASSIGNMENT' 
               IN TYPEOF(oa))) AND (oa.role.name = 'library supplier')) )) 
               = 0);
  END_ENTITY; -- known_source

  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- length_unit

  ENTITY library_applied_version_assignment
    SUBTYPE OF (applied_external_identification_assignment);
    WHERE
      wr1: (SELF\identification_assignment.role.name = 'property version');
      wr2: (SIZEOF(SELF\applied_external_identification_assignment.items) 
               = 1);
      wr3: ('SHIP_STRUCTURES_SCHEMA.KNOWN_SOURCE' IN TYPEOF(SELF\
               external_identification_assignment.source));
  END_ENTITY; -- library_applied_version_assignment

  ENTITY library_class_version_assignment
    SUBTYPE OF (applied_external_identification_assignment);
    WHERE
      wr1: (SELF\identification_assignment.role.name = 'class version');
      wr2: (SIZEOF(SELF\applied_external_identification_assignment.items) 
               > 1);
      wr3: ('SHIP_STRUCTURES_SCHEMA.KNOWN_SOURCE' IN TYPEOF(SELF\
               external_identification_assignment.source));
  END_ENTITY; -- library_class_version_assignment

  ENTITY line
    SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      wr1: (dir.dim = pnt.dim);
  END_ENTITY; -- line

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY; -- local_time

  ENTITY loop
    SUPERTYPE OF (ONEOF (vertex_loop,edge_loop,poly_loop))
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- loop

  ENTITY manifold_solid_brep
    SUBTYPE OF (solid_model);
      outer : closed_shell;
  END_ENTITY; -- manifold_solid_brep

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]);
  END_ENTITY; -- mapped_item

  ENTITY measure_with_unit;
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY; -- measure_with_unit

  ENTITY name_attribute;
      attribute_value : label;
      named_item      : name_attribute_select;
  END_ENTITY; -- name_attribute

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (si_unit,conversion_based_unit,
        context_dependent_unit) ANDOR ONEOF (length_unit,time_unit,
        thermodynamic_temperature_unit,plane_angle_unit));
      dimensions : dimensional_exponents;
  END_ENTITY; -- named_unit

  ENTITY non_manifold_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL',
                'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM',
                'SHIP_STRUCTURES_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
                = 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL',
                'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                > 0);
      wr3 : (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (
                NOT ((('SHIP_STRUCTURES_SCHEMA.' + 
                'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION') IN TYPEOF(mi\
                mapped_item.mapping_source.mapped_representation)) AND (
                SIZEOF(QUERY ( mr_it <* mi\mapped_item.mapping_source.
                mapped_representation.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(mr_it)) )) > 0))) )) = 0);
      wr4 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT (SIZEOF([
                'SHIP_STRUCTURES_SCHEMA.FACE_SURFACE',
                'SHIP_STRUCTURES_SCHEMA.ORIENTED_FACE'] * TYPEOF(fa)) = 1)) )) 
                = 0)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (
                'SHIP_STRUCTURES_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) ) | (
                NOT (('SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf)) 
                OR nmsf_surface_check(f_sf\face_surface.face_geometry))) )) 
                = 0)) )) = 0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( o_fa <* QUERY ( fa <* cfs.cfs_faces | (
                'SHIP_STRUCTURES_SCHEMA.ORIENTED_FACE' IN TYPEOF(fa)) ) | (
                NOT (('SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(o_fa
                \oriented_face.face_element)) OR nmsf_surface_check(o_fa\
                oriented_face.face_element\face_surface.face_geometry))) )) 
                = 0)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( bnds <* fa.bounds | (NOT (SIZEOF([
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP',
                'SHIP_STRUCTURES_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnds.bound)) 
                = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT ('SHIP_STRUCTURES_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.
                edge_element))) )) = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe_cv <* QUERY ( oe <* elp_fbnds\
                path.edge_list | ('SHIP_STRUCTURES_SCHEMA.EDGE_CURVE' IN 
                TYPEOF(oe.edge_element)) ) | (NOT (SIZEOF([
                'SHIP_STRUCTURES_SCHEMA.B_SPLINE_CURVE',
                'SHIP_STRUCTURES_SCHEMA.CONIC',
                'SHIP_STRUCTURES_SCHEMA.CURVE_REPLICA',
                'SHIP_STRUCTURES_SCHEMA.LINE',
                'SHIP_STRUCTURES_SCHEMA.OFFSET_CURVE_3D',
                'SHIP_STRUCTURES_SCHEMA.PCURVE',
                'SHIP_STRUCTURES_SCHEMA.POLYLINE',
                'SHIP_STRUCTURES_SCHEMA.SURFACE_CURVE'] * TYPEOF(oe_cv.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0))) )) = 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT nmsf_curve_check(oe.edge_element\edge_curve.
                edge_geometry)) )) = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr11: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT (('SHIP_STRUCTURES_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_start)) AND (
                'SHIP_STRUCTURES_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_end)))) )) = 0)) )) = 0))) )) = 0)) )) = 
                0)) )) = 0);
      wr12: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_STRUCTURES_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT ((SIZEOF(['SHIP_STRUCTURES_SCHEMA.CARTESIAN_POINT',
                'SHIP_STRUCTURES_SCHEMA.DEGENERATE_PCURVE',
                'SHIP_STRUCTURES_SCHEMA.POINT_ON_CURVE',
                'SHIP_STRUCTURES_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_start\vertex_point.vertex_geometry)) = 1) 
                AND (SIZEOF(['SHIP_STRUCTURES_SCHEMA.CARTESIAN_POINT',
                'SHIP_STRUCTURES_SCHEMA.DEGENERATE_PCURVE',
                'SHIP_STRUCTURES_SCHEMA.POINT_ON_CURVE',
                'SHIP_STRUCTURES_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_end\vertex_point.vertex_geometry)) = 1))) )) 
                = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr13: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_STRUCTURES_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT ('SHIP_STRUCTURES_SCHEMA.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\vertex_loop.loop_vertex))) )) = 0))) )) = 0)) )) 
                = 0)) )) = 0);
      wr14: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_STRUCTURES_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_STRUCTURES_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_STRUCTURES_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(['SHIP_STRUCTURES_SCHEMA.CARTESIAN_POINT',
                'SHIP_STRUCTURES_SCHEMA.DEGENERATE_PCURVE',
                'SHIP_STRUCTURES_SCHEMA.POINT_ON_CURVE',
                'SHIP_STRUCTURES_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(
                vlp_fbnds\vertex_loop.loop_vertex\vertex_point.
                vertex_geometry)) = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
  END_ENTITY; -- non_manifold_surface_shape_representation

  ENTITY object_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- object_role

  ENTITY offset_curve_3d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
      ref_direction  : direction;
    WHERE
      wr1: ((basis_curve.dim = 3) AND (ref_direction.dim = 3));
  END_ENTITY; -- offset_curve_3d

  ENTITY offset_surface
    SUBTYPE OF (surface);
      basis_surface  : surface;
      distance       : length_measure;
      self_intersect : LOGICAL;
  END_ENTITY; -- offset_surface

  ENTITY open_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- open_shell

  ENTITY ordinal_date
    SUBTYPE OF (date);
      day_component : day_in_year_number;
    WHERE
      wr1: (((NOT leap_year(SELF.year_component)) AND (1 <= day_component) 
               AND (day_component <= 365)) OR (leap_year(SELF.
               year_component) AND (1 <= day_component) AND (day_component 
               <= 366)));
  END_ENTITY; -- ordinal_date

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- organization

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role                  : organization_role;
  END_ENTITY; -- organization_assignment

  ENTITY organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- organization_role

  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : OPTIONAL text;
  END_ENTITY; -- organizational_address

  ENTITY organizational_project;
      name                      : label;
      description               : OPTIONAL text;
      responsible_organizations : SET [1:?] OF organization;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- organizational_project

  ENTITY oriented_closed_shell
    SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation          : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             closed_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('SHIP_STRUCTURES_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(
               SELF.closed_shell_element)));
  END_ENTITY; -- oriented_closed_shell

  ENTITY oriented_edge
    SUBTYPE OF (edge);
      edge_element : edge;
      orientation  : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_start,SELF.
                                edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_end,SELF.
                                edge_element.edge_start);
    WHERE
      wr1: (NOT ('SHIP_STRUCTURES_SCHEMA.ORIENTED_EDGE' IN TYPEOF(SELF.
               edge_element)));
  END_ENTITY; -- oriented_edge

  ENTITY oriented_face
    SUBTYPE OF (face);
      face_element : face;
      orientation  : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(
                            SELF.orientation,SELF.face_element.bounds);
    WHERE
      wr1: (NOT ('SHIP_STRUCTURES_SCHEMA.ORIENTED_FACE' IN TYPEOF(SELF.
               face_element)));
  END_ENTITY; -- oriented_face

  ENTITY oriented_open_shell
    SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation        : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             open_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('SHIP_STRUCTURES_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(
               SELF.open_shell_element)));
  END_ENTITY; -- oriented_open_shell

  ENTITY oriented_path
    SUBTYPE OF (path);
      path_element : path;
      orientation  : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := 
                               conditional_reverse(SELF.orientation,SELF.
                               path_element.edge_list);
    WHERE
      wr1: (NOT ('SHIP_STRUCTURES_SCHEMA.ORIENTED_PATH' IN TYPEOF(SELF.
               path_element)));
  END_ENTITY; -- oriented_path

  ENTITY oriented_surface
    SUBTYPE OF (surface);
      orientation : BOOLEAN;
  END_ENTITY; -- oriented_surface

  ENTITY parabola
    SUBTYPE OF (conic);
      focal_dist : length_measure;
    WHERE
      wr1: (focal_dist <> 0);
  END_ENTITY; -- parabola

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY; -- parametric_representation_context

  ENTITY path
    SUPERTYPE OF (ONEOF (edge_loop,oriented_path))
    SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
    WHERE
      wr1: path_head_to_tail(SELF);
  END_ENTITY; -- path

  ENTITY pcurve
    SUBTYPE OF (curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('SHIP_STRUCTURES_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\
               representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- pcurve

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    WHERE
      wr1: (EXISTS(last_name) OR EXISTS(first_name));
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_and_organization_role

  ENTITY person_assignment
    ABSTRACT SUPERTYPE;
      assigned_person : person;
      role            : person_role;
  END_ENTITY; -- person_assignment

  ENTITY person_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_role

  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : OPTIONAL text;
  END_ENTITY; -- personal_address

  ENTITY placement
    SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d,
        axis2_placement_3d))
    SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY; -- placement

  ENTITY plane
    SUBTYPE OF (elementary_surface);
  END_ENTITY; -- plane

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- plane_angle_unit

  ENTITY point
    SUPERTYPE OF (ONEOF (cartesian_point,point_on_curve,point_on_surface,
        point_replica,degenerate_pcurve))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- point

  ENTITY point_on_curve
    SUBTYPE OF (point);
      basis_curve     : curve;
      point_parameter : parameter_value;
  END_ENTITY; -- point_on_curve

  ENTITY point_on_surface
    SUBTYPE OF (point);
      basis_surface     : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
  END_ENTITY; -- point_on_surface

  ENTITY point_replica
    SUBTYPE OF (point);
      parent_pt      : point;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_pt.dim);
      wr2: acyclic_point_replica(SELF,parent_pt);
  END_ENTITY; -- point_replica

  ENTITY poly_loop
    SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY; -- poly_loop

  ENTITY polyline
    SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY; -- polyline

  ENTITY pre_defined_item;
      name : label;
  END_ENTITY; -- pre_defined_item

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY; -- product

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- product_category

  ENTITY product_category_relationship;
      name         : label;
      description  : OPTIONAL text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY; -- product_category_relationship

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition;
      id                 : identifier;
      description        : OPTIONAL text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- product_definition

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY; -- product_definition_context

  ENTITY product_definition_formation;
      id          : identifier;
      description : OPTIONAL text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_relationship;
      id                          : identifier;
      name                        : label;
      description                 : OPTIONAL text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY; -- product_definition_relationship

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : definition;
    WHERE
      wr1: (SIZEOF([
               'SHIP_STRUCTURES_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION',
               'SHIP_STRUCTURES_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF(SELF
               \property_definition.definition)) > 0);
  END_ENTITY; -- product_definition_shape

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
  END_ENTITY; -- product_definition_with_associated_documents

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY; -- product_related_product_category

  ENTITY property_definition;
      name        : label;
      description : OPTIONAL text;
      definition  : characterized_definition;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- property_definition

  ENTITY property_definition_relationship;
      name                         : label;
      description                  : text;
      relating_property_definition : property_definition;
      related_property_definition  : property_definition;
  END_ENTITY; -- property_definition_relationship

  ENTITY property_definition_representation;
      definition          : represented_definition;
      used_representation : representation;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- property_definition_representation

  ENTITY quasi_uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- quasi_uniform_curve

  ENTITY quasi_uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- quasi_uniform_surface

  ENTITY rational_b_spline_curve
    SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := 
                   list_to_array(weights_data,0,
                   upper_index_on_control_points);
    WHERE
      wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
               control_points_list));
      wr2: curve_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_curve

  ENTITY rational_b_spline_surface
    SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := 
                   make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      wr1: ((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_surface.control_points_list[1])));
      wr2: surface_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_surface

  ENTITY reparametrised_composite_curve_segment
    SUBTYPE OF (composite_curve_segment);
      param_length : parameter_value;
    WHERE
      wr1: (param_length > 0);
  END_ENTITY; -- reparametrised_composite_curve_segment

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id          : identifier := get_id_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- representation

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR 
                                      context_of_items;
  END_ENTITY; -- representation_context

  ENTITY representation_item;
      name : label;
    WHERE
      wr1: (SIZEOF(using_representations(SELF)) > 0);
  END_ENTITY; -- representation_item

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY; -- representation_map

  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY; -- representation_relationship

  ENTITY role_association;
      role           : object_role;
      item_with_role : role_select;
  END_ENTITY; -- role_association

  ENTITY seam_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               = associated_surface(SELF\surface_curve.associated_geometry[
               2]));
      wr3: ('SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.
               associated_geometry[1]));
      wr4: ('SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.
               associated_geometry[2]));
  END_ENTITY; -- seam_curve

  ENTITY shape_aspect;
      name                 : label;
      description          : OPTIONAL text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- shape_aspect

  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : OPTIONAL text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_STRUCTURES_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- shape_aspect_relationship

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: (('SHIP_STRUCTURES_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               SELF.definition)) OR (
               'SHIP_STRUCTURES_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(SELF.
               definition.definition)));
      wr2: ('SHIP_STRUCTURES_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF.
               used_representation));
  END_ENTITY; -- shape_definition_representation

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- shape_representation

  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := 
                                      dimensions_for_si_unit(name);
  END_ENTITY; -- si_unit

  ENTITY solid_model
    SUPERTYPE OF (manifold_solid_brep)
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- solid_model

  ENTITY spherical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- spherical_surface

  ENTITY surface
    SUPERTYPE OF (ONEOF (elementary_surface,swept_surface,bounded_surface,
        offset_surface,surface_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- surface

  ENTITY surface_curve
    SUPERTYPE OF (ONEOF (intersection_curve,seam_curve) ANDOR 
        bounded_surface_curve)
    SUBTYPE OF (curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (curve_3d.dim = 3);
      wr2: (('SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(associated_geometry
               [1])) OR (master_representation <> pcurve_s1));
      wr3: (('SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(associated_geometry
               [2])) OR (master_representation <> pcurve_s2));
      wr4: (NOT ('SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(curve_3d)));
  END_ENTITY; -- surface_curve

  ENTITY surface_of_linear_extrusion
    SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
  END_ENTITY; -- surface_of_linear_extrusion

  ENTITY surface_of_revolution
    SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
    DERIVE
      axis_line : line := representation_item('') || 
                     geometric_representation_item() || curve() || line(
                     axis_position.location,representation_item('') || 
                     geometric_representation_item() || vector(
                     axis_position.z,1));
  END_ENTITY; -- surface_of_revolution

  ENTITY surface_replica
    SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_surface_replica(SELF,parent_surface);
  END_ENTITY; -- surface_replica

  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,surface_of_revolution))
    SUBTYPE OF (surface);
      swept_curve : curve;
  END_ENTITY; -- swept_surface

  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 1) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- thermodynamic_temperature_unit

  ENTITY time_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 1) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- time_unit

  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (vertex,edge,face_bound,face,connected_edge_set,
        connected_face_set,loop ANDOR path))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- topological_representation_item

  ENTITY toroidal_surface
    SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY; -- toroidal_surface

  ENTITY trimmed_curve
    SUBTYPE OF (bounded_curve);
      basis_curve           : curve;
      trim_1                : SET [1:2] OF trimming_select;
      trim_2                : SET [1:2] OF trimming_select;
      sense_agreement       : BOOLEAN;
      master_representation : trimming_preference;
    WHERE
      wr1: ((HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2])));
      wr2: ((HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2])));
  END_ENTITY; -- trimmed_curve

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      wr1: valid_measure_value(SELF\measure_with_unit.value_component);
  END_ENTITY; -- uncertainty_measure_with_unit

  ENTITY uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- uniform_curve

  ENTITY uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- uniform_surface

  ENTITY value_representation_item
    SUBTYPE OF (representation_item);
      value_component : measure_value;
    WHERE
      wr1: (SIZEOF(QUERY ( rep <* using_representations(SELF) | (NOT (
               'SHIP_STRUCTURES_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN 
               TYPEOF(rep.context_of_items))) )) = 0);
  END_ENTITY; -- value_representation_item

  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: (magnitude >= 0);
  END_ENTITY; -- vector

  ENTITY versioned_action_request;
      id          : identifier;
      version     : label;
      purpose     : text;
      description : OPTIONAL text;
  END_ENTITY; -- versioned_action_request

  ENTITY vertex
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- vertex

  ENTITY vertex_loop
    SUBTYPE OF (loop);
      loop_vertex : vertex;
  END_ENTITY; -- vertex_loop

  ENTITY vertex_point
    SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
  END_ENTITY; -- vertex_point

  ENTITY week_of_year_and_day_date
    SUBTYPE OF (date);
      week_component : week_in_year_number;
      day_component  : OPTIONAL day_in_week_number;
  END_ENTITY; -- week_of_year_and_day_date

  RULE action_request_solution_connected_to_action FOR (
                          action_request_solution, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action_request_solution := [];
      set_3   : SET OF action_method := [];
      t2_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action_request_solution | VALUE_IN(which_class(
        a),'change plan') );
    t2_set := QUERY ( b <* action | VALUE_IN(which_class(b),'change') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      set_3 := [];
      REPEAT j := 1 TO HIINDEX(t2_set) BY 1;
        set_3 := set_3 + [t2_set[j].chosen_method];
      END_REPEAT;
      violate := VALUE_IN(set_3,t1_set[i].method);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- action_request_solution_connected_to_action

  RULE action_request_solution_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF action_request_solution := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['definable object'];
      t2_set    : SET OF action_request_solution := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- action_request_solution_with_identification_assignment

  RULE action_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF action := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['definable object'];
      t2_set    : SET OF action := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- action_with_identification_assignment

  RULE alternative_version_relationship_has_mandatory_description FOR (
             identification_assignment_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF identification_assignment_relationship := [];
    END_LOCAL;
    t1_set := QUERY ( i <* identification_assignment_relationship | 
        VALUE_IN(which_class(i),'alternative version relationship') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- alternative_version_relationship_has_mandatory_description

  RULE alternative_version_relationship_has_unique_versions FOR (
             identification_assignment_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF identification_assignment_relationship := [];
    END_LOCAL;
    t1_set := QUERY ( a <* identification_assignment_relationship | 
        VALUE_IN(which_class(a),'alternative version relationship') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      violate := t1_set[i].relating_identification_assignment.assigned_id 
          = t1_set[i].related_identification_assignment.assigned_id;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- alternative_version_relationship_has_unique_versions

  RULE alternative_version_relationship_versionable_object FOR (
             applied_identification_assignment);

    LOCAL
      violate  : LOGICAL := FALSE;
      violate1 : LOGICAL := FALSE;
      violate2 : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1
         WHILE NOT violate;
      violate1 := (SIZEOF(USEDIN(applied_identification_assignment[i],
          'SHIP_STRUCTURES_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' 
          + 'RELATING_IDENTIFICATION_ASSIGNMENT')) > 0) AND (NOT VALUE_IN(
          which_class(applied_identification_assignment[i]),
          'versionable object'));
      violate2 := (SIZEOF(USEDIN(applied_identification_assignment[i],
          'SHIP_STRUCTURES_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' 
          + 'RELATED_IDENTIFICATION_ASSIGNMENT')) > 0) AND (NOT VALUE_IN(
          which_class(applied_identification_assignment[i]),
          'versionable object'));
      violate := violate1 OR violate2;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- alternative_version_relationship_versionable_object

  RULE applied_approval_assignment_has_exactly_one_elements FOR (
             object_role, applied_approval_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( ass_inst <* applied_approval_assignment | (NOT ((
             ass_inst.role.name = 'subject') AND (SIZEOF(ass_inst.items) = 
             1))) )) = 0);

  END_RULE; -- applied_approval_assignment_has_exactly_one_elements

  RULE applied_group_assignment_has_at_least_one_elements FOR (object_role, 
             applied_group_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( ass_inst <* applied_group_assignment | (NOT ((
             ass_inst.role.name = 'approvals') AND (SIZEOF(ass_inst.items) 
             >= 1) AND (SIZEOF(QUERY ( item <* ass_inst.items | (NOT (
             'SHIP_STRUCTURES_SCHEMA.APPROVAL' IN TYPEOF(item))) )) = 0))) )) 
             = 0);

  END_RULE; -- applied_group_assignment_has_at_least_one_elements

  RULE approval_event_with_approval_date_time FOR (approval, 
             approval_date_time);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF approval := [];
      t2_set  : SET OF approval_date_time := [];
    END_LOCAL;
    t1_set := QUERY ( i <* approval | VALUE_IN(which_class(i),
        'approval event') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPROVAL_DATE_TIME.' + 'DATED_APPROVAL'));
      violate := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- approval_event_with_approval_date_time

  RULE approval_event_with_approval_person_organization FOR (approval, 
             approval_person_organization);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF approval := [];
      t2_set  : SET OF approval_person_organization := [];
    END_LOCAL;
    t1_set := QUERY ( i <* approval | VALUE_IN(which_class(i),
        'approval event') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPROVAL_PERSON_ORGANIZATION.' + 
          'AUTHORIZED_APPROVAL'));
      violate := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- approval_event_with_approval_person_organization

  RULE approval_history_approves_same_definition FOR (
             applied_group_assignment, applied_approval_assignment);

    LOCAL
      violate : LOGICAL := FALSE;
      t3_set  : SET OF approval := [];
      t4_set  : SET OF group_item := [];
      t5_set  : SET OF applied_approval_assignment := [];
      t2_set  : SET OF applied_group_assignment := [];
    END_LOCAL;
    t2_set := QUERY ( a <* applied_group_assignment | VALUE_IN(
        which_class(a.assigned_group),'approval history') );
    t3_set := QUERY ( b <* t2_set[1].items | (
        'SHIP_STRUCTURES_SCHEMA.APPROVAL' IN TYPEOF(b)) );
    t4_set := QUERY ( b <* t2_set[1].items | VALUE_IN(which_class(b),
        'DEFINITION') );
    violate := NOT (SIZEOF(t4_set) = 1);
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1 WHILE NOT violate;
      t5_set := QUERY ( a <* applied_approval_assignment | ((a.
          assigned_approval = t3_set[i]) AND (NOT VALUE_IN(a.items,t4_set[1]))) );
      violate := SIZEOF(t5_set) > 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);
    wr2: (SIZEOF(t4_set) = 1);

  END_RULE; -- approval_history_approves_same_definition

  RULE approval_history_contains_approval_elements FOR (object_role, 
             applied_group_assignment);

    LOCAL
      t3_set          : SET OF approval := [];
      gr_ass_set      : SET OF applied_group_assignment := [];
      violation       : LOGICAL := FALSE;
      valid_items_set : SET OF approval_item := [];
      t1_set          : SET OF applied_approval_assignment := [];
      first_runs      : LOGICAL := TRUE;
    END_LOCAL;
    gr_ass_set := QUERY ( aga <* applied_group_assignment | ((aga.role.
        name = 'approvals') AND ('approval history' IN which_class(aga.
        assigned_group))) );
    REPEAT i := 1 TO HIINDEX(gr_ass_set) BY 1 WHILE NOT violation;
      t3_set := QUERY ( aga_item <* gr_ass_set[i].items | (
          'SHIP_STRUCTURES_SCHEMA.APPROVAL' IN TYPEOF(aga_item)) );
      REPEAT j := 1 TO HIINDEX(t3_set) BY 1;
        t1_set := QUERY ( aga <* bag_to_set(USEDIN(t3_set[j],
            'SHIP_STRUCTURES_SCHEMA.' + 
            'APPROVAL_ASSIGNMENT.ASSIGNED_APPROVAL')) | (aga.role.name = 
            'subject') );
        REPEAT k := 1 TO HIINDEX(t1_set) BY 1;
          IF first_runs AND (SIZEOF(t1_set[k].items) > 0) THEN
            valid_items_set := t1_set[k].items;
            first_runs := FALSE;
          ELSE
            REPEAT l := 1 TO HIINDEX(t1_set[k].items) BY 1;
              violation := t1_set[k].items[l] :<>: valid_items_set[l];
            END_REPEAT;
          END_IF;
        END_REPEAT;
      END_REPEAT;
      first_runs := TRUE;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- approval_history_contains_approval_elements

  RULE approval_history_has_at_least_one_member FOR (group, 
             applied_group_assignment);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      t2_set  : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( i <* group | VALUE_IN(which_class(i),
        'approval history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := QUERY ( a <* applied_group_assignment | (a.assigned_group 
          = t1_set[i]) );
      violate := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- approval_history_has_at_least_one_member

  RULE approvals_references_approval_history FOR (object_role, 
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'approval history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | (NOT ((b.
          assigned_group = t1_set[i]) AND (b.role.name = 'approvals'))) );
      violate := SIZEOF(a_set) > 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- approvals_references_approval_history

  RULE assembly_relationship_has_product_definition FOR (group, 
             applied_classification_assignment);

    LOCAL
      cl_ass      : SET OF applied_classification_assignment := [];
      clfied_inst : SET OF product_definition_relationship := [];
    END_LOCAL;
    cl_ass := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'assembly relationship') );
    REPEAT i := 1 TO HIINDEX(cl_ass) BY 1;
      clfied_inst := clfied_inst + cl_ass[i].items;
    END_REPEAT;

  WHERE
    wr1: ((SIZEOF(QUERY ( pdr <* clfied_inst | (NOT (SIZEOF(which_class(
             pdr.relating_product_definition)) > 0)) )) - SIZEOF(
             QUERY ( pdr <* clfied_inst | (NOT (SIZEOF(which_class(pdr.
             related_product_definition)) > 0)) ))) = 0);

  END_RULE; -- assembly_relationship_has_product_definition

  RULE author_for_change_plan FOR (
             applied_person_and_organization_assignment, 
             person_and_organization_role, action_request_solution);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action_request_solution := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action_request_solution | VALUE_IN(which_class(
        a),'change plan') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'author')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- author_for_change_plan

  RULE author_for_change_realisation FOR (
             applied_person_and_organization_assignment, 
             person_and_organization_role, executed_action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF executed_action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* executed_action | VALUE_IN(which_class(a),
        'change realisation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'author')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- author_for_change_realisation

  RULE author_for_change_request FOR (
             applied_person_and_organization_assignment, 
             person_and_organization_role, versioned_action_request);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF versioned_action_request := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* versioned_action_request | VALUE_IN(
        which_class(a),'change request') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'author')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- author_for_change_request

  RULE caused_by_for_check FOR (applied_person_and_organization_assignment, 
             person_and_organization_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),'check') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_check

  RULE caused_by_for_envisaged_version_creation FOR (
             applied_person_and_organization_assignment, 
             person_and_organization_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'envisaged version creation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_envisaged_version_creation

  RULE caused_by_for_version_creation FOR (
             applied_person_and_organization_assignment, 
             person_and_organization_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version creation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_version_creation

  RULE caused_by_for_version_deletion FOR (
             applied_person_and_organization_assignment, 
             person_and_organization_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version deletion') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_version_deletion

  RULE caused_by_for_version_modification FOR (
             applied_person_and_organization_assignment, 
             person_and_organization_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version modification') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_version_modification

  RULE caused_when_for_check FOR (applied_date_and_time_assignment, 
             date_time_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),'check') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_check

  RULE caused_when_for_envisaged_version_creation FOR (
             applied_date_and_time_assignment, date_time_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'envisaged version creation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_envisaged_version_creation

  RULE caused_when_for_version_creation FOR (
             applied_date_and_time_assignment, date_time_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version creation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_version_creation

  RULE caused_when_for_version_deletion FOR (
             applied_date_and_time_assignment, date_time_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version deletion') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_version_deletion

  RULE caused_when_for_version_modification FOR (
             applied_date_and_time_assignment, date_time_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version modification') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_version_modification

  RULE centre_location_compound_representation_has_specified_name FOR (
             compound_representation_item, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['longitudinal location',
                   'transversal location','vertical location'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'centre location') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- centre_location_compound_representation_has_specified_name

  RULE change_impact_with_versionable_object_change_event FOR (
             applied_action_request_assignment, object_role, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF applied_action_request_assignment := [];
      a_set   : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( b <* applied_action_request_assignment | (b.role.
        name = 'change impact') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* t1_set[i].items | ((
          'SHIP_STRUCTURES_SCHEMA.ACTION' IN TYPEOF(b)) AND VALUE_IN(
          which_class(b),'versionable object change event')) );
      violate := SIZEOF(a_set) = 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- change_impact_with_versionable_object_change_event

  RULE change_plan_has_mandatory_attribute_description FOR (
             action_request_solution);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action_request_solution := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action_request_solution | VALUE_IN(which_class(
        i),'change plan') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- change_plan_has_mandatory_attribute_description

  RULE class_and_statutory_designation_has_properties FOR (
             product_definition, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : SET OF product_definition := [];
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class and statutory designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'class and statutory designation') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- class_and_statutory_designation_has_properties

  RULE class_notation_with_named_representation_items FOR (representation, 
             representation_item, property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['class notations hull',
                   'class notations machinery'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class notation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) < 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- class_notation_with_named_representation_items

  RULE class_parameters_has_properties FOR (product_definition, 
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : SET OF product_definition := [];
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class parameters') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'class parameters') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- class_parameters_has_properties

  RULE compatible_dimension FOR (cartesian_point, direction, 
             representation_context, geometric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 
             0) )) = 0);
    wr2: (SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) 
             > 0) )) = 0);

  END_RULE; -- compatible_dimension

  RULE corrugated_structure_design_definition_has_at_least_one_class FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corrugated structure design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | ('border' IN 
          which_class(t2_inst)) )) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- corrugated_structure_design_definition_has_at_least_one_class

  RULE corrugated_structure_design_definition_has_at_most_one_class FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corrugated structure design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | ('moulded surface' 
          IN which_class(t2_inst)) )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- corrugated_structure_design_definition_has_at_most_one_class

  RULE date_time_for_change_realisation FOR (
             applied_date_and_time_assignment, date_time_role, 
             executed_action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF executed_action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* executed_action | VALUE_IN(which_class(a),
        'change realisation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'date time')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- date_time_for_change_realisation

  RULE date_time_for_change_request FOR (applied_date_and_time_assignment, 
             date_time_role, versioned_action_request);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF versioned_action_request := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* versioned_action_request | VALUE_IN(
        which_class(a),'change request') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'date time')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- date_time_for_change_request

  RULE define_maximum_permissible_still_water_bending_moment_values FOR (
             product_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'maximum permissible still water bending moment') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'maximum permissible still water bending  moment values') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- define_maximum_permissible_still_water_bending_moment_values

  RULE define_maximum_permissible_still_water_shear_force_values FOR (
             product_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'maximum permissible still water shear force') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'maximum permissible still water shear force values') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- define_maximum_permissible_still_water_shear_force_values

  RULE definition_for_design_still_water_bending_moment_parameters FOR (
             product_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'design still water bending moment') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'design still water bending moment parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- definition_for_design_still_water_bending_moment_parameters

  RULE definition_for_design_vertical_wave_bending_moment_parameters FOR (
             product_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'design vertical wave bending moment') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'design vertical wave bending moment parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- definition_for_design_vertical_wave_bending_moment_parameters

  RULE definition_for_design_vertical_wave_shear_force_parameters FOR (
             product_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'design vertical wave shear force') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'design vertical wave shear force parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- definition_for_design_vertical_wave_shear_force_parameters

  RULE document_has_at_least_one_references FOR (document, 
             document_representation_type);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF document := [];
      t2_set  : SET OF document_representation_type := [];
    END_LOCAL;
    t1_set := QUERY ( i <* document | VALUE_IN(which_class(i),'document') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.DOCUMENT_REPRESENTATION_TYPE.' + 
          'REPRESENTED_DOCUMENT'));
      violate := SIZEOF(t2_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- document_has_at_least_one_references

  RULE document_has_exactly_one_author FOR (document);

    LOCAL
      violate : LOGICAL := FALSE;
      bag_3   : BAG OF applied_organization_assignment := [];
      bag_2   : BAG OF applied_person_and_organization_assignment := [];
      bag_1   : BAG OF applied_person_assignment := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(document) BY 1 WHILE NOT violate;
      bag_1 := USEDIN(document[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'APPLIED_PERSON_ASSIGNMENT.ITEMS');
      bag_2 := USEDIN(document[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS');
      bag_3 := USEDIN(document[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS');
      violate := NOT ((SIZEOF(bag_1) + SIZEOF(bag_2) + SIZEOF(bag_3)) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- document_has_exactly_one_author

  RULE document_reference_has_at_least_one_references FOR (document, 
             document_usage_constraint);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF document := [];
      t2_set  : SET OF document_usage_constraint := [];
    END_LOCAL;
    t1_set := QUERY ( i <* document | VALUE_IN(which_class(i),
        'document reference') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.DOCUMENT_USAGE_CONSTRAINT.SOURCE'));
      violate := SIZEOF(t2_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- document_reference_has_at_least_one_references

  RULE document_reference_reference_with_address_with_references FOR (
             document, document_usage_constraint);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF document := [];
      t2_set  : SET OF document_usage_constraint := [];
    END_LOCAL;
    t1_set := QUERY ( i <* document | VALUE_IN(which_class(i),
        'document reference reference with address') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.DOCUMENT_USAGE_CONSTRAINT.SOURCE'));
      violate := SIZEOF(t2_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- document_reference_reference_with_address_with_references

  RULE document_reference_with_address_has_at_least_one_references FOR (
             document, applied_external_identification_assignment);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF document := [];
      t2_set  : SET OF applied_external_identification_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( i <* document | VALUE_IN(which_class(i),
        'document reference with address') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violate := SIZEOF(t2_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- document_reference_with_address_has_at_least_one_references

  RULE envisaged_version_creation_has_mandatory_attribute_description FOR (
             action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action | VALUE_IN(which_class(i),
        'envisaged version creation') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- envisaged_version_creation_has_mandatory_attribute_description

  RULE executed_action_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF executed_action := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['definable object'];
      t2_set    : SET OF executed_action := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- executed_action_with_identification_assignment

  RULE externally_defined_class_with_known_source_requirement FOR (
             externally_defined_class);

  WHERE
    wr1: (SIZEOF(QUERY ( edc <* externally_defined_class | ((
             'SHIP_STRUCTURES_SCHEMA.KNOWN_SOURCE' IN TYPEOF(edc.source)) 
             AND (SIZEOF(QUERY ( aoa <* USEDIN(edc,'SHIP_STRUCTURES_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
              | (aoa.role.name = 'library supplier') )) = 0)) )) = 0);

  END_RULE; -- externally_defined_class_with_known_source_requirement

  RULE flare_area_parameters_has_exactly_two_representation_items FOR (
             representation, property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'flare area parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      violation := SIZEOF(reps[i].items) > 2;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- flare_area_parameters_has_exactly_two_representation_items

  RULE freeboard_characteristics_has_properties FOR (product_definition, 
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : SET OF product_definition := [];
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'freeboard characteristics') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'freeboard characteristics') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- freeboard_characteristics_has_properties

  RULE global_axis_placement_has_properties FOR (
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : SET OF product_definition := [];
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'global axis placement') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'global axis placement') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- global_axis_placement_has_properties

  RULE global_id_is_unique FOR (applied_identification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      set_1     : SET OF applied_identification_assignment := [];
      bag_2     : BAG OF STRING := [];
    END_LOCAL;
    set_1 := QUERY ( i <* applied_identification_assignment | (i.role.name 
        = 'globally unambiguous identifier') );
    REPEAT i := 1 TO HIINDEX(set_1) BY 1;
      bag_2 := bag_2 + [set_1[i].assigned_id];
    END_REPEAT;
    violation := SIZEOF(QUERY ( i <* set_1 | (NOT (i.assigned_id LIKE 
        '*:*')) )) = 0;

  WHERE
    wr1: VALUE_UNIQUE(bag_2);
    wr2: (NOT violation);

  END_RULE; -- global_id_is_unique

  RULE group_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF group := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := [
                   'structural cutout boundary relationship'];
      t2_set    : SET OF group := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- group_with_identification_assignment

  RULE homogeneous_ship_material_property_has_named_references FOR (
             object_role, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_document_reference := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'homogeneous_ship material property') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_DOCUMENT_REFERENCE.ITEMS'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.name =
           'material reference') )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- homogeneous_ship_material_property_has_named_references

  RULE hull_cross_section_contains_specified_classes FOR (
             applied_group_assignment, group, 
             applied_classification_assignment);
    LOCAL
      violation : LOGICAL := FALSE;
      cl_ass    : SET OF applied_classification_assignment := [];
      gr_ass    : SET OF applied_group_assignment := [];
      pd        : SET OF product_definition := [];
      groups    : SET OF group := [];
    END_LOCAL;
    cl_ass := QUERY ( i <* applied_classification_assignment | ((i.role.
        name = 'class membership') AND (i.assigned_class.name = 
        'hull cross section')) );
    REPEAT i := 1 TO HIINDEX(cl_ass) BY 1;
      REPEAT j := 1 TO HIINDEX(cl_ass[i].items) BY 1;
        pd := pd + cl_ass[i].items[j];
      END_REPEAT;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | (i.role.name = 
        'equivalence') );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1;
      REPEAT j := 1 TO HIINDEX(gr_ass[i].items) BY 1;
        IF gr_ass[i].items[j] IN pd THEN
          groups := groups + gr_ass[i].assigned_group;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | (((SIZEOF(i.items) 
        <> 0) AND (i.role.name = 'item structure')) AND (i.assigned_group 
        IN groups)) );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1 WHILE NOT violation;
      violation := SIZEOF(QUERY ( inst <* gr_ass[i].items | ((
          'compartment' IN which_class(inst)) AND ('structural system' IN 
          which_class(inst))) )) > 0;
    END_REPEAT;
  WHERE
    wr1: NOT violation;
  END_RULE; -- hull_cross_section_contains_specified_classes

  RULE hull_cross_section_design_definition_for_representation_items FOR (
             property_definition_representation, representation);

    LOCAL
      violation : LOGICAL := FALSE;
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'hull cross section design definition parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      violation := SIZEOF(reps[i].items) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- hull_cross_section_design_definition_for_representation_items

  RULE hull_cross_section_design_has_at_least_one_revision_with_context FOR (
             group, applied_classification_assignment);

    LOCAL
      gr_ass_set : SET OF applied_group_assignment := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF product_definition_shape := [];
      c_a_set    : SET OF applied_classification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hull cross section design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      gr_ass_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
      violation := SIZEOF(QUERY ( aga <* gr_ass_set | ((aga.role.name = 
          'members') AND ('revision with context' IN which_class(aga.
          assigned_group))) )) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- hull_cross_section_design_has_at_least_one_revision_with_context

  RULE hull_cross_section_design_has_at_most_one_revision_with_context FOR (
             group, applied_classification_assignment);

    LOCAL
      gr_ass_set : SET OF applied_group_assignment := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF product_definition_shape := [];
      c_a_set    : SET OF applied_classification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hull cross section design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      gr_ass_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
      violation := SIZEOF(QUERY ( aga <* gr_ass_set | ((aga.role.name = 
          'members') AND ('revision with context' IN which_class(aga.
          assigned_group))) )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- hull_cross_section_design_has_at_most_one_revision_with_context

  RULE hull_cross_section_has_at_least_one_revision_with_context FOR (
             object_role, group, applied_classification_assignment);

    LOCAL
      gr_ass_set : SET OF applied_group_assignment := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF product_definition := [];
      c_a_set    : SET OF applied_classification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hull cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      gr_ass_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
      violation := SIZEOF(QUERY ( aga <* gr_ass_set | ((aga.role.name = 
          'context of revision') AND ('revision with context' IN 
          which_class(aga.assigned_group))) )) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- hull_cross_section_has_at_least_one_revision_with_context

  RULE hull_cross_section_optionally_contains_specified_classes FOR (group, 
             applied_classification_assignment, applied_group_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      cl_ass    : SET OF applied_classification_assignment := [];
      gr_ass    : SET OF applied_group_assignment := [];
      pd        : SET OF product_definition := [];
      groups    : SET OF group := [];
    END_LOCAL;
    cl_ass := QUERY ( i <* applied_classification_assignment | ((i.role.
        name = 'class membership') AND (i.assigned_class.name = 
        'hull cross section')) );
    REPEAT i := 1 TO HIINDEX(cl_ass) BY 1;
      pd := pd + cl_ass[i].items;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | (i.role.name = 
        'equivalence') );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1;
      REPEAT j := 1 TO HIINDEX(gr_ass[i].items) BY 1;
        IF gr_ass[i].items[j] IN pd THEN
          groups := groups + gr_ass[i].assigned_group;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | ((SIZEOF(i.items) <>
         0) AND (i.role.name = 'item structure') AND (i.assigned_group IN 
        groups)) );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1 WHILE NOT violation;
      violation := SIZEOF(QUERY ( inst <* gr_ass[i].items | (
          'structural system' IN which_class(inst)) )) = 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- hull_cross_section_optionally_contains_specified_classes

  RULE hull_cross_section_result_for_representation_item FOR (
             representation, representation_item, group, 
             applied_classification_assignment);

    LOCAL
      violation       : LOGICAL := FALSE;
      c_a_set         : SET OF applied_classification_assignment := [];
      arg_list        : LIST OF STRING := [
                         'actual first moment horizontal',
                         'actual first moment vertical',
                         'actual inertia cross','actual inertia horizontal',
                         'actual inertia torsion','actual inertia vertical',
                         'actual neutral axis position horizontal',
                         'actual neutral axis position vertical',
                         'actual section area',
                         'actual section modulus bottom',
                         'actual section modulus coaming',
                         'actual section modulus deck',
                         'actual stress bottom','actual stress coaming',
                         'actual stress deck',
                         'actual twist centre horizontal',
                         'actual twist centre vertical',
                         'direction largest inertia',
                         'direction least inertia','max moment',
                         'max shear force','meter weight','min moment',
                         'min shear force',
                         'required section modulus bottom',
                         'required section modulus coaming',
                         'required section modulus deck',
                         'required stress bottom','required stress coaming',
                         'required stress deck'];
      classed_rep_set : SET OF representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hull cross section result') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        classed_rep_set := classed_rep_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(classed_rep_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* classed_rep_set[i].items
             | (rep_item.name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- hull_cross_section_result_for_representation_item

  RULE identification_role_optional_attribute_description_required FOR (
             identification_role);

  WHERE
    wr1: (SIZEOF(QUERY ( i <* identification_role | ((i.name = 
             'external reference') AND (NOT EXISTS(i.description))) )) = 0);

  END_RULE; -- identification_role_optional_attribute_description_required

  RULE initiator_for_change_request FOR (
             applied_person_and_organization_assignment, 
             person_and_organization_role, versioned_action_request);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF versioned_action_request := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* versioned_action_request | VALUE_IN(
        which_class(a),'change request') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'initiator')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- initiator_for_change_request

  RULE library_manufacturing_definition_for_class_references FOR (
             shape_aspect, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'library manufacturing definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | ('source' IN 
          which_class(t2_inst)) )) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- library_manufacturing_definition_for_class_references

  RULE lightship_definition_has_properties FOR (product_definition, 
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : SET OF product_definition := [];
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'lightship_definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'lightship_definition') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- lightship_definition_has_properties

  RULE mandatory_entity_type_for_external_instance_reference FOR (
             external_source, external_source_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      bag_1   : BAG OF external_source := [];
    END_LOCAL;
    bag_1 := QUERY ( a <* external_source | (a.description = 'schema') );
    REPEAT i := 1 TO SIZEOF(bag_1) BY 1 WHILE NOT violate;
      violate := SIZEOF(QUERY ( a <* external_source_relationship | ((a.
          related_source :=: bag_1[i]) AND (a.relating_source.description =
           'entity type')) )) = 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- mandatory_entity_type_for_external_instance_reference

  RULE maximum_of_one_representation_items_for_class_library_definition FOR (
             representation, applied_classification_assignment, 
             classification_role, group);

    LOCAL
      var_representation : BAG OF representation := [];
    END_LOCAL;
    var_representation := QUERY ( temp1 <* representation | (SIZEOF(
        QUERY ( temp2 <* bag_to_set(USEDIN(temp1,
        'SHIP_STRUCTURES_SCHEMA.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS'))
         | ((temp2\classification_assignment.role.name = 'class membership') 
        AND (temp2\classification_assignment.assigned_class\group.name = 
        'library definition')) )) > 0) );

  WHERE
    wr1: (SIZEOF(QUERY ( temp3 <* var_representation | (SIZEOF(temp3.items) 
             > 1) )) = 0);

  END_RULE; -- maximum_of_one_representation_items_for_class_library_definition

  RULE members_is_referenced_by_at_least_one_revision FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),'members') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'revision')) );
      violate := SIZEOF(a_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- members_is_referenced_by_at_least_one_revision

  RULE no_approvals_except_in_approval_history FOR (approval);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF approval := [];
      t2_set  : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* approval | VALUE_IN(which_class(a),
        'approval event') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
      violate := SIZEOF(t2_set) = 0;
      REPEAT k := 1 TO HIINDEX(t2_set) BY 1 WHILE NOT violate;
        violate := NOT VALUE_IN(which_class(t2_set[k].assigned_group),
            'approval history');
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- no_approvals_except_in_approval_history

  RULE panel_system_design_definition_has_at_least_one_class FOR (
             shape_aspect, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'panel system design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | ('border' IN 
          which_class(t2_inst)) )) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- panel_system_design_definition_has_at_least_one_class

  RULE panel_system_design_definition_has_at_most_one_class FOR (
             shape_aspect, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'panel system design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | ('moulded surface' 
          IN which_class(t2_inst)) )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- panel_system_design_definition_has_at_most_one_class

  RULE panel_system_optionally_contains_specified_classes FOR (group, 
             applied_classification_assignment, applied_group_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      cl_ass    : SET OF applied_classification_assignment := [];
      gr_ass    : SET OF applied_group_assignment := [];
      pd        : SET OF product_definition := [];
      groups    : SET OF group := [];
    END_LOCAL;
    cl_ass := QUERY ( i <* applied_classification_assignment | ((i.role.
        name = 'class membership') AND (i.assigned_class.name = 
        'panel system')) );
    REPEAT i := 1 TO HIINDEX(cl_ass) BY 1;
      pd := pd + cl_ass[i].items;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | (i.role.name = 
        'equivalence') );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1;
      REPEAT j := 1 TO HIINDEX(gr_ass[i].items) BY 1;
        IF gr_ass[i].items[j] IN pd THEN
          groups := groups + gr_ass[i].assigned_group;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | ((SIZEOF(i.items) <>
         0) AND (i.role.name = 'item structure') AND (i.assigned_group IN 
        groups)) );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1 WHILE NOT violation;
      violation := SIZEOF(QUERY ( inst <* gr_ass[i].items | ('plate' IN 
          which_class(inst)) )) = 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- panel_system_optionally_contains_specified_classes

  RULE plate_design_definition_has_at_least_one_class_references FOR (
             shape_aspect, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'plate design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | ('border' IN 
          which_class(t2_inst)) )) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- plate_design_definition_has_at_least_one_class_references

  RULE plate_design_definition_has_at_most_one_class_references FOR (
             shape_aspect, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'plate design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | ('moulded surface' 
          IN which_class(t2_inst)) )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- plate_design_definition_has_at_most_one_class_references

  RULE plate_manufacturing_definition_has_class_references FOR (
             shape_aspect, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'plate manufacturing definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | ('outer contour' IN 
          which_class(t2_inst)) )) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- plate_manufacturing_definition_has_class_references

  RULE principal_characteristics_has_properties FOR (
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : SET OF product_definition := [];
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'principal characteristics') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'principal characteristics') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- principal_characteristics_has_properties

  RULE product_definition_for_call_sign FOR (product_definition, 
             applied_identification_assignment, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'call sign') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_call_sign

  RULE product_definition_for_class_notation FOR (property_definition, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class and statutory designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (
          'class notation' IN which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_class_notation

  RULE product_definition_for_design_still_water_shear_force_values FOR (
             product_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'design still water shear  force') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'design still water shear force values') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_design_still_water_shear_force_values

  RULE product_definition_for_flag_state FOR (product_definition, 
             applied_identification_assignment, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'flag state') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_flag_state

  RULE product_definition_for_port_of_registration FOR (product_definition, 
             applied_identification_assignment, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'port of registration') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_port_of_registration

  RULE product_definition_for_regulation FOR (product_definition, 
             property_definition, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class and statutory designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ('regulation' 
          IN which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_regulation

  RULE product_definition_for_shipyard FOR (product_definition, 
             applied_organization_assignment, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_organization_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'shipyard designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'shipyard') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_shipyard

  RULE product_definition_has_references_with_class_loadline FOR (
             product_definition, property_definition, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'freeboard characteristics') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ('loadline' IN 
          which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_has_references_with_class_loadline

  RULE product_definition_local_coordinate_system_with_station_reference FOR (
             product_definition, property_definition, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hull cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (
          'local co ordinate system with station reference' IN which_class(
          t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_local_coordinate_system_with_station_reference

  RULE product_definition_relationship_with_definable_object FOR (
             product_definition_relationship, group, 
             applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'definable object' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- product_definition_relationship_with_definable_object

  RULE product_definition_relationship_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_relationship := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['assembly relationship',
                   'structural part penetration relationship',
                   'structural system penetration relationship'];
      t2_set    : SET OF product_definition_relationship := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_relationship_with_identification_assignment

  RULE product_definition_shape_for_assembly_manufacturing FOR (
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'assembly manufacturing definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'assembly manufacturing definition parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_assembly_manufacturing

  RULE product_definition_shape_for_bevel_design_parameters FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'bevel design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'bevel design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_bevel_design_parameters

  RULE product_definition_shape_for_beveled_groove_weld_design FOR (
             product_definition_shape, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'beveled groove weld') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'beveled groove weld design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_beveled_groove_weld_design

  RULE product_definition_shape_for_butt_groove_weld_design FOR (
             product_definition_shape, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'butt groove weld') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'butt groove weld design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_butt_groove_weld_design

  RULE product_definition_shape_for_circular_cutout_design_parameters FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'circular cutout design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'circular cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_circular_cutout_design_parameters

  RULE product_definition_shape_for_class_torch_vector FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'weld manufacturing definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ('torch vector' 
          IN which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_class_torch_vector

  RULE product_definition_shape_for_continuous_fillet_weld_design FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'continuous fillet weld') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'continuous fillet  weld design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_continuous_fillet_weld_design

  RULE product_definition_shape_for_corrugated_part_design FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corrugated part design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'corrugated part design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_corrugated_part_design

  RULE product_definition_shape_for_corrugated_structure_design FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corrugated structure design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           ' corrugated structure design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_corrugated_structure_design

  RULE product_definition_shape_for_corrugation FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corrugated part design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ('corrugation' 
          IN which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_corrugation

  RULE product_definition_shape_for_drain_hole_cutout_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'drain hole cutout design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'drain hole cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_drain_hole_cutout_design

  RULE product_definition_shape_for_elliptical_cutout_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'elliptical cutout design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'elliptical cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_elliptical_cutout_design

  RULE product_definition_shape_for_elongated_oval_cutout_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'elongated oval cutout l design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'elongated oval cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_elongated_oval_cutout_design

  RULE product_definition_shape_for_fillet_weld_design_parameters FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'fillet weld') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'fillet  weld design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_fillet_weld_design_parameters

  RULE product_definition_shape_for_free_form_interior_cutout_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'free form interior cutout design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'free form interior cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_free_form_interior_cutout_design

  RULE product_definition_shape_for_groove_weld_design FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'groove weld') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'groove weld design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_groove_weld_design

  RULE product_definition_shape_for_hull_cross_section_design_definition FOR (
             product_definition);

    LOCAL
      gr_ass_set : SET OF applied_group_assignment := [];
      violation  : LOGICAL := FALSE;
      t1_set1    : SET OF product_definition_shape := [];
      t1_set2    : SET OF product_definition_shape := [];
      t2_set     : SET OF product_definition := [];
    END_LOCAL;
    t2_set := QUERY ( all_t2_inst <* product_definition | (
        'hull cross section' IN which_class(all_t2_inst)) );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1 WHILE NOT violation;
      t1_set1 := QUERY ( pd <* bag_to_set(USEDIN(t2_set[i],
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION')) | (
          'SHIP_STRUCTURES_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) );
      t1_set2 := QUERY ( t1_inst1 <* t1_set1 | (
          'hull cross section design definition' IN which_class(t1_inst1)) );
      REPEAT j := 1 TO HIINDEX(t1_set2) BY 1;
        gr_ass_set := QUERY ( aga <* bag_to_set(USEDIN(t1_set2[j],
            'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS')) | ((
            aga.role.name = 'versions') AND ('version history' IN 
            which_class(aga.assigned_group))) );
      END_REPEAT;
      violation := SIZEOF(gr_ass_set) > 1;
      gr_ass_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_hull_cross_section_design_definition

  RULE product_definition_shape_for_intermittent_fillet_weld_design FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'intermittent fillet weld') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'intermittent fillet  weld design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_intermittent_fillet_weld_design

  RULE product_definition_shape_for_inward_round_corner_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'inward round corner design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'inward round corner design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_inward_round_corner_design

  RULE product_definition_shape_for_library_definition_parameters FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'library definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'library definition parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_library_definition_parameters

  RULE product_definition_shape_for_library_design_parameters FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'library design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'library design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_library_design_parameters

  RULE product_definition_shape_for_library_manufacturing_defiinition FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'library manufacturing definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'library manufacturing defiinition parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_library_manufacturing_defiinition

  RULE product_definition_shape_for_manufacturing_definition_parameters FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'manufacturing definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'manufacturing definition parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_manufacturing_definition_parameters

  RULE product_definition_shape_for_name FOR (product_definition_shape, 
             shape_aspect, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'library design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ('name' IN 
          which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_name

  RULE product_definition_shape_for_outer_contour_representation FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'plate manufacturing definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'outer contour representation') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_outer_contour_representation

  RULE product_definition_shape_for_outward_round_corner_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'outward round corner design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'outward round corner design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_outward_round_corner_design

  RULE product_definition_shape_for_panel_system_design_parameters FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'panel system design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'panel system design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_panel_system_design_parameters

  RULE product_definition_shape_for_part_edge_cutout_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'part edge cutout design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'part edge cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_part_edge_cutout_design

  RULE product_definition_shape_for_plate_design_parameters FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'plate design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'plate design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_plate_design_parameters

  RULE product_definition_shape_for_profile_cross_section FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'profile design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (
          'profile cross section' IN which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_profile_cross_section

  RULE product_definition_shape_for_profile_design_parameters FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'profile design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'profile design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_profile_design_parameters

  RULE product_definition_shape_for_rectangular_cutout_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'rectangular cutout design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'rectangular cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_rectangular_cutout_design

  RULE product_definition_shape_for_round_corner_rectangular_cutout FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'round corner rectangular cutout design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'round corner rectangular cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_round_corner_rectangular_cutout

  RULE product_definition_shape_for_round_edge_rectangular_cutout FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'round edge rectangular cutout design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'round edge rectangular cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_round_edge_rectangular_cutout

  RULE product_definition_shape_for_shear_bevel_design_parameters FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'shear bevel design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'shear bevel design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_shear_bevel_design_parameters

  RULE product_definition_shape_for_source FOR (product_definition_shape, 
             shape_aspect, group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'library definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ('source' IN 
          which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_source

  RULE product_definition_shape_for_spot_seam_weld_design FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spot seam weld') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'spot seam weld design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_spot_seam_weld_design

  RULE product_definition_shape_for_structural_part_joint_design FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'structural part joint design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'structural part joint design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_structural_part_joint_design

  RULE product_definition_shape_for_structural_system_design FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'structural system design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'structural system design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_structural_system_design

  RULE product_definition_shape_for_triangular_cutout_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'triangular cutout design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'triangular cutout design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_triangular_cutout_design

  RULE product_definition_shape_for_welded_joint_design_parameters FOR (
             product_definition_shape, property_definition_representation, 
             group, applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'welded joint design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'welded joint design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_for_welded_joint_design_parameters

  RULE product_definition_shape_has_references_for_centre_of_gravity FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'assembly manufacturing definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (
          'centre of gravity' IN which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_has_references_for_centre_of_gravity

  RULE product_definition_shape_has_references_with_class_border FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corrugated part design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ('border' IN 
          which_class(t2_inst)) )) = 2);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_has_references_with_class_border

  RULE product_definition_shape_has_references_with_name_weld_design_parameters FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'weld design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'weld design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_has_references_with_name_weld_design_parameters

  RULE product_definition_shape_of_rectangular_cutback_corner_design FOR (
             product_definition_shape, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'rectangular cutback corner design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'rectangular cutback corner design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_of_rectangular_cutback_corner_design

  RULE product_definition_shape_with_definition_matches_pattern FOR (
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'DEFINITION' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- product_definition_shape_with_definition_matches_pattern

  RULE product_definition_shape_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['explicit feature design definition',
                   'assembly manufacturing definition',
                   'structural added material feature design definition',
                   'structural part manufacturing definition',
                   'corrugated part design definition','plate',
                   'plate design definition','profile design definition',
                   'weld manufacturing definition',
                   'bevel design definition',
                   'circular cutout design definition',
                   'drain hole cutout design definition',
                   'elliptical cutout design definition',
                   'elongated oval cutout design definition',
                   'free form interior cutout design definition',
                   'inward round corner design definition',
                   'outward round corner design definition',
                   'part edge cutout design definition',
                   'rectangular cutback corner design definition',
                   'rectangular cutout design definition',
                   'round edge rectangular cutout design definition',
                   'seam design definition','shear bevel design definition',
                   'triangular cutout design definition'];
      t2_set    : SET OF product_definition_shape := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_with_identification_assignment

  RULE product_definition_shape_with_versionable_object FOR (group, 
             applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'versionable object' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- product_definition_shape_with_versionable_object

  RULE product_definition_shape_with_versionable_object_matches_pattern FOR (
             group, applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'versionable object' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- product_definition_shape_with_versionable_object_matches_pattern

  RULE product_definition_with_date_freeboard_assigned FOR (
             product_definition, applied_date_and_time_assignment, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'freeboard characteristics') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'date freeboard assigned') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_with_date_freeboard_assigned

  RULE product_definition_with_definable_object_matches_pattern FOR (
             product_definition, group, applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'definable object' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- product_definition_with_definable_object_matches_pattern

  RULE product_definition_with_freeboard_assigned_by FOR (
             product_definition, applied_organization_assignment, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_organization_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'freeboard characteristics') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'freeboard assigned by') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_with_freeboard_assigned_by

  RULE product_definition_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['principal characteristics',
                   'class and statutory designation',
                   'freeboard characteristics','lightship definition',
                   'ship designation','shipyard designation',
                   'owner designation','assembly','corrugated part',
                   'plate boundary relationship','profile',
                   'versionable object'];
      t2_set    : SET OF product_definition := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_with_identification_assignment

  RULE product_related_product_category_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_related_product_category := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['ship type'];
      t2_set    : SET OF product_related_product_category := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_related_product_category_with_identification_assignment

  RULE product_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['definable object'];
      t2_set    : SET OF product := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_with_identification_assignment

  RULE profile_cross_section_has_at_most_one_named_references FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'profile cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name = 
          'section properties') )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- profile_cross_section_has_at_most_one_named_references

  RULE profile_design_definition_has_at_most_one_class_references FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'profile design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | (
          'profile curve trace line' IN which_class(t2_inst)) )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- profile_design_definition_has_at_most_one_class_references

  RULE profile_design_definition_has_zero_or_two_class_references FOR (
             product_definition_shape, shape_aspect, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'profile design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      violation := (NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ('border' IN 
          which_class(t2_inst)) )) = 0)) AND (NOT (SIZEOF(
          QUERY ( t2_inst <* t2_set | ('border' IN which_class(t2_inst)) )) 
          = 2));
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- profile_design_definition_has_zero_or_two_class_references

  RULE property_definition_for_class_notation FOR (property_definition, 
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class notation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'class notation') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_class_notation

  RULE property_definition_for_class_society FOR (property_definition, 
             applied_organization_assignment, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_organization_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class notation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'class society') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_class_society

  RULE property_definition_for_corrugated_structure_function FOR (
             property_definition, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corrugated structure functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'corrugated structure function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_corrugated_structure_function

  RULE property_definition_for_edge_cutout_function_parameters FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'edge cutout functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'edge cutout function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_edge_cutout_function_parameters

  RULE property_definition_for_edge_feature_function_parameters FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'edge feature functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'edge feature function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_edge_feature_function_parameters

  RULE property_definition_for_homogeneous_ship_material_property FOR (
             property_definition, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'homogeneous ship material property') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'homogeneous ship  material property parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_homogeneous_ship_material_property

  RULE property_definition_for_interior_cutout_function_parameters FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'interior cutout functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'interior cutout function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_interior_cutout_function_parameters

  RULE property_definition_for_local_coordinate_system FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'local coordinate system') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'local coordinate system') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_local_coordinate_system

  RULE property_definition_for_local_coordinate_system_with_position FOR (
             property_definition, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'local co ordinatesystem with position reference') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'local co ordinatesystem with position reference') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_local_coordinate_system_with_position

  RULE property_definition_for_panel_system_function_parameters FOR (
             property_definition, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'panel system functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'panel system function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_panel_system_function_parameters

  RULE property_definition_for_plate_function_parameters FOR (
             property_definition, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'plate functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'plate function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_plate_function_parameters

  RULE property_definition_for_plate_strake_function_parameters FOR (
             property_definition, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'plate strake functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'plate strake function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_plate_strake_function_parameters

  RULE property_definition_for_profile_function_parameters FOR (
             property_definition, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'profile functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'profile function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_profile_function_parameters

  RULE property_definition_for_ship_material_property_parameters FOR (
             property_definition, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship material property') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'ship material property parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_ship_material_property_parameters

  RULE property_definition_for_structural_system_function_parameters FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'structural system functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'structural system function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_structural_system_function_parameters

  RULE property_definition_for_weld_filler_material_design FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'weld filler material') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'weld filler material design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_weld_filler_material_design

  RULE property_definition_has_references_lightship_weight_item FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'lightship weight item') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'lightship weight item') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_has_references_lightship_weight_item

  RULE property_definition_has_references_with_name_loadline FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'loadline') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'loadline') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_has_references_with_name_loadline

  RULE property_definition_structural_weld_shrinkage_allowance_feature FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'structural weld shrinkage allowance feature design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'structural weld shrinkage allowance feature design parameters') )) 
          = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_structural_weld_shrinkage_allowance_feature

  RULE property_definition_to_structural_added_material_feature_design FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'structural added material feature design definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'structural added material feature design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_to_structural_added_material_feature_design

  RULE property_definition_with_definition_matches_pattern FOR (group, 
             applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'DEFINITION' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- property_definition_with_definition_matches_pattern

  RULE property_definition_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := [
                   'moulded form characteristics definition',
                   'ship overall dimensions','local co ordinate system',
                   'spacing table','global axis placement',
                   'hydrostatic definition','stability definition',
                   'plate functional definition',
                   'profile functional definition',
                   'edge cutout functional definition',
                   'edge feature functional definition',
                   'interior cutout functional definition','structural weld shrinkage allowance  feature design definition'];
      t2_set    : SET OF property_definition := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_with_identification_assignment

  RULE property_definition_with_versionable_object_matches_pattern FOR (
             group, applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'versionable object' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- property_definition_with_versionable_object_matches_pattern

  RULE property_definition_with_weight_and_centre_of_gravity FOR (
             property_definition, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'weight and centre of gravity') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'weight and centre of gravity') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_with_weight_and_centre_of_gravity

  RULE representation_design_vertical_wave_bending_moment_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['hogging','sagging'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'design vertical wave bending moment parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_design_vertical_wave_bending_moment_parameters

  RULE representation_for_angle_bar_cross_section_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','width','radius','thk'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'angle bar cross section dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_angle_bar_cross_section_dimensions

  RULE representation_for_assembly_manufacturing_definition FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['assembly method','assembly stage',
                   'mass','center of gravity'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'assembly manufacturing definition parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_assembly_manufacturing_definition

  RULE representation_for_bulbflat_cross_section_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','bulb width','bulb radius',
                   'tw'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'bulbflat cross section dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_bulbflat_cross_section_dimensions

  RULE representation_for_channel_cross_section_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','width','web thk',
                   'flange thk','radius','k'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'channel cross section dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_channel_cross_section_dimensions

  RULE representation_for_circular_cutout_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['radius'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'circular cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_circular_cutout_design_parameters

  RULE representation_for_circular_hollow_profile_cross_section FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','width','web thk',
                   'flange thk','radius','k'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'channel cross section dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_circular_hollow_profile_cross_section

  RULE representation_for_class_and_statutory_designation FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['class number'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class and statutory designation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_class_and_statutory_designation

  RULE representation_for_corrugated_part_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['mirrored','offset','repetition',
                   'thickness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'corrugated part design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_corrugated_part_design_parameters

  RULE representation_for_design_vertical_wave_shear_force_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['negative value','positive value'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'design vertical wave shear force parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_design_vertical_wave_shear_force_parameters

  RULE representation_for_drain_hole_cutout_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','drain hole radius','gap',
                   'gap radius','width'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'drain hole cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_drain_hole_cutout_design_parameters

  RULE representation_for_edge_cutout_function_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'edge cutout function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_edge_cutout_function_parameters

  RULE representation_for_edge_feature_function_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'edge feature function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_edge_feature_function_parameters

  RULE representation_for_electrode_chemical_composition_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['carbon','silicon','manganese',
                   'phosphorus','sulphur','nickel','molydenum','aliminium',
                   'titanium','zirconium','chromium','copper','vanadium'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'electrode chemical composition design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_electrode_chemical_composition_design

  RULE representation_for_elliptical_cutout_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['half axis a','half axis b'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'elliptical cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_elliptical_cutout_design_parameters

  RULE representation_for_elongated_oval_cutout_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['distance','r1','r2'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'elongated oval cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_elongated_oval_cutout_design_parameters

  RULE representation_for_explicit_profile_cross_section_shape FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['cross section geometry',
                   'local coordinate system'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'explicit profile cross section shape') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_explicit_profile_cross_section_shape

  RULE representation_for_flanged_plate_cross_section_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','width','radius','thk'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'flanged plate cross section dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_flanged_plate_cross_section_dimensions

  RULE representation_for_flat_bar_cross_section_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','width'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'flat bar cross section dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_flat_bar_cross_section_dimensions

  RULE representation_for_global_axis_placement FOR (representation, 
             representation_item, property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['global axes and origin',
                   'after perpendicular offset','orientation'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'global axis placement') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_global_axis_placement

  RULE representation_for_interior_cutout_function_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'interior cutout function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_interior_cutout_function_parameters

  RULE representation_for_inward_round_corner_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['radius','x offset','y offset'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'inward round corner design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_inward_round_corner_design_parameters

  RULE representation_for_local_co_ordinate_system FOR (representation, 
             representation_item, property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['local axes and origin'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'local co ordinatesystem') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_local_co_ordinate_system

  RULE representation_for_moment_3d_restricts_representation_item FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['longitudinal moment',
                   'transverse moment','vertical moment','origin'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( i <* representation | (i.name = 'moment 3d') );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_moment_3d_restricts_representation_item

  RULE representation_for_outward_round_corner_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['radius','x offset','y offset'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'outward round corner design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_outward_round_corner_design_parameters

  RULE representation_for_part_edge_cutout_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['r left','r right','x a','x b','x c',
                   'x d','y b','y c'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'part edge cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_part_edge_cutout_design_parameters

  RULE representation_for_profile_curve_trace_line_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['curve'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'profile curve trace line design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_profile_curve_trace_line_design_parameters

  RULE representation_for_profile_function_parameters FOR (representation, 
             representation_item, property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'profile function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_profile_function_parameters

  RULE representation_for_rectangular_cutback_corner_design FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['radius','x depth','y depth'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'rectangular cutback corner design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_rectangular_cutback_corner_design

  RULE representation_for_rectangular_cutout_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['length of','width'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'rectangular cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_rectangular_cutout_design_parameters

  RULE representation_for_round_bar_cross_section_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['radius'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'round bar cross section dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_round_bar_cross_section_dimensions

  RULE representation_for_round_corner_rectangular_cutout_design FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['corner radius','length of','width'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'round corner rectangular cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_round_corner_rectangular_cutout_design

  RULE representation_for_round_edge_rectangular_cutout_design FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['distance','edge radius','length of',
                   'width'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'round edge rectangular cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_round_edge_rectangular_cutout_design

  RULE representation_for_shear_bevel_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['offset','x y angle','x z angle'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'shear bevel design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_shear_bevel_design_parameters

  RULE representation_for_square_tube_cross_section_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','width','wall thk'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'square tube cross section dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_square_tube_cross_section_dimensions

  RULE representation_for_structural_added_material_feature_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['added_material_length'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = (
        'structural added material feature ' + 'design parameters')) )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_structural_added_material_feature_design

  RULE representation_for_structural_part_joint_design FOR (representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['tightness','joint orientation'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'structural part joint design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_structural_part_joint_design

  RULE representation_for_structural_part_symmetry_relationship FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['mirroring plane'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'structural part symmetry relationship design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_structural_part_symmetry_relationship

  RULE representation_for_structural_system_symmetry_relationship FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['mirroring plane'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'structural system symmetry relationship design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_structural_system_symmetry_relationship

  RULE representation_for_t_bar_cross_section_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','width','web thk',
                   'flange thk','radius','k'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        't bar cross section dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_t_bar_cross_section_dimensions

  RULE representation_for_triangular_cutout_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['c1 radius','c2 radius','c3 radius',
                   'c2 x','c3 x','c3 y'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'triangular cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_triangular_cutout_design_parameters

  RULE representation_for_twist_location_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['location','direction'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'twist location design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_twist_location_design_parameters

  RULE representation_has_global_unit_assigned_context FOR (representation);

    LOCAL
      has_guac : LOGICAL := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(representation) BY 1 WHILE has_guac;
      REPEAT j := 1 TO SIZEOF(representation[i].items) BY 1 WHILE has_guac;
        IF ('SHIP_STRUCTURES_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF(
            representation[i].items[j])) OR (
            'SHIP_STRUCTURES_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN 
            TYPEOF(representation[i].items[j])) THEN
          has_guac := 
              'SHIP_STRUCTURES_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN 
              TYPEOF(representation[i].context_of_items);
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: has_guac;

  END_RULE; -- representation_has_global_unit_assigned_context

  RULE representation_has_references_with_name_moment_3d FOR (
             representation, property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF representation := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'weight and centre of gravity') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'moment 3d') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_has_references_with_name_moment_3d

  RULE representation_item_corrugated_structure_boundary_relationship FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'corrugated structure boundary relationship design parameters') )) 
        > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_item_corrugated_structure_boundary_relationship

  RULE representation_item_for_panel_system_curve_boundary_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'panel system curve boundary design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_item_for_panel_system_curve_boundary_design

  RULE representation_item_for_structural_weld_shrinkage_allowance FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['longitudinal allowance',
                  'transverse allowance','vertical allowance'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = (
        'structural weld shrinkage allowance feature ' + 
        'design parameters')) )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_item_for_structural_weld_shrinkage_allowance

  RULE representation_item_for_transformation_to_parent FOR (
             property_definition, representation, mapped_item, group, 
             applied_classification_assignment);

    LOCAL
      t3_set     : SET OF representation := [];
      t4_set     : SET OF representation_map := [];
      t1_set     : SET OF property_definition := [];
      t5_set     : SET OF mapped_item := [];
      c_a_set    : SET OF applied_classification_assignment := [];
      arg_list   : LIST OF STRING := ['local coordinate system position in global coordinate system','local coordinate system position in parent local coordinate system','local coordinate system position in parent local coordinate system with position reference'];
      violation1 : LOGICAL := FALSE;
      violation2 : LOGICAL := FALSE;
      t2_set     : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'local co ordinate system') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation1;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation1 := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.
          used_representation.name = 'local axis representation') )) = 1);
      t3_set := t3_set + t2_set[i].used_representation;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation1;
      t4_set := bag_to_set(USEDIN(t3_set[i],'SHIP_STRUCTURES_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation1;
      t5_set := bag_to_set(USEDIN(t4_set[i],
          'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
      REPEAT j := 1 TO 3 BY 1 WHILE NOT violation2;
        violation2 := NOT (SIZEOF(QUERY ( t2_inst <* t5_set | (t2_inst.
            name = arg_list[j]) )) = 1);
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation1);
    wr2: (NOT violation2);

  END_RULE; -- representation_item_for_transformation_to_parent

  RULE representation_item_to_structural_system_adjacency_relationship FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'structural system adjacency relationship design parameters') )) > 
        0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_item_to_structural_system_adjacency_relationship

  RULE representation_items_for_corrugated_part_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['mass'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'corrugated part design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_corrugated_part_design_parameters

  RULE representation_items_for_corrugated_structure_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['corrugation width',
                  'user defined tightness'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'corrugated structure design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_corrugated_structure_design

  RULE representation_items_for_corrugated_structure_function FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'corrugated structure function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_corrugated_structure_function

  RULE representation_items_for_edge_cutout_function_parameters FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'edge cutout function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_edge_cutout_function_parameters

  RULE representation_items_for_edge_feature_function_parameters FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'edge feature function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_edge_feature_function_parameters

  RULE representation_items_for_elongated_oval_cutout_design FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['r3','r3 x','r3 y'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'elongated oval cutout design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_elongated_oval_cutout_design

  RULE representation_items_for_interior_cutout_function_parameters FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'interior cutout function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_interior_cutout_function_parameters

  RULE representation_items_for_inward_round_corner_design FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['z depth'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'inward round corner design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_inward_round_corner_design

  RULE representation_items_for_maximum_permissible_swbm_values FOR (
             compound_representation_item);

    LOCAL
      violation : LOGICAL := FALSE;
      rep_item  : SET OF representation_item := [];
      arg_list  : LIST OF STRING := ['hogging','sagging','position'];
      creps     : BAG OF compound_representation_item := [];
    END_LOCAL;
    creps := QUERY ( temp_comp_rep_item <* compound_representation_item | 
        (temp_comp_rep_item.name = 'maximum permissible swbm values') );
    REPEAT i := 1 TO HIINDEX(creps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        REPEAT k := 1 TO HIINDEX(creps[i].item_element) BY 1;
          rep_item := creps[i].item_element;
          violation := SIZEOF(QUERY ( items <* rep_item | (items.name = 
              arg_list[j]) )) = 1;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_items_for_maximum_permissible_swbm_values

  RULE representation_items_for_maximum_permissible_swsf_values FOR (
             compound_representation_item);

    LOCAL
      violation : LOGICAL := FALSE;
      rep_item  : SET OF representation_item := [];
      arg_list  : LIST OF STRING := ['negative value','positive value',
                   'position'];
      creps     : BAG OF compound_representation_item := [];
    END_LOCAL;
    creps := QUERY ( temp_comp_rep_item <* compound_representation_item | 
        (temp_comp_rep_item.name = 'maximum permissible swsf values') );
    REPEAT i := 1 TO HIINDEX(creps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        REPEAT k := 1 TO HIINDEX(creps[i].item_element) BY 1;
          rep_item := creps[i].item_element;
          violation := SIZEOF(QUERY ( items <* rep_item | (items.name = 
              arg_list[j]) )) = 1;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_items_for_maximum_permissible_swsf_values

  RULE representation_items_for_outward_round_corner_design FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['z depth'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'outward round corner design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_outward_round_corner_design

  RULE representation_items_for_panel_system_boundary_relationship FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'panel system boundary relationship design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_panel_system_boundary_relationship

  RULE representation_items_for_panel_system_function_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'panel system function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_panel_system_function_parameters

  RULE representation_items_for_profile_boundary_relationship_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'profile boundary relationship design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_profile_boundary_relationship_design

  RULE representation_items_for_profile_curve_trace_line_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'profile curve trace line design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_profile_curve_trace_line_design

  RULE representation_items_for_profile_trace_line_relationship_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['displacement','auxiliary line'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'profile trace line relationship design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_profile_trace_line_relationship_design

  RULE representation_items_for_rectangular_cutback_corner_design FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['z depth'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'rectangular cutback corner design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_rectangular_cutback_corner_design

  RULE representation_items_for_seam_curve_relationship_parameter FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'seam curve relationship parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_seam_curve_relationship_parameter

  RULE representation_items_for_shear_bevel_design_parameters FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['z angle'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'shear bevel design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_shear_bevel_design_parameters

  RULE representation_items_optional_for_bevel_design_parameters FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['z angle'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'bevel design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_bevel_design_parameters

  RULE representation_items_optional_for_beveled_groove_weld_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['weld backing type','taper angle'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'beveled groove weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_beveled_groove_weld_design

  RULE representation_items_optional_for_butt_groove_weld_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['weld backing type'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'butt groove weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_butt_groove_weld_design

  RULE representation_items_optional_for_class_notation FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['ice class notation','service factor',
                  'approval required for heavy cargo'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class notation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_class_notation

  RULE representation_items_optional_for_corrugation_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['radius 1','radius 2'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'corrugation dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_corrugation_dimensions

  RULE representation_items_optional_for_groove_weld_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['weld backing type'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'groove weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_groove_weld_design

  RULE representation_items_optional_for_owner_designation FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['owner approval'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'owner designation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_owner_designation

  RULE representation_items_optional_for_panel_system_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['stiffener spacing',
                  'user defined tightness'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'panel system design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_panel_system_design

  RULE representation_items_optional_for_plate_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['mass'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'plate design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_plate_design_parameters

  RULE representation_items_optional_for_plate_function_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'plate function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_plate_function_parameters

  RULE representation_items_optional_for_plate_strake_function FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'plate strake function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_plate_strake_function

  RULE representation_items_optional_for_principal_characteristics FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['block coefficient'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'principal characteristics') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_principal_characteristics

  RULE representation_items_optional_for_profile_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['mass'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'profile design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_profile_design_parameters

  RULE representation_items_optional_for_profile_function_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'profile function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_profile_function_parameters

  RULE representation_items_optional_for_seam_design_parameters FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['seam curve'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'seam design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_seam_design_parameters

  RULE representation_items_optional_for_structural_system_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def  tightness'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'structural system design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_structural_system_design

  RULE representation_items_optional_for_structural_system_function FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'structural system function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_structural_system_function

  RULE representation_items_optional_for_weld_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['start suspension','end suspension',
                  'weld cross section area'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_weld_design_parameters

  RULE representation_items_optional_for_weld_filler_material_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['chemical composition id',
                  'electrode id','material strength id',
                  'notch impact work id'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'weld filler material design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_weld_filler_material_design

  RULE representation_items_specified_for_design_swsf_values FOR (
             compound_representation_item, representation_item);

    LOCAL
      violation : LOGICAL := FALSE;
      rep_item  : SET OF representation_item := [];
      arg_list  : LIST OF STRING := ['negative value','positive value',
                   'position'];
      creps     : BAG OF compound_representation_item := [];
    END_LOCAL;
    creps := QUERY ( temp_comp_rep_item <* compound_representation_item | 
        (temp_comp_rep_item.name = 'design swsf values') );
    REPEAT i := 1 TO HIINDEX(creps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        REPEAT k := 1 TO HIINDEX(creps[i].item_element) BY 1;
          rep_item := creps[i].item_element;
          violation := SIZEOF(QUERY ( items <* rep_item | (items.name = 
              arg_list[j]) )) = 1;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_items_specified_for_design_swsf_values

  RULE representation_local_coordinate_system_with_position_reference FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['local axes and origin'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'local co ordinatesystem with position reference') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_local_coordinate_system_with_position_reference

  RULE representation_maximum_permissible_still_water_bending_moment FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (temp_rep.name = 
        'maximum permissible still water bending moment') );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
          name = 'maximum permissible swbm values') )) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_maximum_permissible_still_water_bending_moment

  RULE representation_of_design_still_water_bending_moment_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['hogging amidship','sagging amidship'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'design still water bending moment parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_of_design_still_water_bending_moment_parameters

  RULE representation_of_maximum_permissible_still_water_shear_force FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (temp_rep.name = 
        'maximum permissible still water shear force') );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
          name = 'maximum permissible swsf values') )) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_of_maximum_permissible_still_water_shear_force

  RULE representation_restricted_by_name_bevel_design_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['offset','x y angle'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION' + 
        '.USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'bevel design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_bevel_design_parameters

  RULE representation_restricted_by_name_class_notation FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['service area',
                   'approval required for oil cargo',
                   'approval required for loading unloading aground',
                   'approval required for unloading grabs'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class notation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_class_notation

  RULE representation_restricted_by_name_class_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['length class','length solas',
                   'scantlings draught','block coefficient class',
                   'design speed ahead','design speed astern'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_class_parameters

  RULE representation_restricted_by_name_corrugation_dimensions FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','flat width 1','flat width 2',
                   'slope width'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'corrugation dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_corrugation_dimensions

  RULE representation_restricted_by_name_flare_area_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['area','height'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'flare area parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_flare_area_parameters

  RULE representation_restricted_by_name_freeboard_characteristics FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['assigned code','freeboard'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'freeboard characteristics') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_freeboard_characteristics

  RULE representation_restricted_by_name_lightship_definition FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['lightship weight',
                   'lightship centre of gravity'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'lightship_definition') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_lightship_definition

  RULE representation_restricted_by_name_lightship_weight_item FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['aft weight extent',
                   'fwd weight extent'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'lightship weight item') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_lightship_weight_item

  RULE representation_restricted_by_name_loadline FOR (representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['load line length','load line depth',
                   'load line displacement','load line block coefficient',
                   'load line regulation'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 'loadline') )) 
        > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_loadline

  RULE representation_restricted_by_name_plate_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['material offset','thickness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'plate design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_plate_design_parameters

  RULE representation_restricted_by_name_plate_function_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'plate function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_plate_function_parameters

  RULE representation_restricted_by_name_principal_characteristics FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['length between perpendiculars',
                   'moulded breadth','moulded depth','design draught',
                   'design deadweight','min draught at fp',
                   'max draught at fp','min draught at ap',
                   'max draught at ap'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'principal characteristics') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_principal_characteristics

  RULE representation_restricted_by_name_profile_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['mirrored'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'profile design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_profile_design_parameters

  RULE representation_restricted_by_name_section_properties FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['nominal mass per length','area',
                   'na u','na v','moi u','moi v','moi uv','tr'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'section properties') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_section_properties

  RULE representation_restricted_by_name_table_of_shear_force_values FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (temp_rep.name = 
        'table of shear force values') );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
          name = 'design swsf values') )) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_table_of_shear_force_values

  RULE representation_restricted_by_name_w_shape_cross_section FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['depth','width','web thk',
                   'flange thk','radius','k'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'w shape cross section') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_w_shape_cross_section

  RULE representation_restricted_for_assembly_manufacturing_position FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['assembly footprint','orientation'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'assembly manufacturing position parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_assembly_manufacturing_position

  RULE representation_restricted_for_beveled_groove_weld_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['endcut shape','taper','sideness',
                   'weld joint spacer','configuration','penetration',
                   'joint_orientation','tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'beveled groove weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_beveled_groove_weld_design

  RULE representation_restricted_for_butt_groove_weld_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['face shape','sideness',
                   'weld joint spacer','configuration','penetration',
                   'joint_orientation','tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'butt groove weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_butt_groove_weld_design

  RULE representation_restricted_for_composite_feature_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['composed of','description','name'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'composite feature design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_composite_feature_design

  RULE representation_restricted_for_continuous_fillet_weld_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['endcut shape type','sideness',
                   'configuration','penetration','joint_orientation',
                   'tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'continuous fillet weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_continuous_fillet_weld_design

  RULE representation_restricted_for_corrugated_structure_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['thickness','tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'corrugated structure design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_corrugated_structure_design

  RULE representation_restricted_for_corrugated_structure_function FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'corrugated structure function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_corrugated_structure_function

  RULE representation_restricted_for_fillet_weld_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['endcut shape type','sideness',
                   'configuration','penetration','joint_orientation',
                   'tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'fillet weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_fillet_weld_design_parameters

  RULE representation_restricted_for_groove_weld_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['sideness','weld joint spacer',
                   'configuration','penetration','joint_orientation',
                   'tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'groove weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_groove_weld_design

  RULE representation_restricted_for_homogeneous_ship_material_property FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['density','poisson ratio',
                   'stress of fracture','thermal expansion coefficient',
                   'yield point','youngs module'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'homogeneous ship material property parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_homogeneous_ship_material_property

  RULE representation_restricted_for_hull_cross_section_design_definition FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['mirrored symmetry'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'hull cross section design definition parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_hull_cross_section_design_definition

  RULE representation_restricted_for_intermittent_fillet_weld_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['end rules','cutout rules',
                   'fillet alignment','fillet weld length',
                   'fillet weld spacing','penetration rules',
                   'endcut shape type','sideness','configuration',
                   'penetration','joint_orientation','tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'intermittent fillet weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_intermittent_fillet_weld_design

  RULE representation_restricted_for_panel_system_curve_boundary FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['curve'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'panel system curve boundary design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_panel_system_curve_boundary

  RULE representation_restricted_for_panel_system_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['material offset','thickness',
                   'tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'panel system design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_panel_system_design_parameters

  RULE representation_restricted_for_panel_system_function FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'panel system function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_panel_system_function

  RULE representation_restricted_for_panel_system_plane_boundary FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['plane'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'panel system plane boundary design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_panel_system_plane_boundary

  RULE representation_restricted_for_plate_renewal_definition_attributes FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['rule thickness','renewal thickness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'plate renewal definition attributes') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_plate_renewal_definition_attributes

  RULE representation_restricted_for_plate_strake_function FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'plate strake function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_plate_strake_function

  RULE representation_restricted_for_ship_material_property FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['density'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'ship material property parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_ship_material_property

  RULE representation_restricted_for_spot_seam_weld_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['weld context','configuration',
                   'penetration','joint_orientation','tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'spot seam weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_spot_seam_weld_design

  RULE representation_restricted_for_structural_part_joint_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['tightness','joint orientation'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'structural part joint design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_structural_part_joint_design

  RULE representation_restricted_for_structural_system_design FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['thightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'structural system design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_structural_system_design

  RULE representation_restricted_for_structural_system_function FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'structural system function parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_structural_system_function

  RULE representation_restricted_for_weld_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['shape of weld surface',
                   'weld geometry','connection angle','rotation angle',
                   'inclination angle','shrinkage','weld size'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'weld design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_weld_design_parameters

  RULE representation_restricted_for_weld_filler_material_design FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['density'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'weld filler material design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_weld_filler_material_design

  RULE representation_restricted_for_weld_manufacturing_definition FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['position','process',
                   'degree of automations','number of weld passes',
                   'welding deposition sequences','welding environment',
                   'tack weld used'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'weld manufacturing definition parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_weld_manufacturing_definition

  RULE representation_restricted_for_welded_joint_design_parameters FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['configuration','penetration',
                   'joint_orientation','tightness'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'welded joint design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_welded_joint_design_parameters

  RULE representation_restricted_for_welding_sequence_representation FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['name','start offset','end offset',
                   'direction'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'welding sequence representation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_for_welding_sequence_representation

  RULE representation_restricted_weight_and_centre_of_gravity FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['mass','centre of gravity'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'weight and centre of gravity') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_weight_and_centre_of_gravity

  RULE representation_restricts_profile_renewal_definition_attributes FOR (
             representation, representation_item, 
             property_definition_representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['renewal modulus','rule inertia',
                   'rule section modulus'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'profile renewal definition attributes') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricts_profile_renewal_definition_attributes

  RULE representation_with_versionable_object_matches_pattern FOR (group, 
             applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'versionable object' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- representation_with_versionable_object_matches_pattern

  RULE restrict_name_for_known_source FOR (known_source);

  WHERE
    wr1: (SIZEOF(QUERY ( ks <* known_source | (ks.name <> 
             'ISO 13584 library') )) = 0);

  END_RULE; -- restrict_name_for_known_source

  RULE revision_has_mandatory_attribute_description FOR (group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
    END_LOCAL;
    t1_set := QUERY ( i <* group | VALUE_IN(which_class(i),'revision') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- revision_has_mandatory_attribute_description

  RULE revision_with_context_referenced_for_context_of_revision FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'revision with context') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'context of revision')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- revision_with_context_referenced_for_context_of_revision

  RULE seam_has_at_most_one_class_references FOR (shape_aspect, 
             shape_aspect_relationship, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF shape_aspect_relationship := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'seam') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | (
          'seam curve relationship' IN which_class(t2_inst)) )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- seam_has_at_most_one_class_references

  RULE shape_aspect_for_angle_bar_cross_section_dimensions FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'angle bar cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'angle bar cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_angle_bar_cross_section_dimensions

  RULE shape_aspect_for_assembly_manufacturing_position_parameters FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'assembly manufacturing position') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'assembly manufacturing position parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_assembly_manufacturing_position_parameters

  RULE shape_aspect_for_border_corner_cutout_boundary_relationship FOR (
             shape_aspect, applied_group_assignment, group, 
             applied_classification_assignment);

    LOCAL
      gr_ass_set : BAG OF applied_group_assignment := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF shape_aspect := [];
      c_a_set    : SET OF applied_classification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'border') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      gr_ass_set := USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS');
      violation := SIZEOF(QUERY ( aga <* gr_ass_set | ((aga.role.name = 
          'boundary index 2') AND ('corner cutout boundary relationship' IN
           which_class(aga.assigned_group))) )) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_border_corner_cutout_boundary_relationship

  RULE shape_aspect_for_bulbflat_cross_section_dimensions FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'bulbflat cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'bulbflat cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_bulbflat_cross_section_dimensions

  RULE shape_aspect_for_channel_cross_section_dimensions FOR (shape_aspect, 
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'channel cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'channel cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_channel_cross_section_dimensions

  RULE shape_aspect_for_circular_hollow_cross_section_dimensions FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'circular hollow cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'circular hollow cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_circular_hollow_cross_section_dimensions

  RULE shape_aspect_for_composite_feature_design_parameters FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'composite feature') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'composite feature design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_composite_feature_design_parameters

  RULE shape_aspect_for_composite_feature_has_at_least_two_instances FOR (
             shape_aspect, applied_classification_assignment);

    LOCAL
      violation       : LOGICAL := FALSE;
      c_a_set         : SET OF applied_classification_assignment := [];
      t2_set          : SET OF shape_aspect := [];
      classed_s_a_set : SET OF shape_aspect := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'composite feature') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        classed_s_a_set := classed_s_a_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c_a_set := [];
    REPEAT i := 1 TO HIINDEX(classed_s_a_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(classed_s_a_set[1],
          'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' + 
          'RELATING_SHAPE_ASPECT'));
      violation := NOT (SIZEOF(t2_set) = 2);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_composite_feature_has_at_least_two_instances

  RULE shape_aspect_for_corner_cutout FOR (shape_aspect, 
             applied_group_assignment, group, 
             applied_classification_assignment);

    LOCAL
      gr_ass_set : BAG OF applied_group_assignment := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF shape_aspect := [];
      c_a_set    : SET OF applied_classification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corner cutout') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      gr_ass_set := USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS');
      violation := SIZEOF(QUERY ( aga <* gr_ass_set | ((aga.role.name = 
          'item 1') AND ('structural cutout boundary relationship' IN 
          which_class(aga.assigned_group))) )) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_corner_cutout

  RULE shape_aspect_for_corner_cutout_boundary_relationship FOR (
             shape_aspect, applied_group_assignment, group, 
             applied_classification_assignment);

    LOCAL
      gr_ass_set : BAG OF applied_group_assignment := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF shape_aspect := [];
      c_a_set    : SET OF applied_classification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corner cutout') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      gr_ass_set := USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS');
      violation := SIZEOF(QUERY ( aga <* gr_ass_set | ((aga.role.name = 
          'item 1') AND ('corner cutout boundary relationship' IN 
          which_class(aga.assigned_group))) )) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_corner_cutout_boundary_relationship

  RULE shape_aspect_for_corrugation_dimensions FOR (shape_aspect, 
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'corrugation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'corrugation dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_corrugation_dimensions

  RULE shape_aspect_for_explicit_profile_cross_section_dimensions FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'explicit profile cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           ' explicit profile cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_explicit_profile_cross_section_dimensions

  RULE shape_aspect_for_flanged_plate_cross_section_dimensions FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'flanged plate cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'flanged plate cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_flanged_plate_cross_section_dimensions

  RULE shape_aspect_for_flare_area_parameters FOR (shape_aspect, 
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'flare area') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'flare area parameters') )) = 2);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_flare_area_parameters

  RULE shape_aspect_for_flat_bar_cross_section_dimensions FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'flat bar cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'flat  bar cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_flat_bar_cross_section_dimensions

  RULE shape_aspect_for_panel_system_curve_boundary_design FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'panel system curve boundary') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'panel system curve boundary design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_panel_system_curve_boundary_design

  RULE shape_aspect_for_panel_system_plane_boundary_design FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'panel system plane boundary') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'panel system plane boundary design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_panel_system_plane_boundary_design

  RULE shape_aspect_for_profile_curve_trace_line_design_parameters FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'profile curve trace line') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'profile curve trace line design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_profile_curve_trace_line_design_parameters

  RULE shape_aspect_for_round_bar_cross_section_dimensions FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'round bar cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'round bar cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_round_bar_cross_section_dimensions

  RULE shape_aspect_for_square_tube_cross_section_dimensions FOR (
             shape_aspect, property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'square tube cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'square tube cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_square_tube_cross_section_dimensions

  RULE shape_aspect_for_structural_cutout_boundary_relationship FOR (
             shape_aspect, applied_group_assignment, group, 
             applied_classification_assignment);

    LOCAL
      gr_ass_set : BAG OF applied_group_assignment := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF shape_aspect := [];
      c_a_set    : SET OF applied_classification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'structural cutout') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      gr_ass_set := USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS');
      violation := SIZEOF(QUERY ( aga <* gr_ass_set | ((aga.role.name = 
          'item 1') AND ('structural cutout boundary relationship' IN 
          which_class(aga.assigned_group))) )) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_structural_cutout_boundary_relationship

  RULE shape_aspect_for_t_bar_cross_section_dimensions FOR (shape_aspect, 
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 't bar cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           't bar cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_t_bar_cross_section_dimensions

  RULE shape_aspect_for_twist_location_design_parameters FOR (shape_aspect, 
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'twist location') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'twist location design parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_twist_location_design_parameters

  RULE shape_aspect_for_w_shape_cross_section_dimensions FOR (shape_aspect, 
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'w shape cross section') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'w shape cross section dimensions') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_for_w_shape_cross_section_dimensions

  RULE shape_aspect_relationship_attributes_references_are_distinct FOR (
             shape_aspect_relationship);

    LOCAL
      cyclic_relationship : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(shape_aspect_relationship) BY 1 WHILE NOT 
        cyclic_relationship;
      cyclic_relationship := shape_aspect_relationship[i].
          relating_shape_aspect :=: shape_aspect_relationship[i].
          related_shape_aspect;
    END_REPEAT;

  WHERE
    wr1: (NOT cyclic_relationship);

  END_RULE; -- shape_aspect_relationship_attributes_references_are_distinct

  RULE shape_aspect_relationship_with_definable_object FOR (group, 
             applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'definable object' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- shape_aspect_relationship_with_definable_object

  RULE shape_aspect_relationship_with_definition_matches_pattern FOR (
             group, applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'DEFINITION' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- shape_aspect_relationship_with_definition_matches_pattern

  RULE shape_aspect_relationship_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect_relationship := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['composite feature',
                   'seam curve relationship'];
      t2_set    : SET OF shape_aspect_relationship := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_relationship_with_identification_assignment

  RULE shape_aspect_with_definable_object_matches_pattern FOR (group, 
             applied_classification_assignment);

    LOCAL
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_classification_assignment) BY 1;
      IF applied_classification_assignment[i].assigned_class.name = 
          'definable object' THEN
        clfied_inst := clfied_inst + applied_classification_assignment[i].
            items;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (SIZEOF(QUERY ( i <* clfied_inst | (NOT (i.id LIKE '*.*')) )) = 0);

  END_RULE; -- shape_aspect_with_definable_object_matches_pattern

  RULE shape_aspect_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF shape_aspect := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['composite feature','seam',
                   'structural cutout'];
      t2_set    : SET OF shape_aspect := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- shape_aspect_with_identification_assignment

  RULE ship_designation_has_one_specified_names FOR (product_definition, 
             applied_identification_assignment, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ((t2_inst.role.
          name = 'imo number') OR (t2_inst.role.name = 
          'pennant hull number')) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- ship_designation_has_one_specified_names

  RULE ship_material_property_has_at_most_one_named_references FOR (
             property_definition, applied_document_reference, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_document_reference := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship material property') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_STRUCTURES_SCHEMA.' + 
          'APPLIED_DOCUMENT_REFERENCE.ITEMS'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.name =
           'material reference') )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- ship_material_property_has_at_most_one_named_references

  RULE source_for_library_definition FOR (representation, 
             representation_item, group, applied_classification_assignment);

    LOCAL
      violation       : LOGICAL := FALSE;
      c_a_set         : SET OF applied_classification_assignment := [];
      arg_list        : LIST OF STRING := ['library definition'];
      classed_rep_set : SET OF representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'source') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        classed_rep_set := classed_rep_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(classed_rep_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* classed_rep_set[i].items
             | (rep_item.name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- source_for_library_definition

  RULE spacing_position_compound_representation_has_name FOR (
             compound_representation_item, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['position number','position'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spacing position') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- spacing_position_compound_representation_has_name

  RULE spacing_position_with_offset_compound_representation_has_class FOR (
             compound_representation_item, group, 
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF representation_item := [];
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      c_a_set2  : SET OF applied_classification_assignment := [];
      t2_set    : SET OF compound_representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spacing position with offset') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c_a_set2 := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spacing position') );
    REPEAT i := 1 TO HIINDEX(c_a_set2) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set2[i].items) BY 1;
        t2_set := t2_set + c_a_set2[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(t1_set[i].item_element) BY 1;
        t3_set := t3_set + t1_set[i].item_element;
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) <> 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- spacing_position_with_offset_compound_representation_has_class

  RULE spacing_position_with_offset_compound_representation_has_name FOR (
             compound_representation_item, group, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['offset'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spacing position with offset') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- spacing_position_with_offset_compound_representation_has_name

  RULE structural_class_rejection_has_at_least_one_role_references FOR (
             group, applied_document_reference, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF group := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_document_reference := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'structural class rejection') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_DOCUMENT_REFERENCE.ITEMS'));
      violation := SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.name =
           'explanations') )) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- structural_class_rejection_has_at_least_one_role_references

  RULE structural_part_symmetry_relationship_has_product_definition FOR (
             group, applied_classification_assignment);

    LOCAL
      cl_ass      : SET OF applied_classification_assignment := [];
      clfied_inst : SET OF product_definition_relationship := [];
    END_LOCAL;
    cl_ass := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'structural part symmetry relationship') );
    REPEAT i := 1 TO HIINDEX(cl_ass) BY 1;
      clfied_inst := clfied_inst + cl_ass[i].items;
    END_REPEAT;

  WHERE
    wr1: ((SIZEOF(QUERY ( pdr <* clfied_inst | (NOT (SIZEOF(which_class(
             pdr.relating_product_definition)) > 0)) )) - SIZEOF(
             QUERY ( pdr <* clfied_inst | (NOT (SIZEOF(which_class(pdr.
             related_product_definition)) > 0)) ))) = 0);

  END_RULE; -- structural_part_symmetry_relationship_has_product_definition

  RULE structural_system_symmetry_relationship_has_product_definition FOR (
             group, applied_classification_assignment);

    LOCAL
      cl_ass      : SET OF applied_classification_assignment := [];
      clfied_inst : SET OF product_definition_relationship := [];
    END_LOCAL;
    cl_ass := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'structural system symmetry relationship') );
    REPEAT i := 1 TO HIINDEX(cl_ass) BY 1;
      clfied_inst := clfied_inst + cl_ass[i].items;
    END_REPEAT;

  WHERE
    wr1: ((SIZEOF(QUERY ( pdr <* clfied_inst | (NOT (SIZEOF(which_class(
             pdr.relating_product_definition)) > 0)) )) - SIZEOF(
             QUERY ( pdr <* clfied_inst | (NOT (SIZEOF(which_class(pdr.
             related_product_definition)) > 0)) ))) = 0);

  END_RULE; -- structural_system_symmetry_relationship_has_product_definition

  RULE unique_approvals_in_approval_history FOR (group, 
             applied_group_assignment);

    LOCAL
      violate : LOGICAL := FALSE;
      t3_set  : SET OF approval := [];
      t1_set  : SET OF group := [];
      t2_set  : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( i <* group | VALUE_IN(which_class(i),
        'APPROVAL HISTORY') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := QUERY ( a <* applied_group_assignment | (a.assigned_group 
          = t1_set[i]) );
      t3_set := QUERY ( b <* t2_set[1].items | (
          'SHIP_STRUCTURES_SCHEMA.APPROVAL' IN TYPEOF(b)) );
      violate := NOT VALUE_UNIQUE(t3_set);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- unique_approvals_in_approval_history

  RULE user_def_function_description_required FOR (representation, 
             representation_item);

    LOCAL
      violation : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(representation) BY 1 WHILE NOT violation;
      violation := (SIZEOF(QUERY ( r <* representation[i].items | ((
          'SHIP_STRUCTURES_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN 
          TYPEOF(r)) AND (r.name = 'function') AND (r\
          descriptive_representation_item.description = 'user defined')) )) 
          > 0) AND (SIZEOF(QUERY ( r <* representation[i].items | (r.name =
           'user def function') )) = 0);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- user_def_function_description_required

  RULE user_defined_requires_user_defined_class FOR (product_definition, 
             group, applied_classification_assignment);

    LOCAL
      violation   : LOGICAL := FALSE;
      cl_ass      : SET OF applied_classification_assignment := [];
      clfied_inst : SET OF classification_item := [];
    END_LOCAL;
    cl_ass := QUERY ( i <* applied_classification_assignment | ((i.role.
        name = 'class membership') AND (i.assigned_class.name = 
        'user defined')) );
    REPEAT i := 1 TO HIINDEX(cl_ass) BY 1;
      clfied_inst := clfied_inst + cl_ass[i].items;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(clfied_inst) BY 1 WHILE NOT violation;
      violation := NOT ('user defined class' IN which_class(clfied_inst[i]));
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- user_defined_requires_user_defined_class

  RULE user_defined_tightness_description_required FOR (representation, 
             representation_item);

    LOCAL
      violation : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(representation) BY 1 WHILE NOT violation;
      violation := (SIZEOF(QUERY ( r <* representation[i].items | ((
          'SHIP_STRUCTURES_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN 
          TYPEOF(r)) AND (r.name = 'tightness') AND (r\
          descriptive_representation_item.description = 'user defined')) )) 
          > 0) AND (SIZEOF(QUERY ( r <* representation[i].items | (r.name =
           'user defined tightness') )) = 0);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- user_defined_tightness_description_required

  RULE version_creation_has_mandatory_attribute_description FOR (action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action | VALUE_IN(which_class(i),
        'version creation') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_creation_has_mandatory_attribute_description

  RULE version_deletion_has_mandatory_attribute_description FOR (action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action | VALUE_IN(which_class(i),
        'version deletion') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_deletion_has_mandatory_attribute_description

  RULE version_history_has_exactly_one_assigned_group FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      set_1   : SET OF applied_group_assignment := [];
      set_3   : SET OF group_item := [];
      set_2   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'version history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      set_1 := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'current version')) );
      set_2 := QUERY ( c <* applied_group_assignment | ((c.assigned_group 
          = t1_set[i]) AND (c.role.name = 'members')) );
      violate := (SIZEOF(set_1) <> 1) OR (SIZEOF(set_2) <> 1);
      IF NOT violate THEN
        set_3 := set_1[1].items * set_2[1].items;
        violate := (SIZEOF(set_3) <> 1) OR (NOT VALUE_IN(which_class(set_3
            [1]),'versionable object'));
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_history_has_exactly_one_assigned_group

  RULE version_history_referenced_by_exactly_one_current_version FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'version history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'current version')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_history_referenced_by_exactly_one_current_version

  RULE version_history_referenced_by_multiple_roles FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'version history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (NOT (b.role.name IN ['versions',
          'current version','relationships']))) );
      violate := SIZEOF(a_set) > 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_history_referenced_by_multiple_roles

  RULE version_modification_has_mandatory_attribute_description FOR (
             action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action | VALUE_IN(which_class(i),
        'version modification') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_modification_has_mandatory_attribute_description

  RULE version_relationship_associates_with_versionable_object FOR (
             applied_identification_assignment);

    LOCAL
      violate  : LOGICAL := FALSE;
      violate1 : LOGICAL := FALSE;
      violate2 : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1
         WHILE NOT violate;
      violate1 := (SIZEOF(USEDIN(applied_identification_assignment[i],
          'SHIP_STRUCTURES_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' 
          + 'RELATING_IDENTIFICATION_ASSIGNMENT')) > 0) AND (NOT VALUE_IN(
          which_class(applied_identification_assignment[i]),
          'versionable object'));
      violate2 := (SIZEOF(USEDIN(applied_identification_assignment[i],
          'SHIP_STRUCTURES_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' 
          + 'RELATED_IDENTIFICATION_ASSIGNMENT')) > 0) AND (NOT VALUE_IN(
          which_class(applied_identification_assignment[i]),
          'versionable object'));
      violate := violate1 OR violate2;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_relationship_associates_with_versionable_object

  RULE version_relationship_has_mandatory_attribute_description FOR (
             identification_assignment_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF identification_assignment_relationship := [];
    END_LOCAL;
    t1_set := QUERY ( i <* identification_assignment_relationship | 
        VALUE_IN(which_class(i),'version relationship') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_relationship_has_mandatory_attribute_description

  RULE version_relationship_has_unique_versions FOR (
             identification_assignment_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF identification_assignment_relationship := [];
    END_LOCAL;
    t1_set := QUERY ( a <* identification_assignment_relationship | 
        VALUE_IN(which_class(a),'version relationship') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      violate := t1_set[i].relating_identification_assignment.assigned_id 
          = t1_set[i].related_identification_assignment.assigned_id;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_relationship_has_unique_versions

  RULE versionable_object_has_one_version_id FOR (
             applied_identification_assignment);

    LOCAL
      version_ids         : SET OF applied_identification_assignment := [];
      duplicate           : LOGICAL := FALSE;
      versionable_objects : BAG OF identification_item := [];
    END_LOCAL;
    version_ids := QUERY ( i <* applied_identification_assignment | (i.
        role.name = 'version identifier') );
    REPEAT i := 1 TO HIINDEX(version_ids) BY 1;
      versionable_objects := versionable_objects + version_ids[i].items;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(versionable_objects) BY 1 WHILE NOT duplicate;
      REPEAT j := i + 1 TO HIINDEX(versionable_objects) BY 1 WHILE NOT 
          duplicate;
        duplicate := versionable_objects[i] :=: versionable_objects[j];
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT duplicate);

  END_RULE; -- versionable_object_has_one_version_id

  RULE versioned_action_request_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF versioned_action_request := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['definable object'];
      t2_set    : SET OF versioned_action_request := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- versioned_action_request_with_identification_assignment

  RULE versions_is_referenced_by_at_least_one_version_history FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),'versions') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'version history')) );
      violate := SIZEOF(a_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- versions_is_referenced_by_at_least_one_version_history

  FUNCTION acyclic_curve_replica(
               rep: curve_replica;
               parent: curve
      ): BOOLEAN;
    IF NOT ('SHIP_STRUCTURES_SCHEMA.CURVE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;

  END_FUNCTION; -- acyclic_curve_replica

  FUNCTION acyclic_mapped_representation(
               parent_set: SET OF representation;
               children_set: SET OF representation_item
      ): BOOLEAN;

    LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | ('SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM' 
        IN TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
            'SHIP_STRUCTURES_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_mapped_representation

  FUNCTION acyclic_point_replica(
               rep: point_replica;
               parent: point
      ): BOOLEAN;
    IF NOT ('SHIP_STRUCTURES_SCHEMA.POINT_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
    END_IF;

  END_FUNCTION; -- acyclic_point_replica

  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category
      ): BOOLEAN;

    LOCAL
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,'SHIP_STRUCTURES_SCHEMA.' + 
        'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_category_relationship

  FUNCTION acyclic_surface_replica(
               rep: surface_replica;
               parent: surface
      ): BOOLEAN;
    IF NOT ('SHIP_STRUCTURES_SCHEMA.SURFACE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_surface_replica(rep,parent\surface_replica.
          parent_surface));
    END_IF;

  END_FUNCTION; -- acyclic_surface_replica

  FUNCTION associated_surface(
               arg: pcurve_or_surface
      ): surface;

    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);

  END_FUNCTION; -- associated_surface

  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;

    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

  END_FUNCTION; -- bag_to_set

  FUNCTION base_axis(
               dim: INTEGER;
               axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;

    LOCAL
      u      : LIST [2:3] OF direction;
      d1     : direction;
      d2     : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));
      d2 := first_proj_axis(d1,axis1);
      u := [d2,second_proj_axis(d1,d2,axis2),d1];
    ELSE
      IF EXISTS(axis1) THEN
        d1 := normalise(axis1);
        u := [d1,orthogonal_complement(d1)];
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          d1 := normalise(axis2);
          u := [orthogonal_complement(d1),d1];
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u := [dummy_gri || direction([1,0]),dummy_gri || direction([0,1])];
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

  END_FUNCTION; -- base_axis

  FUNCTION boolean_choose(
               b: BOOLEAN;
               choice1: GENERIC:item;
               choice2: GENERIC:item
      ): GENERIC:item;
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;

  END_FUNCTION; -- boolean_choose

  FUNCTION build_2axes(
               ref_direction: direction
      ): LIST [2:2] OF direction;

    LOCAL
      d : direction := NVL(normalise(ref_direction),dummy_gri || 
           direction([1,0]));
    END_LOCAL;
    RETURN([d,orthogonal_complement(d)]);

  END_FUNCTION; -- build_2axes

  FUNCTION build_axes(
               axis, ref_direction: direction
      ): LIST [3:3] OF direction;

    LOCAL
      d1 : direction;
      d2 : direction;
    END_LOCAL;
    d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    d2 := first_proj_axis(d1,ref_direction);
    RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);

  END_FUNCTION; -- build_axes

  FUNCTION closed_shell_reversed(
               a_shell: closed_shell
      ): oriented_closed_shell;

    LOCAL
      the_reverse : oriented_closed_shell;
    END_LOCAL;
    IF 'SHIP_STRUCTURES_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell\oriented_closed_shell.
          closed_shell_element,NOT a_shell\oriented_closed_shell.
          orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- closed_shell_reversed

  FUNCTION conditional_reverse(
               p: BOOLEAN;
               an_item: reversible_topology
      ): reversible_topology;
    IF p THEN
      RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;

  END_FUNCTION; -- conditional_reverse

  FUNCTION constraints_composite_curve_on_surface(
               c: composite_curve_on_surface
      ): BOOLEAN;

    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(c\composite_curve
          .segments[k].parent_curve))) AND (NOT (
          'SHIP_STRUCTURES_SCHEMA.SURFACE_CURVE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) AND (NOT (
          'SHIP_STRUCTURES_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_composite_curve_on_surface

  FUNCTION constraints_param_b_spline(
               degree: INTEGER;
               up_knots: INTEGER;
               up_cp: INTEGER;
               knot_mult: LIST OF INTEGER;
               knots: LIST OF parameter_value
      ): BOOLEAN;

    LOCAL
      k      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (
        degree + up_cp + 2)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k < 1) OR (k > (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i < up_knots) AND (k > degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k > (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_param_b_spline

  FUNCTION cross_product(
               arg1, arg2: direction
      ): vector;

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(
            v1[3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[
            1])]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(arg1,0);
        END_IF;
        RETURN(result);
      END;
    END_IF;

  END_FUNCTION; -- cross_product

  FUNCTION curve_weights_positive(
               b: rational_b_spline_curve
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] <= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- curve_weights_positive

  FUNCTION derive_dimensional_exponents(
               x: unit
      ): dimensional_exponents;

    LOCAL
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'SHIP_STRUCTURES_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- derive_dimensional_exponents

  FUNCTION dimension_of(
               item: geometric_representation_item
      ): dimension_count;

    LOCAL
      x   : SET OF representation;
      y   : representation_context;
      dim : dimension_count;
    END_LOCAL;
    IF 'SHIP_STRUCTURES_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
      dim := SIZEOF(item\cartesian_point.coordinates);
      RETURN(dim);
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
      dim := SIZEOF(item\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.VECTOR' IN TYPEOF(item) THEN
      dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    x := using_representations(item);
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN(dim);

  END_FUNCTION; -- dimension_of

  FUNCTION dimensions_for_si_unit(
               n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      OTHERWISE     :         RETURN(?);
      END_CASE;

  END_FUNCTION; -- dimensions_for_si_unit

  FUNCTION dot_product(
               arg1, arg2: direction
      ): REAL;

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);

  END_FUNCTION; -- dot_product

  FUNCTION edge_reversed(
               an_edge: edge
      ): oriented_edge;

    LOCAL
      the_reverse : oriented_edge;
    END_LOCAL;
    IF 'SHIP_STRUCTURES_SCHEMA.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge\oriented_edge.edge_element,NOT an_edge\
          oriented_edge.orientation);
    ELSE
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- edge_reversed

  FUNCTION face_bound_reversed(
               a_face_bound: face_bound
      ): face_bound;

    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'SHIP_STRUCTURES_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
         THEN
      the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
          NOT a_face_bound\face_bound.orientation) || face_outer_bound();
    ELSE
      the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT 
          a_face_bound.orientation);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_bound_reversed

  FUNCTION face_reversed(
               a_face: face
      ): oriented_face;

    LOCAL
      the_reverse : oriented_face;
    END_LOCAL;
    IF 'SHIP_STRUCTURES_SCHEMA.ORIENTED_FACE' IN TYPEOF(a_face) THEN
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face\oriented_face.face_element,NOT 
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_reversed

  FUNCTION first_proj_axis(
               z_axis, arg: direction
      ): direction;

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN
      RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios <> [1,0,0] THEN
          v := dummy_gri || direction([1,0,0]);
        ELSE
          v := dummy_gri || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim <> 3 THEN
          RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

  END_FUNCTION; -- first_proj_axis

  FUNCTION get_basis_surface(
               c: curve_on_surface
      ): SET [0:2] OF surface;

    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'SHIP_STRUCTURES_SCHEMA.SURFACE_CURVE' IN TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
         THEN
      n := SIZEOF(c\composite_curve.segments);
      surfs := get_basis_surface(c\composite_curve.segments[1].
          parent_curve);
      IF n > 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve.segments[i]
              .parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);

  END_FUNCTION; -- get_basis_surface

  FUNCTION get_description_value(
               obj: description_attribute_select
      ): text;

    LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,
                         'SHIP_STRUCTURES_SCHEMA.' + 
                         'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM');
    END_LOCAL;
    IF SIZEOF(description_bag) = 1 THEN
      RETURN(description_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_description_value

  FUNCTION get_id_value(
               obj: id_attribute_select
      ): identifier;

    LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,'SHIP_STRUCTURES_SCHEMA.' 
                + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM');
    END_LOCAL;
    IF SIZEOF(id_bag) = 1 THEN
      RETURN(id_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_id_value

  FUNCTION get_name_value(
               obj: name_attribute_select
      ): label;

    LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,
                  'SHIP_STRUCTURES_SCHEMA.' + 'NAME_ATTRIBUTE.' + 
                  'NAMED_ITEM');
    END_LOCAL;
    IF SIZEOF(name_bag) = 1 THEN
      RETURN(name_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_name_value

  FUNCTION get_role(
               obj: role_select
      ): object_role;

    LOCAL
      role_bag : BAG OF role_association := USEDIN(obj,
                  'SHIP_STRUCTURES_SCHEMA.' + 'ROLE_ASSOCIATION.' + 
                  'ITEM_WITH_ROLE');
    END_LOCAL;
    IF SIZEOF(role_bag) = 1 THEN
      RETURN(role_bag[1].role);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_role

  FUNCTION item_in_context(
               item: representation_item;
               cntxt: representation_context
      ): BOOLEAN;

    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'SHIP_STRUCTURES_SCHEMA.REPRESENTATION.ITEMS') *
         cntxt.representations_in_context) > 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | (
          'SHIP_STRUCTURES_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) );
      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- item_in_context

  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- leap_year

  FUNCTION list_face_loops(
               f: face
      ): LIST [0:?] OF loop;

    LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);

  END_FUNCTION; -- list_face_loops

  FUNCTION list_of_topology_reversed(
               a_list: list_of_reversible_topology_item
      ): list_of_reversible_topology_item;

    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- list_of_topology_reversed

  FUNCTION list_to_array(
               lis: LIST [0:?] OF GENERIC:t;
               low: INTEGER;
               u: INTEGER
      ): ARRAY OF GENERIC:t;

    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n <> ((u - low) + 1) THEN
      RETURN(?);
    ELSE
      res := [lis[1]];
      REPEAT i := 2 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;

  END_FUNCTION; -- list_to_array

  FUNCTION list_to_set(
               l: LIST [0:?] OF GENERIC:t
      ): SET OF GENERIC:t;

    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);

  END_FUNCTION; -- list_to_set

  FUNCTION make_array_of_array(
               lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1: INTEGER;
               u1: INTEGER;
               low2: INTEGER;
               u2: INTEGER
      ): ARRAY OF ARRAY OF GENERIC:t;

    LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN
      RETURN(?);
    END_IF;
    IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN
      RETURN(?);
    END_IF;
    res := [list_to_array(lis[1],low2,u2)];
    REPEAT i := 2 TO HIINDEX(lis) BY 1;
      IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN
        RETURN(?);
      END_IF;
      res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    RETURN(res);

  END_FUNCTION; -- make_array_of_array

  FUNCTION mixed_loop_type_set(
               l: SET [0:?] OF loop
      ): LOGICAL;

    LOCAL
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) <= 1 THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := 'SHIP_STRUCTURES_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('SHIP_STRUCTURES_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> 
          poly_loop_type THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);

  END_FUNCTION; -- mixed_loop_type_set

  FUNCTION msb_shells(
               brep: manifold_solid_brep
      ): SET [1:?] OF closed_shell;
    IF SIZEOF(QUERY ( msbtype <* TYPEOF(brep) | (msbtype LIKE 
        '*BREP_WITH_VOIDS') )) >= 1 THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;

  END_FUNCTION; -- msb_shells

  FUNCTION nmsf_curve_check(
               cv: representation_item
      ): BOOLEAN;
    IF SIZEOF(['SHIP_STRUCTURES_SCHEMA.BOUNDED_CURVE',
        'SHIP_STRUCTURES_SCHEMA.CONIC',
        'SHIP_STRUCTURES_SCHEMA.CURVE_REPLICA',
        'SHIP_STRUCTURES_SCHEMA.LINE',
        'SHIP_STRUCTURES_SCHEMA.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
      RETURN(FALSE);
    ELSE
      IF (('SHIP_STRUCTURES_SCHEMA.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\
          b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve.
          self_intersect = UNKNOWN) THEN
        RETURN(TRUE);
      ELSE
        IF SIZEOF(['SHIP_STRUCTURES_SCHEMA.CONIC',
            'SHIP_STRUCTURES_SCHEMA.LINE'] * TYPEOF(cv)) = 1 THEN
          RETURN(TRUE);
        ELSE
          IF 'SHIP_STRUCTURES_SCHEMA.CURVE_REPLICA' IN TYPEOF(cv) THEN
            RETURN(nmsf_curve_check(cv\curve_replica.parent_curve));
          ELSE
            IF ('SHIP_STRUCTURES_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(cv)) 
                AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
                offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
                'SHIP_STRUCTURES_SCHEMA.POLYLINE' IN TYPEOF(cv\
                offset_curve_3d.basis_curve))) THEN
              RETURN(nmsf_curve_check(cv\offset_curve_3d.basis_curve));
            ELSE
              IF 'SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(cv) THEN
                RETURN(nmsf_curve_check(cv\pcurve.reference_to_curve\
                    representation.items[1]) AND nmsf_surface_check(cv\
                    pcurve.basis_surface));
              ELSE
                IF 'SHIP_STRUCTURES_SCHEMA.SURFACE_CURVE' IN TYPEOF(cv)
                     THEN
                  IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                        associated_geometry) BY 1;
                      IF 'SHIP_STRUCTURES_SCHEMA.SURFACE' IN TYPEOF(cv\
                          surface_curve.associated_geometry[i]) THEN
                        IF NOT nmsf_surface_check(cv\surface_curve.
                            associated_geometry[i]) THEN
                          RETURN(FALSE);
                        END_IF;
                      ELSE
                        IF 'SHIP_STRUCTURES_SCHEMA.PCURVE' IN TYPEOF(cv\
                            surface_curve.associated_geometry[i]) THEN
                          IF NOT nmsf_curve_check(cv\surface_curve.
                              associated_geometry[i]) THEN
                            RETURN(FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF 'SHIP_STRUCTURES_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN
                    IF SIZEOF(cv\polyline.points) >= 3 THEN
                      RETURN(TRUE);
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- nmsf_curve_check

  FUNCTION nmsf_surface_check(
               surf: surface
      ): BOOLEAN;
    IF 'SHIP_STRUCTURES_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
      RETURN(TRUE);
    ELSE
      IF 'SHIP_STRUCTURES_SCHEMA.SWEPT_SURFACE' IN TYPEOF(surf) THEN
        RETURN(nmsf_curve_check(surf\swept_surface.swept_curve));
      ELSE
        IF (('SHIP_STRUCTURES_SCHEMA.OFFSET_SURFACE' IN TYPEOF(surf)) AND 
            (surf\offset_surface.self_intersect = FALSE)) OR (surf\
            offset_surface.self_intersect = UNKNOWN) THEN
          RETURN(nmsf_surface_check(surf\offset_surface.basis_surface));
        ELSE
          IF 'SHIP_STRUCTURES_SCHEMA.SURFACE_REPLICA' IN TYPEOF(surf)
               THEN
            RETURN(nmsf_surface_check(surf\surface_replica.parent_surface));
          ELSE
            IF (('SHIP_STRUCTURES_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(surf)) 
                AND (surf\b_spline_surface.self_intersect = FALSE)) OR (
                surf\b_spline_surface.self_intersect = UNKNOWN) THEN
              RETURN(TRUE);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- nmsf_surface_check

  FUNCTION normalise(
               arg: vector_or_direction
      ): vector_or_direction;

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      result := ?;
    ELSE
      ndim := arg.dim;
      IF 'SHIP_STRUCTURES_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          v := dummy_gri || direction(arg.orientation.direction_ratios);
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec := dummy_gri || vector(v,1);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction(arg.direction_ratios);
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'SHIP_STRUCTURES_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- normalise

  FUNCTION open_shell_reversed(
               a_shell: open_shell
      ): oriented_open_shell;

    LOCAL
      the_reverse : oriented_open_shell;
    END_LOCAL;
    IF 'SHIP_STRUCTURES_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- open_shell_reversed

  FUNCTION orthogonal_complement(
               vec: direction
      ): direction;

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result := dummy_gri || direction([-vec.direction_ratios[2],vec.
          direction_ratios[1]]);
      RETURN(result);
    END_IF;

  END_FUNCTION; -- orthogonal_complement

  FUNCTION path_head_to_tail(
               a_path: path
      ): BOOLEAN;

    LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);

  END_FUNCTION; -- path_head_to_tail

  FUNCTION path_reversed(
               a_path: path
      ): oriented_path;

    LOCAL
      the_reverse : oriented_path;
    END_LOCAL;
    IF 'SHIP_STRUCTURES_SCHEMA.ORIENTED_PATH' IN TYPEOF(a_path) THEN
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path\oriented_path.path_element,
          NOT a_path\oriented_path.orientation);
    ELSE
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- path_reversed

  FUNCTION scalar_times_vector(
               scalar: REAL;
               vec: vector_or_direction
      ): vector;

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      IF 'SHIP_STRUCTURES_SCHEMA.VECTOR' IN TYPEOF(vec) THEN
        v := dummy_gri || direction(vec.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v),mag);
    END_IF;
    RETURN(result);

  END_FUNCTION; -- scalar_times_vector

  FUNCTION second_proj_axis(
               z_axis, x_axis, arg: direction
      ): direction;

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := dummy_gri || direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

  END_FUNCTION; -- second_proj_axis

  FUNCTION set_of_topology_reversed(
               a_set: set_of_reversible_topology_item
      ): set_of_reversible_topology_item;

    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- set_of_topology_reversed

  FUNCTION shell_reversed(
               a_shell: shell
      ): shell;
    IF 'SHIP_STRUCTURES_SCHEMA.OPEN_SHELL' IN TYPEOF(a_shell) THEN
      RETURN(open_shell_reversed(a_shell));
    ELSE
      IF 'SHIP_STRUCTURES_SCHEMA.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
        RETURN(closed_shell_reversed(a_shell));
      ELSE
        RETURN(?);
      END_IF;
    END_IF;

  END_FUNCTION; -- shell_reversed

  FUNCTION surface_weights_positive(
               b: rational_b_spline_surface
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] <= 0 THEN
          result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- surface_weights_positive

  FUNCTION topology_reversed(
               an_item: reversible_topology
      ): reversible_topology;
    IF 'SHIP_STRUCTURES_SCHEMA.EDGE' IN TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.PATH' IN TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.FACE_BOUND' IN TYPEOF(an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.FACE' IN TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.SHELL' IN TYPEOF(an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);

  END_FUNCTION; -- topology_reversed

  FUNCTION using_items(
               item: founded_item_select;
               checked_items: SET OF founded_item_select
      ): SET OF founded_item_select;

    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | ((
        'SHIP_STRUCTURES_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
        'SHIP_STRUCTURES_SCHEMA.FOUNDED_ITEM' IN TYPEOF(z))) );
    IF SIZEOF(next_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);

  END_FUNCTION; -- using_items

  FUNCTION using_representations(
               item: founded_item_select
      ): SET OF representation;

    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,
        'SHIP_STRUCTURES_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],
            'SHIP_STRUCTURES_SCHEMA.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);

  END_FUNCTION; -- using_representations

  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    CASE date.month_component OF
      1 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      2 :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      3 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      4 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      5 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      6 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      7 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      8 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      9 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      10  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      11  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      12  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      END_CASE;
    RETURN(FALSE);

  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_geometrically_bounded_wf_curve(
               crv: curve
      ): BOOLEAN;
    IF SIZEOF(['SHIP_STRUCTURES_SCHEMA.POLYLINE',
        'SHIP_STRUCTURES_SCHEMA.B_SPLINE_CURVE',
        'SHIP_STRUCTURES_SCHEMA.ELLIPSE','SHIP_STRUCTURES_SCHEMA.CIRCLE'] *
         TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'SHIP_STRUCTURES_SCHEMA.TRIMMED_CURVE' IN TYPEOF(crv) THEN
        IF SIZEOF(['SHIP_STRUCTURES_SCHEMA.LINE',
            'SHIP_STRUCTURES_SCHEMA.PARABOLA',
            'SHIP_STRUCTURES_SCHEMA.HYPERBOLA'] * TYPEOF(crv\trimmed_curve.
            basis_curve)) = 1 THEN
          RETURN(TRUE);
        ELSE
          RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.
              basis_curve));
        END_IF;
      ELSE
        IF 'SHIP_STRUCTURES_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
          RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.
              basis_curve));
        ELSE
          IF 'SHIP_STRUCTURES_SCHEMA.CURVE_REPLICA' IN TYPEOF(crv) THEN
            RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.
                parent_curve));
          ELSE
            IF 'SHIP_STRUCTURES_SCHEMA.COMPOSITE_CURVE' IN TYPEOF(crv)
                 THEN
              RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments | 
                  (NOT valid_geometrically_bounded_wf_curve(ccs.
                  parent_curve)) )) = 0);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_geometrically_bounded_wf_curve

  FUNCTION valid_geometrically_bounded_wf_point(
               pnt: point
      ): BOOLEAN;
    IF 'SHIP_STRUCTURES_SCHEMA.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'SHIP_STRUCTURES_SCHEMA.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
        RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.
            basis_curve));
      ELSE
        IF 'SHIP_STRUCTURES_SCHEMA.POINT_REPLICA' IN TYPEOF(pnt) THEN
          RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.
              parent_pt));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_geometrically_bounded_wf_point

  FUNCTION valid_measure_value(
               m: measure_value
      ): BOOLEAN;
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m > 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN
        RETURN(m > 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;

  END_FUNCTION; -- valid_measure_value

  FUNCTION valid_time(
               time: local_time
      ): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- valid_time

  FUNCTION valid_units(
               m: measure_with_unit
      ): BOOLEAN;
    IF 'SHIP_STRUCTURES_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_STRUCTURES_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- valid_units

  FUNCTION valid_wireframe_edge_curve(
               crv: curve
      ): BOOLEAN;
    IF SIZEOF(['SHIP_STRUCTURES_SCHEMA.LINE',
        'SHIP_STRUCTURES_SCHEMA.CONIC',
        'SHIP_STRUCTURES_SCHEMA.B_SPLINE_CURVE',
        'SHIP_STRUCTURES_SCHEMA.POLYLINE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'SHIP_STRUCTURES_SCHEMA.CURVE_REPLICA' IN TYPEOF(crv) THEN
        RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
      ELSE
        IF 'SHIP_STRUCTURES_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
          RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.
              basis_curve));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_edge_curve

  FUNCTION valid_wireframe_vertex_point(
               pnt: point
      ): BOOLEAN;
    IF 'SHIP_STRUCTURES_SCHEMA.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'SHIP_STRUCTURES_SCHEMA.POINT_REPLICA' IN TYPEOF(pnt) THEN
        RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_vertex_point

  FUNCTION vector_difference(
               arg1, arg2: vector_or_direction
      ): vector;

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      RETURN(?);
    ELSE
      BEGIN
        IF 'SHIP_STRUCTURES_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'SHIP_STRUCTURES_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(vec1,0);
        END_IF;
      END;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- vector_difference

  FUNCTION which_class(
               t: GENERIC
      ): LIST OF STRING;

    LOCAL
      class_list : LIST OF STRING := [];
      elements   : BAG OF applied_classification_assignment;
    END_LOCAL;
    elements := USEDIN(t,
        'SHIP_STRUCTURES_SCHEMA.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS');
    REPEAT i := 1 TO HIINDEX(elements) BY 1;
      IF elements[i]\classification_assignment.role.name = 
          'class membership' THEN
        class_list := class_list + elements[i]\classification_assignment.
            assigned_class\group.name;
      END_IF;
    END_REPEAT;
    RETURN(class_list);

  END_FUNCTION; -- which_class

END_SCHEMA; -- ship_structures_schema
