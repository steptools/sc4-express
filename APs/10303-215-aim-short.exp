(*  AIM EXPRESS short form for ISO/IS 10303-215
    2003-12-14
    Peter Lazo
    ISO TC184/SC4 WG3 N1231
*)

SCHEMA Ship_arrangement_schema;

    USE FROM aic_non_manifold_surface                 -- ISO 10303-508
    (non_manifold_surface_shape_representation);
    
    USE FROM aic_topologically_bounded_surface        -- ISO 10303-511
    (advanced_face);

    USE FROM action_schema                            -- ISO 10303-41
    (action,
    action_method,
    action_request_solution,
    executed_action,
    versioned_action_request);
    
   USE FROM application_context_schema                -- ISO 10303-41
   (application_context,
   application_protocol_definition);

    USE FROM approval_schema                          -- ISO 10303-41
   (approval,
    approval_date_time,
    approval_person_organization,
    approval_status);

   USE FROM basic_attribute_schema                    -- ISO 10303-41
   (object_role);
    
   USE FROM date_time_schema                          -- ISO 10303-41
   (calendar_date,
   date_and_time,
   date_time_role,
   ordinal_date,
   week_of_year_and_day_date);

   USE FROM document_schema                           -- ISO 10303-41
   (document,
    document_representation_type,
    document_usage_constraint);

   USE FROM external_reference_schema                 -- ISO 10303-41
   (external_source,
   external_source_relationship);

  USE FROM effectivity_schema                        -- ISO 10303-41
   (effectivity,
    serial_numbered_effectivity);

  USE FROM geometric_model_schema                     -- ISO 10303-42
   (face_based_surface_model); 

  REFERENCE FROM geometry_schema                       -- ISO 10303-42
   (dummy_gri); 

  USE FROM geometry_schema                            -- ISO 10303-42
   (axis2_placement_2d,
    axis2_placement_3d,
    bezier_curve,
    bezier_surface,
    b_spline_curve,
    b_spline_curve_with_knots,
    b_spline_surface,
    b_spline_surface_with_knots,
    bounded_curve,
    bounded_pcurve,
    bounded_surface_curve,
    cartesian_point,
    cartesian_transformation_operator_3d, 
    circle,
    composite_curve_on_surface,
    conical_surface,
    curve, 
    curve_replica, 
    cylindrical_surface,
    degenerate_pcurve,
    degenerate_toroidal_surface, 
    direction,
    ellipse,
    evaluated_degenerate_pcurve, 
    geometric_representation_context,
    geometric_representation_item,
    hyperbola,
    intersection_curve, 
    line,
    offset_curve_3d, 
    offset_surface, 
    oriented_surface,
    point_on_curve, 
    point_on_surface, 
    parabola,
    pcurve,
    plane,
    polyline,
    quasi_uniform_curve,
    quasi_uniform_surface,
    rational_b_spline_curve,
    rational_b_spline_surface,
    seam_curve, 
    spherical_surface,
    surface, 
    surface_curve,
    surface_of_linear_extrusion,
    surface_of_revolution,
    surface_replica,
    swept_surface,
    toroidal_surface,
    uniform_curve,
    uniform_surface,
    vector);

   USE FROM group_schema                               -- ISO 10303-41
   (group,
    group_relationship);

   USE FROM management_resources_schema                -- ISO 10303-41
   (action_assignment,
    action_request_assignment,
    approval_assignment,
    classification_assignment,
    classification_role,
    date_and_time_assignment,
    document_reference,
    effectivity_assignment,
    external_identification_assignment,
    group_assignment,
    identification_assignment,
    identification_assignment_relationship,
    identification_role,
    organization_assignment,
    person_assignment,
    person_and_organization_assignment);

   USE FROM material_property_definition_schema        -- ISO 10303-41
   (property_definition_relationship);

  USE FROM measure_schema                              -- ISO 10303-41
    (amount_of_substance_measure,
    area_measure,
    context_dependent_measure,
    context_dependent_unit,
    count_measure,
    derived_unit,
    electric_current_measure,
    derived_unit_element,
    global_unit_assigned_context,
    length_measure,
    length_unit,
    luminous_intensity_measure,
    luminous_intensity_unit,
    mass_measure,
    mass_unit,
    named_unit,
    parameter_value,
    plane_angle_measure,
    plane_angle_unit,
    positive_length_measure,
    positive_plane_angle_measure,
    ratio_measure,
    ratio_unit,
    si_unit,
    solid_angle_measure,                             
    thermodynamic_temperature_measure,
    thermodynamic_temperature_unit,
    time_measure,
    time_unit,
    volume_measure);     

   USE FROM person_organization_schema                -- ISO 10303-41
   (address,
    person,
    person_and_organization,
    person_and_organization_role,
    personal_address,
    organization,
    organizational_address,
    organizational_project);

   USE FROM product_definition_schema                 -- ISO 10303-41
   (product,
   product_category,
   product_definition,
   product_definition_relationship,
   product_definition_with_associated_documents,
   product_related_product_category);
   
   USE FROM product_property_definition_schema        -- ISO 10303-41
   (characterized_product_definition,
    characterized_object,
    product_definition_shape,
    property_definition,
    shape_aspect);
   
   USE FROM product_property_representation_schema    -- ISO 10303-41
   (property_definition_representation,
    shape_definition_representation, 
    shape_representation);

   USE FROM qualified_measure_schema                  -- ISO 10303-45
   (descriptive_representation_item);

   USE FROM representation_schema                     -- ISO 10303-43
    (compound_item_definition,
    compound_representation_item,
    global_uncertainty_assigned_context,
    definitional_representation,
    founded_item,
    item_defined_transformation,
    list_representation_item,
    mapped_item,
    parametric_representation_context,
    representation,
    representation_item,
    representation_map,
    representation_relationship,
    set_representation_item,
    uncertainty_measure_with_unit,
    value_representation_item);
    
   USE FROM support_resource_schema                    -- ISO 10303-41
    (label); 
   
  REFERENCE FROM topology_schema                       -- ISO 10303-42
   (dummy_tri); 

   USE FROM topology_schema                            -- ISO 10303-42
   (edge,
    edge_curve,
    edge_loop,
    face_bound,
    face_outer_bound,
    face_surface,
    oriented_edge,
    path,
    poly_loop,
    oriented_path,
    closed_shell,
    connected_face_set, 
    face,
    shell,
    open_shell, 
    oriented_face,
    vertex_loop,
    vertex_point); 

TYPE action_item = SELECT
    (action_request_solution,
     document,
     executed_action,
     group,
     product,
     product_definition,
     product_definition_relationship,
     product_definition_shape,
     product_related_product_category,
     property_definition
     );
END_TYPE;

TYPE action_request_item = SELECT(
   action, executed_action);
END_TYPE;

TYPE approval_item = SELECT(
	product_definition,
	product_definition_shape,
	product_related_product_category,
	property_definition
	);   
END_TYPE;

TYPE classification_item = SELECT(
   action,
   action_request_solution,
   applied_action_request_assignment,
   approval,
   compound_representation_item, 
   document,
   executed_action,
   external_source,
   group,
   identification_assignment_relationship,
   product,
   product_definition, 
   product_definition_relationship, 
   product_definition_shape, 
   product_related_product_category,
   property_definition,
   property_definition_representation,
   representation,
   shape_aspect,
   versioned_action_request);
END_TYPE;

TYPE date_and_time_item = SELECT(
   action,
   action_request_solution,  
   executed_action ,
   product_definition, 
   property_definition,
   property_definition_representation,
   versioned_action_request);
END_TYPE;

TYPE document_reference_item = SELECT (
   action,
   product,
   product_definition,
   property_definition);
END_TYPE;

TYPE effectivity_item = SELECT(
   product_definition,
   product_definition_shape,
   product_related_product_category,
   property_definition
	);
END_TYPE;

TYPE external_identification_item = SELECT(
	action,
	document,
	product,
	product_definition,
	property_definition,
	shape_aspect);   
END_TYPE;

TYPE group_item = SELECT(
	applied_external_identification_assignment,
	approval,
	document,
	group,
	identification_assignment_relationship,
	product,
	product_definition,
	product_definition_relationship,
	product_definition_shape,
	product_related_product_category,
	property_definition);
END_TYPE;

TYPE identification_item = SELECT(
   action,
   action_request_solution,
   document,
   executed_action,
   group,
   product,
   product_definition,
   product_definition_relationship,
   product_definition_shape,
   product_related_product_category,
   property_definition,
   versioned_action_request);
END_TYPE;

TYPE organization_item = SELECT(
   document,
   product_definition, 
   property_definition);
END_TYPE;

TYPE person_item = SELECT(
   document);
END_TYPE;

TYPE person_and_organization_item = SELECT(
   action,
   action_request_solution,  
   document,
   executed_action, 
   versioned_action_request);
END_TYPE;

ENTITY applied_action_assignment
  SUBTYPE OF (action_assignment);
  items : SET [1:?] OF action_item;
END_ENTITY;

ENTITY applied_action_request_assignment
  SUBTYPE OF (action_request_assignment);
  items: SET[1:?] OF action_request_item;
END_ENTITY;

ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
END_ENTITY;

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items: SET[1:?] OF classification_item;
END_ENTITY;

ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items: SET[1:?] OF date_and_time_item;
END_ENTITY;  

ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items: SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY applied_effectivity_assignment
SUBTYPE OF (effectivity_assignment);
items : SET [1:?] OF effectivity_item;
END_ENTITY; -- applied_effectivity_assignment

ENTITY applied_external_identification_assignment
  SUBTYPE OF (external_identification_assignment);
  items: SET[1:?] OF external_identification_item;
END_ENTITY;

ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items: SET[1:?] OF group_item;
END_ENTITY;

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items: SET[1:?] OF identification_item;
END_ENTITY;

ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items: SET[1:?] OF organization_item;
END_ENTITY;

ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items: SET[1:?] OF person_and_organization_item;
END_ENTITY;

ENTITY applied_person_assignment
  SUBTYPE OF (person_assignment);
  items: SET[1:?] OF person_item;
END_ENTITY;

  ENTITY class
    SUBTYPE OF (group);
    WHERE
     WR1:   (SIZEOF(QUERY ( oa <* USEDIN(SELF,
            'SHIP_ARRANGEMENT_SCHEMA.GROUP_ASSIGNMENT.ASSIGNED_GROUP')|
         NOT ('SHIP_ARRANGEMENT_SCHEMA.APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(oa)) 
             )) =0);
  END_ENTITY; -- class

RULE action_request_solution_connected_to_action
FOR(action_request_solution, action);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    t2_set:  SET OF action := [];
    set_3 :  SET OF ACTION_METHOD := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of action_request_solution with class 'change plan' *)
t1_set := QUERY(a <* action_request_solution |
 VALUE_IN(WHICH_CLASS(a), 'change plan'));

(* get all instances of action with class 'change' *)
t2_set := QUERY(b <* action | VALUE_IN(WHICH_CLASS(b), 'change'));

(* for all instances found above *)
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   set_3 := [];
   REPEAT j := 1 TO HIINDEX(t2_set);
      set_3 := set_3 + [t2_set[j].chosen_method]; 
   END_REPEAT;

   violate := VALUE_IN(set_3, t1_set[i].method);
END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE action_request_solution_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF action_request_solution := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['change plan'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
     t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');

      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE action_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF action := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['change', 'versionable object change event', 'check'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances*)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
  'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
     t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE alternative_version_relationship_has_mandatory_description
FOR (identification_assignment_relationship);
LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of identification_assignment_relationship *)
(*being classified as 'alternative version relationship' *)
t1_set := QUERY(i <* identification_assignment_relationship | 
  VALUE_IN(WHICH_CLASS(i), 'alternative version relationship')); 

(* from all instances found above:
   find those for which attribute description is not instantiated
*)
violate := (SIZEOF(QUERY(k <* t1_set | NOT EXISTS (k.description))) > 0);

WHERE
    wr1: NOT violate; 
END_RULE;

RULE alternative_version_relationship_has_unique_versions
FOR (identification_assignment_relationship);

LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
END_LOCAL;

(* get all instances of identification_assignment_relationship with
class 'alternative version relationship' *)
   t1_set := QUERY(a <* identification_assignment_relationship | 
      VALUE_IN(WHICH_CLASS(a), 'alternative version relationship'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    violate := 
          ( t1_set[i].relating_identification_assignment.assigned_id =
            t1_set[i].related_identification_assignment.assigned_id );
END_REPEAT; 

WHERE
    wr1: NOT violate; 
END_RULE;

RULE alternative_version_relationship_versionable_object
FOR (applied_identification_assignment,
     identification_assignment_relationship);
LOCAL
 violate: LOGICAL := FALSE;
END_LOCAL;

(* get all instances of applied_identification_assignment *)
REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1 WHILE NOT violate;

 IF ( (SIZEOF(USEDIN(applied_identification_assignment[i],
            ('SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
             +'RELATING_IDENTIFICATION_ASSIGNMENT'))) > 0) OR
      (SIZEOF(USEDIN(applied_identification_assignment[i],
            ('SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
             +'RELATED_IDENTIFICATION_ASSIGNMENT'))) > 0) ) THEN
  REPEAT j := 1 to HIINDEX(applied_identification_assignment[i].items) BY 1 WHILE NOT violate;
 violate := NOT VALUE_IN(which_class(
applied_identification_assignment [i].items[j]),'versionable object');
  END_REPEAT;
 END_IF;

END_REPEAT;

WHERE
wr1: NOT violate;
END_RULE;

RULE applied_approval_assignment_has_exactly_one_elements
FOR (object_role, applied_approval_assignment);
WHERE
    WR1: SIZEOF(QUERY(ass_inst <* applied_approval_assignment |
           NOT((ass_inst.role.name = 'subject')
               AND
               (SIZEOF(ass_inst.items) = 1)
              )
           )) = 0;
END_RULE;

RULE 
applied_group_assignment_has_at_least_one_elements
FOR (object_role, applied_group_assignment);
WHERE
    WR1: SIZEOF(QUERY(ass_inst <* applied_group_assignment | 
           NOT((ass_inst.role.name = 'approvals') 
               AND
               (SIZEOF(ass_inst.items) >= 1)
               AND
               (SIZEOF(QUERY(item <* ass_inst.items |
                  NOT('SHIP_ARRANGEMENT_SCHEMA.APPROVAL' 
                  IN TYPEOF(item)))) = 0) 
              )
           )) = 0;
END_RULE;

RULE approval_event_with_approval_date_time
FOR(approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF approval_date_time := [];
    violate: LOGICAL := FALSE;
    
  END_LOCAL;

t1_set := QUERY(i <* approval |
 VALUE_IN(WHICH_CLASS(i), 'approval event')); 

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPROVAL_DATE_TIME.' +
'DATED_APPROVAL'));
(* stop, if there total number is not equal to 1 *) 
    violate := NOT (SIZEOF(t2_set) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violate;
END_RULE;

RULE approval_event_with_approval_person_organization
FOR(approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF approval_person_organization := [];
    violate: LOGICAL := FALSE;

  END_LOCAL;

t1_set := QUERY(i <* approval |
 VALUE_IN(WHICH_CLASS(i), 'approval event')); 

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPROVAL_PERSON_ORGANIZATION.' + 'AUTHORIZED_APPROVAL'));
 
    violate := NOT (SIZEOF(t2_set) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violate;
END_RULE;

RULE approval_history_approves_same_definition
FOR (applied_group_assignment, applied_approval_assignment);
LOCAL
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    t3_set:  SET OF APPROVAL :=[];  
    t4_set:  SET OF group_item :=[];   
    t5_set:  SET OF APPLIED_APPROVAL_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;

t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
                VALUE_IN(WHICH_CLASS(a.ASSIGNED_GROUP),
				'approval history'));

t3_set := QUERY(b <* t2_set[1].items |
 'SHIP_ARRANGEMENT_SCHEMA.APPROVAL' IN TYPEOF(b));

t4_set := QUERY(b <* t2_set[1].items |
 VALUE_IN(WHICH_CLASS(b), 'definition'));

violate := NOT(SIZEOF(t4_set) = 1);

REPEAT i := 1 TO HIINDEX(t3_set) WHILE NOT violate;
    t5_set := QUERY(a <* APPLIED_APPROVAL_ASSIGNMENT | 
(a.ASSIGNED_APPROVAL = t3_set[i]) AND
(NOT (VALUE_IN(a.ITEMS, t4_set[1]))));

    violate := (SIZEOF(t5_set) > 0);
  END_REPEAT;

WHERE
    wr1: NOT violate; 
    wr2: (SIZEOF(t4_set) = 1);
END_RULE;

RULE approval_history_has_at_least_one_member
FOR (GROUP, APPLIED_GROUP_ASSIGNMENT);
LOCAL
    t1_set:  SET OF GROUP := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;

t1_set := QUERY(i <* group |
 VALUE_IN(WHICH_CLASS(i), 'approval history')); 

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT |
		 a.ASSIGNED_GROUP = t1_set[i]);

    violate := NOT(SIZEOF(t2_set) = 1);
  END_REPEAT;

WHERE
    wr1: NOT violate; 
END_RULE;

RULE approvals_references_approval_history
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group |
 VALUE_IN(WHICH_CLASS(a), 'approval history'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_group_assignment | 
   NOT ((b.assigned_group = t1_set[i]) AND (b.role.name = 'approvals')));

    violate := SIZEOF(a_set) > 0;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE author_for_change_plan
FOR(applied_person_and_organization_assignment, action_request_solution);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action_request_solution | 
             VALUE_IN(WHICH_CLASS(a), 'change plan'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE author_for_change_realization
FOR(applied_person_and_organization_assignment,executed_action);
  LOCAL
    t1_set:  SET OF executed_action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* executed_action | 
             VALUE_IN(WHICH_CLASS(a), 'change realization'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE author_for_change_request
FOR(applied_person_and_organization_assignment, versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_check
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 'check'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_envisaged_version_creation
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'envisaged version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_version_creation
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:   SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_version_deletion
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version deletion'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_by_for_version_modification
FOR(applied_person_and_organization_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:   SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version modification'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_check
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 'check'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_envisaged_version_creation
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 
             'envisaged version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_version_creation
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_version_deletion
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version deletion'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE caused_when_for_version_modification
FOR(applied_date_and_time_assignment, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version modification'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE centre_location_compound_representation_has_specified_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['longitudinal location', 'transversal location', 'vertical location'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'centre location' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'centre location');

  (* get all instances of compound_representation_item that have class id 'centre location' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE change_impact_with_versionable_object_change_event
FOR(applied_action_request_assignment);
  LOCAL
    t1_set:  SET OF applied_action_request_assignment := [];
    a_set:   SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  
   t1_set := QUERY(b <* applied_action_request_assignment | 
                   (b.role.name= 'change impact'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
          a_set := QUERY(b <* t1_set[i].items | 
          ('SHIP_ARRANGEMENT_SCHEMA.ACTION' IN TYPEOF(b)) AND
             VALUE_IN(WHICH_CLASS(b), 'versionable object change event'));
         violate := SIZEOF(a_set) = 0;
      END_REPEAT;

WHERE
    WR1: NOT violate;
END_RULE;

RULE change_plan_has_mandatory_attribute_description
FOR (action_request_solution);
LOCAL
    t1_set:  SET OF action_request_solution := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action_request_solution | 
  VALUE_IN(WHICH_CLASS(i), 'change plan')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE class_and_statutory_designation_has_properties
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_list: LIST OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_list: LIST OF property_definition := [];
    t4_list: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_list := t1_list + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'class and statutory designation');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_list := t3_list + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_list);
    t4_list := t4_list + t3_list[i].definition;
  END_REPEAT;
  violation := t1_list <> t4_list;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE class_notation_with_named_representation_items
FOR (representation);
LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['class notations hull', 
                                  'class notations machinery'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
             'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
             'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) < 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE class_parameters_has_properties
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class parameters');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'class parameters');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE date_time_for_change_plan
FOR(applied_date_and_time_assignment,  action_request_solution);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action_request_solution | 
             VALUE_IN(WHICH_CLASS(a), 'change plan'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE date_time_for_change_realization
FOR(applied_date_and_time_assignment, executed_action);
  LOCAL
    t1_set:  SET OF executed_action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* executed_action | 
             VALUE_IN(WHICH_CLASS(a), 'change realization'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE date_time_for_change_request
FOR(applied_date_and_time_assignment,  versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE document_has_at_least_one_references
FOR(document);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF document_representation_type := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
                                   'document')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.DOCUMENT_REPRESENTATION_TYPE.'+
      'REPRESENTED_DOCUMENT'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE document_has_exactly_one_author
FOR(document);
  LOCAL
    bag_1: BAG OF applied_person_assignment := [];
    bag_2: BAG OF applied_person_and_organization_assignment := [];
    bag_3: BAG OF applied_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
REPEAT i := 1 TO SIZEOF(document) WHILE (NOT violate);
  bag_1 := USEDIN(document[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
         'APPLIED_PERSON_ASSIGNMENT.ITEMS'); 
     bag_1 := QUERY( assign <* bag_1 | assign.role.name = 'author');
   bag_2 := USEDIN(document[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
         'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS');
  bag_2 := QUERY( assign <* bag_2 | assign.role.name = 'author');
  bag_3 := USEDIN(document[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
         'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS');

  bag_3 := QUERY( assign <* bag_3 | assign.role.name = 'author');
    violate := NOT ((SIZEOF( bag_1 ) + SIZEOF( bag_2 )+ SIZEOF( bag_3 ))= 1);
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE document_reference_with_address_has_at_least_one_references
FOR(document);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF applied_external_identification_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
                                'document reference with address')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
  'SHIP_ARRANGEMENT_SCHEMA.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE envisaged_version_creation_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
   'envisaged version creation')); 
   violate := (SIZEOF(QUERY(k <* t1_set | 
   NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;

RULE executed_action_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF executed_action := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'change realization'];
    violation: LOGICAL := FALSE;
  END_LOCAL;


    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
	t2_set := QUERY ( j <* t2_set | j.role.name = 'globally unambiguous identifier');
      	violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE external_instance_reference_has_same_identifier 
FOR (applied_external_identification_assignment);
LOCAL
 violation    : LOGICAL := FALSE;
 extref_set   : SET OF applied_external_identification_assignment := [];
 aia_set      : SET OF applied_identification_assignment := [];
END_LOCAL;

 extref_set := QUERY ( i <* applied_external_identification_assignment | 	(i.role.name = 'external instance reference'));

 REPEAT i := 1 TO HIINDEX(extref_set) BY 1 WHILE NOT violation;
   aia_set := USEDIN(extref_set[i].items[1],
       'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS');
   violation := NOT (aia_set[1].assigned_id = extref_set[i].assigned_id);
 END_REPEAT;
 WHERE
   wr1: NOT violation;
 END_RULE;

RULE floating_position_compound_representation_with_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['moulded form displacement', 'draught at amidships', 'length of waterline', 'breadth of waterline', 'angle of trim', 'angle of heel'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'floating position');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
  violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE freeboard_characteristics_has_properties
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'freeboard characteristics');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'freeboard characteristics');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE global_axis_placement_has_properties
FOR (property_definition_representation, 
group, applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'global axis placement');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'global axis placement');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE global_id_is_unique 
FOR (APPLIED_IDENTIFICATION_ASSIGNMENT);
  LOCAL
    set_1:  SET OF APPLIED_IDENTIFICATION_ASSIGNMENT:= [];
    bag_2:     BAG OF STRING := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all instances of guid  *)


  set_1 := QUERY(i <* APPLIED_IDENTIFICATION_ASSIGNMENT |
          (i.role.name = 'globally unambiguous identifier'));

REPEAT i := 1 TO HIINDEX(set_1);
    bag_2 := bag_2 + [set_1[i].assigned_id];

END_REPEAT;
violation := SIZEOF (QUERY(i <* set_1 | (SIZEOF(i.items) = 1))) <> SIZEOF(set_1);

WHERE
    WR1: VALUE_UNIQUE(bag_2);
    WR2: NOT violation;
END_RULE;

RULE identification_role_optional_attribute_description_required
FOR (identification_role);
WHERE
 wr1: SIZEOF(QUERY(i <* identification_role |
 		((i.name = 'external reference')
 		AND NOT(EXISTS (i.description))))) = 0;
END_RULE;

RULE initiator_for_change_request
FOR(applied_person_and_organization_assignment,
    versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'initiator')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE lightship_definition_has_properties

FOR (property_definition_representation, 
group, applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'lightship definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'lightship definition parameters');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE mandatory_entity_type_for_external_instance_reference  
FOR(external_source, external_source_relationship);
  LOCAL
    bag_1: BAG OF external_source := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
bag_1 := QUERY(a <* external_source | a.description = 'schema name');
 
REPEAT i := 1 TO SIZEOF(bag_1) WHILE (NOT violate);
violate := (SIZEOF( QUERY(
    a <* external_source_relationship | (a.relating_source :=: bag_1[i]) AND 
           (a.related_source.description = 'entity type'))) = 0 );
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;

RULE members_is_referenced_by_at_least_one_revision
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'revision'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
       (b.assigned_group :=: t1_set[i]) AND (b.role.name = 'members'));

    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE no_approvals_except_in_approval_history
FOR (approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
   t1_set := QUERY(a <* approval |
		 VALUE_IN(WHICH_CLASS(a), 'approval event'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   t2_set := bag_to_set(USEDIN(t1_set[i], 
   'SHIP_ARRANGEMENT_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
    violate := (SIZEOF(t2_set) = 0);
   REPEAT k := 1 TO HIINDEX(t2_set) WHILE NOT violate;
      violate := NOT (VALUE_IN(WHICH_CLASS(t2_set[k].ASSIGNED_GROUP), 
      'approval history'));
   END_REPEAT;
END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;

RULE principal_characteristics_has_properties
FOR (property_definition_representation,
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set: LIST OF product_definition := [];
    t2_set: SET OF property_definition_representation := [];
    t3_set: LIST OF property_definition := [];
    t4_set: LIST OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
          i.assigned_class.NAME = 'principal characteristics');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'principal characteristics');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;

RULE product_definition_for_call_sign
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],         'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
		t2_inst.role.name = 'call sign')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_certifying_organization
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
             i.assigned_class.name = 'coating certification');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	t2_inst.role.name = 'certifying organization')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_class_notation
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 	
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
		 'class notation' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE product_definition_for_expiry_date
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'coating certification' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'coating certification');

  (* get all instances of T1 that have class id 'coating certification' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of product_definition in t1_set:
     get the applied_date_and_time_assignment instances that are referencing a product_definition instance via items,
     filter out those applied_date_and_time_assignment instances whose attribute role has the value 'expiry date'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.role.name = 'expiry date')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_flag_state
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'flag state')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_loadline
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'freeboard characteristics');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
	 'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	 'loadline' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_managing_company
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =
                    'owner designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
    'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'managing company')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_ordering_company
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'owner designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 
    'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'ordering company')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_owning_company
FOR(applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'owner designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_ARRANGEMENT_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'owning company')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_port_of_registration
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name =
     'port of registration')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_for_regulation
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
             i.assigned_class.NAME = 'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
		'regulation' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE product_definition_for_shipyard
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'shipyard designation');
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_ARRANGEMENT_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'shipyard')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_relationship_references_are_distinct
FOR (product_definition_relationship);
  LOCAL
    cyclic_relationship: LOGICAL := FALSE;
  END_LOCAL;

  REPEAT i := 1 TO HIINDEX(product_definition_relationship) 
                                               WHILE NOT cyclic_relationship;
    cyclic_relationship:= 
                product_definition_relationship[i].related_product_definition 
                  :=: product_definition_relationship[i].relating_product_definition;
  END_REPEAT;

  WHERE
    wr1: NOT cyclic_relationship;
END_RULE;

RULE product_definition_relationship_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_relationship := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['space arrangement relationship'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id in arg_list *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  (* get all instances of property_definition_representation *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
	t2_set := QUERY ( j <* t2_set |
  j.role.name = 'globally unambiguous identifier');
     violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_shape_for_deck_zone_design
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'deck zone design definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'deck zone design definition');

  (* get all instances of T1 that have class id 'deck zone design definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of product_definition_shape in t1_set:
     get the property_definition_representation instances that are referencing a product_definition_shape instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'deck zone design parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	 t2_inst.name = 'deck zone design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_shape_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
 c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
 t1_set: SET OF product_definition_shape := [];
 t2_set: SET OF applied_identification_assignment := [];
 arg_list: LIST OF STRING := ['design definition'];
 violation: LOGICAL := FALSE;
END_LOCAL;

(* get all classification_assignment instances with id in arg_list *)
REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
		   i.assigned_class.NAME = arg_LIST[j]);
END_REPEAT;

(* get all instances of product_definition_shape that have class id *)
REPEAT i := 1 TO HIINDEX(c_a_set);
 REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
  t1_set := t1_set + c_a_set[i].items[j];
 END_REPEAT;
END_REPEAT;

REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
 t2_set := bag_to_set(USEDIN(t1_set[i],
    'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
 t2_set := QUERY ( j <* t2_set | 
		     j.role.name = 'globally unambiguous identifier'); 
 violation := NOT (SIZEOF(T2_SET) = 1);
END_REPEAT;
WHERE
wr1: NOT violation;
END_RULE;

RULE product_definition_with_date_freeboard_assigned
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                i.assigned_class.name = 'freeboard characteristics');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	 t2_inst.role.name = 'date freeboard assigned')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_with_freeboard_assigned_by
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
               i.assigned_class.name = 'freeboard characteristics');

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
	 'SHIP_ARRANGEMENT_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
		 t2_inst.role.name = 'freeboard assigned by')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := [ 'definition',
                                   'definable object'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances  *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  (* get all instances of product_definition that have class id *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
		     j.role.name = 'globally unambiguous identifier');
              violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_related_product_category_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_related_product_category := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['shiptype'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id  *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  (* get all instances that have class id *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');
           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['ship'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');
           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_class_bulk_load_requirement_definition
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'class bulk load requirement definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
       i.assigned_class.name = 'class bulk load requirement definition');

  (* get all instances of T1 that have class id 'class bulk load requirement definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'class bulk load requirement definition parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'class bulk load requirement definition parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_class_compartment_requirement_definition
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'class compartment requirement definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
      i.assigned_class.name = 'class compartment requirement definition');

  (* get all instances of T1 that have class id 'class compartment requirement definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'class compartment requirement definition parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
t2_inst.name = 'class compartment requirement definition parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_class_deck_load_requirement_definition
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'class deck load requirement definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
      i.assigned_class.name = 'class deck load requirement definition');

  (* get all instances of T1 that have class id 'class deck load requirement definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'class deck load requirement definition parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
t2_inst.name = 'class deck load requirement definition parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_class_notation
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'class notation' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'class notation');

  (* get all instances of T1 that have class id 'class notation' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'class notation'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'class notation')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_class_society
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'class notation' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'class notation');

  (* get all instances of T1 that have class id 'class notation' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the applied_organization_assignment instances that are referencing a property_definition instance via items,
     filter out those applied_organization_assignment instances whose attribute role has the value 'class society'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.role.name = 'class society')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_class_tank_requirement_definition
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'class tank requirement definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
        i.assigned_class.name = 'class tank requirement definition');

  (* get all instances of T1 that have class id 'class tank requirement definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'class tank requirement definition parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'class tank requirement definition parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_compartment_design_requirement
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'compartment design requirement' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
      i.assigned_class.name = 'compartment design requirement');

  (* get all instances of T1 that have class id 'compartment design requirement' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'compartment design requirement parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'compartment design requirement parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_compartment_function
FOR(property_definition, property_definition_representation, APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'compartment functional definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
     i.assigned_class.name = 'compartment functional definition');

  (* get all instances of T1 that have class id 'compartment functional definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'compartment function parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'compartment function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_compensated_gross_tonnage
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'tonnage definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
         i.assigned_class.name = 'tonnage definition');

  (* get all instances of property_definition that have class id 'tonnage definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose class id is 'compensated gross tonnage'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 'compensated gross tonnage' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_damage_stability_definition_requires_reference
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF representation := [];
    t3_set:  SET OF property_definition_representation := [];
    t4_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'damage stability definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'damage stability definition');

  (* get all instances of property_definition that have class id 'damage stability definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'stability table' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'stability table');

  (* get all instances of representation that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all property_definition_representation instances which have as the 
.used_representation the representation instances that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + bag_to_set(USEDIN(t2_set[i], 
            'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'));
  END_REPEAT;

(* get all property_definition instances which are the .definition of the 
property_definition *)
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;

(* compare both lists with product_definition instances which have to be identical *)
  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;
  
END_RULE;

RULE property_definition_for_date_of_loading
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'loading condition operating definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
         i.ASSIGNED_CLASS.NAME = 'loading condition operating definition');

  (* get all instances of T1 that have class id 'loading condition operating definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the applied_date_and_time_assignment instances that are referencing a property_definition instance via items,
     filter out those applied_date_and_time_assignment instances whose attribute role has the value 'date of loading'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.role.name = 'date of loading')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_deck_zone_function
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'deck zone functional definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
         i.assigned_class.name = 'deck zone functional definition');

  (* get all instances of T1 that have class id 'deck zone functional definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'deck zone function parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'deck zone function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_gross_tonnage
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'tonnage definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
              i.assigned_class.name = 'tonnage definition');

  (* get all instances of property_definition that have class id 'tonnage definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose class id is 'gross tonnage'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 'gross tonnage' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_local_coordinate_system
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'local co ordinate system' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'local co ordinate system');

  (* get all instances that have class id 'local co ordinate system' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set: get the property_definition_representation instances that are referencing a property_definition instance via definition, filter out those property_definition_representation instances whose attribute name has the value 'local coordinate system'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	t2_inst.name = 'local coordinate system')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_local_coordinate_system_with_position
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'local co ordinate system with position reference');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'local coordinate system with position reference')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE property_definition_for_net_tonnage
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'tonnage definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'tonnage definition');

  (* get all instances of property_definition that have class id 'tonnage definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose class id is 'net tonnage'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
	 'net tonnage' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_stability_definition_requires_reference
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF representation := [];
    t3_set:  SET OF property_definition_representation := [];
    t4_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'stability definition');

  (* get all instances of property_definition that have class id 'stability definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'stability table' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'stability table');

  (* get all instances of representation that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all property_definition_representation instances which have as the 
.used_representation the representation instances that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + bag_to_set(USEDIN(t2_set[i], 
            'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'));
  END_REPEAT;

(* get all property_definition instances which are the .definition of the 
property_definition *)
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;

(* compare both lists with product_definition instances which have to be identical *)
  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;
  
END_RULE;

RULE property_definition_for_tonnage_definition
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'tonnage definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'tonnage definition');

  (* get all instances of T1 that have class id 'tonnage definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'tonnage definition parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'tonnage definition parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_for_zone_function
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'zone functional definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'zone functional definition');

  (* get all instances of T1 that have class id 'zone functional definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'zone function parameters'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'zone function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_has_references_with_name_loadline
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'loadline' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'loadline');

  (* get all instances of T1 that have class id 'loadline' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'loadline'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
 t2_inst.name = 'loadline')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_representation_for_date_of_measurement
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition_representation := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'tonnage measurement' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'tonnage measurement');

  (* get all instances of T1 that have class id 'tonnage measurement' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition_representation in t1_set:
     get the applied_date_and_time_assignment instances that are referencing a property_definition_representation instance via items,
     filter out those applied_date_and_time_assignment instances whose attribute role has the value 'date of 	measurement'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' +  'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 'date of 	measurement')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_representation_for_gross_tonnage
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition_representation := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'gross tonnage' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'gross tonnage');

  (* get all instances of T1 that have class id 'gross tonnage' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition_representation in t1_set:
     get the applied_date_and_time_assignment instances that are referencing 
     a property_definition_representation instance via items,
     filter out those applied_date_and_time_assignment instances 
     whose attribute role has the value 'date of measurement'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
                 'SHIP_ARRANGEMENT_SCHEMA.' +  'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 'date of measurement')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_representation_for_net_tonnage
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition_representation := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'net tonnage' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'net tonnage');

  (* get all instances of T1 that have class id 'net tonnage' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition_representation in t1_set:
     get the applied_date_and_time_assignment instances that are referencing a property_definition_representation instance via items,
     filter out those applied_date_and_time_assignment instances whose attribute role has the value 'date of 	measurement'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' +  'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 'date of measurement')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := 
['cargo bay definition', 'compartment functional definition', 'deck zone functional definition', 'design requirement', 'loading condition definition', 'local co ordinate system', 'spacing table', 'stability definition', 'tonnage definition', 'zone functional definition'];
        violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');
           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_with_lightship_weight_item
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'lightship weight item' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'lightship weight item');

  (* get all instances of T1 that have class id 'lightship weight item' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'lightship weight item'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'lightship weight item')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE property_definition_with_weight_and_centre_of_gravity
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'weight and centre of gravity' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'weight and centre of gravity');

  (* get all instances of T1 that have class id 'weight and centre of gravity' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of property_definition in t1_set:
     get the property_definition_representation instances that are referencing a property_definition instance via definition,
     filter out those property_definition_representation instances whose attribute name has the value 'weight and centre of gravity'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'weight and centre of gravity')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE representation_for_absolute_cargo
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['position', 'orientation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'absolute cargo position parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'absolute cargo position parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_adjacent_space_surface_area
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['surface area'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'adjacent space surface area parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'adjacent space surface area parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_bulk_cargo
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['natural angle of repose', 'pollution code', 'required carriage temperature', 'type of', 'un type code'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'bulk cargo parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'bulk cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_bulk_cargo_assignment
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['actual angle of repose', 'assignment context', 'cargo height',
 'cargo identifier', 'trimmed'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'bulk cargo assignment parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))
     | (temp_prop_def_rep.name = 'bulk cargo assignment parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_capacity_properties
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['capacity level origin', 'capacity centre', 'capacity level', 'capacity trim angle', 'capacity heel angle', 'capacity volume', 'capacity context'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'capacity properties' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))
       | (temp_prop_def_rep.name = 'capacity properties')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_cargo_compartment_property
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'design stowage density'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'cargo compartment property' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.name = 'cargo compartment property')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_cargo_footprint
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['contact material', 'shape', 'transferred mass'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'cargo footprint' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'cargo footprint')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_class_and_statutory_designation
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['class number'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'class and statutory designation')
                   )
              ) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_class_bulk_load_requirement_definition
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['ambient temperature', 'angle of repose', 'bulk cargo mass', 'cargo density', 'cargo height', 'coating', 'damage waterline', 'max pressure', 'max temperature', 'min pressure', 'min temperature', 'permeability', 'top of hatch'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'class bulk load requirement definition parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'class bulk load requirement definition parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_class_compartment_requirement_definition
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['ambient temperature', 'cargo density', 'cargo height', 'coating', 'damage waterline', 'max pressure', 'max temperature', 'min pressure', 'min temperature'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'class compartment requirement definition parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'class compartment requirement definition parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_class_notation
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['service area', 'approval required for oil cargo', 'approval required for loading unloading aground', 'approval required for unloading grabs'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'class notation' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_class_parameters
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['length class', 'length solas', 'scantlings draught', 'block coefficient class', 'design speed ahead','design speed astern'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'class parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'class parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_class_tank_requirement_definition
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['ambient temperature', 'cargo density', 'cargo height', 'coating', 'damage waterline', 'max pressure', 'max temperature', 'min pressure', 'min temperature', 'overflow height', 'partial filling', 'pressure relief setting'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'class tank requirement definition parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'class tank requirement definition parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_coating
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['dry film thickness', 'number of coats', 'surface preparation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'coating parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'coating parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_coating_level
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['lower extent', 'upper extent'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'coating level' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'coating level')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_abbreviated_name
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'name'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to
    'compartment abbreviated name' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' +
  'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment abbreviated name')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_acceleration
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'acceleration g force'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment acceleration' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment acceleration')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_access_authorization
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'authorization classification'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment access authorization' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment access authorization')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_air_circulation_rate
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'air circulation rate'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment air circulation rate' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment air circulation rate')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_cargo_assignment
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['assignment context',  'cargo identifier'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment cargo assignment parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment cargo assignment parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_coating
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment coating' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment coating')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_design_requirement
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['description', 'requirement type'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment design requirement parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment design requirement parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_function
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['used for'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment function parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment function parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_group
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['tonnage volume'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment group parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment group parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_horizontal_cross_sectional_area
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'horizontal cross sectional area'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment horizontal cross sectional area property' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'compartment horizontal cross sectional area property')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_illumination
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'illumination value'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment illumination' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment illumination')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_insulation
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'insulation category'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment insulation' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment insulation')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_noise_category
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'noise category'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment noise category' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment noise category')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_nuclear_classification
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'nuclear classification'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment nuclear classification' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment nuclear classification')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_occupancy
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'occupancy'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment occupancy' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment occupancy')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_safety_class
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'safety category'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment safety class' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment safety class')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_security_classification
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'security classification'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment security classification' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment security classification')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_stiffened_surface_area_property
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'stiffened surface area'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment stiffened surface area property' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'compartment stiffened surface area property')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_tightness
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'required bulkhead tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment tightness' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment tightness')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_unstiffened_surface_area_property
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'unstiffened surface area'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment unstiffened surface area property' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'compartment unstiffened surface area property')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_vertical_longitudinal_sectional_area
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context',
 'vertical 	longitudinal cross 	sectional area'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment vertical longitudinal sectional area property' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'compartment vertical longitudinal sectional area property')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_vertical_transverse_sectional_area
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context',
 'vertical transverse cross 	sectional area'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment vertical transverse sectional area property' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'compartment vertical transverse sectional area property')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_volume_permeability_property
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'permeability'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment volume permeability property' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'compartment volume permeability property')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_volume_property
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['centre of volume', 'context', 'volume'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment volume property' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'compartment volume property')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compartment_ziplist_number
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'department ziplist number', 'division ziplist number'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment ziplist number' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'compartment ziplist number')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_compensated_gross_tonnage
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['compensation factor', 'tonnage value'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compensated gross tonnage' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compensated gross tonnage')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_corrosion_control_coating
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['applicability', 'dry film thickness', 'number of coats', 'surface preparation', 'type of'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'corrosion control coating parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'corrosion control coating parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_corrosion_protection
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['cathodic protection'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'corrosion protection' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'corrosion protection')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_damage_case
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['damage cause', 'relative damage position'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'damage case parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'damage case parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_damage_position
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['centre of damage', 'position accuracy'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'damage position parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'damage position parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_dangerous_goods_code
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['class', 'subsidiary risks'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'dangerous goods code parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'dangerous goods code parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_deck_cargo_assignment
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['assignment context',  'cargo identifier'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'deck cargo assignment parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'deck cargo assignment parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_deck_zone_function
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['used for'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'deck zone function parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'deck zone function parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_dry_cargo
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['pollution code', 'un type code'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'dry cargo parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'dry cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_fire_safe_coating
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['dry film thickness', 'low flame spread', 'nitro cellulose based', 'number of coats', 'surface preparation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'fire safe coating parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'fire safe coating parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_freeboard_characteristics
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['assigned code','freeboard'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'freeboard characteristics' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'freeboard characteristics')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_gaseous_cargo
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['cargo type', 'carried in liquid state', 'pollution code', 'un type code'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'gaseous cargo parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'gaseous cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_gaseous_cargo_assignment
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['assignment context',  'cargo identifier'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'gaseous cargo assignment parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'gaseous cargo assignment parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_global_axis_placement
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['global axes and origin', 'after perpendicular offset', 'orientation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'global axis placement')
                   )
              ) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_gross_tonnage
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['overdeck tonnage', 'tonnage value', 'underdeck tonnage'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'gross tonnage' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'gross tonnage')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_lightship_definition
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['lightship weight', 'lightship centre of gravity'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'lightship definition parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'lightship definition parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_lightship_weight_item
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['aft weight extent','fwd weight extent'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'lightship weight item' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'lightship weight item')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_liquid_cargo
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['cargo type', 'pollution code', 'un type code'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'liquid cargo parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'liquid cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_liquid_cargo_assignment
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['assignment context',  'cargo height', 'cargo identifier'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'liquid cargo assignment parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'liquid cargo assignment parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_loading_condition_design_definition
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['type of'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'loading condition design definition parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'loading condition design definition parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_loading_condition_operating_definition
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['type of'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'loading condition operating definition parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'loading condition operating definition parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_loadline
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['load line length','load line depth','load line displacement','load line block coefficient','load line regulation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'loadline' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 'loadline')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_local_coordinate_system
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['local axes and origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'local coordinate system')
                   )
              ) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_moment_3d_restricts_representation_item
FOR (representation);
LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['longitudinal moment', 'transverse moment', 'vertical moment', 'origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation with name equal to 'moment 3d'
   *)
  reps := QUERY(i <* representation |
       i.NAME = 'moment 3d');

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_moments_of_inertia
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['long moment of inertia', 'trans moment of inertia'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'moments of inertia' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'moments of inertia')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_net_tonnage
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['tonnage value'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'net tonnage' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'net tonnage')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_person_group
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['number of people', 'person type', 'volume'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'person group parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' +
  'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'person group parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_primer_coating
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['dry film thickness', 'number of coats', 'surface preparation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'primer coating parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'primer coating parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_principal_characteristics
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['length between perpendiculars',
 'moulded breadth', 'moulded depth'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'principal characteristics' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'principal characteristics')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_space_adjacency_relationship
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['adjacency access', 'adjacency type'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'space adjacency relationship parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'space adjacency relationship parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_space_positional_relationship
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['relationship type'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'space positional relationship parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'space positional relationship parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_stability_table_restricted
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c2_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
    t1_set:  SET OF representation := [];
    t2_set:  SET OF representation_item := [];
    t3_set:  SET OF representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability table' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability table');

  (* get all instances of representation that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'stability properties for one floating position' *)
  c2_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability properties for one floating position');

  (* get all instances of representation_item that have class id 'stability properties for one floating position' *)
  REPEAT i := 1 TO HIINDEX(c2_a_set);
    REPEAT j := 1 TO HIINDEX(c2_a_set[i].items);
      t2_set := t2_set + c2_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all representation_item instances which are the .items of the representation 
instances that have class id 'stability table' *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].items);
(* compare both lists with representation_item instances and the intersection has to be 
greater 0 *)
      t3_set := t3_set + t1_set[i].items[j];
    END_REPEAT;
  violation := (SIZEOF(t3_set* t2_set) < 1);
  t3_set:= [];
  END_REPEAT;

WHERE
    wr1: NOT violation;
  END_RULE;

RULE representation_for_stability_table_restricted_by_class_id
FOR (applied_classification_assignment);
LOCAL
  c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT:= [];
  t1_set: SET OF REPRESENTATION := [];
  arg_list: LIST OF STRING := ['mean shell thickness'];
  violation: LOGICAL := FALSE;
END_LOCAL;

(* get all classification_assignment instances with id
 'stability table'*)

c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
  i.assigned_class.NAME = 'stability table');

(* get all instances of representation that have class id *)
(* 'stability table'*)

REPEAT i := 1 TO HIINDEX(c_a_set);
  REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
    t1_set := t1_set + c_a_set[i].items[j];
  END_REPEAT;
END_REPEAT;

(*iterate over all representation instances found above; stop, *)
(* if one of them has not exactly one rep_item for each name in *)
(* the arg_list*)

REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
  REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
    violation:= (SIZEOF(QUERY(rep_item<* t1_set[i].items |
    rep_item.name = arg_list[j])) <> 1);
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: NOT violation;
END_RULE;

RULE representation_for_tank_compartment_property
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['context', 'design stowage density'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'tank compartment property' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))| (temp_prop_def_rep.name =
 'tank compartment property')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_tonnage_definition
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['tonnage regulation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal TO 'tonnage definition' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'tonnage definition')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_tonnage_measurement
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['tonnage value'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'tonnage measurement' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.name = 'tonnage measurement')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_unit_cargo
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['cargo type', 'pollution code', 'un type code'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'unit cargo parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'unit cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_unit_cargo_assignment
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['assignment context',  'cargo identifier'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'unit cargo assignment parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'unit cargo assignment parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_unit_cargo_bounding_box
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['point max',  'point min'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'unit cargo bounding box' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'unit cargo bounding box')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_unit_cargo_group
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['volume'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'unit cargo group parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'unit cargo group parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_vehicle_load_description
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['load handling', 'load per wheel', 'number of wheels', 'type of vehicle'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'vehicle load description' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'vehicle load description')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_zone_function
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['used for'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'zone function parameters' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'zone function parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_has_global_uncertainty_assigned_context      
     FOR (SHAPE_REPRESENTATION);  
LOCAL    
 has_gunac: LOGICAL := TRUE;  
END_LOCAL;  

REPEAT i := 1 TO HIINDEX(SHAPE_REPRESENTATION) WHILE has_gunac;
 has_gunac := ('SHIP_ARRANGEMENT_SCHEMA.GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN 
               TYPEOF(SHAPE_REPRESENTATION[i].CONTEXT_OF_ITEMS));
END_REPEAT;

WHERE    
 WR1: has_gunac;  
END_RULE;

RULE representation_has_global_unit_assigned_context 
     FOR (REPRESENTATION);
  LOCAL
    has_guac: LOGICAL := TRUE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE has_guac;
    REPEAT j := 1 TO SIZEOF(REPRESENTATION[i].ITEMS) WHILE has_guac;
      IF (('SHIP_ARRANGEMENT_SCHEMA.VALUE_REPRESENTATION_ITEM' 
          IN TYPEOF(REPRESENTATION[i].ITEMS[j])) OR
          ('SHIP_ARRANGEMENT_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM'
           IN TYPEOF(REPRESENTATION[i].ITEMS[j]))) THEN
      has_guac := ('SHIP_ARRANGEMENT_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
         IN TYPEOF(REPRESENTATION[i].CONTEXT_OF_ITEMS));
      END_IF;
    END_REPEAT;
  END_REPEAT;
  WHERE
    WR1: has_guac;  
END_RULE; 

RULE representation_item_for_transformation_to_parent
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF representation := [];
    t4_set:  SET OF representation_map := [];
    t5_set:  SET OF mapped_item := [];
    arg_list:  LIST OF STRING := 
['local coordinate system position in global coordinate system', 
'local coordinate system position in parent local coordinate system',
'local coordinate system position in parent local coordinate system with position reference'];
    violation1: LOGICAL := FALSE;
    violation2: LOGICAL := FALSE;

  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
            i.assigned_class.NAME =  'local co ordinate system');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation1 := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.used_representation.name = 
      'local axis representation')) = 1);
    t3_set := t3_set + t2_set[i].used_representation;
  END_REPEAT;
  
   REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t4_set := bag_to_set(USEDIN(t3_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
  END_REPEAT;
  
   REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t5_set := bag_to_set(USEDIN(t4_set[i], 
      'SHIP_ARRANGEMENT_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
      REPEAT j := 1 TO 3 WHILE NOT violation2;
      violation2 := NOT (SIZEOF(QUERY(t2_inst <* t5_set | t2_inst.name = 
      ARG_LIST[j])) = 1);
      END_REPEAT;
  END_REPEAT;  
  
  WHERE
    WR1: NOT violation1;
    WR2: NOT violation2;
END_RULE;

RULE representation_items_optional_for_bulk_cargo 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['flash point', 'required carriage temperature', 'permeability', 'stowage factor', 'user def cargo'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'bulk cargo parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.name = 'bulk cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_capacity_properties 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined capacity context'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'capacity properties'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'capacity properties')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_class_deck_load_requirement_definition 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['grab weight', 'stowage height', 'stowage rate', 'vehicle load'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'class deck load requirement definition parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
'class deck load requirement definition parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_class_notation 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['ice class notation','service factor', 'approval required for heavy cargo'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_access_authorization 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined value'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment access authorization'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment access authorization')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_design_requirement 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined value'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment design requirement parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'compartment design requirement parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_function 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment function parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION'))|
 (temp_prop_def_rep.name = 'compartment function parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_insulation 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined value'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment insulation'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment insulation')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_noise_category 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined value'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment noise category'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment noise category')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_safety_class 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined value'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment safety class'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment safety class')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_security 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined value'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment security classification'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment security classification')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_compartment_tightness 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined value'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'compartment tightness'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'compartment tightness')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_corrosion_control_coating 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined type'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'corrosion control coating parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'corrosion control coating parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_damage_case 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user defined'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'damage case parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'damage case parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_deck_zone_function 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'deck zone function parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'deck zone function parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_detailed_cargo_material_properties 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['density',  'expansion coefficient', 'specific heat capacity', 'thermal conductivity', 'viscosity'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'detailed cargo material properties parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'detailed cargo material properties parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_dry_cargo 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['flash point', 'required carriage temperature', 'user def cargo', 'permeability', 'stowage factor'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'dry cargo parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'dry cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_gaseous_cargo 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['flash point', 'required carriage pressure', 'required carriage temperature', 'user def cargo'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'gaseous cargo parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'gaseous cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_general_cargo_material_properties 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['density'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'general cargo material properties parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
'general cargo material properties parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_liquid_cargo 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['flash point', 'required carriage pressure', 'required carriage temperature', 'user def cargo'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'liquid cargo parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'liquid cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_loading_condition_operating_definition 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['place of loading'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'loading condition operating definition parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
 'loading condition operating definition parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_owner_designation
	   	FOR (representation);
LOCAL
   reps: BAG OF REPRESENTATION := [];
   arg_list: LIST OF STRING := ['owner approval'];
   found: LOGICAL := FALSE;
END_LOCAL;

(* Find all instances of representation which are used
by a property_definition_representation with name equal to 'owner
designation'
*)

reps := QUERY(temp_rep <* representation |
  SIZEOF (QUERY(temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION'))|
 (temp_prop_def_rep.name = 'owner designation')))>0 );

(* iterate over all representations found above. Stop, if for one of
them the names of its representation_items are duplicated.
*)

REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
 REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
 found := (SIZEOF(QUERY(rep_item <* reps[i].items |
          rep_item.name = arg_list[j])) > 1);
 END_REPEAT;
END_REPEAT;
WHERE

wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_principal_characteristics 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['block coefficient', 'design draught',
 'design deadweight','min draught at fp','max draught at fp', 'min draught at ap',
 'max draught at ap'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'principal characteristics'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'principal characteristics')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_space_connection_relationship 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['connecting system'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'space connection relationship parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
'space connection relationship parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_tank_geometric_parameters 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['breadth wash', 'length wash'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'tank geometric parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'tank geometric parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_tank_piping_design_properties 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['airpipe height', 'filling height', 'relief valve pressure setting', 'sounding pipe height'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'tank piping design properties'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'tank piping design properties')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_unit_cargo 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['flash point', 'permeability', 'stowage factor',
  'required carriage temperature', 'stack limit', 'user def cargo', 'volume'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'unit cargo parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'unit cargo parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_vehicle_load_description 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['max tyre pressure', 'print area'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'vehicle load description'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'vehicle load description')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_items_optional_for_zone_function 
FOR (representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;

  (* Find all instances of representation  which are used
     by a property_definition_representation with name equal to 'zone function parameters'
   *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'zone function parameters')
                   )
              ) > 0 
           );

  (* iterate over all representations found above. Stop, if for one of
     them the names of its representation_items are duplicated.
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;

RULE representation_local_coordinate_system_with_position_reference
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['local axes and origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name =
		 'local coordinate system with position reference')
                   )
              ) > 0 
           );

  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_restricted_weight_and_centre_of_gravity
FOR (representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['mass ','centre of gravity'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* find all instances of representation  which are used
     by a property_definition_representation with name equal to 'weight and centre of gravity' *)
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_ARRANGEMENT_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')) |
 (temp_prop_def_rep.name = 'weight and centre of gravity')
                   )
              ) > 0 
           );

  (* iterate over all representations found above; stop, if one of
     them has not exactly one rep_item with for each name of the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE revision_has_mandatory_attribute_description
FOR (group);
LOCAL
    t1_set:  SET OF group := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of group being classified as 'revision' *)
t1_set := QUERY(i <* group | VALUE_IN(WHICH_CLASS(i), 'revision')); 

(* from all instances found above:
   find those for which attribute description is not instantiated
*)

violate := (SIZEOF(QUERY(k <* t1_set |
NOT EXISTS (k.description))) > 0);

WHERE
    wr1: NOT violate; 
END_RULE;

RULE revision_with_context_referenced_for_context_of_revision
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of group with class 'revision with context' *)
t1_set := QUERY(a <* group |
 VALUE_IN(WHICH_CLASS(a), 'revision with context'));

  (* for all instances found above *)
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
(* get the instances of applied_group_assignment that have a role 'context of revision' *)
   a_set := QUERY(b <* applied_group_assignment | 
             (b.assigned_group = t1_set[i]) AND
					 (b.role.name = 'context of revision'));

(* there shall be no such instances *)
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE shape_representation_subtype_exclusiveness
FOR (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (sr <* shape_representation |
    NOT (SIZEOF (TYPEOF (sr) *
    ['SHIP_ARRANGEMENT_SCHEMA.NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION'])
    <= 2))) = 0;
END_RULE;

RULE ship_designation_has_one_specified_names 
FOR(APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'ship designation' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'ship designation');

  (* get all instances of T1 that have class id 'ship designation' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* for all instances of product_definition in t1_set:
     get the applied_identification_assignment instances that are referencing a product_definition instance via items,
     filter out those applied_identification_assignment instances whose attribute role.name has the value 'imo number'
     check if their number equals 1
   *)
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_ARRANGEMENT_SCHEMA.' + 'APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | (t2_inst.role.name = 'imo number')OR (t2_inst.role.name = 'pennant hull number') )) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE spacing_position_compound_representation_has_name
FOR (applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET Of representation_item := [];
    arg_list:  LIST OF STRING := ['position number', 'position'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
        violation := (SIZEOF(QUERY(items <* t2_set |
           items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE spacing_position_with_offset_compound_representation_has_class
FOR (applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET Of representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position with offset');
      REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position');
 
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
      t3_set := t3_set + t1_set[i].item_element;
    END_REPEAT;
    violation := (SIZEOF(t3_set * t2_set) <> 1);
    t3_set:= [];
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE spacing_position_with_offset_compound_representation_has_name
FOR (applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET Of representation_item := [];
    arg_list:  LIST OF STRING := ['offset'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'spacing position with offset');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
        violation := (SIZEOF(QUERY(items <* t2_set | 
        items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;

RULE stability_properties_for_floating_position_has_class
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET OF REPRESENTATION_ITEM := [];
    l_rep_item : list_representation_item;
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability properties for one floating position' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability properties for one floating position');

  (* get all instances of compound_representation_item that have class id 'stability properties for one floating position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

(* get all classification_assignment instances with id 'stability property' *)
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability property');

  (* get all instances of compound_representation_item that have class id 'stability property' *)
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found in the first list; then iterate
   over all item_element for each compound_representation_item,
   check that the intersection of these item_elements and and the second list of
   compound_representation_item is greater than or equal to 1
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
          l_rep_item := t1_set[i].item_element;
      t3_set := t3_set + l_rep_item[j];
    END_REPEAT;
    violation := (SIZEOF(t3_set * t2_set) < 1);
    t3_set:= [];
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE stability_properties_for_floating_position_has_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['centre of gravity above keel', 'definition of starting floating position'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability properties for one floating position' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name =
 'stability properties for one floating position');

  (* get all instances of compound_representation_item that have class id 'stability properties for one floating position' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
  violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE stability_property_has_name
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['angle of heel', 'righting arm',
 'centre of buoyancy'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'stability property' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.Assigned_class.name = 'stability property');

  (* get all instances of compound_representation_item that have class id 'stability property' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* iterate over all compound_representation_item found above; stop, if one of
     them has not exactly one rep_item for each name in the arg_list
   *)
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set |
 items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;

RULE tonnage_definition_has_properties
FOR (property_definition_representation, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  LIST OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  LIST OF property_definition := [];
    t4_set:  LIST OF product_definition := [];

    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances with id 'tonnage definition' *)
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.name = 'tonnage definition');

  (* get all instances of product_definition that have class id 'tonnage definition' *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  (* get all property_definition_representation instances with name 'tonnage definition' *)
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'tonnage definition');

(* get all property_definition instances which are the .definition of the 
property_definition_representation *)
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;

(* get all product_definition instances which are the .definition of the 
property_definition *)
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;

(* compare both lists with product_definition instances which have to be identical *)
  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;

  
END_RULE;

RULE unique_approvals_in_approval_history
FOR (GROUP, APPLIED_GROUP_ASSIGNMENT);
LOCAL
    t1_set:  SET OF GROUP := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    t3_set:  SET OF approval :=[];
    violate: LOGICAL := FALSE;
END_LOCAL;
  t1_set := QUERY(i <* GROUP | VALUE_IN(WHICH_CLASS(i), 
    'approval history')); 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
     a.ASSIGNED_GROUP = t1_set[i]);
   t3_set := QUERY(b <* t2_set[1].items | 
     'SHIP_ARRANGEMENT_SCHEMA.APPROVAL' IN TYPEOF(b));
    violate := NOT (VALUE_UNIQUE(t3_set));
END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;

RULE user_def_cargo_description_required_for_cargo_type
FOR (REPRESENTATION);

  LOCAL
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'cargo type') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user def cargo'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_def_cargo_description_required_for_type_of
FOR (REPRESENTATION);

  LOCAL
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'type of') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user def cargo'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_def_function_description_required
FOR (REPRESENTATION);

  LOCAL
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'used for') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user def function'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_capacity_context_description_required_for_capacity_context 
FOR (REPRESENTATION);

  LOCAL
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'capacity context') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined capacity context'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_description_required_for_damage_cause
FOR (REPRESENTATION);

  LOCAL

    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'damage cause') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_type_description_required_for_type_of
FOR (REPRESENTATION);

  LOCAL
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'type of') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined type'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_authorization_classification
FOR (REPRESENTATION);

  LOCAL
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'authorization classification') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined value'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_insulation
FOR (REPRESENTATION);

  LOCAL
    rep_set:   SET OF representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'compartment insulation') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined value'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_noise_category
FOR (REPRESENTATION);

  LOCAL
    rep_set:   SET OF representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'compartment noise category') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined value'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_safety_class
FOR (REPRESENTATION);

  LOCAL
    rep_set:   SET OF representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'compartment safety class') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined value'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_security
FOR (REPRESENTATION);

  LOCAL
    rep_set:   SET OF representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'compartment security classification') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined value'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_compartment_tightness
FOR (REPRESENTATION);

  LOCAL
    rep_set:   SET OF representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'compartment tightness') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined value'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE user_defined_value_description_required_for_requirement_type
FOR (REPRESENTATION);

  LOCAL
    rep_set:   SET OF representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         ('SHIP_ARRANGEMENT_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                          IN TYPEOF(r)) AND
                         (r.NAME = 'requirement type') AND
                         (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 'user defined'))) > 0)
                 AND
                 (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
                         (r.NAME = 'user defined value'))) = 0);
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;

RULE version_creation_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of action being classified as 'version creation' *)
t1_set := QUERY(i <* action |
 VALUE_IN(WHICH_CLASS(i), 'version creation')); 

(* from all instances found above:
   find those for which attribute description is not instantiated
*)

violate := (SIZEOF(QUERY(k <* t1_set |
 NOT EXISTS (k.description))) > 0);

WHERE
    wr1: NOT violate; 
END_RULE;

RULE version_deletion_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of action being classified as 'version deletion' *)
t1_set := QUERY(i <* action |
 VALUE_IN(WHICH_CLASS(i), 'version deletion')); 

(* from all instances found above:
   find those for which attribute description is not instantiated
*)

violate := (SIZEOF(QUERY(k <* t1_set |
 NOT EXISTS (k.description))) > 0);

WHERE
    wr1: NOT violate; 
END_RULE;

RULE version_history_has_exactly_one_assigned_group
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    set_1, set_2: SET OF applied_group_assignment := [];
    set_3: SET OF group_item := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of group with class 'version history' *)
t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

  (* for all instances found above *)
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
(* get the instances of applied_group_assignment that have a role 'current version' *)
   set_1 := QUERY(b <* applied_group_assignment | 
           (b.assigned_group = t1_set[i]) AND
				 (b.role.name = 'current version'));

(* get the instances of applied_group_assignment that have a role 'members' *)
   set_2 := QUERY(c <* applied_group_assignment | 
             (c.assigned_group = t1_set[i]) AND
					 (c.role.name = 'members'));

(* there shall be only one assignment in each of both cases *)
   violate := ((SIZEOF(set_1) <> 1) OR (SIZEOF(set_2) <> 1));

   IF NOT violate THEN
(* find all instances with class versionable object which are shared by  
      set_1[1].items and in set_2[1].items *)
      set_3 := set_1[1].items * set_2[1].items;

(* there must be at exactly one instance with class 'versionable object' *)
      violate := (SIZEOF(set_3) <> 1) OR 
                  NOT (VALUE_IN(WHICH_CLASS(set_3[1]),
						 'versionable object'));
   END_IF;
END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE version_history_is_referenced_by_at_least_one_versions
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
(* get the instances of applied_group_assignment that have a role 'versions' *)
   a_set := QUERY(b <* applied_group_assignment | 
           (b.assigned_group = t1_set[i]) AND
				 (b.role.name = 'versions'));

(* there shall be at least one such instance *)
    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE version_history_referenced_by_exactly_one_current_version
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of group with class 'version history' *)
t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

  (* for all instances found above *)
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
(* get the instances of applied_group_assignment that have a role 'current version' *)
   a_set := QUERY(b <* applied_group_assignment | 
             (b.assigned_group = t1_set[i]) AND
					 (b.role.name = 'current version'));

(* there shall be no such instances *)
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

RULE version_history_referenced_by_multiple_roles
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
    (b.assigned_group = t1_set[i]) AND NOT (b.role.name IN ['versions', 'current version', 'relationships']));
    violate := SIZEOF(a_set) < 1;
END_REPEAT;
WHERE
    wr1: NOT violate;
END_RULE;

RULE version_modification_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of action being classified as 'version modification' *)
t1_set := QUERY(i <* action |
 VALUE_IN(WHICH_CLASS(i), 'version modification')); 

(* from all instances found above:
   find those for which attribute description is not instantiated
*)

violate := (SIZEOF(QUERY(k <* t1_set | NOT EXISTS (k.description))) > 0);

WHERE
    wr1: NOT violate; 
END_RULE;

RULE version_relationship_associates_with_versionable_object
FOR (applied_identification_assignment);
LOCAL
    violate: LOGICAL := FALSE;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1 WHILE NOT violate;
 IF ( (SIZEOF(USEDIN(applied_identification_assignment[i],           ('SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATING_IDENTIFICATION_ASSIGNMENT'))) > 0) OR
      (SIZEOF(USEDIN(applied_identification_assignment[i],
      ('SHIP_ARRANGEMENT_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT'))) > 0) ) THEN
  REPEAT j := 1 to HIINDEX(applied_identification_assignment[i].items) BY 1 WHILE NOT violate;
   violate := NOT  VALUE_IN(which_class(applied_identification_assignment[i].items[j]),            'versionable object');
  END_REPEAT;
 END_IF;

END_REPEAT; 
WHERE
    WR1: NOT violate; 
END_RULE;

RULE version_relationship_has_mandatory_attribute_description
FOR (identification_assignment_relationship);
LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

(* get all instances of identification_assignment_relationship being classified as 'version relationship' *)
t1_set := QUERY(i <* identification_assignment_relationship | VALUE_IN(WHICH_CLASS(i), 'version relationship')); 

(* from all instances found above:
   find those for which attribute description is not instantiated
*)

violate := (SIZEOF(QUERY(k <* t1_set | NOT EXISTS (k.description))) > 0);

WHERE
    wr1: NOT violate; 
END_RULE;

RULE version_relationship_has_unique_versions
FOR (identification_assignment_relationship);
LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
   t1_set := QUERY(a <* identification_assignment_relationship | 
   VALUE_IN(WHICH_CLASS(a), 'version relationship'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    violate := 
          ( t1_set[i].relating_identification_assignment.assigned_id =
            t1_set[i].related_identification_assignment.assigned_id );
END_REPEAT; 
WHERE
    WR1: NOT violate; 
END_RULE;

RULE versionable_object_has_one_version_id
FOR(APPLIED_IDENTIFICATION_ASSIGNMENT);
  LOCAL
    version_ids:         SET OF APPLIED_IDENTIFICATION_ASSIGNMENT := [];
    versionable_objects: BAG OF identification_item := [];
    duplicate:           LOGICAL := FALSE;
  END_LOCAL;
 
  version_ids := QUERY(i <* APPLIED_IDENTIFICATION_ASSIGNMENT |
                       i.ROLE.NAME = 'version identifier');
 
  REPEAT i := 1 TO HIINDEX(version_ids);
    versionable_objects := versionable_objects + version_ids[i].items;
  END_REPEAT;
   REPEAT i := 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
    REPEAT j := i + 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
      duplicate := versionable_objects[i] :=: versionable_objects[j];
    END_REPEAT;
  END_REPEAT;
  WHERE
    WR1: NOT duplicate;
END_RULE;

RULE versioned_action_request_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF versioned_action_request := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['change request'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_ARRANGEMENT_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
	       	     j.role.name = 'globally unambiguous identifier');
           violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE versions_is_referenced_by_at_least_one_version_history
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group |
 VALUE_IN(WHICH_CLASS(a), 'versions'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;

   a_set := QUERY(b <* applied_group_assignment | 
      (b.assigned_group = t1_set[i]) AND
		 (b.role.name = 'version history'));

    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;

FUNCTION WHICH_CLASS(T: GENERIC): LIST OF STRING;
  LOCAL
     elements: BAG OF APPLIED_CLASSIFICATION_ASSIGNMENT;
     class_list: LIST OF STRING :=[];
  END_LOCAL;
  elements :=   USEDIN(T,
            'SHIP_ARRANGEMENT_SCHEMA.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS');
  REPEAT i:=1 TO HIINDEX(elements);
 IF (elements[i]\classification_assignment.role.name = 'class membership') THEN
  class_list := class_list + 
  elements[i]\classification_assignment.assigned_class\group.name;
 END_IF;
  END_REPEAT;
  RETURN(class_list);
END_FUNCTION;

END_SCHEMA;

