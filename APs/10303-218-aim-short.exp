(* 
AIM short form for ISO/IS 10303-218
Len Slovensky
2003-06-17
ISO TC184/SC4/WG3 N1343
*)

SCHEMA SHIP_STRUCTURES_SCHEMA;
    USE FROM aic_advanced_brep                              -- ISO 10303-514
    (advanced_brep_shape_representation);
 
    USE FROM aic_edge_based_wireframe                       -- ISO 10303-501
    (edge_based_wireframe_shape_representation);
    
    USE FROM aic_geometrically_bounded_wireframe            -- ISO 10303-510
    (geometrically_bounded_wireframe_shape_representation);
    
    USE FROM aic_non_manifold_surface                       -- ISO 10303-508
    (non_manifold_surface_shape_representation );
    
    USE FROM aic_topologically_bounded_surface              -- ISO 10303-511
    (advanced_face);
    
    USE FROM action_schema                                   -- ISO 10303-41
    (action,
    action_method,
    action_request_solution,
    executed_action,
    versioned_action_request);
    
   USE FROM application_context_schema                      -- ISO 10303-41
   (application_context,
   application_protocol_definition);
   
   USE FROM approval_schema                                  -- ISO 10303-41
   (approval,
    approval_date_time,
    approval_person_organization,
    approval_status);
    
   USE FROM basic_attribute_schema                           -- ISO 10303-41
   (object_role);
    
   USE FROM date_time_schema                                 -- ISO 10303-41
   (calendar_date,                    
   date_and_time,
   date_time_role,
   ordinal_date,                      
   week_of_year_and_day_date);        
   
   USE FROM document_schema                                  -- ISO 10303-41
   (document,
    document_representation_type,
    document_usage_constraint);
    
   USE FROM external_reference_schema                        -- ISO 10303-41
   (external_source,
    external_source_relationship,
    externally_defined_item);
    
  REFERENCE FROM geometry_schema                             -- ISO 10303-42
   (dummy_gri); 
   
   USE FROM geometric_model_schema
   (faceted_brep,                  
   geometric_curve_set);           
    
   USE FROM geometry_schema                                  -- ISO 10303-42
   (axis1_placement,                
    axis2_placement_2d,
    axis2_placement_3d,
    b_spline_curve,                
    b_spline_surface,              
    b_spline_curve_with_knots,     
    b_spline_surface_with_knots,   
    bezier_curve,                  
    bezier_surface,                
    bounded_curve,
    cartesian_point,
    composite_curve_on_surface,    
    conical_surface,               
    curve,
    cylindrical_surface,           
    degenerate_pcurve,             
    degenerate_toroidal_surface,   
    direction,
    elementary_surface,            
    ellipse,                       
    geometric_representation_item,
    circle,                        
    parabola,                      
    hyperbola,                     
    line,
    plane,
    oriented_surface,              
    point_on_curve,                
    point_on_surface,              
    quasi_uniform_curve,           
    quasi_uniform_surface,         
    rational_b_spline_curve,       
    rational_b_spline_surface,     
    spherical_surface,             
    surface_of_linear_extrusion,  
    surface_of_revolution,        
    toroidal_surface,              
    uniform_curve,                 
    uniform_surface,               
    vector);
    
   USE FROM group_schema                                     -- ISO 10303-41
   (group,
    group_relationship);
   
   USE FROM management_resources_schema                      -- ISO 10303-41
   (action_request_assignment,
    approval_assignment,
    classification_assignment,
    classification_role,
    date_and_time_assignment,
    document_reference,
    external_identification_assignment,
    group_assignment,
    identification_assignment,
    identification_assignment_relationship,
    identification_role,
    organization_assignment,
    person_assignment,
    person_and_organization_assignment);
    
   USE FROM material_property_definition_schema               -- ISO 10303-41
   (property_definition_relationship);
   
   USE FROM measure_schema                                    -- ISO 10303-41
   (amount_of_substance_measure,
    area_measure,
    celsius_temperature_measure,
    context_dependent_measure,
    context_dependent_unit,
    conversion_based_unit,
    count_measure,
    derived_unit,
    derived_unit_element,
    electric_current_measure,
    global_unit_assigned_context,
    length_measure,
    length_unit,
    luminous_intensity_measure,
    mass_measure,
    named_unit,
    plane_angle_measure,
    plane_angle_unit,
    positive_plane_angle_measure,
    positive_length_measure,
    ratio_measure,
    si_unit,
    solid_angle_measure,
    thermodynamic_temperature_measure,
    thermodynamic_temperature_unit,
    time_measure,
    time_unit,
    volume_measure);
    
   USE FROM person_organization_schema                       -- ISO 10303-41
   (address,                             
    person,
    person_and_organization,
    person_and_organization_role,
    personal_address,                    
    organization,
    organizational_address,              
    organizational_project);
    
   USE FROM product_definition_schema                        -- ISO 10303-41
   (product,
   product_category,
   product_category_relationship,
   product_definition,
   product_definition_relationship,
   product_definition_with_associated_documents,
   product_related_product_category);
   
   USE FROM product_property_definition_schema                -- ISO 10303-41
   (characterized_object,                
    general_property,
    product_definition_shape,
    property_definition,
    shape_aspect,
    shape_aspect_relationship);
    
   USE FROM product_property_representation_schema           -- ISO 10303-41
   (property_definition_representation,
    shape_definition_representation,
    shape_representation);
    
   USE FROM qualified_measure_schema                         -- ISO 10303-41
   (descriptive_representation_item);
   
    USE FROM representation_schema                           -- ISO 10303-43
   (compound_representation_item,
    global_uncertainty_assigned_context,
    set_representation_item,
    list_representation_item,
    item_defined_transformation,
    mapped_item,
    parametric_representation_context,     
    representation,
    representation_item,
    representation_map,
    representation_relationship,
    uncertainty_measure_with_unit,
    value_representation_item);
    
   USE FROM support_resource_schema                          -- ISO 10303-41
   (bag_to_set, 
   label);                 
   
   REFERENCE FROM topology_schema                             -- ISO 10303-42
   (dummy_tri,
    edge_loop,            
    poly_loop);
TYPE action_request_item = SELECT (
    action,
    executed_action,
    group,
    product,
    product_definition,
    product_definition_relationship,
    product_definition_shape,
    property_definition);
END_TYPE;
TYPE approval_item = SELECT (
    product_definition_shape,
    product_definition,
    property_definition); 
END_TYPE;
TYPE classification_item = SELECT (
    action,
    action_request_solution,
    compound_representation_item,
    group,
    product,
    product_definition,
    product_definition_with_associated_documents,
    product_definition_relationship,
    product_definition_shape,
    product_related_product_category,
    property_definition,
    property_definition_relationship,
    representation,
    shape_aspect,
    shape_aspect_relationship,
    versioned_action_request);
END_TYPE;
TYPE date_and_time_item = SELECT (
     action,
     action_request_solution,
     product_definition,
     versioned_action_request);                     
END_TYPE;
TYPE document_reference_item = SELECT (
    group,
    property_definition);
END_TYPE;
TYPE external_identification_item = SELECT (
    document,
    document_reference,
    product_definition_shape);
END_TYPE;
TYPE group_item = SELECT (
    approval, 
    product_definition,
    product_definition_shape,
    product_definition_with_associated_documents,
    product_definition_relationship,
    representation,
    shape_aspect);
END_TYPE;
TYPE identification_item = SELECT (
    action_request_solution,
    executed_action,
    externally_defined_general_property,
    externally_defined_class,
    group,
    product,
    product_definition,
    product_definition_shape,
    product_definition_relationship,
    product_related_product_category,
    property_definition_relationship,
    property_definition,
    representation,
    shape_aspect,
    shape_aspect_relationship,
    versioned_action_request);
END_TYPE;
TYPE organization_item = SELECT (
     externally_defined_class,
    document,
     known_source,
    product_definition,
    property_definition); 
END_TYPE;
TYPE person_item = SELECT (
     action_request_solution,
     document,
     executed_action,
     versioned_action_request);  
END_TYPE;
TYPE person_and_organization_item = SELECT (
     action_request_solution,
     executed_action,
     document,
     versioned_action_request); 
END_TYPE;
ENTITY applied_action_request_assignment
  SUBTYPE OF (action_request_assignment);
  items: SET[1:?] OF action_request_item;
END_ENTITY;
ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
    WHERE
    wr1: NOT((SELF\approval_assignment.role.name = 'proposed alternative')) OR
         (SIZEOF(QUERY( app <*  
         USEDIN (SELF\approval_assignment.assigned_approval, 
         'SHIP_STRUCTURES_SCHEMA.APPROVAL_ASSIGNMENT.ASSIGNED_APPROVAL') |
       ('SHIP_STRUCTURES_SCHEMA.APPLIED_APPROVAL_ASSIGNMENT' IN TYPEOF (app)) AND
         (app\approval_assignment.role.name='subject')))=1);
END_ENTITY;
ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items: SET[1:?] OF classification_item;
END_ENTITY;
ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items: SET[1:?] OF date_and_time_item;
END_ENTITY;  
ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items: SET[1:?] OF document_reference_item;
END_ENTITY;
ENTITY applied_external_identification_assignment
  SUBTYPE OF (external_identification_assignment);
  items: SET[1:?] OF external_identification_item;
END_ENTITY;
ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items: SET[1:?] OF group_item;
 
END_ENTITY;
ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items: SET[1:?] OF identification_item;
END_ENTITY;
ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items: SET[1:?] OF organization_item;
END_ENTITY;
ENTITY applied_person_assignment
  SUBTYPE OF (person_assignment);
  items: SET[1:?] OF person_item;
END_ENTITY;
ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items: SET[1:?] OF person_and_organization_item;
END_ENTITY;
  ENTITY class
    SUBTYPE OF (group);
    WHERE
     WR1:   (SIZEOF(QUERY ( oa <* USEDIN(SELF,
            'SHIP_STRUCTURES_SCHEMA.GROUP_ASSIGNMENT.ASSIGNED_GROUP')|
         NOT ('SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(oa)) 
             )) =0);
  END_ENTITY; -- class
ENTITY externally_defined_class
  SUBTYPE OF (class, externally_defined_item);
END_ENTITY; 
ENTITY externally_defined_general_property 
  SUBTYPE OF (general_property, externally_defined_item); 
END_ENTITY; 
  ENTITY library_class_version_assignment
    SUBTYPE OF (applied_external_identification_assignment);
    WHERE
  WR1: SELF\identification_assignment.role.name = 'class version';
  WR2: SIZEOF (SELF\applied_external_identification_assignment.items) >1;
  WR3: ('SHIP_STRUCTURES_SCHEMA.KNOWN_SOURCE' 
        IN TYPEOF (SELF\external_identification_assignment.source));    
  END_ENTITY; -- library_class_version_assignment
  ENTITY library_applied_version_assignment
    SUBTYPE OF (applied_external_identification_assignment);
   WHERE
  WR1: SELF\identification_assignment.role.name = 'property version';
  WR2: SIZEOF (SELF\applied_external_identification_assignment.items) =1;
  WR3: ('SHIP_STRUCTURES_SCHEMA.KNOWN_SOURCE' 
        IN TYPEOF (SELF\external_identification_assignment.source));     
  END_ENTITY; -- library_applied_version_assignment
  ENTITY known_source
   SUBTYPE OF (pre_defined_item, external_source);
   WHERE
     WR1:  SELF\pre_defined_item.name = 'ISO 13584 library';
     
     WR2:   (SIZEOF(QUERY ( oa <* USEDIN(SELF,
            'SHIP_STRUCTURES_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|
          NOT ('SHIP_STRUCTURES_SCHEMA.ORGANIZATION_ASSIGNMENT' IN TYPEOF(oa)) 
             AND (oa.role.name='library supplier'
              ))) =0);
     
    
  END_ENTITY; -- known_source
 ENTITY pre_defined_item;
     name          : label;
  END_ENTITY;  -- pre_defined_item

(*  RULES 121401 *)

RULE 
action_request_solution_connected_to_action
FOR(action_request_solution, action);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    t2_set:  SET OF action := [];
    set_3 :  SET OF ACTION_METHOD := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(a <* action_request_solution | 
          VALUE_IN(WHICH_CLASS(a), 'change plan'));
t2_set := QUERY(b <* action | VALUE_IN(WHICH_CLASS(b), 'change'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   set_3 := [];
   REPEAT j := 1 TO HIINDEX(t2_set);
      set_3 := set_3 + [t2_set[j].chosen_method]; 
   END_REPEAT;
   violate := VALUE_IN(set_3, t1_set[i].method);
END_REPEAT;
WHERE
    WR1: NOT violate;
END_RULE;



RULE action_request_solution_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF action_request_solution := [];
    t2_set:  SET OF action_request_solution := [];
    arg_list:  LIST OF STRING := [ 'definable object'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE action_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF action := [];
    t2_set:  SET OF action := [];
    arg_list:  LIST OF STRING := [ 'definable object'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
  'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE alternative_version_relationship_versionable_object
FOR (applied_identification_assignment);

LOCAL

    violate1, violate2, violate: LOGICAL := FALSE;
END_LOCAL;


    REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1
         WHILE NOT violate;
      violate1 := (SIZEOF(USEDIN(applied_identification_assignment[i],
         ('SHIP_STRUCTURES_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
         +'RELATING_IDENTIFICATION_ASSIGNMENT')))
         > 0) AND (NOT VALUE_IN(which_class(
          applied_identification_assignment[i]),'versionable object'));
      violate2 := (SIZEOF(USEDIN(applied_identification_assignment[i],
          ('SHIP_STRUCTURES_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
          +'RELATED_IDENTIFICATION_ASSIGNMENT'))) 
          > 0) AND (NOT VALUE_IN(which_class(
          applied_identification_assignment[i]),'versionable object'));
      violate := violate1 OR violate2;
    END_REPEAT;

WHERE
    wr1: NOT violate; 
END_RULE;


RULE alternative_version_relationship_has_mandatory_description
FOR (identification_assignment_relationship);

LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;



t1_set := QUERY(i <* identification_assignment_relationship | 
  VALUE_IN(WHICH_CLASS(i), 'alternative version relationship')); 



violate := (SIZEOF(QUERY(k <* t1_set | NOT EXISTS (k.description))) > 0);

WHERE
    wr1: NOT violate; 
END_RULE;


RULE alternative_version_relationship_has_unique_versions
FOR (identification_assignment_relationship);

LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
END_LOCAL;



   t1_set := QUERY(a <* identification_assignment_relationship | 
      VALUE_IN(WHICH_CLASS(a), 'alternative version relationship'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    violate := 
          ( t1_set[i].relating_identification_assignment.assigned_id =
            t1_set[i].related_identification_assignment.assigned_id );
END_REPEAT; 

WHERE
    wr1: NOT violate; 
END_RULE;


RULE  applied_approval_assignment_has_exactly_one_elements
FOR (object_role, applied_approval_assignment);

WHERE
    WR1: SIZEOF(QUERY(ass_inst <* applied_approval_assignment |
           NOT((ass_inst.role.name = 'subject')
               AND
               (SIZEOF(ass_inst.items) = 1)
              )
           )) = 0;
END_RULE;

RULE 
applied_group_assignment_has_at_least_one_elements
FOR (object_role, applied_group_assignment);

WHERE
    WR1: SIZEOF(QUERY(ass_inst <* applied_group_assignment | 
           NOT((ass_inst.role.name = 'approvals') 
               AND
               (SIZEOF(ass_inst.items) >= 1)
               AND
               (SIZEOF(QUERY(item <* ass_inst.items |
                  NOT('SHIP_STRUCTURES_SCHEMA.APPROVAL' 
                  IN TYPEOF(item)))) = 0) 
              )
           )) = 0;
END_RULE;



RULE 
approval_event_with_approval_date_time
FOR(approval, approval_date_time);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF approval_date_time := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* approval | 
    VALUE_IN(WHICH_CLASS(i), 'approval event')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.APPROVAL_DATE_TIME.' + 
      'DATED_APPROVAL'));
    violate := NOT (SIZEOF(t2_set) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE 
approval_event_with_approval_person_organization
FOR(approval, approval_person_organization);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF approval_person_organization := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* approval | 
            VALUE_IN(WHICH_CLASS(i), 'approval event')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.APPROVAL_PERSON_ORGANIZATION.' + 
      'AUTHORIZED_APPROVAL'));
    violate := NOT (SIZEOF(t2_set) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE 
approval_history_approves_same_definition
FOR (applied_group_assignment, applied_approval_assignment);
LOCAL
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    t3_set:  SET OF GENERIC :=[];   
    t4_set:  SET OF GENERIC :=[];   
    t5_set:  SET OF APPLIED_APPROVAL_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
                VALUE_IN(WHICH_CLASS(a.ASSIGNED_GROUP), 
                'approval history'));
t3_set := QUERY(b <* t2_set[1].items | 
  'SHIP_STRUCTURES_SCHEMA.APPROVAL' IN TYPEOF(b));
t4_set := QUERY(b <* t2_set[1].items | 
  VALUE_IN(WHICH_CLASS(b), 'DEFINITION'));
violate := NOT(SIZEOF(t4_set) = 1);

REPEAT i := 1 TO HIINDEX(t3_set) WHILE NOT violate;
    t5_set := QUERY(a <* APPLIED_APPROVAL_ASSIGNMENT | 
    (a.ASSIGNED_APPROVAL = t3_set[i]) AND 
    (NOT (VALUE_IN(a.items, t4_set[1]))));
   violate := (SIZEOF(t5_set) > 0);
  END_REPEAT;
WHERE
    WR1: NOT violate; 
    wr2: (SIZEOF(t4_set) = 1);
END_RULE;


RULE approval_history_contains_approval_elements
FOR (object_role, applied_group_assignment);

LOCAL
    t1_set:  SET OF applied_approval_assignment := [];
    t3_set:  SET OF approval := [];
    gr_ass_set:  SET OF applied_group_assignment := [];
    violation: LOGICAL := FALSE;
    first_runs: LOGICAL := TRUE;
    valid_items_set: SET OF GENERIC := [];
  END_LOCAL;
  gr_ass_set := QUERY(aga <* applied_group_assignment |
       (aga.role.name = 'approvals') 
       AND
      ('approval history' IN WHICH_CLASS(aga.assigned_group)));
  REPEAT i := 1 TO HIINDEX(gr_ass_set) WHILE NOT violation;
    t3_set := QUERY(aga_item <* gr_ass_set[i].items |
      'SHIP_STRUCTURES_SCHEMA.APPROVAL' IN TYPEOF(aga_item)); 
 
    REPEAT j := 1 TO HIINDEX(t3_set);
      t1_set := QUERY(aga <* bag_to_set(USEDIN(t3_set[j], 
         'SHIP_STRUCTURES_SCHEMA.' + 
         'APPROVAL_ASSIGNMENT.ASSIGNED_APPROVAL'))|
         aga.role.name = 'subject'
         );
   
      REPEAT k:= 1 TO HIINDEX(t1_set);
       
        IF ((first_runs) AND (SIZEOF(t1_set[k].items) > 0)) THEN
          valid_items_set := t1_set[k].items;
          first_runs := FALSE;
        ELSE
       
          REPEAT l := 1 TO HIINDEX(t1_set[k].items);
            violation := t1_set[k].items[l] :<>: valid_items_set[l];
          END_REPEAT;
        END_IF;
      END_REPEAT;
   
    END_REPEAT;
 
  first_runs := TRUE;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE 
approval_history_has_at_least_one_member
FOR (group, applied_group_assignment);
LOCAL
    t1_set:  SET OF GROUP := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
  T1_set := QUERY(i <* group | VALUE_IN(WHICH_CLASS(i), 
  'approval history')); 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
      a.ASSIGNED_GROUP = t1_set[i]);
 
    violate := NOT(SIZEOF(t2_set) = 1);
  END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;



RULE  approvals_references_approval_history
FOR(object_role, applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;


t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'approval history'));


REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
       NOT ((b.assigned_group = t1_set[i]) AND (b.role.name = 'approvals')));


    violate := SIZEOF(a_set) > 0;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;


RULE  
assembly_relationship_has_product_definition
FOR (group, applied_classification_assignment);

  LOCAL
    cl_ass:      SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    clfied_inst: SET OF product_definition_RELATIONSHIP := [];
  END_LOCAL;
 
  cl_ass := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                  i.assigned_class.NAME = 'assembly relationship');
 
  REPEAT i := 1 TO HIINDEX(cl_ass);
    clfied_inst := clfied_inst + cl_ass[i].items;
  END_REPEAT;
  
  WHERE
    WR1:  SIZEOF(QUERY(pdr <* clfied_inst | 
          (NOT(SIZEOF(WHICH_CLASS(pdr.relating_product_definition)) >0))
          )) -
          SIZEOF(QUERY(pdr <* clfied_inst | 
         (NOT(SIZEOF(WHICH_CLASS(pdr.related_product_definition)) >0))
         )) 
         =0;    
END_RULE;



RULE  
author_for_change_plan
FOR(applied_person_and_organization_assignment, 
person_and_organization_role, action_request_solution);
  LOCAL
    t1_set:  SET OF action_request_solution := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action_request_solution | 
             VALUE_IN(WHICH_CLASS(a), 'change plan'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
author_for_change_realisation
FOR(applied_person_and_organization_assignment,
 person_and_organization_role, executed_action);
  LOCAL
    t1_set:  SET OF executed_action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* executed_action | 
             VALUE_IN(WHICH_CLASS(a), 'change realisation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
author_for_change_request
FOR(applied_person_and_organization_assignment, 
person_and_organization_role, versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'author')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_by_for_check
FOR(applied_person_and_organization_assignment, 
person_and_organization_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 'check'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_by_for_envisaged_version_creation
FOR(applied_person_and_organization_assignment, 
person_and_organization_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'envisaged version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_by_for_version_creation
FOR(applied_person_and_organization_assignment, 
person_and_organization_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:   SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_by_for_version_deletion
FOR(applied_person_and_organization_assignment, 
person_and_organization_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version deletion'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_by_for_version_modification
FOR(applied_person_and_organization_assignment, 
person_and_organization_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:   SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version modification'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused by')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_when_for_check
FOR(applied_date_and_time_assignment, date_time_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 'check'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_when_for_envisaged_version_creation
FOR(applied_date_and_time_assignment, date_time_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | VALUE_IN(WHICH_CLASS(a), 
             'envisaged version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_when_for_version_creation
FOR(applied_date_and_time_assignment, date_time_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version creation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_when_for_version_deletion
FOR(applied_date_and_time_assignment, date_time_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version deletion'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
caused_when_for_version_modification
FOR(applied_date_and_time_assignment, date_time_role, action);
  LOCAL
    t1_set:  SET OF action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* action | 
             VALUE_IN(WHICH_CLASS(a), 'version modification'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'caused when')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;




RULE centre_location_compound_representation_has_specified_name
FOR (compound_representation_item, APPLIED_CLASSIFICATION_ASSIGNMENT);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['longitudinal location', 'transversal location', 'vertical location'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'centre location');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
   violation := (SIZEOF(QUERY(items <* t2_set | items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;

END_RULE;



RULE
change_impact_with_versionable_object_change_event
FOR(applied_action_request_assignment, object_role, action);
  LOCAL
    t1_set:  SET OF applied_action_request_assignment := [];
    a_set:   SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  
   t1_set := QUERY(b <* applied_action_request_assignment | 
                   (b.role.name= 'change impact'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
          a_set := QUERY(b <* t1_set[i].items | 
          ('SHIP_STRUCTURES_SCHEMA.ACTION' IN TYPEOF(b)) AND
             VALUE_IN(WHICH_CLASS(b), 'versionable object change event'));
         violate := SIZEOF(a_set) = 0;
      END_REPEAT;

WHERE
    WR1: NOT violate;
END_RULE;


RULE 
change_plan_has_mandatory_attribute_description
FOR (action_request_solution);
LOCAL
    t1_set:  SET OF action_request_solution := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action_request_solution | 
  VALUE_IN(WHICH_CLASS(i), 'change plan')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;


RULE class_and_statutory_designation_has_properties
FOR (product_definition, 
property_definition_representation, 
group, applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF property_definition := [];
    t4_set:  SET OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'class and statutory designation');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;



RULE class_notation_with_named_representation_items
FOR (representation, representation_item, property_definition_representation);
LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['class notations hull', 
                                  'class notations machinery'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
             'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
             'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) < 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;


RULE class_parameters_has_properties
FOR (product_definition, 
property_definition_representation, 
group, applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF property_definition := [];
    t4_set:  SET OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class parameters');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'class parameters');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;


RULE 
corrugated_structure_design_definition_has_at_least_one_class
FOR(product_definition_shape, 
shape_aspect, 
group, applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'corrugated structure design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set |
      'border' IN WHICH_CLASS(t2_inst))) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
corrugated_structure_design_definition_has_at_most_one_class 
FOR(product_definition_shape, 
shape_aspect, 
group, applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =
                    'corrugated structure design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set | 'moulded surface'
      IN WHICH_CLASS(t2_inst))) > 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE  
date_time_for_change_realisation
FOR(applied_date_and_time_assignment, date_time_role, executed_action);
  LOCAL
    t1_set:  SET OF executed_action := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* executed_action | 
             VALUE_IN(WHICH_CLASS(a), 'change realisation'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE  
date_time_for_change_request
FOR(applied_date_and_time_assignment, date_time_role,  versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_date_and_time_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_date_and_time_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'date time')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;


RULE 
 define_maximum_permissible_still_water_bending_moment_values
FOR(product_definition, 
    property_definition_representation, 
    APPLIED_CLASSIFICATION_ASSIGNMENT);


  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 
                   'maximum permissible still water bending moment');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
    'maximum permissible still water bending  moment values')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
 definition_for_design_still_water_bending_moment_parameters
FOR(product_definition, 
    property_definition_representation, 
    APPLIED_CLASSIFICATION_ASSIGNMENT);


  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 
                   'design still water bending moment');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
    'design still water bending moment parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
 definition_for_design_vertical_wave_bending_moment_parameters
FOR(product_definition, 
    property_definition_representation, 
    APPLIED_CLASSIFICATION_ASSIGNMENT);


  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 
                   'design vertical wave bending moment');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
    'design vertical wave bending moment parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE 
 definition_for_design_vertical_wave_shear_force_parameters
FOR(product_definition, 
    property_definition_representation, 
    APPLIED_CLASSIFICATION_ASSIGNMENT);


  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 
                   'design vertical wave shear force');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
    'design vertical wave shear force parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  
define_maximum_permissible_still_water_shear_force_values
FOR(product_definition, 
    property_definition_representation, 
    APPLIED_CLASSIFICATION_ASSIGNMENT);


  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 
                   'maximum permissible still water shear force');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
    'maximum permissible still water shear force values')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE document_has_at_least_one_references
FOR(document, document_representation_type);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF document_representation_type := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
                                   'document')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.DOCUMENT_REPRESENTATION_TYPE.'+
      'REPRESENTED_DOCUMENT'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE document_has_exactly_one_author
FOR(document);
  LOCAL
    bag_1: BAG OF applied_person_assignment := [];
    bag_2: BAG OF applied_person_and_organization_assignment := [];
    bag_3: BAG OF applied_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
REPEAT i := 1 TO SIZEOF(document) WHILE (NOT violate);
  bag_1 := USEDIN(document[i], 'SHIP_STRUCTURES_SCHEMA.' + 
         'APPLIED_PERSON_ASSIGNMENT.ITEMS');
  bag_2 := USEDIN(document[i], 'SHIP_STRUCTURES_SCHEMA.' + 
         'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS');
  bag_3 := USEDIN(document[i], 'SHIP_STRUCTURES_SCHEMA.' + 
         'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS');
    violate := NOT ((SIZEOF( bag_1 ) + SIZEOF( bag_2 )+ SIZEOF( bag_3 ))= 1);
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE document_reference_has_at_least_one_references
FOR(document, document_usage_constraint);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF document_usage_constraint := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
                                  'document reference')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.DOCUMENT_USAGE_CONSTRAINT.SOURCE'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE 
document_reference_reference_with_address_with_references
FOR(document, document_usage_constraint);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF document_usage_constraint := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
           'document reference reference with address')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
          'SHIP_STRUCTURES_SCHEMA.DOCUMENT_USAGE_CONSTRAINT.SOURCE'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE document_reference_with_address_has_at_least_one_references
FOR(document, 
    applied_external_identification_assignment);
  LOCAL
    t1_set:  SET OF document := [];
    t2_set:  SET OF applied_external_identification_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(i <* document | VALUE_IN(WHICH_CLASS(i), 
                                'document reference with address')); 
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
  'SHIP_STRUCTURES_SCHEMA.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violate := SIZEOF(t2_set) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;



RULE 
envisaged_version_creation_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
   'envisaged version creation')); 
   violate := (SIZEOF(QUERY(k <* t1_set | 
   NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;



RULE executed_action_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF executed_action := [];
    t2_set:  SET OF executed_action := [];
    arg_list:  LIST OF STRING := [ 'definable object'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE externally_defined_class_with_known_source_requirement FOR
(externally_defined_class);
WHERE
    WR1: SIZEOF ( QUERY ( edc <* externally_defined_class | 
       ('SHIP_STRUCTURES_SCHEMA.KNOWN_SOURCE' IN TYPEOF ( edc.source ) ) AND 
       ( SIZEOF ( QUERY ( aoa <* 
       USEDIN ( edc 
       ,'SHIP_STRUCTURES_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' )
       | aoa. role.name = 'library supplier' ) ) =0 ) ) ) =0;
END_RULE;

RULE flare_area_parameters_has_exactly_two_representation_items
FOR (representation, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
      'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'flare area parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
      violation := SIZEOF(reps[i].items) > 2;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;


RULE freeboard_characteristics_has_properties

FOR (product_definition, property_definition, property_definition_representation, 
applied_classification_assignment);

LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF property_definition := [];
    t4_set:  SET OF product_definition := [];

    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'freeboard characteristics');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'freeboard characteristics');


  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;


  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;


  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE global_axis_placement_has_properties
FOR (property_definition_representation, 
group, applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF property_definition := [];
    t4_set:  SET OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'global axis placement');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'global axis placement');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;



RULE global_id_is_unique 
FOR (APPLIED_IDENTIFICATION_ASSIGNMENT);
  LOCAL
    set_1:  SET OF APPLIED_IDENTIFICATION_ASSIGNMENT:= [];
    bag_2:     BAG OF STRING := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 


  set_1 := QUERY(i <* APPLIED_IDENTIFICATION_ASSIGNMENT |
                          (i.role.name = 'globally unambiguous identifier'));

REPEAT i := 1 TO HIINDEX(set_1);
    bag_2 := bag_2 + [set_1[i].assigned_id];

END_REPEAT;
violation := SIZEOF(QUERY(i <* set_1 | NOT(i.assigned_id LIKE '*:*')) )= 0;

WHERE
    WR1: VALUE_UNIQUE(bag_2);
    WR2:  NOT violation;
END_RULE;



RULE group_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF group := [];
    t2_set:  SET OF group := [];
    arg_list:  LIST OF STRING := ['structural cutout boundary relationship'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
homogeneous_ship_material_property_has_named_references 
FOR(object_role, group, applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_document_reference := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'homogeneous_ship material property');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.APPLIED_DOCUMENT_REFERENCE.ITEMS'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set |
       t2_inst.role.name = 'material reference')) > 1;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;

RULE hull_cross_section_contains_specified_classes FOR (
             applied_group_assignment, group, 
             applied_classification_assignment);
    LOCAL
      violation : LOGICAL := FALSE;
      cl_ass    : SET OF applied_classification_assignment := [];
      gr_ass    : SET OF applied_group_assignment := [];
      pd        : SET OF product_definition := [];
      groups    : SET OF group := [];
    END_LOCAL;
    cl_ass := QUERY ( i <* applied_classification_assignment | ((i.role.
        name = 'class membership') AND (i.assigned_class.name = 
        'hull cross section')) );
    REPEAT i := 1 TO HIINDEX(cl_ass) BY 1;
      REPEAT j := 1 TO HIINDEX(cl_ass[i].items) BY 1;
        pd := pd + cl_ass[i].items[j];
      END_REPEAT;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | (i.role.name = 
        'equivalence') );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1;
      REPEAT j := 1 TO HIINDEX(gr_ass[i].items) BY 1;
        IF gr_ass[i].items[j] IN pd THEN
          groups := groups + gr_ass[i].assigned_group;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | (((SIZEOF(i.items) 
        <> 0) AND (i.role.name = 'item structure')) AND (i.assigned_group 
        IN groups)) );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1 WHILE NOT violation;
      violation := SIZEOF(QUERY ( inst <* gr_ass[i].items | ((
          'compartment' IN which_class(inst)) AND ('structural system' IN 
          which_class(inst))) )) > 0;
    END_REPEAT;
  WHERE
    wr1: NOT violation;
  END_RULE;

RULE 
hull_cross_section_design_definition_for_representation_items
FOR (property_definition_representation, representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
      'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'hull cross section design definition parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
      violation := SIZEOF(reps[i].items) > 1;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;


RULE 
hull_cross_section_design_has_at_least_one_revision_with_context
 FOR(group, applied_classification_assignment);

  LOCAL
    c_a_set: SET OF applied_classification_assignment := [];
    t1_set:  SET OF product_definition_shape := [];
    gr_ass_set:  SET OF applied_group_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 
                   'hull cross section design definition');

 
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    gr_ass_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
    violation := SIZEOF(QUERY(aga <* gr_ass_set | 
      (aga.role.name = 'members') 
      AND
      ('revision with context' IN WHICH_CLASS(aga.assigned_group)))) < 1;
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
hull_cross_section_design_has_at_most_one_revision_with_context
 FOR(group, applied_classification_assignment);

  LOCAL
    c_a_set: SET OF applied_classification_assignment := [];
    t1_set:  SET OF product_definition_shape := [];
    gr_ass_set:  SET OF applied_group_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'hull cross section design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    gr_ass_set := bag_to_set(USEDIN(t1_set[i],
       'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
    violation := SIZEOF(QUERY(aga <* gr_ass_set | 
     (aga.role.name = 'members') 
     AND
     ('revision with context' IN WHICH_CLASS(aga.assigned_group)))) > 1;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
hull_cross_section_has_at_least_one_revision_with_context
 FOR(object_role, group, applied_classification_assignment);

  LOCAL
    c_a_set: SET OF applied_classification_assignment := [];
    t1_set:  SET OF product_definition := [];
    gr_ass_set:  SET OF applied_group_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'hull cross section');

 
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    gr_ass_set := bag_to_set(USEDIN(t1_set[i],
        'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
    violation := SIZEOF(QUERY(aga <* gr_ass_set | 
       (aga.role.name = 'context of revision') 
       AND
      ('revision with context' IN WHICH_CLASS(aga.assigned_group)))) < 1;
  END_REPEAT;

  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
hull_cross_section_optionally_contains_specified_classes
FOR (group, applied_classification_assignment, applied_group_assignment);

  LOCAL
    cl_ass:    SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    pd:        SET OF PRODUCT_DEFINITION := [];
    gr_ass:    SET OF APPLIED_GROUP_ASSIGNMENT := [];
    groups:    SET OF GROUP := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  cl_ass := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                  (i.role.name = 'class membership') AND
                  (i.assigned_class.name = 'hull cross section'));
  REPEAT i := 1 TO HIINDEX(cl_ass);
    pd := pd + cl_ass[i].items;
  END_REPEAT;
 
  gr_ass := QUERY(i <* APPLIED_GROUP_ASSIGNMENT |
                  i.role.name = 'equivalence');
  REPEAT i := 1 TO HIINDEX(gr_ass);
    REPEAT j := 1 TO HIINDEX(gr_ass[i].items);  -- should always be just one
      IF (gr_ass[i].items[j] IN pd) THEN
        groups := groups + gr_ass[i].assigned_group;
      END_IF;
    END_REPEAT;
  END_REPEAT;
 
  gr_ass := QUERY(i <* APPLIED_GROUP_ASSIGNMENT |
                  (SIZEOF(i.items) <> 0) AND
                  (i.role.name = 'item structure') AND
                  (i.assigned_group IN groups));
 
  REPEAT i := 1 TO HIINDEX(gr_ass) WHILE NOT violation;
    violation := SIZEOF(QUERY(inst <* gr_ass[i].items |
                  'structural system' IN WHICH_CLASS(inst))) = 0;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
hull_cross_section_result_for_representation_item
FOR (representation, representation_item, group, 
 applied_classification_assignment);

LOCAL
    c_a_set: SET OF applied_classification_assignment := [];
    classed_rep_set: SET OF representation := [];
    arg_list:  LIST OF STRING := [ 'actual first moment horizontal', 
   'actual first moment vertical', 'actual inertia cross', 
   'actual inertia horizontal', 'actual inertia torsion', 
   'actual inertia vertical', 'actual neutral axis position horizontal', 
   'actual neutral axis position vertical', 'actual section area', 
   'actual section modulus bottom', 'actual section modulus coaming', 
   'actual section modulus deck', 'actual stress bottom', 
   'actual stress coaming', 'actual stress deck', 
   'actual twist centre horizontal', 'actual twist centre vertical', 
   'direction largest inertia', 'direction least inertia', 
   'max moment', 'max shear force', 'meter weight', 'min moment', 
   'min shear force', 'required section modulus bottom', 
   'required section modulus coaming', 'required section modulus deck', 
   'required stress bottom', 'required stress coaming', 'required stress deck'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'hull cross section result');
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      classed_rep_set:= classed_rep_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
  REPEAT i:=1 TO HIINDEX(classed_rep_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* classed_rep_set[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;



RULE identification_role_optional_attribute_description_required
FOR (identification_role);
WHERE
 WR1: SIZEOF(QUERY(i <* identification_role | 
      ((i.name = 'external reference') 
      AND NOT(EXISTS (i.description))))) = 0;
END_RULE;



RULE  
initiator_for_change_request
FOR(applied_person_and_organization_assignment, person_and_organization_role, 
    versioned_action_request);
  LOCAL
    t1_set:  SET OF versioned_action_request := [];
    a_set:  SET OF applied_person_and_organization_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
   t1_set := QUERY(a <* versioned_action_request | 
             VALUE_IN(WHICH_CLASS(a), 'change request'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
  a_set := QUERY(b <* applied_person_and_organization_assignment | 
               (VALUE_IN(b.items, t1_set[i]) AND 
               (b.role.name = 'initiator')));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;


RULE 
library_manufacturing_definition_for_class_references
FOR(shape_aspect, 
group, applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'library manufacturing definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set | 'source'
      IN WHICH_CLASS(t2_inst))) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE lightship_definition_has_properties

FOR (product_definition, property_definition, property_definition_representation, 
applied_classification_assignment);

LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF property_definition := [];
    t4_set:  SET OF product_definition := [];

    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'lightship_definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'lightship_definition');


  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;


  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;


  violation := t1_set <> t4_set;

  WHERE
    wr1: NOT violation;

  
END_RULE;



RULE mandatory_entity_type_for_external_instance_reference  
FOR(external_source, 
    external_source_relationship);
  LOCAL
    bag_1: BAG OF external_source := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
bag_1 := QUERY(a <* external_source | a.description = 'schema');
 
REPEAT i := 1 TO SIZEOF(bag_1) WHILE (NOT violate);
violate := (SIZEOF( QUERY(
    a <* external_source_relationship | (a.related_source :=: bag_1[i]) AND 
           (a.relating_source.description = 'entity type'))) = 0 );
END_REPEAT;
  WHERE
    WR1: NOT violate;
END_RULE;


RULE 
maximum_of_one_representation_items_for_class_library_definition
FOR (representation, applied_classification_assignment, classification_role,  group);
  LOCAL
    var_representation: BAG OF representation := [];
  END_LOCAL;
 
  var_representation := QUERY(
           temp1 <* representation | 
              SIZEOF (
                 QUERY(
                    temp2 <* bag_to_set(USEDIN(temp1, 
         'SHIP_STRUCTURES_SCHEMA.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS'))
         | ((temp2\classification_assignment.role.name = 
              'class membership') AND
              (temp2\classification_assignment.assigned_class\group.name = 
              'library definition'))
                   )
              ) > 0 
           );
  WHERE 
    wr1: SIZEOF(QUERY(temp3 <* var_representation |
                SIZEOF(temp3.items) > 1)) = 0;
END_RULE; 



RULE members_is_referenced_by_at_least_one_revision
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'members'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
               (b.assigned_group = t1_set[i]) AND (b.role.name = 'revision'));

    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;



RULE 
no_approvals_except_in_approval_history 
FOR (approval);
LOCAL
    t1_set:  SET OF approval := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
   t1_set := QUERY(a <* approval | VALUE_IN(WHICH_CLASS(a), 
                                   'approval event'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   t2_set := bag_to_set(USEDIN(t1_set[i], 
   'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
    violate := (SIZEOF(t2_set) = 0);
   REPEAT k := 1 TO HIINDEX(t2_set) WHILE NOT violate;
      violate := NOT (VALUE_IN(WHICH_CLASS(t2_set[k].ASSIGNED_GROUP), 
      'approval history'));
   END_REPEAT;
END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;


RULE 
panel_system_design_definition_has_at_least_one_class
FOR(shape_aspect, 
group, applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'panel system design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set | 'border'
      IN WHICH_CLASS(t2_inst))) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
panel_system_design_definition_has_at_most_one_class 
FOR(shape_aspect, 
group, applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'panel system design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set | 
    'moulded surface' IN WHICH_CLASS(t2_inst))) > 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
panel_system_optionally_contains_specified_classes
FOR (group, applied_classification_assignment, applied_group_assignment);

  LOCAL
    cl_ass:    SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    pd:        SET OF PRODUCT_DEFINITION := [];
    gr_ass:    SET OF APPLIED_GROUP_ASSIGNMENT := [];
    groups:    SET OF GROUP := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  cl_ass := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                  (i.role.name = 'class membership') AND
                  (i.assigned_class.name = 'panel system'));
  REPEAT i := 1 TO HIINDEX(cl_ass);
    pd := pd + cl_ass[i].items;
  END_REPEAT;
 
  gr_ass := QUERY(i <* APPLIED_GROUP_ASSIGNMENT |
                  i.role.name = 'equivalence');
  REPEAT i := 1 TO HIINDEX(gr_ass);
    REPEAT j := 1 TO HIINDEX(gr_ass[i].items);  -- should always be just one
      IF (gr_ass[i].items[j] IN pd) THEN
        groups := groups + gr_ass[i].assigned_group;
      END_IF;
    END_REPEAT;
  END_REPEAT;
 
  gr_ass := QUERY(i <* APPLIED_GROUP_ASSIGNMENT |
                  (SIZEOF(i.items) <> 0) AND
                  (i.role.name = 'item structure') AND
                  (i.assigned_group IN groups));
 
  REPEAT i := 1 TO HIINDEX(gr_ass) WHILE NOT violation;
    violation := SIZEOF(QUERY(inst <* gr_ass[i].items |
                              'plate' IN WHICH_CLASS(inst))) = 0;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
plate_design_definition_has_at_least_one_class_references
FOR(shape_aspect, group,
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'plate design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set | 'border'
      IN WHICH_CLASS(t2_inst))) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
plate_design_definition_has_at_most_one_class_references 
FOR(shape_aspect, group,
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'plate design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set |
      'moulded surface' IN WHICH_CLASS(t2_inst))) > 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
plate_manufacturing_definition_has_class_references
FOR(shape_aspect, group,
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'plate manufacturing definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set | 'outer contour'
      IN WHICH_CLASS(t2_inst))) < 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE principal_characteristics_has_properties
FOR (property_definition_representation, group,
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF property_definition := [];
    t4_set:  SET OF product_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'principal characteristics');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  t2_set:= QUERY(i <* PROPERTY_DEFINITION_REPRESENTATION |
                   i.NAME = 'principal characteristics');
  REPEAT i := 1 TO HIINDEX(t2_set);
    t3_set := t3_set + t2_set[i].definition;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(t3_set);
    t4_set := t4_set + t3_set[i].definition;
  END_REPEAT;
  violation := t1_set <> t4_set;
  WHERE
    WR1: NOT violation;
  
END_RULE;


RULE  
product_definition_for_call_sign
FOR(product_definition, 
applied_identification_assignment, group, 
applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
        'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
        'call sign')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_for_class_notation
FOR(property_definition, group,
applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 'class notation' 
      IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_for_design_still_water_shear_force_values
FOR(product_definition, 
    property_definition_representation, 
    APPLIED_CLASSIFICATION_ASSIGNMENT);


  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 
                   'design still water shear  force');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
    'design still water shear force values')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_for_flag_state
FOR(product_definition, 
applied_identification_assignment, group,
applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'flag state')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_for_port_of_registration
FOR(product_definition, 
applied_identification_assignment, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name =
     'port of registration')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_for_regulation
FOR(product_definition, 
property_definition, group,
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'class and statutory designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 'regulation' 
    IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_for_shipyard
FOR(product_definition, 
applied_organization_assignment, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'shipyard designation');
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
    'shipyard')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;


RULE product_definition_has_references_with_class_loadline
FOR(product_definition, property_definition, APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'freeboard characteristics');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
          'SHIP_STRUCTURES_SCHEMA.' + 'PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 'loadline' 
           IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_local_coordinate_system_with_station_reference
FOR(product_definition, 
property_definition, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF property_definition := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'hull cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
     'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
     'local co ordinate system with station reference' 
     IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
product_definition_relationship_with_definable_object
FOR (product_definition_relationship, group,
 applied_classification_assignment);

  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(APPLIED_CLASSIFICATION_ASSIGNMENT);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'definable object') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;


RULE product_definition_relationship_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_relationship := [];
    t2_set:  SET OF product_definition_relationship := [];
    arg_list:  LIST OF STRING := ['assembly relationship',
               'structural part penetration relationship',
               'structural system penetration relationship' ];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_shape_for_assembly_manufacturing
FOR(property_definition_representation, group,
 applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'assembly manufacturing definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 
              'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
                 'assembly manufacturing definition parameters')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_bevel_design_parameters
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'bevel design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
     t2_inst.name = 'bevel design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_shape_for_beveled_groove_weld_design
FOR(product_definition_shape, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'beveled groove weld');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
         'beveled groove weld design parameters')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_butt_groove_weld_design
FOR(product_definition_shape, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'butt groove weld');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
        'butt groove weld design parameters')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_circular_cutout_design_parameters
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'circular cutout design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'circular cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_shape_for_class_torch_vector
FOR(product_definition_shape, 
shape_aspect, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'weld manufacturing definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
     'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
     'torch vector' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_continuous_fillet_weld_design
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'continuous fillet weld');
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
        'continuous fillet  weld design parameters')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;

RULE  
product_definition_shape_for_corrugated_part_design
FOR(product_definition_shape, 
property_definition_representation, group,
Applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'corrugated part design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'corrugated part design parameters')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_corrugated_structure_design
FOR(product_definition_shape, 
property_definition_representation, group,
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'corrugated structure design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      ' corrugated structure design parameters')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_shape_for_corrugation
FOR(product_definition_shape, 
shape_aspect, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'corrugated part design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
     'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
     'corrugation' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  product_definition_shape_for_drain_hole_cutout_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'drain hole cutout design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
    t2_inst.name = 'drain hole cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_elliptical_cutout_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'elliptical cutout design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
   'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
    t2_inst.name = 'elliptical cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_elongated_oval_cutout_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'elongated oval cutout l design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
      t2_inst.name = 'elongated oval cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_fillet_weld_design_parameters
FOR(product_definition_shape, 
property_definition_representation, group,
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'fillet weld');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'fillet  weld design parameters')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;



RULE 
product_definition_shape_for_free_form_interior_cutout_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'free form interior cutout design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
    'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
      t2_inst.name = 'free form interior cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_groove_weld_design
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'groove weld');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'groove weld design parameters')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_shape_for_hull_cross_section_design_definition
FOR(product_definition);

  LOCAL
    t1_set1:  SET OF product_definition_shape := [];
    t1_set2:  SET OF product_definition_shape := [];
    t2_set:  SET OF product_definition := [];
    gr_ass_set:  SET OF applied_group_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
  t2_set := QUERY(all_t2_inst <* product_definition |
                   'hull cross section' IN which_class(all_t2_inst));
  REPEAT i := 1 TO HIINDEX(t2_set) WHILE NOT violation;
    t1_set1 := QUERY (pd <* bag_to_set(USEDIN(t2_set[i], 
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION.DEFINITION'))|
    'SHIP_STRUCTURES_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd));
    t1_set2 := QUERY(t1_inst1 <* t1_set1 |
             'hull cross section design definition' 
             IN which_class(t1_inst1));
    REPEAT j := 1 TO HIINDEX(t1_set2);
      gr_ass_set := QUERY(aga <* bag_to_set(USEDIN(t1_set2[j], 
       'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS')) |
       (aga.role.name = 'versions') 
       AND
      ('version history' IN WHICH_CLASS(aga.assigned_group)));
    END_REPEAT;
    violation := SIZEOF(gr_ass_set) > 1;
    gr_ass_set := []; 
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_intermittent_fillet_weld_design
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'intermittent fillet weld');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
    'intermittent fillet  weld design parameters')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_inward_round_corner_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
          i.ASSIGNED_CLASS.NAME = 'inward round corner design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
    'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
     t2_inst.name = 'inward round corner design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_library_definition_parameters
FOR(product_definition_shape, 
shape_aspect, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'library definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
       'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
       'library definition parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_library_design_parameters
FOR(product_definition_shape, 
shape_aspect, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'library design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
       'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
       'library design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_library_manufacturing_defiinition
FOR(product_definition_shape, 
shape_aspect, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'library manufacturing definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
       'library manufacturing defiinition parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_manufacturing_definition_parameters
FOR(product_definition_shape, 
shape_aspect, group,
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'manufacturing definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
       'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
       'manufacturing definition parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
product_definition_shape_for_name
FOR(product_definition_shape, 
shape_aspect, group,
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'library design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
     'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
     'name' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_outer_contour_representation
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'plate manufacturing definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
                  'outer contour representation')) = 1);
  END_REPEAT;
  WHERE
    wr1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_outward_round_corner_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
          i.ASSIGNED_CLASS.NAME = 'outward round corner design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
   'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
   t2_inst.name = 'outward round corner design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_panel_system_design_parameters
FOR(product_definition_shape, 
property_definition_representation, group,
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =
                    'panel system design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'panel system design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_part_edge_cutout_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
            i.ASSIGNED_CLASS.NAME = 'part edge cutout design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
   t2_inst.name = 'part edge cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_plate_design_parameters
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =
                    'plate design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
    'plate design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
product_definition_shape_for_profile_cross_section
FOR(product_definition_shape, 
shape_aspect, group,
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'profile design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
     'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
     'profile cross section' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_profile_design_parameters
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'profile design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
    'profile design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_rectangular_cutout_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
            i.ASSIGNED_CLASS.NAME = 'rectangular cutout design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
   'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
   t2_inst.name = 'rectangular cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE 
 product_definition_shape_for_round_corner_rectangular_cutout
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
 i.ASSIGNED_CLASS.NAME = 'round corner rectangular cutout design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
    t2_inst.name = 'round corner rectangular cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE 
 product_definition_shape_for_round_edge_rectangular_cutout
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
  i.ASSIGNED_CLASS.NAME = 'round edge rectangular cutout design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
   'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
   'round edge rectangular cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_shear_bevel_design_parameters
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'shear bevel design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
    'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'shear bevel design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_shape_for_source
FOR(product_definition_shape, 
shape_aspect, group,
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'library definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
      'source' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_spot_seam_weld_design
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spot seam weld');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
       'spot seam weld design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_structural_part_joint_design
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'structural part joint design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'structural part joint design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_structural_system_design
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'structural system design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'structural system design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE  product_definition_shape_for_triangular_cutout_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'triangular cutout design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
    'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
    t2_inst.name = 'triangular cutout design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
product_definition_shape_for_welded_joint_design_parameters
FOR(product_definition_shape, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'welded joint design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'welded joint design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
product_definition_shape_has_references_for_centre_of_gravity
FOR(product_definition_shape, 
shape_aspect, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'assembly manufacturing definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
     'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
     'centre of gravity' IN WHICH_CLASS(t2_inst))) = 1);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


	
RULE  product_definition_shape_has_references_with_name_weld_design_parameters
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);


  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'weld design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
        'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
              t2_inst.name = 'weld design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE product_definition_shape_has_references_with_class_border
FOR(product_definition_shape, 
shape_aspect, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'corrugated part design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
     'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
    'border' IN WHICH_CLASS(t2_inst))) = 2);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE 
 product_definition_shape_of_rectangular_cutback_corner_design
FOR(product_definition_shape, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
     i.ASSIGNED_CLASS.NAME = 'rectangular cutback corner design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
    t2_inst.name = 'rectangular cutback corner design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_shape_with_definition_matches_pattern
FOR (property_definition_representation, group,
 applied_classification_assignment);

  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(APPLIED_CLASSIFICATION_ASSIGNMENT);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'DEFINITION') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;


RULE product_definition_shape_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF product_definition_shape := [];
    arg_list:  LIST OF STRING := ['explicit feature design definition',
'assembly manufacturing definition',
'structural added material feature design definition',
'structural part manufacturing definition',
'corrugated part design definition',
'plate',
'plate design definition',
'profile design definition',
'weld manufacturing definition',
'bevel design definition',
'circular cutout design definition',
'drain hole cutout design definition',
'elliptical cutout design definition',
'elongated oval cutout design definition',
'free form interior cutout design definition',
'inward round corner design definition',
'outward round corner design definition',
'part edge cutout design definition',
'rectangular cutback corner design definition',
'rectangular cutout design definition',
'round edge rectangular cutout design definition',
'seam design definition',
'shear bevel design definition',
'triangular cutout design definition'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_shape_with_versionable_object
FOR (group, applied_classification_assignment);

  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(APPLIED_CLASSIFICATION_ASSIGNMENT);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'versionable object') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;

RULE 
product_definition_shape_with_versionable_object_matches_pattern
FOR (group, applied_classification_assignment);
  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(APPLIED_CLASSIFICATION_ASSIGNMENT);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'versionable object') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;


RULE  product_definition_with_date_freeboard_assigned
FOR(product_definition, 
applied_date_and_time_assignment, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_date_and_time_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'freeboard characteristics');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
         'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
                        'date freeboard assigned')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
product_definition_with_definable_object_matches_pattern
FOR (product_definition, group, applied_classification_assignment);

  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(APPLIED_CLASSIFICATION_ASSIGNMENT);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'definable object') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;


RULE  product_definition_with_freeboard_assigned_by
FOR(product_definition, 
applied_organization_assignment, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'freeboard characteristics');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_STRUCTURES_SCHEMA.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
                       'freeboard assigned by')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE product_definition_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF product_definition := [];
    arg_list:  LIST OF STRING := [ 'principal characteristics',
                                   'class and statutory designation',
                                   'freeboard characteristics',
                                   'lightship definition',
                                   'ship designation',
                                   'shipyard designation',
                                   'owner designation',
                                   'assembly',
                                   'corrugated part',
                                   'plate boundary relationship',
                                   'profile',
                                   'versionable object'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE product_related_product_category_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_related_product_category := [];
    t2_set:  SET OF product_related_product_category := [];
    arg_list:  LIST OF STRING := [ 'ship type'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;




RULE product_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product := [];
    t2_set:  SET OF product := [];
    arg_list:  LIST OF STRING := [ 'definable object'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
profile_cross_section_has_at_most_one_named_references 
FOR(shape_aspect, 
property_definition_representation, group, 
Applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'profile cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
     'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set |
      t2_inst.name = 'section properties')) > 1;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
profile_design_definition_has_at_most_one_class_references 
FOR(product_definition_shape, 
shape_aspect, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'profile design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set |
      'profile curve trace line' IN WHICH_CLASS(t2_inst))) > 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
profile_design_definition_has_zero_or_two_class_references 
FOR(product_definition_shape, 
shape_aspect, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition_shape := [];
    t2_set:  SET OF shape_aspect := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'profile design definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set |
      'border' IN WHICH_CLASS(t2_inst))) = 0) AND
                 NOT (SIZEOF(QUERY(t2_inst <* t2_set |
                  'border' IN WHICH_CLASS(t2_inst))) = 2);
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
property_definition_for_class_notation
FOR(property_definition, 
property_definition_representation, group,
Applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'class notation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'class notation')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
property_definition_for_class_society
FOR(property_definition, 
applied_organization_assignment, group, 
applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_organization_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'class notation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 
      'class society')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
property_definition_for_corrugated_structure_function
FOR(property_definition, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'corrugated structure functional definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.'+
        'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'corrugated structure function parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  property_definition_for_edge_cutout_function_parameters
FOR(property_definition, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'edge cutout functional definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
     'edge cutout function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE  property_definition_for_edge_feature_function_parameters
FOR(property_definition, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
             i.ASSIGNED_CLASS.NAME = 'edge feature functional definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
    t2_inst.name = 'edge feature function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  
property_definition_for_homogeneous_ship_material_property
FOR(property_definition, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'homogeneous ship material property');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'homogeneous ship  material property parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE  property_definition_for_interior_cutout_function_parameters
FOR(property_definition, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
          i.ASSIGNED_CLASS.NAME = 'interior cutout functional definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
    t2_inst.name = 'interior cutout function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE  property_definition_for_local_coordinate_system
FOR(property_definition, 
property_definition_representation, APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'local coordinate system');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION' + '.' + 'DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'local coordinate system')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE  
property_definition_for_local_coordinate_system_with_position
FOR(property_definition, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'local co ordinatesystem with position reference');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'local co ordinatesystem with position reference')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
property_definition_for_panel_system_function_parameters
FOR(property_definition, 
property_definition_representation, group,
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'panel system functional definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'panel system function parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
property_definition_for_plate_function_parameters
FOR(property_definition, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'plate functional definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'plate function parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
property_definition_for_plate_strake_function_parameters
FOR(property_definition, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'plate strake functional definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
      'plate strake function parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
property_definition_for_profile_function_parameters
FOR(property_definition, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'profile functional definition');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'profile function parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
property_definition_for_ship_material_property_parameters
FOR(property_definition, 
property_definition_representation, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'ship material property');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'ship material property parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE  
property_definition_for_structural_system_function_parameters
FOR(property_definition, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'structural system functional definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | 
          t2_inst.name = 'structural system function parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  property_definition_for_weld_filler_material_design
FOR(property_definition,
 property_definition_representation,
 APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'weld filler material');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 
    'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
     'weld filler material design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;




RULE  property_definition_has_references_with_name_loadline
FOR(property_definition, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'loadline');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.' +
     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'loadline')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE 
 property_definition_structural_weld_shrinkage_allowance_feature
FOR(property_definition, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'structural weld shrinkage allowance feature design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'structural weld shrinkage allowance feature design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  property_definition_to_structural_added_material_feature_design
FOR(property_definition, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL  := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'structural added material feature design definition');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'structural added material feature design parameters')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
property_definition_with_definition_matches_pattern
FOR (group, applied_classification_assignment);

  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(Applied_classification_assignment);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'DEFINITION') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;



RULE property_definition_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition := [];
    arg_list:  LIST OF STRING := [ 'moulded form characteristics definition',
                                'ship overall dimensions',
                                'local co ordinate system',
                                'spacing table',
                                'global axis placement',
                                'hydrostatic definition',
                                'stability definition',
                                'plate functional definition',
                                'profile functional definition',
                                'edge cutout functional definition',
                                'edge feature functional definition',
                                'interior cutout functional definition',
        'structural weld shrinkage allowance  feature design definition'];

    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE  property_definition_has_references_lightship_weight_item
FOR(property_definition, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'lightship weight item');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_STRUCTURES_SCHEMA.' +
      'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
                       'lightship weight item')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
property_definition_with_versionable_object_matches_pattern
FOR (group, applied_classification_assignment);
  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(Applied_classification_assignment);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'versionable object') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;


RULE  property_definition_with_weight_and_centre_of_gravity
FOR(property_definition, 
property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'weight and centre of gravity');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_STRUCTURES_SCHEMA.' + 
    'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 
                  'weight and centre of gravity')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE 
representation_design_vertical_wave_bending_moment_parameters
FOR (representation);


  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['hogging', 'sagging'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'+
'.USED_REPRESENTATION'))
| (temp_prop_def_rep.name = 'design vertical wave bending moment parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;



RULE representation_for_angle_bar_cross_section_dimensions
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'width', 'radius', 'thk'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
               'USED_REPRESENTATION'))
            | (temp_prop_def_rep.name = 'angle bar cross section dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_assembly_manufacturing_definition
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := 
             ['assembly method','assembly stage','mass','center of gravity'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
              'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
              'USED_REPRESENTATION'))
   | (temp_prop_def_rep.name = 'assembly manufacturing definition parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_bulbflat_cross_section_dimensions
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'bulb width', 'bulb radius', 'tw'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                      'bulbflat cross section dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_for_channel_cross_section_dimensions
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'width', 'web thk',
                                  'flange thk', 'radius', 'k'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                          'channel cross section dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_circular_cutout_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['radius'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'+
    '.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'circular cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_circular_hollow_profile_cross_section
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'width', 'web thk',
                                  'flange thk', 'radius', 'k'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                          'channel cross section dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE
representation_for_class_and_statutory_designation
FOR (representation, representation_item, property_definition_representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['class number'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
               'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                      'class and statutory designation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_corrugated_part_design_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['mirrored', 'offset', 'repetition',
                                  'thickness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                         'corrugated part design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_design_vertical_wave_shear_force_parameters
FOR (representation);


  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['negative value', 'positive value'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'+
  '.USED_REPRESENTATION'))
  | (temp_prop_def_rep.name = 'design vertical wave shear force parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;



RULE representation_for_drain_hole_cutout_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'drain hole radius', 'gap', 'gap radius', 'width'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'+
'.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'drain hole cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_edge_cutout_function_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
    +'.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'edge cutout function parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_edge_feature_function_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
    +'.USED_REPRESENTATION'))
                | (temp_prop_def_rep.name = 'edge feature function parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_electrode_chemical_composition_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['carbon', 'silicon', 'manganese',
                           'phosphorus', 'sulphur', 'nickel', 'molydenum', 
                          'aliminium', 'titanium', 'zirconium', 'chromium', 
                             'copper', 'vanadium'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                          'electrode chemical composition design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_elliptical_cutout_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['half axis a', 'half axis b'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
    +'.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'elliptical cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_elongated_oval_cutout_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['distance', 'r1', 'r2'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
     +'.USED_REPRESENTATION'))
       | (temp_prop_def_rep.name = 'elongated oval cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_explicit_profile_cross_section_shape
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['cross section geometry', 
                                  'local coordinate system'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                     'explicit profile cross section shape')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_flanged_plate_cross_section_dimensions
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'width', 'radius', 'thk'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
               'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                     'flanged plate cross section dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_flat_bar_cross_section_dimensions
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'width'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                   'flat bar cross section dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_global_axis_placement
FOR (representation, representation_item, property_definition_representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['global axes and origin', 
                            'after perpendicular offset', 'orientation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'global axis placement')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_interior_cutout_function_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
     +'.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'interior cutout function parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;



RULE representation_for_inward_round_corner_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['radius', 'x offset', 'y offset'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
     +'.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'inward round corner design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_local_co_ordinate_system
FOR (representation, representation_item, property_definition_representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['local axes and origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                 'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'local co ordinatesystem')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_outward_round_corner_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['radius', 'x offset', 'y offset'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
    +'.USED_REPRESENTATION'))
       | (temp_prop_def_rep.name = 'outward round corner design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_part_edge_cutout_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['r left', 'r right', 'x a', 'x b','x c', 
               'x d', 'y b', 'y c'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
   'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
   +'.USED_REPRESENTATION'))
          | (temp_prop_def_rep.name = 'part edge cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_profile_curve_trace_line_design_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['curve'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'profile curve trace line design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_profile_function_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'profile function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_rectangular_cutback_corner_design
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['radius', 'x depth', 'y depth'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
    +'.USED_REPRESENTATION'))
  | (temp_prop_def_rep.name = 'rectangular cutback corner design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_rectangular_cutout_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['length of', 'width'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
     +'.USED_REPRESENTATION'))
   | (temp_prop_def_rep.name = 'rectangular cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_round_bar_cross_section_dimensions
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['radius'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'round bar cross section dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_round_corner_rectangular_cutout_design
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['corner radius', 'length of', 'width'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
+'.USED_REPRESENTATION'))| (temp_prop_def_rep.name = 
    'round corner rectangular cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_round_edge_rectangular_cutout_design
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['distance', 'edge radius', 'length of', 'width'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
+'.USED_REPRESENTATION'))       | (temp_prop_def_rep.name =
      'round edge rectangular cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;



RULE representation_for_shear_bevel_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['offset', 'x y angle', 'x z angle'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
+'.USED_REPRESENTATION'))
                 | (temp_prop_def_rep.name = 'shear bevel design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_square_tube_cross_section_dimensions
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'width', 'wall thk'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'square tube cross section dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE
representation_for_structural_added_material_feature_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['added_material_length'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                      'structural added material feature '+
                      'design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_structural_part_joint_design
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['tightness','joint orientation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'structural part joint design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_structural_part_symmetry_relationship
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['mirroring plane'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'structural part symmetry relationship design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_structural_system_symmetry_relationship
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['mirroring plane'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                 'structural system symmetry relationship design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_for_t_bar_cross_section_dimensions
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'width', 'web thk', 
                                  'flange thk', 'radius', 'k'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    't bar cross section dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_for_triangular_cutout_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['c1 radius', 'c2 radius', 'c3 radius', 
              'c2 x', 'c3 x', 'c3 y'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
+'.USED_REPRESENTATION'))
        | (temp_prop_def_rep.name = 'triangular cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_for_twist_location_design_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['location', 'direction'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'twist location design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_has_global_unit_assigned_context 
     FOR (REPRESENTATION);
  LOCAL
    has_guac: LOGICAL := TRUE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE has_guac;
    REPEAT j := 1 TO SIZEOF(REPRESENTATION[i].ITEMS) WHILE has_guac;
      IF (('SHIP_STRUCTURES_SCHEMA.VALUE_REPRESENTATION_ITEM' 
          IN TYPEOF(REPRESENTATION[i].ITEMS[j])) OR
          ('SHIP_STRUCTURES_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM'
           IN TYPEOF(REPRESENTATION[i].ITEMS[j]))) THEN
        has_guac := ('SHIP_STRUCTURES_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
         IN TYPEOF(REPRESENTATION[i].CONTEXT_OF_ITEMS));
      END_IF;
    END_REPEAT;
  END_REPEAT;
  WHERE
    WR1: has_guac;  
END_RULE; 



RULE  representation_has_references_with_name_moment_3d
FOR(representation, property_definition_representation, 
APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF representation := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'weight and centre of gravity');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
     'SHIP_STRUCTURES_SCHEMA.' +
      'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name = 'moment 3d')) = 1);
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE
representation_item_corrugated_structure_boundary_relationship 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
              'USED_REPRESENTATION'))
              | (temp_prop_def_rep.name = 
              'corrugated structure boundary relationship design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_item_for_panel_system_curve_boundary_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'panel system curve boundary design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_item_for_structural_weld_shrinkage_allowance 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['longitudinal allowance', 
                                 'transverse allowance', 
                                 'vertical allowance'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                 'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                    'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'structural weld shrinkage allowance feature '+
                    'design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE  
representation_item_for_transformation_to_parent
FOR(property_definition, 
representation, mapped_item, group, 
APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF property_definition_representation := [];
    t3_set:  SET OF representation := [];
    t4_set:  SET OF representation_map := [];
    t5_set:  SET OF mapped_item := [];
    arg_list:  LIST OF STRING := 
['local coordinate system position in global coordinate system', 
'local coordinate system position in parent local coordinate system',
'local coordinate system position in parent local coordinate system with position reference'];
    violation1: LOGICAL := FALSE;
    violation2: LOGICAL := FALSE;

  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
            i.assigned_class.NAME =  'local co ordinate system');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation1 := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.used_representation.name = 
      'local axis representation')) = 1);
    t3_set := t3_set + t2_set[i].used_representation;
  END_REPEAT;
  
   REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t4_set := bag_to_set(USEDIN(t3_set[i], 
      'SHIP_STRUCTURES_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
  END_REPEAT;
  
   REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation1;
    t5_set := bag_to_set(USEDIN(t4_set[i], 
      'SHIP_STRUCTURES_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
      REPEAT j := 1 TO 3WHILE NOT violation2;
      violation2 := NOT (SIZEOF(QUERY(t2_inst <* t5_set | t2_inst.name = 
      ARG_LIST[j])) = 1);
      END_REPEAT;
  END_REPEAT;  
  
  WHERE
    WR1: NOT violation1;
    WR2: NOT violation2;
END_RULE;


RULE 
representation_item_to_structural_system_adjacency_relationship 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                 'USED_REPRESENTATION'))
                 | (temp_prop_def_rep.name = 
                 'structural system adjacency relationship design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_for_corrugated_part_design_parameters 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['mass'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'corrugated part design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_for_corrugated_structure_design 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['corrugation width', 
                                 'user defined tightness'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'corrugated structure design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_for_corrugated_structure_function 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'corrugated structure function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_for_edge_cutout_function_parameters 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
     'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'+
     '.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'edge cutout function parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_for_edge_feature_function_parameters 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
    +'.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'edge feature function parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_for_elongated_oval_cutout_design 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['r3', 'r3 x', 'r3 y'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
     'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
     +'.USED_REPRESENTATION'))
      | (temp_prop_def_rep.name = 'elongated oval cutout design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_for_interior_cutout_function_parameters 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
     +'.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'interior cutout function parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_for_inward_round_corner_design 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['z depth'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
     +'.USED_REPRESENTATION'))
        | (temp_prop_def_rep.name = 'inward round corner design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_for_maximum_permissible_swbm_values
FOR (compound_representation_item);


   LOCAL
    arg_list: LIST OF STRING := ['hogging', 'sagging','position'];
    creps:       BAG OF compound_representation_item := [];
    rep_item:    SET OF representation_item  := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  creps := QUERY( temp_comp_rep_item <* compound_representation_item | 
                     temp_comp_rep_item.name = 'maximum permissible swbm values');

 
REPEAT i:=1 TO HIINDEX(creps) WHILE(NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE(NOT violation);
    REPEAT k:=1 TO HIINDEX(creps[i].item_element);
         rep_item := creps[i].item_element;
         violation:= (SIZEOF(QUERY(items <* rep_item |
                      items.name = arg_list[j])) =1);
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_items_for_maximum_permissible_swsf_values
FOR (compound_representation_item);


   LOCAL
    arg_list: LIST OF STRING := ['negative value', 'positive value', 'position'];
    creps:       BAG OF compound_representation_item := [];
    rep_item:    SET OF representation_item  := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  creps := QUERY( temp_comp_rep_item <* compound_representation_item | 
                     temp_comp_rep_item.name = 'maximum permissible swsf values');

 
REPEAT i:=1 TO HIINDEX(creps) WHILE(NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE(NOT violation);
    REPEAT k:=1 TO HIINDEX(creps[i].item_element);
         rep_item := creps[i].item_element;
         violation:= (SIZEOF(QUERY(items <* rep_item |
                      items.name = arg_list[j])) =1);
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_items_for_outward_round_corner_design 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['z depth'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
    +'.USED_REPRESENTATION'))
       | (temp_prop_def_rep.name = 'outward round corner design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_for_panel_system_boundary_relationship 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'panel system boundary relationship design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_for_panel_system_function_parameters 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'panel system function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_for_profile_boundary_relationship_design 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'profile boundary relationship design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_for_profile_curve_trace_line_design 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'profile curve trace line design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_for_profile_trace_line_relationship_design 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['displacement', 'auxiliary line'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'profile trace line relationship design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_for_rectangular_cutback_corner_design 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['z depth'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
   +'.USED_REPRESENTATION'))
  | (temp_prop_def_rep.name = 'rectangular cutback corner design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_for_seam_curve_relationship_parameter 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['displacement'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'seam curve relationship parameter')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_for_shear_bevel_design_parameters 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['z angle'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
    'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
+'.USED_REPRESENTATION'))
               | (temp_prop_def_rep.name = 'shear bevel design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_bevel_design_parameters 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['z angle'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
      +'.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'bevel design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_optional_for_beveled_groove_weld_design 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['weld backing type', 'taper angle'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                   'USED_REPRESENTATION'))
                   | (temp_prop_def_rep.name = 
                   'beveled groove weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_optional_for_butt_groove_weld_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['weld backing type'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'butt groove weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_class_notation 
FOR (representation, representation_item, property_definition_representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['ice class notation','service factor',
                                 'approval required for heavy cargo'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_corrugation_dimensions 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['radius 1', 'radius 2'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'corrugation dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_groove_weld_design 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['weld backing type'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'groove weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_owner_designation 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['owner approval'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'owner designation')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_optional_for_panel_system_design 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['stiffener spacing', 
                                 'user defined tightness'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'panel system design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_plate_design_parameters 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['mass'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'plate design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_optional_for_plate_function_parameters 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'plate function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_optional_for_plate_strake_function 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'plate strake function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_principal_characteristics 
FOR (representation, representation_item, property_definition_representation);
  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['block coefficient'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'principal characteristics')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_profile_design_parameters 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['mass'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'profile design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_profile_function_parameters 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'profile function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_seam_design_parameters 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['seam curve'];
    found: LOGICAL  := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'+
  '.USED_REPRESENTATION'))
     | (temp_prop_def_rep.name = 'seam design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_optional_for_structural_system_design 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def  tightness'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'structural system design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_structural_system_function 
FOR (representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['user def function'];
    found: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
   'USED_REPRESENTATION'))
       | (temp_prop_def_rep.name = 'structural system function parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_optional_for_weld_design_parameters 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['start suspension', 
                                 'end suspension', 
                                 'weld cross section area'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE 
representation_items_optional_for_weld_filler_material_design 
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps: BAG OF REPRESENTATION := [];
    arg_list: LIST OF STRING := ['chemical composition id', 
                                 'electrode id', 'material strength id', 
                                 'notch impact work id'];
    found: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'weld filler material design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT found);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT found);
      found := (SIZEOF(QUERY(rep_item <* reps[i].items |
                rep_item.name=arg_list[j])) > 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT found;
END_RULE;


RULE representation_items_specified_for_design_swsf_values
FOR (compound_representation_item, 
     representation_item);


   LOCAL
    arg_list: LIST OF STRING := ['negative value', 'positive value',
                                 'position'];
    creps:       BAG OF compound_representation_item := [];
    rep_item:    SET OF representation_item  := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  creps := QUERY( temp_comp_rep_item <* compound_representation_item | 
                     temp_comp_rep_item.name = 'design swsf values');

 
REPEAT i:=1 TO HIINDEX(creps) WHILE(NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE(NOT violation);
    REPEAT k:=1 TO HIINDEX(creps[i].item_element);
         rep_item := creps[i].item_element;
         violation:= (SIZEOF(QUERY(items <* rep_item |
                      items.name = arg_list[j])) =1);
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;

RULE
representation_local_coordinate_system_with_position_reference
FOR (representation, representation_item, property_definition_representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['local axes and origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
               'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
               'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                          'local co ordinatesystem with position reference')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;



RULE 
representation_maximum_permissible_still_water_bending_moment
FOR (representation);


  LOCAL
    reps:       BAG OF REPRESENTATION := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
                temp_rep <* representation | temp_rep.name = 
                'maximum permissible still water bending moment'
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = 'maximum permissible swbm values')) <> 1);
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;




RULE 
representation_of_design_still_water_bending_moment_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['hogging amidship', 'sagging amidship'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'
+'.USED_REPRESENTATION'))
| (temp_prop_def_rep.name = 'design still water bending moment parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;



RULE 
representation_of_maximum_permissible_still_water_shear_force
FOR (representation);


  LOCAL
    reps:       BAG OF REPRESENTATION := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
                temp_rep <* representation | temp_rep.name = 
                'maximum permissible still water shear force'
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = 
                    'maximum permissible swsf values')) <> 1);
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_restricted_by_name_bevel_design_parameters
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['offset', 'x y angle'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
            'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION'+
           '.USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'bevel design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_by_name_class_notation
FOR (representation, representation_item, property_definition_representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['service area', 
                           'approval required for oil cargo', 
                           'approval required for loading unloading aground', 
                           'approval required for unloading grabs'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'class notation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_by_name_class_parameters
FOR (representation, representation_item, property_definition_representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['length class', 'length solas', 
                             'scantlings draught', 'block coefficient class', 
                             'design speed ahead','design speed astern'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'class parameters')
                   )
              ) > 0 
           );
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_restricted_by_name_corrugation_dimensions
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'flat width 1', 'flat width 2',
                                  'slope width'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'corrugation dimensions')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_by_name_flare_area_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['area', 'height'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'flare area parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_by_name_freeboard_characteristics
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['assigned code','freeboard'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                      'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'freeboard characteristics')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;



RULE representation_restricted_by_name_lightship_definition
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['lightship weight',
                                  'lightship centre of gravity'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'lightship_definition')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_restricted_by_name_lightship_weight_item
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['aft weight extent','fwd weight extent'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
      'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'lightship weight item')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;



RULE representation_restricted_by_name_loadline
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['load line length',
                                  'load line depth',
                                  'load line displacement',
                                  'load line block coefficient',
                                  'load line regulation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
     'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'loadline')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_by_name_plate_design_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['material offset', 'thickness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'plate design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_by_name_plate_function_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'plate function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_by_name_principal_characteristics
FOR (representation, representation_item, property_definition_representation);
  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['length between perpendiculars', 
                                  'moulded breadth', 'moulded depth', 
                                  'design draught', 'design deadweight',
                                  'min draught at fp','max draught at fp', 
                                  'min draught at ap','max draught at ap'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'principal characteristics')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_by_name_profile_design_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['mirrored'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'profile design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

RULE representation_restricted_by_name_section_properties
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['nominal mass per length', 'area', 
                                  'na u', 'na v', 'moi u', 'moi v', 
                                  'moi uv', 'tr'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'section properties')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;



RULE 
representation_restricted_by_name_table_of_shear_force_values
FOR (representation);


  LOCAL
    reps:       BAG OF REPRESENTATION := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
   temp_rep <* representation | temp_rep.name = 'table of shear force values'
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = 'design swsf values')) <> 1);
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;



RULE 
representation_restricted_by_name_w_shape_cross_section
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['depth', 'width', 'web thk', 
                                  'flange thk', 'radius', 'k'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'w shape cross section')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE
 representation_restricted_for_assembly_manufacturing_position
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['assembly footprint','orientation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
     | (temp_prop_def_rep.name = 'assembly manufacturing position parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


	
RULE representation_restricted_weight_and_centre_of_gravity
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['mass','centre of gravity'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
          'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
         'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 'weight and centre of gravity')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_beveled_groove_weld_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := 
                ['endcut shape', 'taper', 'sideness', 'weld joint spacer', 
           'configuration', 'penetration', 'joint_orientation', 'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                   'beveled groove weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_butt_groove_weld_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := 
             ['face shape', 'sideness', 'weld joint spacer', 'configuration',
              'penetration', 'joint_orientation', 'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                    'butt groove weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_composite_feature_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['composed of', 'description', 'name'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                      'composite feature design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE
 representation_restricted_for_continuous_fillet_weld_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['endcut shape type', 'sideness',
           'configuration', 'penetration', 'joint_orientation', 'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                 'continuous fillet weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_corrugated_structure_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['thickness', 'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                   'corrugated structure design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE
 representation_restricted_for_corrugated_structure_function
FOR (representation, representation_item,
 property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                              'corrugated structure function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_restricted_for_fillet_weld_design_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['endcut shape type', 'sideness',
           'configuration', 'penetration', 'joint_orientation', 'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                     'fillet weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_restricted_for_groove_weld_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['sideness', 'weld joint spacer',
           'configuration', 'penetration', 'joint_orientation', 'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                                             'groove weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE
representation_restricted_for_homogeneous_ship_material_property
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['density', 'poisson ratio', 
                                  'stress of fracture', 
                                  'thermal expansion coefficient', 
                                  'yield point', 'youngs module'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                             'homogeneous ship material property parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_restricted_for_hull_cross_section_design_definition
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['mirrored symmetry'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                           'hull cross section design definition parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_restricted_for_intermittent_fillet_weld_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['end rules', 'cutout rules', 
           'fillet alignment', 'fillet weld length', 'fillet weld spacing', 
           'penetration rules', 'endcut shape type', 'sideness', 
           'configuration', 'penetration', 'joint_orientation', 'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                              'intermittent fillet weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE
representation_restricted_for_panel_system_curve_boundary
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['curve'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
                'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
                'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                             'panel system curve boundary design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_panel_system_design_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['material offset', 'thickness', 'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'panel system design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_panel_system_function
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'panel system function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_restricted_for_panel_system_plane_boundary
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['plane'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'panel system plane boundary design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_plate_renewal_definition_attributes
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['rule thickness', 'renewal thickness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'plate renewal definition attributes')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_plate_strake_function
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'plate strake function parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_ship_material_property
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['density'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'ship material property parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_spot_seam_weld_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['weld context', 'configuration', 
                                  'penetration', 'joint_orientation', 
                                  'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'spot seam weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_structural_part_joint_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['tightness', 'joint orientation'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'structural part joint design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricted_for_structural_system_design
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['thightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'structural system design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

	
RULE representation_restricted_for_structural_system_function
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['function'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
       | (temp_prop_def_rep.name = 'structural system function parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_restricted_for_weld_design_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['shape of weld surface', 
                                  'weld geometry', 'connection angle', 
                                  'rotation angle', 'inclination angle', 
                                  'shrinkage', 'weld size'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'weld design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;

	
RULE representation_restricted_for_weld_filler_material_design
FOR (representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['density'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name =
                   'weld filler material design parameters')
                   )
              ) > 0 
           );

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE
 representation_restricted_for_weld_manufacturing_definition
FOR (representation, representation_item,
 property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['position','process',
                                  'degree of automations',
                                  'number of weld passes', 
                                  'welding deposition sequences', 
                                  'welding environment', 
                                  'tack weld used'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'weld manufacturing definition parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_restricted_for_welded_joint_design_parameters
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['configuration', 'penetration', 
                                  'joint_orientation', 'tightness'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'welded joint design parameters')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_restricted_for_welding_sequence_representation
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['name','start offset', 
                                  'end offset', 'direction'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'welding sequence representation')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;


RULE representation_restricts_profile_renewal_definition_attributes
FOR (representation, representation_item, property_definition_representation);

  LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['renewal modulus', 
                               'rule inertia', 'rule section modulus'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  reps := QUERY(
           temp_rep <* representation | 
              SIZEOF (
                 QUERY(
                    temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
  'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.'+
  'USED_REPRESENTATION'))
                    | (temp_prop_def_rep.name = 
                    'profile renewal definition attributes')
                   )
              ) > 0 
           );
 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;
  WHERE 
    wr1: NOT violation;
END_RULE;



RULE representation_for_moment_3d_restricts_representation_item
FOR (representation);

LOCAL
    reps:      BAG OF REPRESENTATION := [];
    arg_list:  LIST OF STRING := ['longitudinal moment',
                                  'transverse moment',
                                  'vertical moment','origin'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  reps := QUERY(i <* representation |
       i.NAME = 'moment 3d');

 
  REPEAT i:=1 TO HIINDEX(reps) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* reps[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    wr1: NOT violation;
END_RULE;


RULE 
representation_with_versionable_object_matches_pattern
FOR (group, applied_classification_assignment);

  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(Applied_classification_assignment);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'versionable object') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;

RULE restrict_name_for_known_source FOR
(known_source);
WHERE
WR1: SIZEOF ( QUERY ( ks <* known_source | ( ks. name<>
'ISO 13584 library' ) ) ) =0;
END_RULE;


RULE 
revision_has_mandatory_attribute_description
FOR (group);
LOCAL
    t1_set:  SET OF group := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* group | VALUE_IN(WHICH_CLASS(i), 'revision')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;



RULE 
revision_with_context_referenced_for_context_of_revision
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(a <* group | 
          VALUE_IN(WHICH_CLASS(a), 'revision with context'));
 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
               (b.assigned_group = t1_set[i]) AND 
               (b.role.name = 'context of revision'));
    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;
WHERE
    WR1: NOT violate;
END_RULE;


RULE 
seam_has_at_most_one_class_references 
FOR(shape_aspect, 
shape_aspect_relationship, group,
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF shape_aspect_relationship := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'seam');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set |
      'seam curve relationship' IN WHICH_CLASS(t2_inst))) > 1;
END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_angle_bar_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group,
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'angle bar cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'angle bar cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_assembly_manufacturing_position_parameters
FOR(shape_aspect, 
property_definition_representation, group, 
Applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'assembly manufacturing position');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'assembly manufacturing position parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_border_corner_cutout_boundary_relationship
FOR(shape_aspect, 
applied_group_assignment, group, 
applied_classification_assignment);

  LOCAL
    c_a_set:     SET OF applied_classification_assignment := [];
    t1_set:      SET OF shape_aspect := [];
    gr_ass_set:  BAG OF applied_group_assignment := [];
    violation:   LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'border');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
     gr_ass_set := USEDIN(t1_set[i], 
     'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'); 
                                    
    violation := SIZEOF(QUERY(aga <* gr_ass_set |
       (aga.role.name = 'boundary index 2') AND
       ('corner cutout boundary relationship' 
       IN WHICH_CLASS(aga.assigned_group))
       )) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_bulbflat_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'bulbflat cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'bulbflat cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_channel_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group,
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'channel cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'channel cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_circular_hollow_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group,
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'circular hollow cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'circular hollow cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_composite_feature_design_parameters
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'composite feature');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'composite feature design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE shape_aspect_for_composite_feature_has_at_least_two_instances
FOR (shape_aspect, applied_classification_assignment);  
LOCAL    c_a_set: SET OF applied_classification_assignment := []; 
classed_s_a_set: SET OF shape_aspect := [];  
t2_set: SET OF shape_aspect := []; 
    violation: LOGICAL := FALSE; 
END_LOCAL;  
 
c_a_set := QUERY(i <* applied_classification_assignment |i.assigned_class.name = 'composite feature');

  
 REPEAT i := 1 TO HIINDEX(c_a_set);
     REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
           classed_s_a_set:= classed_s_a_set + c_a_set[i].items[j];
     END_REPEAT;
  END_REPEAT;
  
c_a_set := [];

    REPEAT i := 1 TO HIINDEX(classed_s_a_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN (classed_s_a_set[1], 
      'SHIP_STRUCTURES_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.'+
      'RELATING_SHAPE_ASPECT'));
      violation := NOT (SIZEOF(T2_SET) = 2);
    END_REPEAT;


  WHERE
    wr1: NOT violation;

END_RULE;


RULE  
shape_aspect_for_corner_cutout
FOR(shape_aspect, 
applied_group_assignment, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF applied_classification_assignment := [];
    t1_set:  SET OF shape_aspect := [];
    gr_ass_set:  BAG OF applied_group_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'corner cutout');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    gr_ass_set := USEDIN(t1_set[i], 
      'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS');
    violation := SIZEOF(QUERY(aga <* gr_ass_set |
      (aga.role.name = 'item 1') AND
      ('structural cutout boundary relationship' 
      IN WHICH_CLASS(aga.assigned_group)))) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_corner_cutout_boundary_relationship
FOR(shape_aspect, 
applied_group_assignment, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF applied_classification_assignment := [];
    t1_set:  SET OF shape_aspect := [];
    gr_ass_set:  BAG OF applied_group_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'corner cutout');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    gr_ass_set := USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS');
    violation := SIZEOF(QUERY(aga <* gr_ass_set |
         (aga.role.name = 'item 1') AND
         ('corner cutout boundary relationship' 
         IN WHICH_CLASS(aga.assigned_group)))) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_corrugation_dimensions
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'corrugation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'corrugation dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_explicit_profile_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'explicit profile cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      ' explicit profile cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_flanged_plate_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'flanged plate cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'flanged plate cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_flare_area_parameters
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'flare area');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'flare area parameters')) = 2);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_flat_bar_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group, 
Applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'flat bar cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'flat  bar cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_panel_system_curve_boundary_design
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'panel system curve boundary');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'panel system curve boundary design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_panel_system_plane_boundary_design
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'panel system plane boundary');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'panel system plane boundary design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_profile_curve_trace_line_design_parameters
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'profile curve trace line');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'profile curve trace line design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_round_bar_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'round bar cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'round bar cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_square_tube_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'square tube cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'square tube cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_structural_cutout_boundary_relationship
FOR(shape_aspect, 
applied_group_assignment, group, 
applied_classification_assignment);

  LOCAL
    c_a_set:      SET OF applied_classification_assignment := [];
    t1_set:       SET OF shape_aspect := [];
    gr_ass_set:   BAG OF applied_group_assignment := [];
    violation:    LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'structural cutout');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    gr_ass_set := USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS');
    violation := SIZEOF(QUERY(aga <* gr_ass_set |
      (aga.role.name = 'item 1') AND
      ('structural cutout boundary relationship' 
      IN WHICH_CLASS(aga.assigned_group)))) <> 1;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_t_bar_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   't bar cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      't bar cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_twist_location_design_parameters
FOR(shape_aspect, 
property_definition_representation, group, 
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'twist location');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'twist location design parameters')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
shape_aspect_for_w_shape_cross_section_dimensions
FOR(shape_aspect, 
property_definition_representation, group,
applied_classification_assignment);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF property_definition_representation := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'w shape cross section');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.name =
      'w shape cross section dimensions')) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE shape_aspect_relationship_attributes_references_are_distinct
FOR (shape_aspect_relationship);

  LOCAL
    cyclic_relationship: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(shape_aspect_relationship) 
                   WHILE NOT cyclic_relationship;
    cyclic_relationship:= shape_aspect_relationship[i].relating_shape_aspect :=: 
      shape_aspect_relationship[i].related_shape_aspect;
  END_REPEAT;
  WHERE
    WR1: NOT cyclic_relationship;
END_RULE;


RULE 
shape_aspect_relationship_with_definable_object
FOR (group, applied_classification_assignment);

  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(Applied_classification_assignment);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'definable object') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;

RULE 
shape_aspect_relationship_with_definition_matches_pattern
FOR (group, applied_classification_assignment);

  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(Applied_classification_assignment);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'DEFINITION') THEN
      clfied_inst := clfied_inst + 
         APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;


RULE shape_aspect_relationship_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect_relationship := [];
    t2_set:  SET OF shape_aspect_relationship := [];
    arg_list:  LIST OF STRING := ['composite feature',
        'seam curve relationship'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE 
shape_aspect_with_definable_object_matches_pattern
FOR (group, applied_classification_assignment);

  LOCAL
    clfied_inst  :SET OF GENERIC := [];
  END_LOCAL;
 
  REPEAT i := 1 TO HIINDEX(Applied_classification_assignment);
    IF (APPLIED_CLASSIFICATION_ASSIGNMENT[i].assigned_class.name = 
    'definable object') THEN
      clfied_inst := clfied_inst + 
      APPLIED_CLASSIFICATION_ASSIGNMENT[i].items;
END_IF;
  END_REPEAT;
  WHERE
    WR1: SIZEOF(QUERY(i <* clfied_inst | NOT(i.id LIKE '*.*')) )= 0;
END_RULE;


RULE shape_aspect_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF shape_aspect := [];
    t2_set:  SET OF shape_aspect := [];
    arg_list:  LIST OF STRING := ['composite feature',
                                  'seam',
                                  'structural cutout'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;


RULE ship_designation_has_one_specified_names 
FOR(product_definition, 
applied_identification_assignment, group, 
applied_classification_assignment);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF product_definition := [];
    t2_set:  SET OF applied_identification_assignment := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'ship designation');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i],
      'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
    violation := NOT (SIZEOF(QUERY(t2_inst <* t2_set | (t2_inst.role.name =
      'imo number')OR (t2_inst.role.name = 'pennant hull number') )) = 1);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE ship_material_property_has_at_most_one_named_references 
FOR(property_definition, 
    applied_document_reference, 
    APPLIED_CLASSIFICATION_ASSIGNMENT);

  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF property_definition := [];
    t2_set:  SET OF applied_document_reference := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'ship material property');

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 'SHIP_STRUCTURES_SCHEMA.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set | t2_inst.role.name = 'material reference')) > 1;
  END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;

RULE source_for_library_definition
FOR (representation, representation_item, group,
 applied_classification_assignment);

LOCAL
    c_a_set: SET OF applied_classification_assignment := [];
    classed_rep_set: SET OF representation := [];
    arg_list:  LIST OF STRING := ['library definition'];
    violation: LOGICAL := FALSE;
  END_LOCAL;


  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.ASSIGNED_CLASS.NAME = 'source');


  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      classed_rep_set:= classed_rep_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


  REPEAT i:=1 TO HIINDEX(classed_rep_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
      violation := (SIZEOF(QUERY(rep_item <* classed_rep_set[i].items |
                    rep_item.name = arg_list[j])) <> 1);
    END_REPEAT;
  END_REPEAT;

  WHERE 
    WR1: NOT violation;
END_RULE;


RULE spacing_position_compound_representation_has_name
FOR (compound_representation_item, group, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['position number', 'position'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
        violation := (SIZEOF(QUERY(items <* t2_set |
           items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;


RULE spacing_position_with_offset_compound_representation_has_class
FOR (compound_representation_item, group, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    c_a_set2 : SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t2_set:  SET OF COMPOUND_REPRESENTATION_ITEM := [];
    t3_set:  SET OF representation_item := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position with offset');       REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
  c_a_set2 := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 'spacing position');
 
  REPEAT i := 1 TO HIINDEX(c_a_set2);
    REPEAT j := 1 TO HIINDEX(c_a_set2[i].items);
      t2_set := t2_set + c_a_set2[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j := 1 TO HIINDEX(t1_set[i].item_element);
      t3_set := t3_set + t1_set[i].item_element;
    END_REPEAT;
    violation := (SIZEOF(t3_set * t2_set) <> 1);
    t3_set:= [];
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;



RULE spacing_position_with_offset_compound_representation_has_name
FOR (compound_representation_item, group, 
applied_classification_assignment);
LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF Compound_representation_item := [];
    t2_set:  SET OF representation_item := [];
    arg_list:  LIST OF STRING := ['offset'];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME = 
                   'spacing position with offset');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i:=1 TO HIINDEX(t1_set) WHILE (NOT violation);
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        t2_set := t1_set[i].item_element; 
        violation := (SIZEOF(QUERY(items <* t2_set | 
        items.name = arg_list[j])) <> 1);
 END_REPEAT;
  END_REPEAT;
  WHERE 
    WR1: NOT violation;
END_RULE;


RULE structural_class_rejection_has_at_least_one_role_references 
FOR(group, applied_document_reference, applied_classification_assignment);

  LOCAL
    c_a_set: SET OF applied_classification_assignment := [];
    t1_set:  SET OF group := [];
    t2_set:  SET OF applied_document_reference := [];
    violation: LOGICAL := FALSE;
  END_LOCAL;
 
  c_a_set := QUERY(i <* applied_classification_assignment |
                   i.assigned_class.name = 'structural class rejection');
 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;
 
  REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violation;
    t2_set := bag_to_set(USEDIN(t1_set[i], 
    'SHIP_STRUCTURES_SCHEMA.APPLIED_DOCUMENT_REFERENCE.ITEMS'));
    violation := SIZEOF(QUERY(t2_inst <* t2_set |
       t2_inst.role.name = 'explanations')) < 1;
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE  
structural_part_symmetry_relationship_has_product_definition
FOR (group, applied_classification_assignment);

  LOCAL
    cl_ass:      SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    clfied_inst: SET OF product_definition_RELATIONSHIP := [];
  END_LOCAL;
 
  cl_ass := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                  i.assigned_class.NAME = 
                  'structural part symmetry relationship');
 
  REPEAT i := 1 TO HIINDEX(cl_ass);
    clfied_inst := clfied_inst + cl_ass[i].items;
  END_REPEAT;
 
  WHERE
    WR1:  SIZEOF(QUERY(pdr <* clfied_inst | 
         (NOT(SIZEOF(WHICH_CLASS(pdr.relating_product_definition)) >0))
          )) -
      SIZEOF(QUERY(pdr <* clfied_inst | 
         (NOT(SIZEOF(WHICH_CLASS(pdr.related_product_definition)) >0))
          )) 
          =0;
END_RULE;


RULE  
structural_system_symmetry_relationship_has_product_definition
FOR (group, applied_classification_assignment);

  LOCAL
    cl_ass:      SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    clfied_inst: SET OF product_definition_RELATIONSHIP := [];
  END_LOCAL;
 
  cl_ass := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                  i.assigned_class.NAME = 
                  'structural system symmetry relationship');
 
  REPEAT i := 1 TO HIINDEX(cl_ass);
    clfied_inst := clfied_inst + cl_ass[i].items;
  END_REPEAT;
 
  WHERE
    WR1:  SIZEOF(QUERY(pdr <* clfied_inst | 
         (NOT(SIZEOF(WHICH_CLASS(pdr.relating_product_definition)) >0))
          )) -
      SIZEOF(QUERY(pdr <* clfied_inst | 
         (NOT(SIZEOF(WHICH_CLASS(pdr.related_product_definition)) >0))
          )) 
          =0;
END_RULE;



RULE 
unique_approvals_in_approval_history
FOR (GROUP, APPLIED_GROUP_ASSIGNMENT);
LOCAL
    t1_set:  SET OF GROUP := [];
    t2_set:  SET OF APPLIED_GROUP_ASSIGNMENT := [];
    t3_set:  SET OF GENERIC :=[];
    violate: LOGICAL := FALSE;
END_LOCAL;
  t1_set := QUERY(i <* GROUP | VALUE_IN(WHICH_CLASS(i), 
    'APPROVAL HISTORY')); 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   t2_set := QUERY(a <* APPLIED_GROUP_ASSIGNMENT | 
     a.ASSIGNED_GROUP = t1_set[i]);
   t3_set := QUERY(b <* t2_set[1].items | 
     'SHIP_STRUCTURES_SCHEMA.APPROVAL' IN TYPEOF(b));
    violate := NOT (VALUE_UNIQUE(t3_set));
END_REPEAT;
WHERE
    WR1: NOT violate; 
END_RULE;


RULE user_def_function_description_required
FOR (REPRESENTATION, representation_item);

  LOCAL
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
     ('SHIP_STRUCTURES_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
     IN TYPEOF(r)) AND
     (r.NAME = 'function') AND
     (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 
     'user defined'))) > 0)
     AND
     (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
     (r.NAME = 'user def function'))) = 0);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE user_defined_requires_user_defined_class
FOR (product_definition, group, applied_classification_assignment);

  LOCAL
    cl_ass:      SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    clfied_inst: SET OF GENERIC := [];
    violation:   LOGICAL := FALSE;
  END_LOCAL;
  cl_ass := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                  (i.ROLE.NAME = 'class membership') AND 
                  (i.assigned_class.NAME = 'user defined'));
  REPEAT i := 1 TO HIINDEX(cl_ass);
    clfied_inst := clfied_inst + cl_ass[i].items;
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(clfied_inst) WHILE NOT violation;
    violation := NOT('user defined class' IN WHICH_CLASS(clfied_inst[i]));
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;


RULE 
user_defined_tightness_description_required
FOR (REPRESENTATION, representation_item);

  LOCAL
    violation: LOGICAL := FALSE;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(REPRESENTATION) WHILE NOT violation;
    violation := (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
      ('SHIP_STRUCTURES_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
      IN TYPEOF(r)) AND
      (r.NAME = 'tightness') AND
      (r\DESCRIPTIVE_REPRESENTATION_ITEM.DESCRIPTION = 
      'user defined'))) > 0)
      AND
     (SIZEOF(QUERY(r <* REPRESENTATION[i].ITEMS |
     (r.NAME = 'user defined tightness'))) = 0);
  END_REPEAT;
  WHERE
    WR1: NOT violation;
END_RULE;



RULE 
version_creation_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
  'version creation')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;



RULE 
version_deletion_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
  'version deletion')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;



RULE version_history_has_exactly_one_assigned_group
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    set_1, set_2: SET OF applied_group_assignment := [];
    set_3: SET OF GENERIC := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;


t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   set_1 := QUERY(b <* applied_group_assignment | 
         (b.assigned_group = t1_set[i]) AND (b.role.name = 'current version'));
   set_2 := QUERY(c <* applied_group_assignment | 
               (c.assigned_group = t1_set[i]) AND (c.role.name = 'members'));
   violate := ((SIZEOF(set_1) <> 1) OR (SIZEOF(set_2) <> 1));
   IF NOT violate THEN

      set_3 := set_1[1].items * set_2[1].items;

      violate := (SIZEOF(set_3) <> 1) OR 
                  NOT (VALUE_IN(WHICH_CLASS(set_3[1]), 'versionable object'));
   END_IF;
END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;



RULE version_history_referenced_by_exactly_one_current_version
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;


t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));

 
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;

   a_set := QUERY(b <* applied_group_assignment | 
               (b.assigned_group = t1_set[i]) AND (b.role.name = 'current version'));


    violate := SIZEOF(a_set) <> 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;



RULE version_history_referenced_by_multiple_roles
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'version history'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
   a_set := QUERY(b <* applied_group_assignment | 
    (b.assigned_group = t1_set[i]) AND NOT (b.role.name IN ['versions', 'current version', 'relationships']));
    violate := SIZEOF(a_set) > 0;
END_REPEAT;
WHERE
    wr1: NOT violate;
END_RULE;



RULE 
version_modification_has_mandatory_attribute_description
FOR (action);
LOCAL
    t1_set:  SET OF action := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
  t1_set := QUERY(i <* action | VALUE_IN(WHICH_CLASS(i), 
  'version modification')); 
  violate := (SIZEOF(QUERY(k <* t1_set | 
  NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;



RULE 
version_relationship_associates_with_versionable_object
FOR (applied_identification_assignment);
LOCAL
    violate1, violate2, violate: LOGICAL := FALSE;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(applied_identification_assignment) WHILE NOT violate;
 violate1 := (SIZEOF(USEDIN(applied_identification_assignment[i], 
   'SHIP_STRUCTURES_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
    + 'RELATING_IDENTIFICATION_ASSIGNMENT')) > 0) AND
   (NOT (VALUE_IN(WHICH_CLASS(applied_identification_assignment[i]), 
   'versionable object')));
 violate2 := (SIZEOF(USEDIN(applied_identification_assignment[i], 
   'SHIP_STRUCTURES_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.'
    + 'RELATED_IDENTIFICATION_ASSIGNMENT')) > 0) AND
   (NOT (VALUE_IN(WHICH_CLASS(applied_identification_assignment[i]), 
   'versionable object')));
   
 violate := violate1 OR violate2;
END_REPEAT; 
WHERE
    WR1: NOT violate; 
END_RULE;



RULE 
version_relationship_has_mandatory_attribute_description
FOR (identification_assignment_relationship);
LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;
t1_set := QUERY(i <* identification_assignment_relationship | 
VALUE_IN(WHICH_CLASS(i), 'version relationship')); 
violate := (SIZEOF(QUERY(k <* t1_set | NOT EXISTS (k.description))) > 0);
WHERE
    WR1: NOT violate; 
END_RULE;



RULE 
version_relationship_has_unique_versions
FOR (identification_assignment_relationship);
LOCAL
    t1_set:  SET OF identification_assignment_relationship := [];
    violate: LOGICAL := FALSE;
END_LOCAL;
   t1_set := QUERY(a <* identification_assignment_relationship | 
   VALUE_IN(WHICH_CLASS(a), 'version relationship'));
REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;
    violate := 
          ( t1_set[i].relating_identification_assignment.assigned_id =
            t1_set[i].related_identification_assignment.assigned_id );
END_REPEAT; 
WHERE
    WR1: NOT violate; 
END_RULE;



RULE versionable_object_has_one_version_id
FOR(APPLIED_IDENTIFICATION_ASSIGNMENT);
  LOCAL
    version_ids:         SET OF APPLIED_IDENTIFICATION_ASSIGNMENT := [];
    versionable_objects: BAG OF GENERIC := [];
    duplicate:           LOGICAL := FALSE;
  END_LOCAL;
 
  version_ids := QUERY(i <* APPLIED_IDENTIFICATION_ASSIGNMENT |
                       i.ROLE.NAME = 'version identifier');
 
  REPEAT i := 1 TO HIINDEX(version_ids);
    versionable_objects := versionable_objects + version_ids[i].items;
  END_REPEAT;
   REPEAT i := 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
    REPEAT j := i + 1 TO HIINDEX(versionable_objects) WHILE NOT duplicate;
      duplicate := versionable_objects[i] :=: versionable_objects[j];
    END_REPEAT;
  END_REPEAT;
  WHERE
    WR1: NOT duplicate;
END_RULE;



RULE versioned_action_request_with_identification_assignment
FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF versioned_action_request := [];
    t2_set:  SET OF versioned_action_request := [];
    arg_list:  LIST OF STRING := [ 'definable object'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

 
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

 
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;


    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
'SHIP_STRUCTURES_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
END_RULE;



RULE versions_is_referenced_by_at_least_one_version_history
FOR(applied_group_assignment, group);
  LOCAL
    t1_set:  SET OF group := [];
    a_set:  SET OF applied_group_assignment := [];
    violate: LOGICAL := FALSE;
  END_LOCAL;

t1_set := QUERY(a <* group | VALUE_IN(WHICH_CLASS(a), 'versions'));

REPEAT i := 1 TO HIINDEX(t1_set) WHILE NOT violate;

   a_set := QUERY(b <* applied_group_assignment | 
       (b.assigned_group = t1_set[i]) AND (b.role.name = 'version history'));

    violate := SIZEOF(a_set) < 1;
  END_REPEAT;

WHERE
    wr1: NOT violate;
END_RULE;


(* RULES  121401 *)

FUNCTION WHICH_CLASS(T: GENERIC): LIST OF STRING;
  LOCAL
     elements: BAG OF APPLIED_CLASSIFICATION_ASSIGNMENT;
     class_list: LIST OF STRING :=[];
  END_LOCAL;
  elements :=
      USEDIN(T,
      'SHIP_STRUCTURES_SCHEMA.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS');
  REPEAT i:=1 TO HIINDEX(elements);
 IF (elements[i]\classification_assignment.role.name = 'class membership') THEN
  class_list := class_list + 
  elements[i]\classification_assignment.assigned_class\group.name;
 END_IF;
  END_REPEAT;
  RETURN(class_list);
END_FUNCTION;

  
END_SCHEMA;
























































































































