SCHEMA ISO13584_g_m_iim_library_implicit_schema;

 CONSTANT
  sep_id : STRING := '.';
  det_classification_len : INTEGER := 3;
  value_code_len : INTEGER := 18;
  http_directory_name_length : INTEGER := 8;
  sep_cv : STRING := '-';
  class_code_len : INTEGER := 14;
  pref_name_len : INTEGER := 30;
  data_type_code_len : INTEGER := 14;
  source_doc_len : INTEGER := 80;
  short_name_len : INTEGER := 15;
  syn_name_len: INTEGER := pref_name_len;
  property_code_len : INTEGER := 14;
  supplier_code_len : INTEGER := 18;
  version_len : INTEGER := 3;
  revision_len : INTEGER := 3;
  element_code_len : INTEGER := 14;
  external_file_address_length : INTEGER := 18;
  http_file_name_length : INTEGER := 12;
  value_format_len : INTEGER := 80;
  external_item_code_length : INTEGER := 18;
  dummy_gri : geometric_representation_item := representation_item('')||
                   geometric_representation_item();
 END_CONSTANT;

 TYPE det_classification_type = identifier;
  WHERE
   wr1 : LENGTH(SELF) = det_classification_len;
 END_TYPE;

 TYPE integer_type = INTEGER;
 END_TYPE;

 TYPE value_code_type = identifier;
  WHERE
   wr1 : LENGTH(SELF) <= value_code_len;
 END_TYPE;

 TYPE language_code = identifier;
 END_TYPE;

 TYPE http_directory_name_type = identifier;
  WHERE
   wr1 : LENGTH(SELF) <= http_directory_name_length;
   wr2 : NOT (SELF LIKE '* *');
 END_TYPE;

 TYPE class_code_type = code_type;
  WHERE
   wr1 : LENGTH(SELF) <= class_code_len;
 END_TYPE;

 TYPE identifier = STRING;
 END_TYPE;

 TYPE data_type_code_type = code_type;
  WHERE
   wr1 : LENGTH(SELF) = data_type_code_len;
 END_TYPE;

 TYPE date_type = STRING(10) FIXED;
 END_TYPE;

 TYPE source_doc_type = identifier;
  WHERE
   wr1 : LENGTH(SELF) <= source_doc_len;
 END_TYPE;

 TYPE currency_code = identifier;
  WHERE
   wr1 : LENGTH(SELF) = 3;
 END_TYPE;

 TYPE pref_name_type = translatable_label;
  WHERE
   wr1 : check_label_length(SELF,pref_name_len);
 END_TYPE;

 TYPE short_name_type = translatable_label;
  WHERE
   wr1 : check_label_length(SELF,short_name_len);
 END_TYPE;

 TYPE label = STRING;
 END_TYPE;

 TYPE text = STRING;
 END_TYPE;

 TYPE property_code_type = code_type;
  WHERE
   wr1 : LENGTH(SELF) <= property_code_len;
 END_TYPE;

 TYPE supplier_code_type = code_type;
  WHERE
   wr1 : LENGTH(SELF) <= supplier_code_len;
 END_TYPE;

 TYPE version_type = code_type;
  WHERE
   wr1 : LENGTH(SELF) = version_len;
   wr2 : SELF LIKE '###';
 END_TYPE;

 TYPE boolean_value = BOOLEAN;
 END_TYPE;

 TYPE integer_value = INTEGER;
 END_TYPE;

 TYPE real_value = REAL;
 END_TYPE;

 TYPE string_value = STRING;
 END_TYPE;

 TYPE revision_type = code_type;
  WHERE
   wr1 : LENGTH(SELF) <= revision_len;
 END_TYPE;

 TYPE note_type = translatable_text;
 END_TYPE;

 TYPE remark_type = translatable_text;
 END_TYPE;

 TYPE document_code_type = code_type;
  WHERE
   wr1 : LENGTH(SELF) <= element_code_len;
 END_TYPE;

 TYPE table_code_type = code_type;
  WHERE
   wr1 : LENGTH(SELF) <= element_code_len;
 END_TYPE;

 TYPE external_file_address = identifier;
  WHERE
   wr1 : LENGTH(SELF) <= external_file_address_length;
   wr2 : NOT (SELF LIKE '* *');
 END_TYPE;

 TYPE content_encoding_type = identifier;
  WHERE
   wr1: (SELF = '7bit') OR (SELF = '8bit') OR (SELF = 'binary') 
	OR (SELF = 'quoted-printable') OR (SELF = 'base64');
 END_TYPE;

TYPE MIME_type = identifier;
WHERE 
	WR1: NOT(SELF LIKE '* *'); 
END_TYPE; 

TYPE MIME_subtype = identifier; 
WHERE 
	WR1: NOT(SELF LIKE '* *'); 
END_TYPE; 

 TYPE iab_rfc = INTEGER;
  WHERE
   wr1 : SELF > 0;
 END_TYPE;

 TYPE http_file_name_type = identifier;
  WHERE
   wr1 : LENGTH(SELF) <= http_file_name_length;
   wr2 : NOT (SELF LIKE '* *');
   wr3 : NOT (SELF LIKE '*.*.*');
   wr4 : ((SELF LIKE '*.??') AND (LENGTH(SELF) <= http_file_name_length - 1)) 
         OR (SELF LIKE '*.???');
 END_TYPE;

 TYPE absolute_url_type = identifier;
  WHERE
   wr1 : SELF LIKE '*://:*';
 END_TYPE;

 TYPE character_set_type = identifier;
 END_TYPE;

 TYPE si_prefix = ENUMERATION OF
 (exa,peta,tera,giga,mega,kilo,hecto,deca,deci,centi,milli,micro,nano,pico,
       femto,atto);
 END_TYPE;

 TYPE si_unit_name = ENUMERATION OF
 (metre,gram,second,ampere,kelvin,mole,candela,radian,steradian,hertz,newton,
       pascal,joule,watt,coulomb,volt,farad,ohm,siemens,weber,tesla,henry,
       degree_celsius,lumen,lux,becquerel,gray,sievert);
 END_TYPE;

 TYPE dimension_count = INTEGER;
  WHERE
   wr1 : SELF > 0;
 END_TYPE;

 TYPE value_format_type = identifier;
  WHERE
   wr1 : LENGTH(SELF) <= value_format_len;
 END_TYPE;

 TYPE code_type = identifier;
  WHERE
   wr1 : NOT (SELF LIKE '*.*');
   wr2 : NOT (SELF LIKE '*-*');
   wr3 : NOT (SELF LIKE '* *');
 END_TYPE;

 TYPE level = ENUMERATION OF
 (min,nom,typ,max);
 END_TYPE;

 TYPE year_number = INTEGER;
 END_TYPE;

 TYPE definition_type = translatable_text;
 END_TYPE;

 TYPE external_item_code_type = identifier;
  WHERE
   wr1 : LENGTH(SELF) <= external_item_code_length;
   wr2 : NOT (SELF LIKE '* *');
 END_TYPE;

 TYPE property_semantics_or_path = SELECT
      (property_semantics,sub_property_path);
 END_TYPE;

 TYPE unit = SELECT
      (named_unit,derived_unit);
 END_TYPE;

 TYPE value_type = SELECT
      (value_code_type,integer_type);
 END_TYPE;

 TYPE syn_name_type = SELECT (label_with_language, label);
 WHERE
	wr1: check_syn_length (SELF, syn_name_len);
 END_TYPE;

 TYPE primitive_value = SELECT
      (simple_value,complex_value);
 END_TYPE;

 TYPE library_expression = SELECT
      (expression,level_spec_expression,entity_instance_expression,
       class_instance_expression);
 END_TYPE;

 TYPE entity_instance_value = SELECT
      (defined_entity_instance_value);
 END_TYPE;

 TYPE defined_entity_instance_value=SELECT(
	placement,
	axis1_placement,
	axis2_placement_2d,
	axis2_placement_3d);
 END_TYPE;

 TYPE library_variable = SELECT
      (variable, level_spec_variable,entity_instance_variable,class_instance_variable);
 END_TYPE;

 TYPE boolean_expression_or_others = SELECT
      (others, boolean_expression);
 END_TYPE;

TYPE illustration_type = ENUMERATION OF (	schematic_drawing, 
								 	realistic_picture, 
									not_static_picture); 
END_TYPE; 

 TYPE measure_value = SELECT
	(length_measure,
	mass_measure,
	time_measure,
	electric_current_measure,
	thermodynamic_temperature_measure,
	amount_of_substance_measure,
	luminous_intensity_measure,
	plane_angle_measure,
	solid_angle_measure,
	area_measure,
	volume_measure,
	ratio_measure,
	parameter_value,
	numeric_measure,
	context_dependent_measure,
	descriptive_measure,
	positive_length_measure,
	positive_plane_angle_measure,
	positive_ratio_measure,
	count_measure);
 END_TYPE;

 TYPE length_measure = REAL;
 END_TYPE;

 TYPE mass_measure = REAL;
 END_TYPE;

 TYPE time_measure = REAL;
 END_TYPE;

 TYPE electric_current_measure = REAL;
 END_TYPE;

 TYPE thermodynamic_temperature_measure = REAL;
 END_TYPE;

 TYPE amount_of_substance_measure = REAL;
 END_TYPE;

 TYPE luminous_intensity_measure = REAL;
 END_TYPE;

 TYPE plane_angle_measure = REAL;
 END_TYPE;

 TYPE solid_angle_measure = REAL;
 END_TYPE;

 TYPE area_measure = REAL;
 END_TYPE;

 TYPE volume_measure = REAL;
 END_TYPE;

 TYPE ratio_measure = REAL;
 END_TYPE;

 TYPE parameter_value = REAL;
 END_TYPE;

 TYPE numeric_measure = NUMBER;
 END_TYPE;

 TYPE positive_length_measure = length_measure;
 WHERE
  wr1: SELF > 0;
 END_TYPE;

 TYPE positive_plane_angle_measure = plane_angle_measure;
 WHERE
  wr1: SELF > 0;
 END_TYPE;

 TYPE positive_ratio_measure = ratio_measure;
 WHERE
  wr1: SELF > 0;
 END_TYPE;

 TYPE context_dependent_measure = REAL;
 END_TYPE;

 TYPE descriptive_measure = STRING;
 END_TYPE;

 TYPE count_measure = NUMBER;
 END_TYPE;

 TYPE translatable_label = SELECT
      (translated_label, label);
 END_TYPE;

 TYPE property_or_data_type_bsu = SELECT
      (property_bsu,data_type_bsu);
 END_TYPE;

 TYPE simple_value = SELECT
      (number_value,string_value,boolean_value);
 END_TYPE;

 TYPE complex_value = SELECT
      (entity_instance_value,level_spec_value,dic_class_instance);
 END_TYPE;

 TYPE number_value = SELECT
      (integer_value,real_value);
 END_TYPE;

 TYPE translatable_text = SELECT
      (translated_text, text);
 END_TYPE;

 TYPE vector_or_direction = SELECT
      (vector,direction);
 END_TYPE;

 TYPE person_organization_select = SELECT
      (person,organization);
 END_TYPE;

 TYPE axis2_placement = SELECT
      (axis2_placement_2d,axis2_placement_3d);
 END_TYPE;

 TYPE trimming_select = SELECT
      (cartesian_point);
 END_TYPE;

 ENTITY environment;
  syntactic_representation : generic_variable;
  semantics : variable_semantics;
 END_ENTITY;

 ENTITY abs_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY acos_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY and_expression
  SUBTYPE OF (multiple_arity_boolean_expression);
 END_ENTITY;

 ENTITY asin_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY atan_function
  SUBTYPE OF (binary_function_call);
 END_ENTITY;

 ENTITY boolean_literal
  SUBTYPE OF (simple_boolean_expression,generic_literal);
  the_value : BOOLEAN;
 END_ENTITY;

 ENTITY boolean_variable
  SUBTYPE OF (simple_boolean_expression,variable);
 END_ENTITY;

 ENTITY comparison_equal
  SUBTYPE OF (comparison_expression);
 END_ENTITY;

 ENTITY comparison_greater
  SUBTYPE OF (comparison_expression);
 END_ENTITY;

 ENTITY comparison_greater_equal
  SUBTYPE OF (comparison_expression);
 END_ENTITY;

 ENTITY comparison_less
  SUBTYPE OF (comparison_expression);
 END_ENTITY;

 ENTITY comparison_less_equal
  SUBTYPE OF (comparison_expression);
 END_ENTITY;

 ENTITY comparison_not_equal
  SUBTYPE OF (comparison_expression);
 END_ENTITY;

 ENTITY concat_expression
  SUBTYPE OF (string_expression,multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST[2:?] OF
                                                    string_expression;
 END_ENTITY;

 ENTITY cos_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY div_expression
  SUBTYPE OF (binary_numeric_expression);
 END_ENTITY;

 ENTITY equals_expression
  SUBTYPE OF (binary_boolean_expression);
 END_ENTITY;

 ENTITY exp_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY format_function
  SUBTYPE OF (string_expression,binary_generic_expression);
  DERIVE
   value_to_format : generic_expression := SELF\binary_generic_expression.
                     operands[1];
   format_string : generic_expression := SELF\binary_generic_expression.
                   operands[2];
  WHERE
   wr1 : (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION') IN TYPEOF(
         value_to_format)) AND ((
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION') IN TYPEOF(
         format_string));
 END_ENTITY;

 ENTITY index_expression
  SUBTYPE OF (string_expression,binary_generic_expression);
  DERIVE
   operand : generic_expression := SELF\binary_generic_expression.operands[1];
   index : generic_expression := SELF\binary_generic_expression.operands[2];
  WHERE
   wr1 : ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' IN TYPEOF(operand)) 
         AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(index
         ));
   wr2 : is_int_expr(index);
 END_ENTITY;

 ENTITY interval_expression
  SUBTYPE OF (boolean_expression,multiple_arity_generic_expression);
  DERIVE
   interval_low : generic_expression := SELF\multiple_arity_generic_expression.
                  operands[1];
   interval_item : generic_expression := SELF\multiple_arity_generic_expression
                   .operands[2];
   interval_high : generic_expression := SELF\multiple_arity_generic_expression
                   .operands[3];
  WHERE
   wr1 : ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION' IN TYPEOF(interval_low)) 
         AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION' IN TYPEOF(interval_item
         )) AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION' IN TYPEOF(
         interval_high));
   wr2 : (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF.
         interval_low)) AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' 
         IN TYPEOF(SELF.interval_high)) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF.
         interval_item))) OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'
          IN TYPEOF(SELF.interval_low)) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(SELF.
         interval_item)) AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION'
          IN TYPEOF(SELF.interval_high)));
 END_ENTITY;

 ENTITY int_literal
  SUBTYPE OF (literal_number);
  SELF\literal_number.the_value : INTEGER;
 END_ENTITY;

 ENTITY int_numeric_variable
  SUBTYPE OF (numeric_variable);
 END_ENTITY;

 ENTITY int_value_function
  SUBTYPE OF (value_function);
 END_ENTITY;

 ENTITY length_function
  SUBTYPE OF (numeric_expression,unary_generic_expression);
  SELF\unary_generic_expression.operand : string_expression;
 END_ENTITY;

 ENTITY like_expression
  SUBTYPE OF (comparison_expression);
  WHERE
   wr1 : ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF\
         comparison_expression.operands[1])) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF\
         comparison_expression.operands[2]));
 END_ENTITY;

 ENTITY log_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY log2_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY log10_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY maximum_function
  SUBTYPE OF (multiple_arity_function_call);
 END_ENTITY;

 ENTITY minimum_function
  SUBTYPE OF (multiple_arity_function_call);
 END_ENTITY;

 ENTITY minus_expression
  SUBTYPE OF (binary_numeric_expression);
 END_ENTITY;

 ENTITY minus_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY mod_expression
  SUBTYPE OF (binary_numeric_expression);
 END_ENTITY;

 ENTITY mult_expression
  SUBTYPE OF (multiple_arity_numeric_expression);
 END_ENTITY;

 ENTITY not_expression
  SUBTYPE OF (unary_boolean_expression);
  SELF\unary_generic_expression.operand : boolean_expression;
 END_ENTITY;

 ENTITY odd_function
  SUBTYPE OF (unary_boolean_expression);
  SELF\unary_generic_expression.operand : numeric_expression;
  WHERE
   wr1 : is_int_expr(SELF.operand);
 END_ENTITY;

 ENTITY or_expression
  SUBTYPE OF (multiple_arity_boolean_expression);
 END_ENTITY;

 ENTITY plus_expression
  SUBTYPE OF (multiple_arity_numeric_expression);
 END_ENTITY;

 ENTITY power_expression
  SUBTYPE OF (binary_numeric_expression);
 END_ENTITY;

 ENTITY real_literal
  SUBTYPE OF (literal_number);
  SELF\literal_number.the_value : REAL;
 END_ENTITY;

 ENTITY real_numeric_variable
  SUBTYPE OF (numeric_variable);
 END_ENTITY;

 ENTITY sin_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY slash_expression
  SUBTYPE OF (binary_numeric_expression);
 END_ENTITY;

 ENTITY square_root_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY string_literal
  SUBTYPE OF (simple_string_expression,generic_literal);
  the_value : STRING;
 END_ENTITY;

 ENTITY string_variable
  SUBTYPE OF (simple_string_expression,variable);
 END_ENTITY;

 ENTITY substring_expression
  SUBTYPE OF (string_expression,multiple_arity_generic_expression);
  DERIVE
   operand : generic_expression := SELF\multiple_arity_generic_expression.
             operands[1];
   index1 : generic_expression := SELF\multiple_arity_generic_expression.
            operands[2];
   index2 : generic_expression := SELF\multiple_arity_generic_expression.
            operands[3];
  WHERE
   wr1 : ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' IN TYPEOF(operand)) 
         AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(
         index1)) AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN
         TYPEOF(index2));
   wr2 : SIZEOF(SELF\multiple_arity_generic_expression.operands) = 3;
   wr3 : is_int_expr(index1);
   wr4 : is_int_expr(index2);
 END_ENTITY;

 ENTITY tan_function
  SUBTYPE OF (unary_function_call);
 END_ENTITY;

 ENTITY value_function
  SUPERTYPE OF (int_value_function)
  SUBTYPE OF (numeric_expression,unary_generic_expression);
  SELF\unary_generic_expression.operand : string_expression;
 END_ENTITY;

 ENTITY xor_expression
  SUBTYPE OF (binary_boolean_expression);
  SELF\binary_generic_expression.operands : LIST[2:2] OF boolean_expression;
 END_ENTITY;

 ENTITY axis1_placement_type
  SUBTYPE OF (placement_type);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AXIS1_PLACEMENT' IN SELF\
         entity_instance_type.type_name;
 END_ENTITY;

 ENTITY axis2_placement_2d_type
  SUBTYPE OF (placement_type);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AXIS2_PLACEMENT_2D' IN SELF\
         entity_instance_type.type_name;
 END_ENTITY;

 ENTITY axis2_placement_3d_type
  SUBTYPE OF (placement_type);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AXIS2_PLACEMENT_3D' IN SELF\
         entity_instance_type.type_name;
 END_ENTITY;

 ENTITY boolean_type
  SUBTYPE OF (simple_type);
 END_ENTITY;

 ENTITY class_bsu
  SUBTYPE OF (basic_semantic_unit);
  SELF\basic_semantic_unit.code : class_code_type;
  defined_by : supplier_bsu;
  DERIVE
   absolute_id : identifier := defined_by.absolute_id + sep_id + dic_identifier
                 ;
   known_visible_properties : SET[0:?] OF property_bsu :=
                              compute_known_visible_properties(SELF);
   known_visible_data_types : SET[0:?] OF data_type_bsu :=
                              compute_known_visible_data_types(SELF);
  INVERSE
   subclasses : SET[0:?] OF class FOR its_superclass;
   added_visible_properties : SET[0:?] OF property_bsu FOR name_scope;
   added_visible_data_types : SET[0:?] OF data_type_bsu FOR name_scope;

 UNIQUE
   ur1 : absolute_id;
 END_ENTITY;
-- class_BSU

 ENTITY class_instance_type
  SUBTYPE OF (complex_type);
  domain : class_bsu;
 END_ENTITY;

 ENTITY class_value_assignment;
  super_class_defined_property : property_bsu;
  assigned_value : value_code_type;
  WHERE
   wr1 : definition_available_implies(super_class_defined_property,(
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NON_QUANTITATIVE_CODE_TYPE' 
         IN TYPEOF(super_class_defined_property.definition[1]\property_det.
         domain)));
   wr2 : definition_available_implies(super_class_defined_property,(SIZEOF(
         QUERY(v <* super_class_defined_property.definition[1]\property_det.
         domain\non_quantitative_code_type.domain.its_values | assigned_value =
          v.value_code)) = 1));
 END_ENTITY;

 ENTITY component_class
  SUBTYPE OF (item_class);
 END_ENTITY;

 ENTITY condition_det
  SUBTYPE OF (property_det);
 END_ENTITY;

 ENTITY data_type_bsu
  SUBTYPE OF (basic_semantic_unit);
  SELF\basic_semantic_unit.code : data_type_code_type;
  name_scope : class_bsu;
  DERIVE
   absolute_id : identifier := name_scope.defined_by.absolute_id + sep_id + 
                 name_scope.dic_identifier + sep_id + dic_identifier;
  INVERSE
   defining_class : SET[0:1] OF class FOR defined_types;
 
  UNIQUE
   absolute_id;
  WHERE   
   wr1 : is_subclass(defining_class[1],name_scope.definition[1]);
 END_ENTITY;

 ENTITY data_type_element
  SUBTYPE OF (dictionary_element);
  SELF\dictionary_element.identified_by : data_type_bsu;
  names : item_names;
  type_definition : data_type;
 END_ENTITY;

 ENTITY dates;
  date_of_original_definition : date_type;
  date_of_current_version : date_type;
  date_of_current_revision : OPTIONAL date_type;
 END_ENTITY;

 ENTITY dependent_p_det
  SUBTYPE OF (property_det);
  depends_on : SET[1:?] OF property_bsu;
  WHERE
   wr1 : QUERY(p <* depends_on | NOT (definition_available_implies(p,(
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CONDITION_DET' IN TYPEOF(p.definition)))
         )) = [];
 END_ENTITY;

 ENTITY dic_unit;
  structured_representation : unit;
  string_representation : OPTIONAL mathematical_string;
 END_ENTITY;

 ENTITY dic_value;
  value_code : value_type;
  meaning : item_names;
  source_doc_of_value : OPTIONAL document;
 END_ENTITY;

 ENTITY entity_instance_type
  SUBTYPE OF (complex_type);
  type_name : SET OF STRING;
 END_ENTITY;

 ENTITY identified_document
  SUBTYPE OF (document);
  document_identifier : source_doc_type;
 END_ENTITY;

 ENTITY int_currency_type
  SUBTYPE OF (int_type);
  currency : OPTIONAL currency_code;
 END_ENTITY;

 ENTITY int_measure_type
  SUBTYPE OF (int_type);
  unit : dic_unit;
 END_ENTITY;

 ENTITY int_type
  SUPERTYPE OF (ONEOF(int_measure_type,int_currency_type,
                non_quantitative_int_type))
  SUBTYPE OF (number_type);
 END_ENTITY;

 ENTITY item_class
  SUPERTYPE OF (ONEOF(component_class,material_class))
  SUBTYPE OF (class);
  simplified_drawing : OPTIONAL graphics;
  sub_class_properties : SET[0:?] OF property_bsu;
  class_constant_values : SET[0:?] OF class_value_assignment;
  coded_name : OPTIONAL value_code_type;
  WHERE
   wr1 : QUERY(p <* sub_class_properties | NOT (p IN SELF.described_by)) = [];
   wr2 : NOT all_class_descriptions_reachable(SELF.identified_by) OR (QUERY(va
         <* class_constant_values | SIZEOF(QUERY(c <* va.
         super_class_defined_property.describes_classes | is_subclass(SELF,c)
         AND (va.super_class_defined_property IN c\item_class.
         sub_class_properties))) <> 1) = []);
 END_ENTITY;

 ENTITY item_names;
  preferred_name : pref_name_type;
  synonymous_names : SET OF syn_name_type;
  short_name : short_name_type;
  languages : OPTIONAL present_translations;
  icon : OPTIONAL graphics;
  WHERE
   wr1 : NOT (EXISTS(languages)) OR ((
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_LABEL' IN 
         TYPEOF(preferred_name)) AND (languages :=: preferred_name\
         translated_label.languages) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_LABEL' IN 
         TYPEOF(short_name)) AND (languages :=: short_name\translated_label.
         languages) AND (QUERY(s <* synonymous_names | NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LABEL_WITH_LANGUAGE' IN TYPEOF(s))) = []
         )); 
   wr2 : NOT EXISTS(languages) OR (QUERY(s <* synonymous_names | EXISTS(s.
         language) AND NOT (s.language IN QUERY(l <* languages.language_codes
          | TRUE))) = []);
   wr3 : at_most_two_synonyms_per_language(languages,synonymous_names);
 END_ENTITY;

  ENTITY label_with_language;
  l : label;
  language : language_code;
 END_ENTITY;

 ENTITY material_class
  SUBTYPE OF (item_class);
 END_ENTITY;

 ENTITY mathematical_string;
  text_representation : text;
  sgml_representation : OPTIONAL text;
 END_ENTITY;

 ENTITY named_type
  SUBTYPE OF (data_type);
  referred_type : data_type_bsu;
 END_ENTITY;

 ENTITY non_dependent_p_det
  SUBTYPE OF (property_det);
 END_ENTITY;

 ENTITY non_quantitative_code_type
  SUBTYPE OF (string_type);
  domain : value_domain;
  WHERE
   wr1 : QUERY(v <* domain.its_values | NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VALUE_CODE_TYPE' IN TYPEOF(v.value_code)
         )) = [];
 END_ENTITY;

 ENTITY non_quantitative_int_type
  SUBTYPE OF (int_type);
  domain : value_domain;
  WHERE
   wr1 : QUERY(v <* domain.its_values |
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VALUE_CODE_TYPE' IN TYPEOF(v.value_code)
         ) = [];
 END_ENTITY;

 ENTITY non_si_unit
  SUBTYPE OF (named_unit);
  name : label;
 END_ENTITY;

 ENTITY number_type
  SUPERTYPE OF (ONEOF(int_type,real_type))
  SUBTYPE OF (simple_type);
 END_ENTITY;

 ENTITY placement_type
  SUPERTYPE OF (ONEOF(axis1_placement_type,axis2_placement_2d_type,
                axis2_placement_3d_type))
  SUBTYPE OF (entity_instance_type);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PLACEMENT' IN SELF\entity_instance_type.
         type_name;
 END_ENTITY;

 ENTITY property_bsu
  SUBTYPE OF (basic_semantic_unit);
  SELF\basic_semantic_unit.code : property_code_type;
  name_scope : class_bsu;
  DERIVE
   absolute_id : identifier := name_scope.defined_by.absolute_id + sep_id + 
                 name_scope.dic_identifier + sep_id + dic_identifier;
  INVERSE
   describes_classes : SET OF class FOR described_by;

  UNIQUE
   ur1 : absolute_id;
  WHERE
   wr1 : QUERY(c <* describes_classes | NOT (is_subclass(c,name_scope.
         definition[1]))) = [];
 END_ENTITY;

 ENTITY real_currency_type
  SUBTYPE OF (real_type);
  currency : OPTIONAL currency_code;
 END_ENTITY;

 ENTITY real_measure_type
  SUBTYPE OF (real_type);
  unit : dic_unit;
 END_ENTITY;

 ENTITY real_type
  SUPERTYPE OF (ONEOF(real_measure_type,real_currency_type))
  SUBTYPE OF (number_type);
 END_ENTITY;

 ENTITY string_type
  SUBTYPE OF (simple_type);
 END_ENTITY;

 ENTITY supplier_bsu
  SUBTYPE OF (basic_semantic_unit);
  SELF\basic_semantic_unit.code : supplier_code_type;
  DERIVE
   SELF\basic_semantic_unit.version : version_type := '001';
   absolute_id : identifier := SELF\basic_semantic_unit.code;
  UNIQUE
   ur1 : absolute_id;
 END_ENTITY;

 ENTITY supplier_element
  SUBTYPE OF (dictionary_element);
  SELF\dictionary_element.identified_by : supplier_bsu;
  org : organization;
  addr : address;
 INVERSE
   associated_items : SET[0:?] OF supplier_bsu_relationship FOR relating_supplier;

 END_ENTITY;

 ENTITY value_domain;
  its_values : LIST[2:?] OF dic_value;
  source_doc_of_value_domain : OPTIONAL document;
  languages : OPTIONAL present_translations;
  terms : LIST[0:?] OF item_names;
  WHERE
   wr1 : NOT EXISTS(languages) OR (QUERY(v <* its_values | languages :<>: v.
         meaning.languages) = []);

   wr2 : codes_are_unique(its_values);
 END_ENTITY;

 ENTITY global_language_assignment;
  language : language_code;
 END_ENTITY;

 ENTITY present_translations;
  language_codes : LIST[1:?] OF UNIQUE language_code;
  UNIQUE
   ur1 : language_codes;
 END_ENTITY;

 ENTITY translated_label;
  labels : LIST[1:?] OF label;
  languages : present_translations;
  WHERE
   wr1 : SIZEOF(labels) = SIZEOF(languages.language_codes);
 END_ENTITY;

 ENTITY translated_text;
  texts : LIST[1:?] OF text;
  languages : present_translations;
  WHERE
   wr1 : SIZEOF(texts) = SIZEOF(languages.language_codes);
 END_ENTITY;

 ENTITY dic_component_instance
  SUPERTYPE OF (lib_component_instance)
  SUBTYPE OF (dic_item_instance);
  WHERE
   wr1 : definition_available_implies(SELF\dic_class_instance.class_def,
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPONENT_CLASS' IN TYPEOF(
         SELF\dic_class_instance.class_def.definition[1]));
 END_ENTITY;

 ENTITY dic_feature_instance
  SUPERTYPE OF (lib_feature_instance)
  SUBTYPE OF (dic_item_instance);
  WHERE
   wr1 : definition_available_implies(SELF\dic_class_instance.class_def,
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.FEATURE_CLASS' IN TYPEOF(SELF\
         dic_class_instance.class_def.definition[1]));
 END_ENTITY;

 ENTITY dic_material_instance
  SUPERTYPE OF (lib_material_instance)
  SUBTYPE OF (dic_item_instance);
  WHERE
   wr1 : definition_available_implies(SELF\dic_class_instance.class_def,
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MATERIAL_CLASS' IN TYPEOF(SELF\
         dic_class_instance.class_def.definition[1]));
 END_ENTITY;

 ENTITY int_level_spec_value
  SUBTYPE OF (level_spec_value);
  SELF\level_spec_value.values : ARRAY[4:4] OF OPTIONAL INTEGER;
 END_ENTITY;

 ENTITY lib_component_instance
  SUBTYPE OF (dic_component_instance,lib_item_instance);
 END_ENTITY;

 ENTITY lib_feature_instance
  SUBTYPE OF (dic_feature_instance,lib_item_instance);
 END_ENTITY;

 ENTITY lib_material_instance
  SUBTYPE OF (dic_material_instance,lib_item_instance);
 END_ENTITY;

 ENTITY property_value;
  its_value : OPTIONAL primitive_value;
  prop_def : property_bsu;
  WHERE
   wr1 : (EXISTS(SELF.its_value) AND (compatible_type_and_value(SELF.prop_def,
         SELF.its_value))) OR NOT EXISTS(SELF.its_value);
 END_ENTITY;

 ENTITY real_level_spec_value
  SUBTYPE OF (level_spec_value);
  SELF\level_spec_value.values : ARRAY[4:4] OF OPTIONAL REAL;
 END_ENTITY;

 ENTITY binary_class_instance_constructor
  SUBTYPE OF (class_instance_constructor,binary_class_instance_expression);
  SELF\class_instance_constructor.properties : SET[2:2] OF property_assignment;
  DERIVE
   SELF\binary_generic_expression.operands : LIST[2:2] OF library_expression :=
   collects_referenced_library_expressions(SELF.properties);
  WHERE
   wr1 : SIZEOF(list_to_set(collects_assigned_properties(SELF.properties))) = 
         SIZEOF(collects_assigned_properties(SELF.properties));
 END_ENTITY;

 ENTITY class_instance_literal
  SUBTYPE OF (simple_class_instance_expression,generic_literal);
  the_value : dic_class_instance;
  WHERE
   wr1 : compatible_class_and_class(SELF\class_instance_expression.expr_type,
         SELF.the_value\dic_class_instance.class_def);
 END_ENTITY;

 ENTITY class_instance_variable
  SUBTYPE OF (simple_class_instance_expression,generic_variable);
 END_ENTITY;

 ENTITY entity_instance_literal
  SUBTYPE OF (simple_entity_instance_expression,generic_literal);
  the_value : entity_instance_value;
  WHERE
   wr1 : (SELF\entity_instance_expression.type_name <= TYPEOF(SELF.the_value)) 
         OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNCONTROLLED_ENTITY_INSTANCE_VALUE') 
		IN TYPEOF(SELF.the_value));
 END_ENTITY;

 ENTITY entity_instance_variable
  SUBTYPE OF (simple_entity_instance_expression,generic_variable);
 END_ENTITY;

 ENTITY exists_value
  SUBTYPE OF (unary_generic_expression,boolean_defined_function);
  for_variable : library_variable;
  DERIVE
   SELF\unary_generic_expression.operand : generic_expression := SELF.
                                           for_variable;
 END_ENTITY;

ENTITY instance_comparison_equal  
SUBTYPE OF (binary_generic_expression, boolean_defined_function); 
END_ENTITY; 

 ENTITY int_level_spec_literal
  SUBTYPE OF (level_spec_literal);
  SELF\level_spec_literal.the_value : int_level_spec_value;
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' IN TYPEOF(SELF\
         level_spec_expression.value_type);
   wr2 : compatible_level_type_and_instance(SELF\level_spec_expression.levels,[
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE'],SELF.the_value);
 END_ENTITY;

 ENTITY int_level_spec_variable
  SUBTYPE OF (level_spec_variable);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' IN TYPEOF(SELF\
         level_spec_expression.value_type);
 END_ENTITY;

 ENTITY multiple_arity_class_instance_constructor
  SUBTYPE OF (class_instance_constructor,
              multiple_arity_class_instance_expression);
  SELF\class_instance_constructor.properties : SET[2:?] OF property_assignment;
  DERIVE
   SELF\multiple_arity_generic_expression.operands : LIST[2:?] OF
                                                     library_expression :=
   collects_referenced_library_expressions(SELF.properties);
  WHERE
   wr1 : SIZEOF(list_to_set(collects_assigned_properties(SELF.properties))) = 
         SIZEOF(collects_assigned_properties(SELF.properties));
 END_ENTITY;

 ENTITY property_assignment;
  its_value : OPTIONAL library_expression;
  prop_def : property_bsu;
  WHERE
   wr1 : (EXISTS(SELF.its_value) AND (compatible_type_and_library_expression(
         SELF.prop_def,SELF.its_value))) OR NOT EXISTS(SELF.its_value);
 END_ENTITY;

 ENTITY real_level_spec_literal
  SUBTYPE OF (level_spec_literal);
  SELF\level_spec_literal.the_value : real_level_spec_value;
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN TYPEOF(SELF\
         level_spec_expression.value_type);
   wr2 : compatible_level_type_and_instance(SELF\level_spec_expression.levels,[
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE'],SELF.the_value);
 END_ENTITY;

 ENTITY real_level_spec_variable
  SUBTYPE OF (level_spec_variable);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN TYPEOF(SELF\
         level_spec_expression.value_type);
 END_ENTITY;

 ENTITY unary_class_instance_constructor
  SUBTYPE OF (class_instance_constructor,unary_class_instance_expression);
  SELF\class_instance_constructor.properties : SET[1:1] OF property_assignment;
  DERIVE
   SELF\unary_generic_expression.operand : library_expression :=
   collects_referenced_library_expressions(SELF.properties)[1];
 END_ENTITY;

 ENTITY boolean_column
  SUBTYPE OF (simple_column);
  SELF\column.values : LIST[1:?] OF boolean_value;
 END_ENTITY;

 ENTITY class_instance_column
  SUBTYPE OF (complex_column);
  class_ref : class_bsu;
  SELF\column.values : LIST[1:?] OF dic_class_instance;
  WHERE
   wr1 : QUERY(inst <* SELF\column.values | NOT compatible_class_and_class(SELF
         .class_ref,inst.class_def)) = [];
 END_ENTITY;

 ENTITY column_traversal_variable_semantics
  SUBTYPE OF (variable_semantics);
  ctxt : table_expression;
  domain : variable_semantics;
  WHERE
   wr1 : SELF.domain IN SELF.ctxt.its_columns;
   wr2 : (SIZEOF(USEDIN(SELF,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENVIRONMENT.SEMANTICS')) = 0) OR 
         compatible_variable_semantics_and_expression(SELF.domain,USEDIN(SELF,
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENVIRONMENT.SEMANTICS')[1].
         syntactic_representation);
 END_ENTITY;

 ENTITY difference_table_expression
  SUBTYPE OF (set_table_expression);
 END_ENTITY;

 ENTITY entity_instance_column
  SUBTYPE OF (complex_column);
  type_name : SET[1:?] OF STRING;
  SELF\column.values : LIST[1:?] OF entity_instance_value;
  WHERE
   wr1 : QUERY(inst <* SELF\column.values | NOT (SELF.type_name <= TYPEOF(inst)
         )) = [];
 END_ENTITY;

 ENTITY integer_column
  SUBTYPE OF (number_column);
  SELF\column.values : LIST[1:?] OF integer_value;
  WHERE
   wr1 : (SELF\formatted_column.value_format) LIKE 'NR1*';
 END_ENTITY;

 ENTITY intersect_table_expression
  SUBTYPE OF (set_table_expression);
 END_ENTITY;

 ENTITY int_level_spec_column
  SUBTYPE OF (level_spec_column);
  SELF\column.values : LIST[1:?] OF int_level_spec_value;
 END_ENTITY;

ENTITY in_RDB_table_boolean_expression 
SUBTYPE OF(multiple_arity_generic_expression,
		 boolean_defined_function, 
		 SQL_mappable_defined_function); 
DERIVE 
	from_table: generic_expression :=  
				SELF\multiple_arity_generic_expression.operands[1];
	tuple: LIST[1:?] OF generic_expression  
		:= QUERY(element <*  
SELF\multiple_arity_generic_expression.operands |
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION'  
		IN TYPEOF(element)); 
WHERE 
	WR1: ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXPRESSION' 
		IN TYPEOF(from_table)) 
		AND is_sql_mappable_table_expression (from_table); 
	WR2: SIZEOF (QUERY(simple_expr<* 
		QUERY(expr<*SELF\multiple_arity_generic_expression.operands |
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXPRESSION'  
		IN TYPEOF (expr)))|is_sql_mappable(simple_expr))) 
		= SIZEOF(SELF\multiple_arity_generic_expression.operands) -
1; 
	WR3: SIZEOF (from_table\table_expression.its_columns) = SIZEOF  
(tuple); 
	WR4: compatible_list_variable_semantics_and_expressions 
		(SELF.from_table\table_expression.its_columns, SELF.tuple); 
	WR5: QUERY (e<*tuple |  
		QUERY (v<*used_variables(e)|('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS')  
		IN TYPEOF (v.interpretation.semantics)) <> [] ) = []; 
END_ENTITY; 

 ENTITY multiple_arity_cartesian_product
  SUBTYPE OF (multiple_arity_table_expression);
  SELF\multiple_arity_generic_expression.operands : LIST[2:?] OF
                                                    table_expression;
 END_ENTITY;

 ENTITY natural_join_expression
  SUBTYPE OF (binary_table_expression);
  DERIVE
   table_1 : generic_expression := SELF\binary_generic_expression.operands[1];
   table_2 : generic_expression := SELF\binary_generic_expression.operands[2];
  WHERE
   wr1 : ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXPRESSION' IN TYPEOF(SELF.
         table_1)) AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXPRESSION' IN 
         TYPEOF(SELF.table_2));
   wr2 : SIZEOF(list_to_set(table_1\table_expression.its_columns) * list_to_set
         (table_2\table_expression.its_columns)) > 0;
 END_ENTITY;

 ENTITY projection_expression
  SUBTYPE OF (unary_table_expression);
  SELF\unary_generic_expression.operand : table_expression;
  argts_var : SET[1:?] OF variable_semantics;
  WHERE
   wr1 : SELF.argts_var <= list_to_set(SELF\unary_generic_expression.operand\
         table_expression.its_columns);
 END_ENTITY;

 ENTITY rdb_table_extension
  SUBTYPE OF (table_extension);
  SELF\table_extension.content : LIST[1:?] OF UNIQUE simple_column;
 WHERE
    wr1 : (SIZEOF(USEDIN(SELF\table_extension.table_identifier, 
   	 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION.TABLE_IDENTIFIER'
   	 )) = 0) 
   	 OR 
   	 ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_SPECIFICATION' 
   	 IN TYPEOF(USEDIN(SELF\table_extension.table_identifier, 
   	 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION.TABLE_IDENTIFIER'
   	 )[1]));
 END_ENTITY;

 ENTITY rdb_table_specification
  SUBTYPE OF (table_specification);
  WHERE
   wr1 : QUERY(col <* SELF\table_specification.column_meaning | QUERY(v <*
         syntax_of(col) | NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VARIABLE' IN 
         TYPEOF(v))) <> []) = [];
   wr2 : (SIZEOF(USEDIN(SELF\table_specification.table_identifier, 
   	 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXTENSION.TABLE_IDENTIFIER'
   	 )) = 0) 
   	 OR 
   	 ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_EXTENSION' 
   	 IN TYPEOF(USEDIN(SELF\table_specification.table_identifier, 
   	 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXTENSION.TABLE_IDENTIFIER'
   	 )[1]));
 END_ENTITY;

 ENTITY rdb_table_variable
  SUBTYPE OF (table_variable);
  WHERE
   wr1 : QUERY(col <* SELF\table_expression.its_columns | QUERY(v <* syntax_of(
         col) | NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VARIABLE' IN TYPEOF(v))) <> 
         []) = [];
 END_ENTITY;

 ENTITY real_column
  SUBTYPE OF (number_column);
  SELF\column.values : LIST[1:?] OF real_value;
  WHERE
   wr1 : (SELF\formatted_column.value_format) LIKE 'NR2*';
 END_ENTITY;

 ENTITY real_level_spec_column
  SUBTYPE OF (level_spec_column);
  SELF\column.values : LIST[1:?] OF real_level_spec_value;
 END_ENTITY;

 ENTITY select_expression
  SUBTYPE OF (table_expression,binary_generic_expression);
  DERIVE
   from_table : generic_expression := SELF\binary_generic_expression.operands[1
                ];
   condition : generic_expression := SELF\binary_generic_expression.operands[2]
               ;
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXPRESSION' IN TYPEOF(SELF.
         from_table);
   wr2 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(SELF.
         condition);
   wr3 : QUERY(va <* used_variables(SELF.condition) | NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VARIABLE' IN TYPEOF(va))) = [];
   wr4 : QUERY(v <* used_variables(SELF.condition) | (NOT(check_iterator_context(SELF, v))
	 OR NOT(check_iterator_domain_uniqueness(SELF, v)))) = [];
 END_ENTITY;


FUNCTION check_iterator_context(expr: select_expression; v: generic_variable): LOGICAL;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS' IN
          TYPEOF(v.interpretation.semantics))
	THEN
		IF (v.interpretation.semantics\column_traversal_variable_semantics.ctxt 
			:<>: expr.from_table)
		THEN
			RETURN(FALSE);
		ELSE
			RETURN(TRUE);
		END_IF;
	ELSE
		RETURN(UNKNOWN);
	END_IF;

END_FUNCTION;

FUNCTION check_iterator_domain_uniqueness(expr: select_expression; v: generic_variable): LOGICAL;
	LOCAL
		vars: SET OF generic_variable := [];
		res:  SET OF generic_variable := [];
	END_LOCAL;

	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS' IN
          TYPEOF(v.interpretation.semantics))
	THEN
		vars := used_variables(expr.condition);

		REPEAT i := 1 TO SIZEOF(vars);
			IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS' IN
	          		TYPEOF(vars[i].interpretation.semantics))
			THEN
				IF (vars[i].interpretation.semantics\column_traversal_variable_semantics.domain 
					:=: v.interpretation.semantics\column_traversal_variable_semantics.domain)
				THEN
					res := res + vars[i];
				END_IF;
			END_IF;
		END_REPEAT;

		RETURN(SIZEOF(res) = 1);
	END_IF;
	
	RETURN(UNKNOWN);

END_FUNCTION;

 ENTITY string_column
  SUBTYPE OF (formatted_column);
  SELF\column.values : LIST[1:?] OF string_value;
  WHERE
  wr1 : (((SELF\formatted_column.value_format) LIKE 'A*')
        OR ((SELF\formatted_column.value_format) LIKE 'M*')
        OR ((SELF\formatted_column.value_format) LIKE 'N*')
        OR ((SELF\formatted_column.value_format) LIKE 'X*'))
        AND NOT ((SELF\formatted_column.value_format) LIKE 'NR*');
 END_ENTITY;

 ENTITY table_extension
  SUPERTYPE OF (rdb_table_extension);
  table_identifier : table_identification;
  content : LIST[1:?] OF UNIQUE column;
  revision_of_content : revision_type;
  content_revision_date : date_type;
  WHERE
   wr1 : QUERY(col <* SELF.content | SIZEOF(col.values) <> SIZEOF(SELF.content[
         1].values)) = [];
   wr2 : (SIZEOF(USEDIN(SELF.table_identifier,
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION.TABLE_IDENTIFIER')) = 0) OR 
         compatible_list_variable_semantics_and_columns(USEDIN(SELF.
         table_identifier,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION' + 
         '.TABLE_IDENTIFIER')[1].column_meaning, SELF.content);
 END_ENTITY;

 ENTITY table_literal
  SUBTYPE OF (simple_table_expression,generic_literal);
  the_value : table_identification;
  WHERE
   wr1 : SIZEOF(USEDIN(SELF.the_value,
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION' + 
         '.TABLE_IDENTIFIER')) = 1;
 END_ENTITY;

 ENTITY table_specification
  SUPERTYPE OF (rdb_table_specification);
  table_identifier : table_identification;
  column_meaning : LIST[1:?] OF UNIQUE variable_semantics;
  key : SET[1:?] OF variable_semantics;
  WHERE
   wr1 : SELF.key <= list_to_set(SELF.column_meaning);
 END_ENTITY;

 ENTITY table_variable
  SUPERTYPE OF (rdb_table_variable)
  SUBTYPE OF (simple_table_expression,generic_variable);
  structure : LIST[1:?] OF variable_semantics;
  its_key : SET[1:?] OF variable_semantics;
  WHERE
   wr1 : SELF.its_key <= list_to_set(SELF.structure);
 END_ENTITY;

 ENTITY union_table_expression
  SUBTYPE OF (set_table_expression);
 END_ENTITY;

 ENTITY self_class_code_semantics
  SUBTYPE OF (self_class_name_semantics);
 END_ENTITY;

 ENTITY self_class_preferred_name_semantics
  SUBTYPE OF (self_class_name_semantics);
 END_ENTITY;

 ENTITY self_class_short_name_semantics
  SUBTYPE OF (self_class_name_semantics);
 END_ENTITY;

 ENTITY self_class_supplier_code_semantics
  SUBTYPE OF (self_class_name_semantics);
 END_ENTITY;

 ENTITY self_class_version_semantics
  SUBTYPE OF (self_class_name_semantics);
 END_ENTITY;

 ENTITY self_property_class_code_semantics
  SUBTYPE OF (self_property_name_semantics);
 END_ENTITY;

 ENTITY self_property_class_version_semantics
  SUBTYPE OF (self_property_name_semantics);
 END_ENTITY;

 ENTITY self_property_class_supplier_code_semantics 
  SUBTYPE OF (self_property_name_semantics );
 END_ENTITY;

 ENTITY self_property_code_semantics
  SUBTYPE OF (self_property_name_semantics);
 END_ENTITY;

 ENTITY self_property_preferred_name_semantics
  SUBTYPE OF (self_property_name_semantics);
 END_ENTITY;

 ENTITY self_property_short_name_semantics
  SUBTYPE OF (self_property_name_semantics);
 END_ENTITY;

 ENTITY self_property_value_semantics
  SUBTYPE OF (self_property_semantics);
  WHERE
   wr1 : QUERY(v <* syntax_of(SELF) | NOT compatible_type_and_library_expression
         (bsu_of_property_semantics(SELF),v)) = [];
 END_ENTITY;

 ENTITY self_property_version_semantics
  SUBTYPE OF (self_property_name_semantics);
 END_ENTITY;

 ENTITY sub_property_path;
  the_property : property_bsu;
  its_own_property : OPTIONAL sub_property_path;
 WHERE
	WR1: (NOT (EXISTS (SELF.its_own_property)))
		OR (data_type_typeof(SELF.the_property) = [])
		OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE'
		IN data_type_typeof(SELF.the_property))
		AND applicable_properties (data_type_class_of(
		SELF.the_property)[1],[SELF.its_own_property.the_property]));
 END_ENTITY;

 ENTITY constant_range_defined_domain
  SUBTYPE OF (simple_domain);
  minimal : literal_number;
  maximal : literal_number;
  step : OPTIONAL literal_number;
  WHERE
   wr1 : SIZEOF(SELF\simple_domain.referenced_by.item_of.defines) = 1;
   wr2 : minimal.the_value <= maximal.the_value;
   wr3 : QUERY(va <* collects_variables(SELF\simple_domain.referenced_by.
         item_of.defines) | NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_VARIABLE' IN TYPEOF(va))) = [];
   wr4 : (NOT EXISTS(SELF.step)) OR (SELF.step.the_value > 0);
 END_ENTITY;

 ENTITY domain_restriction
  SUPERTYPE OF (functional_domain_restriction);
  defines : SET[1:?] OF variable_semantics;
  assumes : SET[0:?] OF variable_semantics;
  domains : SET[1:?] OF guarded_simple_domain;
  constraint_description : OPTIONAL message;
  DERIVE
   base_tables : SET[0:?] OF table_identification := used_tables_in_domain(SELF
                 );
  WHERE
   wr1 : SIZEOF(QUERY(g <* SELF.domains | 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.OTHERS'
          IN TYPEOF(g.guard))) = 1;
 END_ENTITY;

 ENTITY functional_domain_restriction
  SUBTYPE OF (domain_restriction);
  SELF\domain_restriction.domains : SET[1:?] OF guarded_functional_domain;
 END_ENTITY;

 ENTITY library_expression_defined_value
  SUBTYPE OF (simple_functional_domain);
  its_value : library_expression;
  WHERE
   wr1 : SIZEOF(SELF\simple_domain.referenced_by.item_of.defines) = 1;
   wr2 : QUERY(va <* collects_variables(SELF\simple_domain.referenced_by.
         item_of.defines) | NOT compatible_variable_and_library_expression(va,
         SELF.its_value)) = [];
   wr3 : collects_var_sem(used_variables(SELF.its_value)) <= SELF\simple_domain
         .referenced_by.item_of.assumes;
 END_ENTITY;

 ENTITY guarded_functional_domain
  SUBTYPE OF (guarded_simple_domain);
  SELF\guarded_simple_domain.domain : simple_functional_domain;
 END_ENTITY;

 ENTITY guarded_simple_domain;
  guard : boolean_expression_or_others;
  domain : simple_domain;
  INVERSE
   item_of : domain_restriction FOR domains;
  WHERE
   wr1 : variables_belong_to_assumes(SELF);
 END_ENTITY;

FUNCTION variables_belong_to_assumes(gsd: guarded_simple_domain): LOGICAL;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION') IN TYPEOF(gsd.guard)
 THEN
  RETURN(collects_var_sem(used_variables(gsd.guard)) <= gsd.item_of.assumes);
 ELSE
  RETURN(UNKNOWN);
END_IF;
END_FUNCTION;

 ENTITY null_defined_value
  SUBTYPE OF (simple_functional_domain);
  WHERE
   wr1 : SIZEOF(SELF\simple_domain.referenced_by.item_of.defines) = 1;
 END_ENTITY;

 ENTITY others;
 END_ENTITY;

 ENTITY predicate_defined_domain
  SUBTYPE OF (simple_domain);
  constraint : boolean_expression;
  WHERE
   wr1 : collects_var_sem(used_variables(SELF.constraint)) <= SELF\
         simple_domain.referenced_by.item_of.defines + SELF\simple_domain.
         referenced_by.item_of.assumes;
 END_ENTITY;

ENTITY subclass_defined_domain 
SUBTYPE OF (simple_domain); 
	from_class: class_BSU; 
WHERE 
	WR1: SIZEOF (SELF\simple_domain.referenced_by.item_of.defines) =  
1; 
	WR2: QUERY (va <* collects_variables(  
		SELF\simple_domain.referenced_by.item_of.defines) 
		|NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
			+ '.CLASS_INSTANCE_VARIABLE' IN TYPEOF (va))) =[]; 
	WR3: QUERY (va <* collects_variables(  
		SELF\simple_domain.referenced_by.item_of.defines) 
		|NOT is_subclass (SELF.from_class.definition[1],  
		va\class_instance_expression.expr_type.definition[1])) = []; 
END_ENTITY; 

 ENTITY table_defined_domain
  SUBTYPE OF (simple_domain);
  from_table : table_expression;
  WHERE
   wr1 : SELF\simple_domain.referenced_by.item_of.defines <= list_to_set(
         collects_columns(SELF.from_table));
   wr2 : QUERY(sem <* collects_var_sem(used_variables(SELF.from_table)) | NOT (
         (sem IN (SELF\simple_domain.referenced_by.item_of.assumes + SELF\
         simple_domain.referenced_by.item_of.defines)) OR (((
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS') IN TYPEOF(sem))) AND (sem\
         column_traversal_variable_semantics.domain IN collects_columns(SELF.
         from_table)))) = [];
 END_ENTITY;

 ENTITY table_defined_value
  SUBTYPE OF (simple_functional_domain);
  from_table : table_expression;
  WHERE
   wr1 : SELF\simple_domain.referenced_by.item_of.defines <= list_to_set(SELF.
         from_table\table_expression.its_columns);
   wr2 : SELF\simple_domain.referenced_by.item_of.assumes >= SELF.from_table\
         table_expression.the_key;
   wr3 : QUERY(sem <* collects_var_sem(used_variables(SELF.from_table)) | NOT (
         (sem IN (SELF\simple_domain.referenced_by.item_of.assumes + SELF\
         simple_domain.referenced_by.item_of.defines)) OR (((
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS') IN TYPEOF(sem))) AND (sem\
         column_traversal_variable_semantics.domain IN collects_columns(
         from_table)))) = [];
 END_ENTITY;

 ENTITY type_defined_domain
  SUBTYPE OF (simple_domain);
  WHERE
   wr1 : SIZEOF(SELF\simple_domain.referenced_by.item_of.defines) = 1;
 END_ENTITY;

 ENTITY variable_range_defined_domain
  SUBTYPE OF (simple_domain);
  minimal : numeric_expression;
  maximal : numeric_expression;
  step : OPTIONAL numeric_expression;
  WHERE
   wr1 : SIZEOF(SELF\simple_domain.referenced_by.item_of.defines) = 1;
   wr2 : collects_var_sem(used_variables(SELF.minimal) + used_variables(SELF.
         maximal)) <= SELF\simple_domain.referenced_by.item_of.assumes;
   wr3 : NOT (EXISTS(SELF.step)) OR (collects_var_sem(used_variables(SELF.step)
         ) <= SELF\simple_domain.referenced_by.item_of.assumes);
   wr4 : QUERY(va <* collects_variables(SELF\simple_domain.referenced_by.
         item_of.defines) | NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_VARIABLE' IN TYPEOF(va))) = [];
 END_ENTITY;

 ENTITY a_posteriori_case_of
  SUBTYPE OF (a_posteriori_semantic_relationship);
  general_model : class_bsu;
  is_case_of : class_bsu;
  corresponding_properties : LIST[0:?] OF LIST[2:2] OF property_bsu;
  WHERE
   wr1 : definition_available_implies(SELF.general_model,(
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS' IN TYPEOF(SELF.general_model
         .definition[1])));
   wr2 : definition_available_implies(SELF.is_case_of,(
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS' IN TYPEOF(SELF.is_case_of.
         definition[1])));
   wr3 : QUERY(couple <* SELF.corresponding_properties | NOT compatible_types(
         couple[1],couple[2])) = [];
   wr4 : QUERY(couple <* SELF.corresponding_properties | (NOT
         applicable_properties(SELF.general_model,[couple[1]]) OR NOT
         applicable_properties(SELF.is_case_of,[couple[2]]))) = [];
 END_ENTITY;

 ENTITY class_document_relationship
  SUBTYPE OF (class_bsu_relationship);
  SELF\class_bsu_relationship.related_tokens : SET[1:?] OF document_bsu;
  WHERE
   wr1 : visible_documents(SELF\class_bsu_relationship.relating_class.
         identified_by,SELF.related_tokens);
 END_ENTITY;

ENTITY class_table_relationship
SUBTYPE OF (class_BSU_relationship);
SELF\class_BSU_relationship.related_tokens: SET [1:?] OF table_BSU;
WHERE
	WR1: visible_properties_for_visible_tables(SELF);
	WR2: visible_tables (
		SELF\class_BSU_relationship.relating_class.
		identified_by, SELF.related_tokens);
END_ENTITY;

 ENTITY component_class_case_of
  SUBTYPE OF (item_class_case_of,component_class);
  WHERE
   wr1 : QUERY(cl <* SELF\item_class_case_of.is_case_of | 
         definition_available_implies(cl,(
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPONENT_CLASS' IN TYPEOF(cl.definition
         [1])))) = SELF\item_class_case_of.is_case_of;
 END_ENTITY;

 ENTITY feature_class
  SUBTYPE OF (item_class);
  WHERE
   wr1 : NOT (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPONENT_CLASS') IN TYPEOF(
         SELF));
   wr2 : NOT (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MATERIAL_CLASS') IN TYPEOF(
         SELF));
 END_ENTITY;

 ENTITY geometric_representation_context_type
  SUBTYPE OF (entity_instance_type);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN 
         SELF\entity_instance_type.type_name;
 END_ENTITY;

 ENTITY library_iim_id
  SUBTYPE OF (data_exchange_specification_id);
 END_ENTITY;


ENTITY dictionary 
SUPERTYPE OF (dictionary_in_standard_format); 
	responsible_supplier: supplier_BSU; 
	library_structure: library_iim_id; 
	base_protocols: SET [0:?] OF external_file_protocol; 
	supported_vep: SET [0:?] OF view_exchange_protocol_id;
	referred_supplier: SET [1:?] OF supplier_BSU; 
	contained_classes: LIST [0:?] OF UNIQUE class_BSU; 
	a_posteriori_semantic_relationships: SET [0:?] OF  
a_posteriori_semantic_relationship; 
	names: item_names; 
	note: OPTIONAL note_type; 
	remark: OPTIONAL remark_type; 
WHERE 
	WR1: prefix_ordered_class_list (SELF.contained_classes); 
END_ENTITY; 

 ENTITY dictionary_in_standard_format
  SUBTYPE OF (dictionary);
  WHERE
   wr1 : QUERY(int <* SELF\dictionary.base_protocols | ((SIZEOF(QUERY(vep <*
         SELF\dictionary.supported_vep | int IN vep\
         data_exchange_specification_id.external_file_protocols)) = 0) AND NOT (
        int IN SELF\dictionary.library_structure.external_file_protocols))) = 
         [];
 END_ENTITY;

 ENTITY document_bsu
  SUBTYPE OF (class_related_bsu);
  name_scope : class_bsu;
  SELF\basic_semantic_unit.code : document_code_type;
  DERIVE
   absolute_id : identifier := name_scope.defined_by.dic_identifier + sep_id + 
                 name_scope.dic_identifier + sep_id + dic_identifier;
  INVERSE
   associate_to_class : class_bsu_relationship FOR related_tokens;
  UNIQUE
   ur1 : absolute_id;
 END_ENTITY;

 ENTITY document_element
  SUPERTYPE OF (ONEOF (
	document_element_with_http_access,
	documented_element_with_translated_http_access))
  SUBTYPE OF (class_related_element);
  SELF\dictionary_element.identified_by : document_bsu;
  authors : OPTIONAL LIST[1:?] OF person;
  publishing_organisation : organization;
 END_ENTITY;

 ENTITY document_element_with_http_access
  SUBTYPE OF (document_element);
    remote_location: absolute_URL_type;
  WHERE
   WR1: remote_location[1:7] = 'http://';
 END_ENTITY;

 ENTITY documented_element_with_translated_http_access
  SUBTYPE OF (document_element);
	remote_locations: LIST [1:?] OF absolute_URL_type;
	languages: present_translations;
  WHERE
	WR1: SIZEOF(remote_locations) = SIZEOF(languages.language_codes);
	WR2: QUERY (url <* remote_locations | url[1:7] <> 'http://') = [];
 END_ENTITY;

ENTITY item_class_case_of		 
SUPERTYPE OF (ONEOF( 	component_class_case_of, 
					material_class_case_of, 
					feature_class_case_of)) 
SUBTYPE OF (item_class, a_priori_semantics_relationship); 
	is_case_of: SET [1:?] OF class_BSU; 
	imported_properties: LIST [0:?] OF property_BSU; 
	imported_types: SET [0:?]OF data_type_BSU; 
	imported_tables : SET [0:?] OF table_BSU ; 
	imported_documents : SET [0:?] OF document_BSU ; 
DERIVE 
	SELF\a_priori_semantics_relationship.referenced_classes:  
		SET [1: ?] OF class_BSU  
		:= SELF.is_case_of; 
	SELF\a_priori_semantics_relationship.referenced_properties: 
		LIST [0:?] OF property_BSU := SELF.imported_properties; 
	SELF\a_priori_semantics_relationship.referenced_data_types: 
		SET [0:?] OF data_type_BSU := SELF.imported_types; 
	SELF\a_priori_semantics_relationship.referenced_tables: 
		SET [0:?] OF table_BSU := SELF.imported_tables; 
	SELF\a_priori_semantics_relationship.referenced_documents: 
		SET [0:?] OF document_BSU := SELF.imported_documents; 
 
WHERE 
	WR1: superclass_of_item_is_item (SELF);
	WR2: QUERY (cl <* SELF\item_class_case_of.is_case_of 
		| definition_available_implies ( cl, 
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS' 
		IN TYPEOF (cl.definition[1])))) 
		= SELF\item_class_case_of.is_case_of; 
END_ENTITY; 


ENTITY feature_class_case_of 
SUBTYPE OF (item_class_case_of, feature_class); 
WHERE 
	WR1: QUERY (cl <* SELF\item_class_case_of.is_case_of 
		| definition_available_implies ( cl, 
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.FEATURE_CLASS' 
		IN TYPEOF (cl.definition[1])))) 
		= SELF\item_class_case_of.is_case_of; 
END_ENTITY; 


 ENTITY material_class_case_of
  SUBTYPE OF (item_class_case_of,material_class);
  WHERE
   wr1 : QUERY(cl <* SELF\item_class_case_of.is_case_of | 
         definition_available_implies(cl,(
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MATERIAL_CLASS' IN TYPEOF(cl.definition[
         1])))) = SELF\item_class_case_of.is_case_of;
 END_ENTITY;

 ENTITY rdb_table_element
  SUBTYPE OF (table_element,rdb_table_specification);
  WHERE
   wr1 : QUERY(temp <* SELF.column_meaning | simple_type_data_type(temp\
         property_semantics.the_property) = FALSE) = [];
 END_ENTITY;

 ENTITY rdb_table_content
  SUBTYPE OF (table_content,rdb_table_extension);
  WHERE
   wr1 : definition_available_implies(SELF\content_item.dictionary_definition,
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_ELEMENT' IN TYPEOF(SELF\
         content_item.dictionary_definition.definition[1]));
 END_ENTITY;

 ENTITY representation_type
  SUBTYPE OF (entity_instance_type);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION' IN SELF\
         entity_instance_type.type_name;
 END_ENTITY;

 ENTITY table_bsu
  SUBTYPE OF (class_related_bsu,table_identification);
  name_scope : class_bsu;
  SELF\basic_semantic_unit.code : table_code_type;
  DERIVE
   absolute_id : identifier := name_scope.defined_by.dic_identifier + sep_id + 
                 name_scope.dic_identifier + sep_id + dic_identifier;
  UNIQUE
   ur1 : absolute_id;
 END_ENTITY;

ENTITY table_content  
SUBTYPE OF (content_item, table_extension); 
	SELF\content_item.dictionary_definition: table_BSU;
DERIVE  
	SELF\table_extension.table_identifier: table_BSU
					:= SELF\content_item.dictionary_definition;
WHERE 
	WR1: definition_available_implies(  
		SELF\content_item.dictionary_definition, 
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_ELEMENT'  
		IN TYPEOF ( 
		SELF\content_item.dictionary_definition.definition[1] )); 
	WR2: compatible_content_and_specification (SELF);
END_ENTITY; 

 

FUNCTION compatible_content_and_specification (
		 tab : table_content) : LOGICAL;
		
		IF SIZEOF (
		tab\content_item.dictionary_definition.definition) = 0
		THEN
			RETURN (UNKNOWN);
		END_IF;

		RETURN (
		compatible_list_library_types_and_columns ( 
		get_property_BSU_from_property_semantics(
		tab\content_item.dictionary_definition.definition[1]
		\table_specification.column_meaning),
		tab\table_extension.content));
END_FUNCTION;	-- compatible_content_and_specification


ENTITY table_element 
SUBTYPE OF (class_related_element, table_specification); 
	SELF\dictionary_element.identified_by: table_BSU; 
	SELF\table_specification.column_meaning: LIST [1:?] OF 		 
				UNIQUE property_semantics; 
	SELF\table_specification.key: SET [1:?] OF 
				property_semantics;
DERIVE
	SELF\table_specification.table_identifier: table_BSU
		:= SELF.identified_by;
WHERE	 
	WR1: QUERY (temp <* SELF.column_meaning 
		| NOT visible_properties (  
		SELF\dictionary_element.identified_by.name_scope, 
		get_property_BSU_from_property_semantics([temp]))) = []; 
END_ENTITY; 


ENTITY item_class_extension
SUBTYPE OF(model_class_extension);
	selection_context_parameters: LIST [0:?] OF UNIQUE
							opt_or_mand_property_BSU;
	free_characteristics 		: LIST [0:?] OF UNIQUE
							opt_or_mand_property_BSU;
	derived_characteristics	: LIST [0:?] OF UNIQUE
							opt_or_mand_property_BSU;
	context_dependent_characteristics: LIST [0:?] OF UNIQUE
							opt_or_mand_property_BSU;
	identified_item			: BOOLEAN;
	supplier_identification	: OPTIONAL string_expression;
	supplier_designation		: OPTIONAL string_expression;
	access_icon				: OPTIONAL A9_illustration;
	content_msg				: OPTIONAL message;
	create_icon 				: LIST [0:?] OF A6_illustration;
	create_msg 				: OPTIONAL message;
	class_presentation_on_paper	: LIST [0:?] OF illustration;
	class_presentation_on_screen	: LIST [0:?] OF illustration;
DERIVE
	SELF\model_class_extension.selectable_properties 
		: LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= SELF.selection_context_parameters 
			+ SELF.free_characteristics;
	SELF\model_class_extension.derived_properties
		: LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= SELF.derived_characteristics
			+ SELF.context_dependent_characteristics;
	SELF\model_class_extension.required_properties
		: LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= [];
WHERE
	WR1: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS' IN
		TYPEOF(
		(SELF\content_item.dictionary_definition.definition[1])));
	wr2: QUERY (elt <* SELF.selection_context_parameters|
		in_typeof ( 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CONDITION_DET',elt))
		= SELF.selection_context_parameters;
	wr3: QUERY (elt <* SELF.free_characteristics|
		in_typeof ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NON_DEPENDENT_P_DET',elt)) 
		= SELF.free_characteristics;

	WR4: QUERY (elt <* SELF.free_characteristics| 
		(data_type_typeof(elt.property)<>[])
		AND NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_TYPE' IN
		data_type_typeof(elt.property))
		AND NOT 
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN
		data_type_typeof(elt.property))
	) = [];
	wr5 : QUERY (elt <* SELF.derived_characteristics|
		in_typeof ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NON_DEPENDENT_P_DET',elt)) 
		=SELF.derived_properties;
	wr6 : QUERY (elt <* SELF.context_dependent_characteristics|
		in_typeof ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DEPENDENT_P_DET',elt)) 
		= SELF.context_dependent_characteristics;
	WR7: SELF.access_icon IN 
		SELF\model_class_extension.referenced_external_items;
	WR8: SELF.content_msg IN 
		SELF\model_class_extension.referenced_external_items;
	WR9: list_to_set(SELF.create_icon)
		 <= SELF\model_class_extension.referenced_external_items;
	WR10: SELF.create_msg IN SELF\model_class_extension.referenced_external_items;
	WR11: SELF.identified_item
		OR (NOT EXISTS (SELF.supplier_identification)
		AND NOT EXISTS (SELF.supplier_designation));
	WR12: list_to_set(SELF.class_presentation_on_paper)
		 <= SELF\model_class_extension.referenced_external_items;
	WR13: list_to_set(SELF.class_presentation_on_screen)
		 <= SELF\model_class_extension.referenced_external_items;
	WR14: QUERY (icon <* SELF.class_presentation_on_paper |
		(NOT EXISTS (icon.width)) OR (icon.kind_of_content 
		= illustration_type.not_static_picture)) = [];
	WR15: QUERY (icon <* SELF.class_presentation_on_screen |
		(NOT EXISTS (icon.width))) = [];
END_ENTITY;

FUNCTION in_typeof ( typ : STRING; elt : opt_or_mand_property_BSU ): LOGICAL ;
  IF SIZEOF(elt.property.definition) = 1 THEN
	RETURN ( typ IN TYPEOF (elt.property.definition [1]));
  ELSE
	RETURN (TRUE);
  END_IF ; 
END_FUNCTION ;

 ENTITY library
  SUPERTYPE OF (library_in_standard_format)
  SUBTYPE OF (dictionary);
  linked_interfaces : SET[0:?] OF external_file_protocol;
  WHERE
   wr1 : QUERY(class <* SELF\dictionary.contained_classes | 
	 referenced_veps_exist_in_supported_veps(
	 SELF, class)) = [];
   wr2 : QUERY(class <* SELF.contained_classes | 
	 referenced_protocols_exist_in_supported_protocols(
	 SELF, class)) = [];
   wr3 : QUERY(int <* SELF.linked_interfaces | NOT ((
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LINKED_INTERFACE_PROGRAM_PROTOCOL'
         ) IN TYPEOF(int))) = []; 
END_ENTITY;

FUNCTION referenced_veps_exist_in_supported_veps(
	lib: library; cl: class_BSU): LOGICAL;
LOCAL
	class_extension: SET [0:1] OF content_item := cl\basic_semantic_unit.referenced_by;
	class_extension_referenced_veps: SET OF view_exchange_protocol_id;
	dictionary_supported_veps: SET OF view_exchange_protocol_id;
	tmp: LOGICAL;
END_LOCAL;

 IF SIZEOF(class_extension) = 1
  THEN
   class_extension_referenced_veps := list_to_set(class_extension[1]\model_class_extension.referenced_view_exchange_protocol);
   dictionary_supported_veps := lib\dictionary.supported_vep;
   tmp := (class_extension_referenced_veps <= dictionary_supported_veps);
   RETURN(
    ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MODEL_CLASS_EXTENSION' IN TYPEOF (class_extension[1]))
      AND NOT (tmp));
  ELSE
   RETURN(FALSE);
 END_IF;
END_FUNCTION;

FUNCTION referenced_protocols_exist_in_supported_protocols(
	lib: library; cl: class_BSU): LOGICAL;
LOCAL
	class_extension: SET [0:1] OF content_item := cl\basic_semantic_unit.referenced_by;
END_LOCAL;
 IF SIZEOF(class_extension) = 1
  THEN
   RETURN(
      ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MODEL_CLASS_EXTENSION' IN TYPEOF(class_extension))
      AND
      (SIZEOF(QUERY(pr <* class_extension[1]\model_class_extension.referenced_external_items | 
		NOT (pr\external_item.used_protocol IN lib\dictionary.base_protocols) 
		AND NOT (pr\external_item.used_protocol IN lib.linked_interfaces))) <> 0)
      );
  ELSE
   RETURN(FALSE);
 END_IF;
END_FUNCTION;



 ENTITY library_in_standard_format
  SUBTYPE OF (library,dictionary_in_standard_format);
  WHERE
   wr1 : QUERY(int <* SELF\library.linked_interfaces | SIZEOF(QUERY(vep <* SELF
         \dictionary.supported_vep | int\external_file_protocol.base_protocol 
         IN vep\data_exchange_specification_id.external_file_protocols)) = 0) =
          [];
 END_ENTITY;

 ENTITY opt_or_mand_property_bsu;
  property : property_bsu;
  is_optional : BOOLEAN;
  displayable : BOOLEAN;
 END_ENTITY;

ENTITY A6_illustration  
SUBTYPE OF (illustration);  
END_ENTITY; 

ENTITY A9_illustration 
SUBTYPE OF (illustration);  
END_ENTITY; 

 ENTITY document_content
  SUBTYPE OF (class_bsu_related_content);
  SELF\content_item.dictionary_definition : document_bsu;
  SELF\external_item.used_protocol : data_protocol;
 END_ENTITY;

 ENTITY external_file_unit
  SUPERTYPE OF (http_file);
  file : external_file_address;
  content_encoding : OPTIONAL content_encoding_type;
  INVERSE
   unit_of : language_specific_content FOR content_files;
  WHERE
   wr1 : (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL' IN TYPEOF(SELF.unit_of.
         content_of.content_of.used_protocol)) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_FILE' IN TYPEOF(SELF))) XOR NOT ((
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL' IN TYPEOF(SELF.unit_of.
         content_of.content_of.used_protocol)) OR (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_FILE' IN TYPEOF(SELF)));
 END_ENTITY;

 ENTITY http_class_directory;
  name : http_directory_name_type;
  class : class_bsu;
  UNIQUE
   ur1 : class;
 END_ENTITY;

ENTITY http_file 
SUBTYPE OF (external_file_unit); 
	mime				: MIME_type;  
	exchange_format	: MIME_subtype;  
	format_RFC		: OPTIONAL IAB_RFC;  
	http_file_name		: http_file_name_type;  
	http_directory		: OPTIONAL http_class_directory;  
	remote_access		: OPTIONAL absolute_URL_type;  
UNIQUE 
	UR1: http_file_name, http_directory; 
WHERE 
	WR1: EXISTS(http_directory) XOR  
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SUPPLIER_BSU_RELATED_CONTENT' 
			IN TYPEOF( SELF.unit_of.content_of.content_of)); 
END_ENTITY; 

 ENTITY http_protocol
  SUBTYPE OF (standard_data_protocol);
  http_rfc : iab_rfc;
  DERIVE
   SELF\external_file_protocol.protocol_name : identifier := 'http';
 END_ENTITY;

ENTITY illustration  
SUPERTYPE OF (ONEOF(A6_illustration,A9_illustration)) 
SUBTYPE OF (dialogue_resource, graphics); 
	kind_of_content : illustration_type; 
	width: OPTIONAL length_measure_with_unit;
	height: OPTIONAL length_measure_with_unit;
WHERE 
 	WR1: (NOT EXISTS (SELF.width) AND NOT EXISTS (SELF.height)) 
		OR (EXISTS (SELF.width) AND EXISTS (SELF.height)); 
END_ENTITY; 

 ENTITY language_specific_content;
  content_files : SET[1:?] OF external_file_unit;
  main_file : OPTIONAL external_file_unit;
  character_encoding : OPTIONAL character_set_type;
  INVERSE
   content_of : external_content FOR consists_of;
  WHERE
   wr1 : NOT EXISTS(main_file) OR (main_file IN content_files);
   wr2 : EXISTS(main_file) XOR (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROGRAM_LIBRARY_CONTENT' IN TYPEOF(SELF.
         content_of.content_of));
   wr3 : EXISTS(character_encoding) OR NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL' IN TYPEOF(SELF.content_of
         .content_of.used_protocol));
 END_ENTITY;

 ENTITY message
  SUBTYPE OF (dialogue_resource);
 END_ENTITY;

 ENTITY non_standard_data_protocol
  SUBTYPE OF (data_protocol,non_standard_protocol);
  WHERE
   wr1 : NOT EXISTS(SELF\external_file_protocol.base_protocol);
 END_ENTITY;

 ENTITY not_translatable_external_content
  SUBTYPE OF (external_content);
  WHERE
   wr1 : SIZEOF(SELF\external_content.consists_of) = 1;
 END_ENTITY;

 ENTITY not_translated_external_content
  SUBTYPE OF (external_content);
  WHERE
   wr1 : SIZEOF(SELF\external_content.consists_of) = 1;
 END_ENTITY;

 ENTITY standard_data_protocol
  SUBTYPE OF (data_protocol,standard_protocol);
  WHERE
   wr1 : NOT EXISTS(SELF\external_file_protocol.base_protocol);
 END_ENTITY;

 ENTITY translated_external_content
  SUBTYPE OF (external_content);
  languages : present_translations;
  WHERE
   wr1 : SIZEOF(SELF\external_content.consists_of) = SIZEOF(SELF.languages.language_codes);
 END_ENTITY;

 ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name : si_unit_name;
  DERIVE
   SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit
                                (SELF.name);
 END_ENTITY;

 ENTITY named_unit
  SUPERTYPE OF (ONEOF(si_unit,conversion_based_unit,context_dependent_unit)
                ANDOR ONEOF(length_unit,mass_unit,time_unit,
                electric_current_unit,thermodynamic_temperature_unit,
                amount_of_substance_unit,luminous_intensity_unit,
                plane_angle_unit,solid_angle_unit,area_unit,volume_unit,
                ratio_unit));
  dimensions : dimensional_exponents;
 END_ENTITY;

 ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
 END_ENTITY;

 ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
 END_ENTITY;

 ENTITY length_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY mass_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY time_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 1.0);
 END_ENTITY;

 ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY area_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY volume_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 3.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY ratio_unit
  SUBTYPE OF (named_unit);
  WHERE
   wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\
         named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.
         dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.
         electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
         thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.
         dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.
         dimensions.luminous_intensity_exponent = 0.0);
 END_ENTITY;

 ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
 END_ENTITY;

 ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
 END_ENTITY;

 ENTITY derived_unit;
  elements : SET[1:?] OF derived_unit_element;
  WHERE
   wr1 : (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements[1].
         exponent <> 1.0));
 END_ENTITY;

 ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET[1:?] OF unit;
 END_ENTITY;

 ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF(length_measure_with_unit,mass_measure_with_unit,
                time_measure_with_unit,electric_current_measure_with_unit,
                thermodynamic_temperature_measure_with_unit,
                amount_of_substance_measure_with_unit,
                luminous_intensity_measure_with_unit,
                plane_angle_measure_with_unit,solid_angle_measure_with_unit,
                area_measure_with_unit,volume_measure_with_unit,
                ratio_measure_with_unit));
  value_component : measure_value;
  unit_component : unit;
  WHERE
   wr1 : valid_units(SELF);
 END_ENTITY;

 ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MASS_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TIME_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN 
         TYPEOF(SELF\measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF
         \measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AREA_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VOLUME_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RATIO_UNIT' IN TYPEOF(SELF\
         measure_with_unit.unit_component);
 END_ENTITY;

 ENTITY organization;
  id : OPTIONAL identifier;
  name : label;
  description : text;
 END_ENTITY;

 ENTITY address;
  internal_location : OPTIONAL label;
  street_number : OPTIONAL label;
  street : OPTIONAL label;
  postal_box : OPTIONAL label;
  town : OPTIONAL label;
  region : OPTIONAL label;
  postal_code : OPTIONAL label;
  country : OPTIONAL label;
  facsimile_number : OPTIONAL label;
  telephone_number : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number : OPTIONAL label;
  WHERE
   wr1 : EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) 
         OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(
         postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(
         telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(
         telex_number);
 END_ENTITY;

 ENTITY axis1_placement
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
  DERIVE
   z : direction := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  WHERE
   wr1 : SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

 ENTITY axis2_placement_2d
  SUBTYPE OF (placement);
  ref_direction : OPTIONAL direction;
  DERIVE
   p : LIST[2:2] OF direction := build_2axes(ref_direction);
  WHERE
   wr1 : SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY axis2_placement_3d
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
  ref_direction : OPTIONAL direction;
  DERIVE
   p : LIST[3:3] OF direction := build_axes(axis,ref_direction);
  WHERE
   wr1 : SELF\placement.location.dim = 3;
   wr2 : (NOT (EXISTS(axis))) OR (axis.dim = 3);
   wr3 : (NOT (EXISTS(ref_direction))) OR (ref_direction.dim = 3);
   wr4 : (NOT (EXISTS(axis))) OR (NOT (EXISTS(ref_direction))) OR (
         cross_product(axis,ref_direction).magnitude > 0.0);
 END_ENTITY;

 ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
 END_ENTITY;

 ENTITY placement
  SUPERTYPE OF (ONEOF(axis1_placement,axis2_placement_2d,axis2_placement_3d))
  SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
 END_ENTITY;

 ENTITY representation;
  name : label;
  items : SET[1:?] OF representation_item;
  context_of_items : representation_context;
 END_ENTITY;

 ENTITY representation_context;
  context_identifier : identifier;
  context_type : text;
  INVERSE
   representations_in_context : SET[1:?] OF representation FOR context_of_items;
 END_ENTITY;

 ENTITY representation_item;
  name : label;
  WHERE
   wr1 : SIZEOF(using_representations(SELF)) > 0;
 END_ENTITY;

 ENTITY generic_variable
  ABSTRACT SUPERTYPE
  SUBTYPE OF (simple_generic_expression);
  INVERSE
   interpretation : environment FOR syntactic_representation;
 END_ENTITY;

 ENTITY variable_semantics
  ABSTRACT SUPERTYPE;
 END_ENTITY;

 ENTITY unary_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(abs_function,minus_function,sin_function,
                         cos_function,tan_function,asin_function,acos_function,
                         exp_function,log_function,log2_function,log10_function
                         ,square_root_function))
  SUBTYPE OF (unary_numeric_expression);
 END_ENTITY;

 ENTITY multiple_arity_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(and_expression,or_expression))
  SUBTYPE OF (boolean_expression,multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST[2:?] OF
                                                    boolean_expression;
 END_ENTITY;

 ENTITY binary_function_call
  ABSTRACT SUPERTYPE OF (atan_function)
  SUBTYPE OF (binary_numeric_expression);
 END_ENTITY;

 ENTITY simple_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(boolean_literal,boolean_variable))
  SUBTYPE OF (boolean_expression,simple_generic_expression);
 END_ENTITY;

 ENTITY generic_literal
  ABSTRACT SUPERTYPE
  SUBTYPE OF (simple_generic_expression);
 END_ENTITY;

 ENTITY variable
  ABSTRACT SUPERTYPE OF (ONEOF(numeric_variable,boolean_variable,
                         string_variable))
  SUBTYPE OF (generic_variable);
 END_ENTITY;

 ENTITY comparison_expression
  ABSTRACT SUPERTYPE OF (ONEOF(comparison_equal,comparison_greater,
                         comparison_greater_equal,comparison_less,
                         comparison_less_equal,comparison_not_equal,
                         like_expression))
  SUBTYPE OF (boolean_expression,binary_generic_expression);
  SELF\binary_generic_expression.operands : LIST[2:2] OF expression;
  WHERE
   wr1 : (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(SELF\
         binary_generic_expression.operands[1])) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(SELF\
         binary_generic_expression.operands[2]))) OR ((
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(SELF\
         binary_generic_expression.operands[1])) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(SELF\
         binary_generic_expression.operands[2]))) OR ((
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF\
         binary_generic_expression.operands[1])) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF\
         binary_generic_expression.operands[2])));
 END_ENTITY;

 ENTITY string_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_string_expression,index_expression,
                         substring_expression,concat_expression,format_function
                         ))
  SUBTYPE OF (expression);
 END_ENTITY;

 ENTITY multiple_arity_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operands : LIST[2:?] OF generic_expression;
 END_ENTITY;

 ENTITY binary_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(minus_expression,div_expression,mod_expression,
                         slash_expression,power_expression,binary_function_call
                         ))
  SUBTYPE OF (numeric_expression,binary_generic_expression);
  SELF\binary_generic_expression.operands : LIST[2:2] OF numeric_expression;
 END_ENTITY;

 ENTITY binary_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(xor_expression,equals_expression))
  SUBTYPE OF (boolean_expression,binary_generic_expression);
 END_ENTITY;

 ENTITY binary_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operands : LIST[2:2] OF generic_expression;
 END_ENTITY;

 ENTITY generic_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_generic_expression,
                         unary_generic_expression,binary_generic_expression,
                         multiple_arity_generic_expression));
  WHERE
   wr1 : is_acyclic(SELF);
 END_ENTITY;

 ENTITY boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_boolean_expression,
                         unary_boolean_expression,binary_boolean_expression,
                         multiple_arity_boolean_expression,
                         comparison_expression,interval_expression,
                         boolean_defined_function))
  SUBTYPE OF (expression);
 END_ENTITY;

 ENTITY literal_number
  ABSTRACT SUPERTYPE OF (ONEOF(int_literal,real_literal))
  SUBTYPE OF (simple_numeric_expression,generic_literal);
  the_value : NUMBER;
 END_ENTITY;

 ENTITY numeric_variable
  SUPERTYPE OF (ONEOF(int_numeric_variable,real_numeric_variable))
  SUBTYPE OF (simple_numeric_expression,variable);
  WHERE
   wr1 : ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(SELF)) 
         OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(
         SELF));
 END_ENTITY;

 ENTITY numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_numeric_expression,
                         unary_numeric_expression,binary_numeric_expression,
                         multiple_arity_numeric_expression,length_function,
                         value_function))
  SUBTYPE OF (expression);
  DERIVE
   is_int : BOOLEAN := is_int_expr(SELF);
   sql_mappable : BOOLEAN := is_sql_mappable(SELF);
 END_ENTITY;

 ENTITY unary_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operand : generic_expression;
 END_ENTITY;

 ENTITY multiple_arity_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(maximum_function,minimum_function))
  SUBTYPE OF (multiple_arity_numeric_expression);
 END_ENTITY;

 ENTITY multiple_arity_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(plus_expression,mult_expression,
                         multiple_arity_function_call))
  SUBTYPE OF (numeric_expression,multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST[2:?] OF
                                                    numeric_expression;
 END_ENTITY;

 ENTITY unary_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(not_expression,odd_function))
  SUBTYPE OF (boolean_expression,unary_generic_expression);
 END_ENTITY;

 ENTITY simple_string_expression
  ABSTRACT SUPERTYPE OF (ONEOF(string_literal,string_variable))
  SUBTYPE OF (string_expression,simple_generic_expression);
 END_ENTITY;

 ENTITY simple_type
  ABSTRACT SUPERTYPE OF (ONEOF(number_type,boolean_type,string_type))
  SUBTYPE OF (data_type);
  value_format : value_format_type;
 END_ENTITY;

 ENTITY basic_semantic_unit
  ABSTRACT SUPERTYPE OF (ONEOF(supplier_bsu,class_bsu,property_bsu,
                         data_type_bsu,supplier_related_bsu,class_related_bsu))
        ;
  code : code_type;
  version : version_type;
  DERIVE
   dic_identifier : identifier := code + sep_cv + version;
  INVERSE
   definition : SET[0:1] OF dictionary_element FOR identified_by;
   referenced_by : SET[0:1] OF content_item FOR dictionary_definition;
 END_ENTITY;
-- basic_semantic_unit

 ENTITY class
  ABSTRACT SUPERTYPE OF (item_class)
  SUBTYPE OF (class_and_property_elements);
  SELF\dictionary_element.identified_by : class_bsu;
  its_superclass : OPTIONAL class_bsu;
  described_by : LIST[0:?] OF UNIQUE property_bsu;
  defined_types : SET[0:?] OF data_type_bsu;
  DERIVE
   subclasses : SET[0:?] OF class := identified_by.subclasses;
   known_applicable_properties : SET[0:?] OF property_bsu :=
                                 compute_known_applicable_properties(SELF\
                                 dictionary_element.identified_by);
   known_applicable_data_types : SET[0:?] OF data_type_bsu :=
                                 compute_known_applicable_data_types(SELF\
                                 dictionary_element.identified_by);
  INVERSE
   associated_items : SET[0:?] OF class_bsu_relationship FOR relating_class;

  WHERE
   wr1 : acyclic_superclass_relationship(SELF.identified_by,[]);
   wr2 : NOT all_class_descriptions_reachable(SELF\dictionary_element.
         identified_by) OR (list_to_set(SELF.described_by) <= SELF\
         dictionary_element.identified_by\class_bsu.known_visible_properties);
   wr3 : NOT all_class_descriptions_reachable(SELF\dictionary_element.
         identified_by) OR (SELF.defined_types <= SELF\dictionary_element.
         identified_by\class_bsu.known_visible_data_types);
   wr4 : check_properties_applicability(SELF);
   wr5 : check_datatypes_applicability(SELF);
 END_ENTITY;

 FUNCTION check_properties_applicability(cl: class): LOGICAL;
 LOCAL
	inter: SET OF property_bsu := [];
 END_LOCAL;

 IF EXISTS(cl.its_superclass)
 THEN
 	IF (SIZEOF(cl.its_superclass.definition)=1)
 	THEN
		inter := (list_to_set(cl.described_by) * cl.its_superclass.definition[1]\class.known_applicable_properties);
		RETURN(inter=[]);
 	ELSE
		RETURN(UNKNOWN);
	END_IF;
 ELSE
	RETURN(UNKNOWN);
 END_IF;
 END_FUNCTION;

 FUNCTION check_datatypes_applicability(cl: class): LOGICAL;
 LOCAL
	inter: SET OF data_type_bsu := [];
 END_LOCAL;

 IF EXISTS(cl.its_superclass)
 THEN
	IF (SIZEOF(cl.its_superclass.definition) = 1)
	THEN
		inter := cl.defined_types * cl.its_superclass.definition[1]\class.known_applicable_data_types;
		RETURN(inter=[]);
 	ELSE
		RETURN(UNKNOWN);
 	END_IF;
 ELSE
	RETURN(UNKNOWN);
 END_IF;
 END_FUNCTION;


 ENTITY complex_type
  ABSTRACT SUPERTYPE OF (ONEOF(level_type,class_instance_type,
                         entity_instance_type))
  SUBTYPE OF (data_type);
 END_ENTITY;

 ENTITY property_det
  ABSTRACT SUPERTYPE OF (ONEOF(condition_det,dependent_p_det,
                         non_dependent_p_det))
  SUBTYPE OF (class_and_property_elements);
  SELF\dictionary_element.identified_by : property_bsu;
  preferred_symbol : OPTIONAL mathematical_string;
  synonymous_symbols : SET[0:2] OF mathematical_string;
  figure : OPTIONAL graphics;
  det_classification : OPTIONAL det_classification_type;
  domain : data_type;
  formula : OPTIONAL mathematical_string;
  DERIVE
   describes_classes : SET[0:?] OF class := identified_by.describes_classes;
 END_ENTITY;

 ENTITY dictionary_element
  ABSTRACT SUPERTYPE OF (ONEOF(supplier_element,class_and_property_elements,
                         data_type_element));
  identified_by : basic_semantic_unit;
  time_stamps : OPTIONAL dates;
  revision : revision_type;
 END_ENTITY;

 ENTITY data_type
  ABSTRACT SUPERTYPE OF (ONEOF(simple_type,complex_type,named_type));
 END_ENTITY;

 ENTITY document
  ABSTRACT SUPERTYPE;
 END_ENTITY;

 ENTITY graphics
  ABSTRACT SUPERTYPE;
 END_ENTITY;

ENTITY referenced_graphics 
SUBTYPE OF (graphics); 
	graphics_reference: document_BSU; 
END_ENTITY; 

ENTITY referenced_document
SUBTYPE OF (document);
	document_reference: document_BSU;
WHERE
WR1 :	NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.IDENTIFIED_DOCUMENT'
	IN TYPEOF (SELF));
END_ENTITY;

 ENTITY supplier_bsu_relationship
  ABSTRACT SUPERTYPE;
  relating_supplier : supplier_element;
  related_tokens : SET[1:?] OF supplier_related_bsu;
 END_ENTITY;

 ENTITY dic_item_instance
  ABSTRACT SUPERTYPE OF (ONEOF(dic_component_instance,dic_material_instance,
                         dic_feature_instance) ANDOR lib_item_instance)
  SUBTYPE OF (dic_class_instance);
  WHERE
   wr1 : definition_available_implies(SELF\dic_class_instance.class_def,
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS' IN TYPEOF(SELF\
         dic_class_instance.class_def.definition[1]));
   wr2 : NOT (all_class_descriptions_reachable(SELF.class_def)) OR (QUERY(prop
         <* SELF.properties | ((SIZEOF(prop.prop_def.definition) = 1) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DEPENDENT_P_DET' IN TYPEOF(prop.prop_def
         .definition[1])) AND EXISTS(prop.its_value) AND (QUERY(ctxt <* prop.
         prop_def.definition[1]\dependent_p_det.depends_on | SIZEOF(QUERY(prop2
         <* SELF.properties | ((prop2.prop_def = ctxt) AND EXISTS(prop2.
         its_value)))) <> 1) <> []))) = []);
 END_ENTITY;

 ENTITY dic_class_instance
  ABSTRACT SUPERTYPE OF (dic_item_instance);
  class_def : class_bsu;
  properties : SET[0:?] OF property_value;
  WHERE
   wr1 : (QUERY(prop <* SELF.properties | NOT ((applicable_properties(SELF.
         class_def,[prop.prop_def])))) = []);
   wr2 : QUERY(prop <* SELF.properties | (SIZEOF(QUERY(prop1 <* SELF.properties
          | prop1.prop_def = prop.prop_def)) = 1)) = SELF.properties;
 END_ENTITY;

 ENTITY level_spec_value
  ABSTRACT SUPERTYPE OF (ONEOF(int_level_spec_value,real_level_spec_value));
  values : ARRAY[4:4] OF OPTIONAL NUMBER;
 END_ENTITY;

 ENTITY lib_item_instance
  ABSTRACT SUPERTYPE OF (ONEOF(lib_component_instance,lib_material_instance,
                         lib_feature_instance))
  SUBTYPE OF (dic_item_instance);
  supplier_identification : OPTIONAL STRING;
  supplier_designation : OPTIONAL STRING;
  user_identification : OPTIONAL STRING;
  user_designation : OPTIONAL STRING;
  WHERE
   wr1 : definition_available_implies(SELF\dic_class_instance.class_def,(SIZEOF
         (SELF\dic_class_instance.class_def.referenced_by) = 1));
   wr2 : QUERY(prop <* SELF.properties | NOT ((allowed_properties(SELF\
         dic_class_instance.class_def,[prop.prop_def])))) = [];
   wr3 : NOT all_class_descriptions_reachable(SELF\dic_class_instance.class_def
         ) OR (QUERY(prop <* gm_free_characteristics_list(SELF\
         dic_class_instance.class_def) | NOT (prop IN 
         collects_assigned_instance_properties(SELF\dic_class_instance.
         properties))) = []);
 END_ENTITY;

 ENTITY class_instance_constructor
  ABSTRACT SUPERTYPE OF (ONEOF(unary_class_instance_constructor,
                         binary_class_instance_constructor,
                         multiple_arity_class_instance_constructor))
  SUBTYPE OF (class_instance_expression);
  properties : SET[1:?] OF property_assignment;
  WHERE
   wr1 : definition_available_implies(SELF\class_instance_expression.expr_type,
         applicable_properties(SELF\class_instance_expression.expr_type,
         list_to_set(collects_assigned_properties(SELF.properties))));
 END_ENTITY;

 ENTITY binary_class_instance_expression
  ABSTRACT SUPERTYPE OF (binary_class_instance_constructor)
  SUBTYPE OF (class_instance_expression,binary_generic_expression);
 END_ENTITY;

 ENTITY simple_class_instance_expression
  ABSTRACT SUPERTYPE OF (ONEOF(class_instance_variable,class_instance_literal))
  SUBTYPE OF (class_instance_expression,simple_generic_expression);
 END_ENTITY;

 ENTITY class_instance_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_class_instance_expression,
                         unary_class_instance_expression,
                         binary_class_instance_expression,
                         multiple_arity_class_instance_expression))
  SUBTYPE OF (generic_expression);
  expr_type : class_bsu;
 END_ENTITY;

 ENTITY simple_entity_instance_expression
  ABSTRACT SUPERTYPE OF (ONEOF(entity_instance_variable,entity_instance_literal
                         ))
  SUBTYPE OF (entity_instance_expression,simple_generic_expression);
 END_ENTITY;

 ENTITY entity_instance_expression
  ABSTRACT SUPERTYPE OF (simple_entity_instance_expression)
  SUBTYPE OF (generic_expression);
  type_name : SET[1:?] OF STRING;
 END_ENTITY;

 ENTITY boolean_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function,boolean_expression);
 END_ENTITY;

 ENTITY level_spec_literal
  ABSTRACT SUPERTYPE OF (ONEOF(int_level_spec_literal,real_level_spec_literal))
  SUBTYPE OF (simple_level_spec_expression,generic_literal);
  the_value : level_spec_value;
  WHERE
   wr1 : compatible_level_type_and_instance(SELF\level_spec_expression.levels,
         TYPEOF(SELF\level_spec_expression.value_type),SELF.the_value);
 END_ENTITY;

 ENTITY level_spec_expression
  ABSTRACT SUPERTYPE OF (simple_level_spec_expression)
  SUBTYPE OF (generic_expression);
  levels : LIST[1:4] OF UNIQUE level;
  value_type : number_type;
 END_ENTITY;

 ENTITY level_spec_variable
  ABSTRACT SUPERTYPE OF (ONEOF(int_level_spec_variable,real_level_spec_variable
                         ))
  SUBTYPE OF (simple_level_spec_expression,generic_variable);
 END_ENTITY;

 ENTITY multiple_arity_class_instance_expression
  ABSTRACT SUPERTYPE OF (multiple_arity_class_instance_constructor)
  SUBTYPE OF (class_instance_expression,multiple_arity_generic_expression);
 END_ENTITY;

 ENTITY unary_class_instance_expression
  ABSTRACT SUPERTYPE OF (unary_class_instance_constructor)
  SUBTYPE OF (class_instance_expression,unary_generic_expression);
 END_ENTITY;

 ENTITY simple_column
  ABSTRACT SUPERTYPE OF (ONEOF(boolean_column,formatted_column))
  SUBTYPE OF (column);
  SELF\column.values : LIST[1:?] OF simple_value;
 END_ENTITY;

 ENTITY complex_column
  ABSTRACT SUPERTYPE OF (ONEOF(level_spec_column,entity_instance_column,
                         class_instance_column))
  SUBTYPE OF (column);
  SELF\column.values : LIST[1:?] OF complex_value;
 END_ENTITY;

 ENTITY column
  ABSTRACT SUPERTYPE OF (ONEOF(simple_column,complex_column));
  values : LIST[1:?] OF primitive_value;
  INVERSE
   belongs_to : table_extension FOR content;
 END_ENTITY;

ENTITY table_expression 
ABSTRACT SUPERTYPE OF (ONEOF(simple_table_expression, 
	unary_table_expression, 
	binary_table_expression, 
	multiple_arity_table_expression, 
	select_expression)) 
SUBTYPE OF (generic_expression); 
DERIVE 
	its_columns: LIST[1:?] OF variable_semantics  
						:=collects_columns (SELF); 
	the_key: SET[1:?] OF variable_semantics := return_key(SELF); 
	is_SQL_mappable: LOGICAL 
					:= is_SQL_mappable_table_expression (SELF); 
WHERE 
	WR1: QUERY (sem<*its_columns 
		|SIZEOF (QUERY (sem_2 <* its_columns 
		|sem_2 :=: sem)) <> 1) = []; 
END_ENTITY; 

 ENTITY set_table_expression
  ABSTRACT SUPERTYPE OF (ONEOF(union_table_expression,
                         intersect_table_expression,difference_table_expression
                         ))
  SUBTYPE OF (binary_table_expression);
  WHERE
   wr1 : SELF\multiple_arity_generic_expression.operands[1]\table_expression.
         its_columns = SELF\multiple_arity_generic_expression.operands[2]\
         table_expression.its_columns;
 END_ENTITY;

 ENTITY number_column
  ABSTRACT SUPERTYPE OF (ONEOF(real_column,integer_column))
  SUBTYPE OF (formatted_column);
  SELF\column.values : LIST[1:?] OF number_value;
 END_ENTITY;

 ENTITY formatted_column
  ABSTRACT SUPERTYPE OF (ONEOF(number_column,string_column))
  SUBTYPE OF (simple_column);
  value_format : value_format_type;
 END_ENTITY;

 ENTITY level_spec_column
  ABSTRACT SUPERTYPE OF (ONEOF(int_level_spec_column,real_level_spec_column))
  SUBTYPE OF (complex_column);
  levels : LIST[1:4] OF UNIQUE level;
  SELF\column.values : LIST[1:?] OF level_spec_value;
  WHERE
   wr1 : QUERY(inst <* SELF\column.values | NOT right_values_for_level_spec(
         SELF.levels,inst)) = [];
 END_ENTITY;

 ENTITY sql_mappable_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function);
 END_ENTITY;

 ENTITY multiple_arity_table_expression
  ABSTRACT SUPERTYPE OF (multiple_arity_cartesian_product)
  SUBTYPE OF (table_expression,multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST[2:?] OF
                                                    table_expression;
 END_ENTITY;

 ENTITY binary_table_expression
  ABSTRACT SUPERTYPE OF (ONEOF(set_table_expression,natural_join_expression))
  SUBTYPE OF (table_expression,binary_generic_expression);
  SELF\binary_generic_expression.operands : LIST[2:2] OF table_expression;
 END_ENTITY;

 ENTITY unary_table_expression
  ABSTRACT SUPERTYPE OF (projection_expression)
  SUBTYPE OF (table_expression,unary_generic_expression);
  SELF\unary_generic_expression.operand : table_expression;
 END_ENTITY;

 ENTITY table_identification
  ABSTRACT SUPERTYPE;
  WHERE
   wr1 : SIZEOF(USEDIN(SELF,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION' 
         + '.TABLE_IDENTIFIER')) <= 1;
   wr2 : SIZEOF(USEDIN(SELF,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_EXTENSION' + 
         '.TABLE_IDENTIFIER')) <= 1;
 END_ENTITY;

 ENTITY simple_table_expression
  ABSTRACT SUPERTYPE OF (ONEOF(table_variable,table_literal))
  SUBTYPE OF (table_expression,simple_generic_expression);
 END_ENTITY;

 ENTITY self_class_name_semantics
  ABSTRACT SUPERTYPE OF (ONEOF(self_class_preferred_name_semantics,
                         self_class_short_name_semantics,
                         self_class_code_semantics,
                         self_class_supplier_code_semantics,
                         self_class_version_semantics))
  SUBTYPE OF (self_class_variable_semantics);
  WHERE
   wr1 : SIZEOF(QUERY(v <* syntax_of(SELF) | NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VARIABLE' IN TYPEOF(v)))) = 0;
 END_ENTITY;

 ENTITY self_property_name_semantics
  ABSTRACT SUPERTYPE OF (ONEOF(self_property_preferred_name_semantics,
                         self_property_short_name_semantics,
                         self_property_code_semantics,
                         self_property_version_semantics,
                         self_property_class_code_semantics,
                         self_property_class_version_semantics,
				 self_property_class_supplier_code_semantics))
  SUBTYPE OF (self_property_semantics);
  WHERE
   wr1 : QUERY(v <* syntax_of(SELF) | NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VARIABLE' IN TYPEOF(v))) = [];
 END_ENTITY;

 ENTITY self_property_semantics
  ABSTRACT SUPERTYPE OF (ONEOF(self_property_value_semantics,
                         self_property_name_semantics))
  SUBTYPE OF (self_variable_semantics,property_semantics);
 END_ENTITY;

 ENTITY simple_domain
  ABSTRACT SUPERTYPE OF (ONEOF(table_defined_domain,type_defined_domain,
                         subclass_defined_domain,constant_range_defined_domain,
                         variable_range_defined_domain,predicate_defined_domain
                         ,simple_functional_domain));
  INVERSE
   referenced_by : guarded_simple_domain FOR domain;
 END_ENTITY;

 ENTITY simple_functional_domain
  ABSTRACT SUPERTYPE OF (ONEOF(library_expression_defined_value,
                         table_defined_value,null_defined_value))
  SUBTYPE OF (simple_domain);
 END_ENTITY;

 ENTITY a_posteriori_semantic_relationship
  ABSTRACT SUPERTYPE OF (a_posteriori_case_of);
 END_ENTITY;

 ENTITY class_bsu_relationship
  ABSTRACT SUPERTYPE;
  relating_class : class;
  related_tokens : SET[1:?] OF class_related_bsu;
 END_ENTITY;

ENTITY external_file_protocol 
 ABSTRACT SUPERTYPE OF ( 
	(ONEOF (standard_protocol, non_standard_protocol)) 
	ANDOR 
	(ONEOF (data_protocol))); 
	organisation: organization; 
	country: OPTIONAL identifier; 
	protocol_name: identifier;
	protocol_version: identifier;
	level: OPTIONAL identifier; 
	designation: item_names; 
	base_protocol: OPTIONAL external_file_protocol; 
 WHERE 
	WR1: (NOT (SELF.protocol_name LIKE '* *')) 
		AND (NOT (SELF.protocol_name LIKE '*.*')) 
		AND (NOT (SELF.protocol_name LIKE '*-*')); 
	WR2: NOT (SELF.protocol_version LIKE '* *'); 
END_ENTITY; 

 ENTITY view_exchange_protocol_id
  SUBTYPE OF (data_exchange_specification_id);
  referenced_iso10303_ap : OPTIONAL application_protocol_definition;
 END_ENTITY;



 ENTITY data_exchange_specification_id
  ABSTRACT SUPERTYPE OF (ONEOF(library_iim_id,view_exchange_protocol_id));
  status : label;
  name : identifier;
  date : year_number;
  application : OPTIONAL identifier;
  level : OPTIONAL identifier;
  external_file_protocols : SET[0:?] OF external_file_protocol;
 END_ENTITY;
 


 ENTITY class_related_bsu
  ABSTRACT SUPERTYPE
  SUBTYPE OF (basic_semantic_unit);
 END_ENTITY;

 ENTITY class_related_element
  ABSTRACT SUPERTYPE OF (ONEOF(table_element,document_element))
  SUBTYPE OF (dictionary_element);
  SELF\dictionary_element.identified_by : class_related_bsu;
  names : item_names;
  definition : definition_type;
  note : OPTIONAL note_type;
  remark : OPTIONAL remark_type;
 END_ENTITY;

 ENTITY person;
  id : identifier;
  last_name : OPTIONAL label;
  first_name : OPTIONAL label;
  middle_names : OPTIONAL LIST[1:?] OF label;
  prefix_titles : OPTIONAL LIST[1:?] OF label;
  suffix_titles : OPTIONAL LIST[1:?] OF label;
  UNIQUE
   ur1 : id;
  WHERE
   wr1 : EXISTS(last_name) OR EXISTS(first_name);
 END_ENTITY;

ENTITY a_priori_semantics_relationship
ABSTRACT SUPERTYPE OF (item_class_case_of)
SUBTYPE OF(class);
	referenced_classes: SET [1:?] OF class_BSU;
	referenced_properties: LIST [0:?] OF property_BSU;
	referenced_data_types: SET [0:?] OF data_type_BSU;
	referenced_tables : SET[0:?] OF table_BSU;
	referenced_documents : SET[0:?] OF document_BSU;
WHERE
	WR1: QUERY ( prop <* referenced_properties
		| QUERY ( cl <* referenced_classes
		| NOT visible_properties (cl, [prop])
		AND NOT applicable_properties (cl, [prop]))
		 = referenced_classes)
		= [];
	WR2: QUERY ( typ <* referenced_data_types
		| QUERY ( cl <* referenced_classes
		| NOT visible_types (cl, [typ])
		AND NOT applicable_types (cl, [typ]))
		= referenced_classes) 
		= [];  
	WR3: QUERY ( tab <* referenced_tables 
		| QUERY ( cl <* referenced_classes 
		| NOT visible_tables (cl, [tab]) 
		AND NOT applicable_tables (cl, [tab]))  
		= referenced_classes) 
		= [];  
	WR4: QUERY ( doc <* referenced_documents 
		| QUERY ( cl <* referenced_classes 
		| NOT visible_documents (cl, [doc]) 
		AND NOT applicable_documents (cl, [doc]))  
		= referenced_classes) 
		= [];  
 
END_ENTITY; 

 ENTITY property_semantics
  ABSTRACT SUPERTYPE OF (self_property_semantics)
  SUBTYPE OF (variable_semantics);
  the_property : property_bsu;
  its_own_property : OPTIONAL sub_property_path;
 WHERE
  wr1 : check_property_semantics(SELF);
 END_ENTITY;

 FUNCTION check_property_semantics(sem: property_semantics): LOGICAL;
 LOCAL
	res: LOGICAL;
 END_LOCAL;

 IF (EXISTS (sem.its_own_property)) AND NOT(data_type_typeof(sem.the_property) = [])
 THEN
	res := ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' 
			IN data_type_typeof(sem.the_property))
	  	 AND 
             applicable_properties (data_type_class_of(sem.the_property)[1],
	  		[sem.its_own_property.the_property]);
	RETURN(res);
 ELSE 
	RETURN (UNKNOWN);
 END_IF;
 END_FUNCTION;

 ENTITY content_item
  ABSTRACT SUPERTYPE;
  dictionary_definition : basic_semantic_unit;
 END_ENTITY;


ENTITY model_class_extension
ABSTRACT SUPERTYPE OF (item_class_extension)
SUBTYPE OF (class_extension);
	selectable_properties	: LIST [0:?] OF UNIQUE 
							opt_or_mand_property_BSU;
	required_properties	: LIST [0:?] OF UNIQUE 
							opt_or_mand_property_BSU;
	derived_properties	: LIST [0:?] OF UNIQUE 
							opt_or_mand_property_BSU;
	new_derived_prop		: SET [0:?] OF property_BSU;
	new_mandatory_prop	: SET [0:?] OF property_BSU;
	class_extension		: SET [0:?] OF domain_restriction;
	derivation			: SET [0:?] OF 
						functional_domain_restriction;
	filters				: SET [0:?] OF domain_restriction;
	referenced_external_items	: SET [0:?] OF 
							class_extension_external_item;
	used_protocols		: SET [0:?] OF external_file_protocol;
	referenced_view_exchange_protocol 	: LIST [0:?] OF
							 view_exchange_protocol_id; 
	content_version		: version_type;
	content_revision		: revision_type;
	
WHERE 
	WR1: QUERY ( opt_or_mand <* SELF.selectable_properties 
		|NOT applicable_properties 
		(SELF\content_item.dictionary_definition,
		[opt_or_mand.property]))
		= [];
		
	WR2: QUERY ( opt_or_mand <* SELF.derived_properties
		|NOT applicable_properties 
		(SELF\content_item.dictionary_definition,
		[opt_or_mand.property]))
		= [];
	WR3: selectable_properties_not_defined_twice(SELF);
	WR4: derived_properties_not_defined_twice(SELF);
	WR5: (NOT all_class_descriptions_reachable(
		SELF.dictionary_definition)) 
		OR (SIZEOF (SELF.new_derived_prop) = 0)
		OR (exists_super(SELF.dictionary_definition)
		AND (QUERY (prop<*SELF.new_derived_prop
		|NOT (prop IN selectable_properties_list(
		super (SELF.dictionary_definition)[1]))) = [])); 
	WR6: (NOT all_class_descriptions_reachable(
		SELF.dictionary_definition))
		OR (SIZEOF (SELF.new_mandatory_prop) = 0)
		OR (exists_super(SELF.dictionary_definition)
		AND (QUERY (prop<*SELF.new_mandatory_prop
		|NOT (prop IN optional_properties_list(
		super (SELF.dictionary_definition)[1]))) = []));
	WR7: QUERY (dom<*
		( SELF.class_extension + SELF.derivation + SELF.filters)
		|(QUERY (sem<*dom.defines
		| NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.SELF_PROPERTY_VALUE_SEMANTICS' IN TYPEOF(sem)))
		 <> [])
		OR (QUERY (sem<* dom.assumes
		| NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+'.SELF_PROPERTY_VALUE_SEMANTICS' IN TYPEOF(sem)))
		 <> [])) = [];
	WR8: QUERY (dom<*( SELF.class_extension + SELF.derivation)
		|QUERY (sem<* dom.defines
		| EXISTS (sem.its_own_property)) 
		<> []) = [];
	WR9: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition)
		OR (QUERY (dom<*
		( SELF.class_extension + SELF.derivation + SELF.filters)
		|(QUERY (sem<*dom.assumes
		| NOT (sem\property_semantics.the_property IN 
		provided_properties_list (
		SELF.dictionary_definition))) <> [])) = []);
	WR10: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition)
		OR (QUERY (dom<* (SELF.class_extension + SELF.filters)
		|(QUERY (sem<*dom.defines
		| NOT (sem\property_semantics.the_property IN 
		selectable_properties_list (
		SELF.dictionary_definition))) <> [])) = []);
	WR11: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition)
		OR (QUERY (dom<*
		( SELF.class_extension + SELF.derivation + SELF.filters)
		|(QUERY (tab<*dom.base_tables
		| NOT applicable_tables (
		SELF.dictionary_definition, [tab])) <> [])) = []);
	WR12: acyclic_class_extension_definition(
		SELF.dictionary_definition);
	WR13: QUERY (prop<*SELF.selectable_properties
		|SIZEOF (QUERY (choi<*SELF.class_extension
		|(prop.property IN get_property_BSU_from_property_semantics(
		choi\domain_restriction.defines))))<> 1) = [];
	WR14: QUERY (prop<*SELF.derived_properties
		|SIZEOF (QUERY (f<*SELF.derivation
		|(prop.property IN get_property_BSU_from_property_semantics( 
		f.defines)))) <> 1) = [];
	WR15: QUERY (prop<*SELF.new_derived_prop
		|SIZEOF (QUERY (f<*SELF.derivation
		|prop IN get_property_BSU_from_property_semantics(
		f.defines))) <> 1) = [];
	WR16:  NOT all_class_descriptions_reachable(
		SELF.dictionary_definition)
		OR (QUERY (f<*SELF.derivation
		|(QUERY (prop<*f.defines 
		|NOT (get_property_BSU_from_property_semantics([prop])[1]
		 IN derived_properties_list 					
		(SELF.dictionary_definition))) 
		<> [])) = []);
	WR17: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition)
		OR (QUERY (prop<* derived_properties_list (
		SELF.dictionary_definition)
		|SIZEOF (QUERY (f<*defined_derivation_function(
		SELF.dictionary_definition)
		|QUERY (sem<* f.defines
		|sem\property_semantics.the_property = prop) <>[])) <> 1 ) 
		= []);
	WR18: QUERY (item<*SELF.referenced_external_items
		|NOT (item\external_item.used_protocol
		IN SELF.used_protocols)) = [];
	WR19: QUERY (filt<*filters
		|NOT( EXISTS(filt.constraint_description))) = [];
	WR20: QUERY (dom_1 <* class_extension |
		NOT ( QUERY ( dom_2 <* dom_1.domains |
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PREDICATE_DEFINED_DOMAIN'
		IN TYPEOF (dom_2.domain)) = [] )) = [];		
END_ENTITY;

 
FUNCTION selectable_properties_not_defined_twice (
				class_ext : model_class_extension):LOGICAL;

IF NOT exists_super(class_ext.dictionary_definition)
THEN
RETURN (UNKNOWN) ;
ELSE
RETURN (	are_properties_not_in(
class_ext.selectable_properties,
provided_properties_list(
super(class_ext.dictionary_definition)[1])));
END_IF;
END_FUNCTION;	-- selectable_properties_not_defined_twice
 
FUNCTION derived_properties_not_defined_twice (
				class_ext: model_class_extension):LOGICAL; 

IF NOT exists_super(class_ext.dictionary_definition) 
THEN 
RETURN (UNKNOWN) ;
ELSE
RETURN (	are_properties_not_in (
class_ext.derived_properties,
provided_properties_list(
super(class_ext.dictionary_definition)[1])));
END_IF;
END_FUNCTION;	


 ENTITY external_item
  ABSTRACT SUPERTYPE OF (ONEOF(dictionary_external_item,
                         class_extension_external_item));
  used_protocol : external_file_protocol;
  content : external_content;
 END_ENTITY;

 ENTITY class_bsu_related_content
  ABSTRACT SUPERTYPE OF (document_content)
  SUBTYPE OF (dictionary_external_item);
  SELF\content_item.dictionary_definition : class_related_bsu;
 END_ENTITY;

 ENTITY data_protocol
  ABSTRACT SUPERTYPE OF (ONEOF(standard_data_protocol,
                         non_standard_data_protocol))
  SUBTYPE OF (external_file_protocol);
 END_ENTITY;

 ENTITY dialogue_resource
  ABSTRACT SUPERTYPE OF (ONEOF(message,illustration))
  SUBTYPE OF (class_extension_external_item);
  SELF\external_item.used_protocol : data_protocol;
 END_ENTITY;

 ENTITY external_content
  ABSTRACT SUPERTYPE OF (ONEOF(translated_external_content,
                         not_translated_external_content,
                         not_translatable_external_content));
  consists_of : LIST[1:?] OF language_specific_content;
  INVERSE
   content_of : external_item FOR content;
 END_ENTITY;

 ENTITY non_standard_protocol
  ABSTRACT SUPERTYPE OF (non_standard_data_protocol)
  SUBTYPE OF (external_file_protocol);
 END_ENTITY;

 ENTITY standard_protocol
  ABSTRACT SUPERTYPE OF (standard_data_protocol)
  SUBTYPE OF (external_file_protocol);

 END_ENTITY;

 ENTITY direction
  SUBTYPE OF (geometric_representation_item);
  direction_ratios : LIST[2:3] OF REAL;
  WHERE
   wr1 : SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
 END_ENTITY;

 ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF(point,direction,vector,placement))
  SUBTYPE OF (representation_item);
  DERIVE
   dim : dimension_count := dimension_of(SELF);
  WHERE
   wr1 : SIZEOF(QUERY(using_rep <* using_representations(SELF) | NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN 
         TYPEOF(using_rep.context_of_items)))) = 0;
 END_ENTITY;

 ENTITY cartesian_point
  SUBTYPE OF (point);
  coordinates : LIST[1:3] OF length_measure;
 END_ENTITY;

 ENTITY simple_generic_expression
  ABSTRACT SUPERTYPE OF (ONEOF(generic_literal,generic_variable))
  SUBTYPE OF (generic_expression);
 END_ENTITY;

 ENTITY unary_numeric_expression
  ABSTRACT SUPERTYPE OF (unary_function_call)
  SUBTYPE OF (numeric_expression,unary_generic_expression);
  SELF\unary_generic_expression.operand : numeric_expression;
 END_ENTITY;

 ENTITY expression
  ABSTRACT SUPERTYPE OF (ONEOF(numeric_expression,boolean_expression,
                         string_expression))
  SUBTYPE OF (generic_expression);
 END_ENTITY;

 ENTITY simple_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(literal_number,numeric_variable))
  SUBTYPE OF (numeric_expression,simple_generic_expression);
 END_ENTITY;

 ENTITY class_and_property_elements
  ABSTRACT SUPERTYPE OF (ONEOF(property_det,class))
  SUBTYPE OF (dictionary_element);
  names : item_names;
  definition : definition_type;
  source_doc_of_definition : OPTIONAL document;
  note : OPTIONAL note_type;
  remark : OPTIONAL remark_type;
 END_ENTITY;

 ENTITY supplier_related_bsu
  ABSTRACT SUPERTYPE
  SUBTYPE OF (basic_semantic_unit);
 END_ENTITY;

 ENTITY defined_function
  ABSTRACT SUPERTYPE OF (boolean_defined_function ANDOR
                         sql_mappable_defined_function);
 END_ENTITY;

 ENTITY simple_level_spec_expression
  ABSTRACT SUPERTYPE OF (ONEOF(level_spec_variable,level_spec_literal))
  SUBTYPE OF (level_spec_expression,simple_generic_expression);
 END_ENTITY;

 ENTITY self_class_variable_semantics
  ABSTRACT SUPERTYPE OF (self_class_name_semantics)
  SUBTYPE OF (self_variable_semantics);
 END_ENTITY;

 ENTITY self_variable_semantics
  ABSTRACT SUPERTYPE OF (ONEOF(self_property_semantics,
                         self_class_variable_semantics))
  SUBTYPE OF (variable_semantics);
 END_ENTITY;

 ENTITY application_protocol_definition;
  status : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year : year_number;
  application : application_context;
 END_ENTITY;

ENTITY class_extension 
ABSTRACT SUPERTYPE OF (ONEOF(model_class_extension)) 
SUBTYPE OF (content_item); 
	SELF\content_item.dictionary_definition: class_BSU; 
WHERE 
	WR1:no_extension_for_superclass (SELF);

END_ENTITY; 

 ENTITY class_extension_external_item
  ABSTRACT SUPERTYPE OF (dialogue_resource)
  SUBTYPE OF (external_item);
  code : external_item_code_type;
  INVERSE
   belongs_to : model_class_extension FOR referenced_external_items;
  UNIQUE
   ur1 : code,belongs_to;
 END_ENTITY;

 ENTITY dictionary_external_item
  ABSTRACT SUPERTYPE OF (class_bsu_related_content)
  SUBTYPE OF (content_item,external_item);
  revision : revision_type;
 END_ENTITY;

 ENTITY vector
  SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude : length_measure;
  WHERE
   wr1 : magnitude >= 0.0;
 END_ENTITY;

 ENTITY point
  SUPERTYPE OF (cartesian_point)
  SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY level_type
  SUBTYPE OF (complex_type);
  levels : LIST[1:4] OF UNIQUE level;
  value_type : simple_type;
  WHERE
   wr1 : 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE' IN TYPEOF(value_type);
 END_ENTITY;

 ENTITY application_context;
  application : text;
  INVERSE
   context_elements : SET[1:?] OF application_context_element FOR
                      frame_of_reference;
 END_ENTITY;

 ENTITY application_context_element;
  name : label;
  frame_of_reference : application_context;
 END_ENTITY;

 FUNCTION is_int_expr(arg : numeric_expression) : BOOLEAN;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_LITERAL' IN TYPEOF(arg)
   THEN
    RETURN (TRUE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_LITERAL' IN TYPEOF(arg)
   THEN
    RETURN (FALSE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(arg)
   THEN
    RETURN (TRUE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg)
   THEN
    RETURN (FALSE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)
   THEN
    RETURN (is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg)
   THEN
    RETURN (is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg))
   THEN
    RETURN (FALSE);
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINIMUM_FUNCTION' IN TYPEOF(arg))
   THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
     IF NOT is_int_expr(arg\multiple_arity_numeric_expression.operands[i])
      THEN
       RETURN (FALSE);
     END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.POWER_EXPRESSION' IN TYPEOF(arg))
   THEN
    RETURN (is_int_expr(arg\binary_numeric_expression.operands[1]) AND 
     is_int_expr(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
   THEN
    RETURN (TRUE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (FALSE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg)
   THEN
    RETURN (TRUE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)
   THEN
    IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_VALUE_FUNCTION' IN TYPEOF(arg)
     THEN
      RETURN (TRUE);
     ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_DEFINED_FUNCTION' IN TYPEOF(arg)
   THEN
    RETURN (TRUE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_DEFINED_FUNCTION' IN TYPEOF(arg)
   THEN
    RETURN (FALSE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg)
   THEN
    RETURN (FALSE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_DEFINED_FUNCTION' IN TYPEOF(arg)
   THEN
    RETURN (FALSE);
  END_IF;
  RETURN (FALSE);
 END_FUNCTION;
-- is_int_expr

 FUNCTION compute_known_visible_properties(cl : class_bsu) : SET OF property_bsu
                                           ;
  LOCAL
   s : SET OF property_bsu := [];
  END_LOCAL;
  s := s + USEDIN(cl,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU.NAME_SCOPE');
  IF SIZEOF(cl.definition) = 0
   THEN
    RETURN (s);
   ELSE
    IF EXISTS(cl.definition[1]\class.its_superclass)
     THEN
      s := s + compute_known_visible_properties(cl.definition[1]\class.
           its_superclass);
    END_IF;
    RETURN (s);
  END_IF;
 END_FUNCTION;

 FUNCTION compute_known_visible_data_types(cl : class_bsu) : SET OF
                                           data_type_bsu;
  LOCAL
   s : SET OF data_type_bsu := [];
  END_LOCAL;
  s := s + USEDIN(cl,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DATA_TYPE_BSU.NAME_SCOPE');
  IF SIZEOF(cl.definition) = 0
   THEN
    RETURN (s);
   ELSE
    IF EXISTS(cl.definition[1]\class.its_superclass)
     THEN
      s := s + compute_known_visible_data_types(cl.definition[1]\class.
           its_superclass);
    END_IF;
    RETURN (s);
  END_IF;
 END_FUNCTION;

FUNCTION definition_available_implies ( 
			BSU: basic_semantic_unit;
			expression: LOGICAL): LOGICAL;

RETURN (NOT (SIZEOF(BSU.definition) = 1) OR expression);

END_FUNCTION; -- definition_available_implies



 FUNCTION is_subclass(sub,super : class) : LOGICAL;
  IF (NOT EXISTS(sub)) OR (NOT EXISTS(super))
   THEN
    RETURN (UNKNOWN);
  END_IF;
  IF sub = super
   THEN
    RETURN (TRUE);
  END_IF;

  IF NOT EXISTS(sub.its_superclass)
   THEN
    RETURN (FALSE);
  END_IF;
  IF SIZEOF(sub.its_superclass.definition) = 1
   THEN
    IF (sub.its_superclass.definition[1] = super)
     THEN
      RETURN (TRUE);
     ELSE
      RETURN (is_subclass(sub.its_superclass.definition[1],super));
    END_IF;
   ELSE
    RETURN (UNKNOWN);
  END_IF;
 END_FUNCTION;
-- is_subclass



FUNCTION all_class_descriptions_reachable (cl:class_BSU): BOOLEAN;

IF NOT EXISTS(cl)
THEN 
	RETURN(FALSE);
END_IF;

IF SIZEOF(cl.definition) = 0 
THEN 
	RETURN(FALSE);
END_IF;

IF NOT (EXISTS(cl.definition[1]\class.its_superclass)) 
THEN 
	RETURN (TRUE);
ELSE
	RETURN(all_class_descriptions_reachable(
					cl.definition[1]\class.its_superclass));
END_IF;

END_FUNCTION; -- all_class_descriptions_reachable 



 FUNCTION at_most_two_synonyms_per_language(languages : present_translations;
                                            synonymous_names : SET OF
                                            syn_name_type) : BOOLEAN;
  IF EXISTS(languages)
   THEN
    REPEAT i := 1 TO SIZEOF(languages.language_codes);
     IF SIZEOF(QUERY(s <* synonymous_names | s.language = languages.
        language_codes[i])) > 2
      THEN
       RETURN (FALSE);
     END_IF;
    END_REPEAT;
    RETURN (TRUE);
   ELSE
    RETURN (SIZEOF(synonymous_names) <= 2);
  END_IF;
 END_FUNCTION;
-- at_most_two_synonyms_per_language

 FUNCTION codes_are_unique(values : LIST OF dic_value) : BOOLEAN;
  LOCAL
   l : SET OF STRING := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF(values);
   l := l + values[i].value_code;
  END_REPEAT;
  RETURN (SIZEOF(values) = SIZEOF(l));
 END_FUNCTION;
-- codes_are_unique

FUNCTION compatible_type_and_value(
			dom: property_or_data_type_BSU;
			val: primitive_value
			): LOGICAL;

LOCAL
	temp: SET[0:1] OF class_BSU;
END_LOCAL;

IF data_type_typeof(dom)= [] 
THEN (* the final domain of the type is not available *)
	RETURN(UNKNOWN);
END_IF;

(* The following express statements deal with simple types *)

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_VALUE' IN TYPEOF(val) THEN	RETURN ( 
('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' 
		IN data_type_typeof (dom)) OR
	 	(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE' 
		IN data_type_typeof (dom)) 
	 	AND NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' 
		IN data_type_typeof (dom))) );
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_VALUE' IN TYPEOF(val) 
THEN	RETURN (  ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' 
		IN data_type_typeof (dom)) OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE' 
		IN data_type_typeof (dom)) 
		AND NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' 
		IN data_type_typeof (dom))) );
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_VALUE' IN TYPEOF(val) THEN
	RETURN ( 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_TYPE' 
		IN data_type_typeof (dom) );
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VALUE' IN TYPEOF(val)
THEN	RETURN ( 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_TYPE' 
		IN data_type_typeof (dom) );
END_IF;

(* The following express statements deal with complex types *)

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_VALUE'
	IN TYPEOF(val) 
THEN	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+
		'.UNCONTROLLED_ENTITY_INSTANCE_VALUE'
		 IN TYPEOF(val) 
	THEN
		RETURN(UNKNOWN);
	END_IF;
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE' 
		IN data_type_typeof (dom)) 
AND (SIZEOF (data_type_type_name(dom)) <> 0)
		AND (data_type_type_name(dom) <= TYPEOF(val)) 
	THEN RETURN(TRUE);
	ELSE RETURN(FALSE); 
	END_IF;
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DIC_CLASS_INSTANCE' 
	IN TYPEOF(val) THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' 
		IN data_type_typeof (dom))
		AND (SIZEOF (data_type_class_of(dom)) <> 0)
	THEN 
		temp := data_type_class_of(dom);
		RETURN (compatible_class_and_class(temp[1],
				val\dic_class_instance.class_def));
	ELSE 
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_VALUE' IN TYPEOF(val) THEN	
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' 
		IN data_type_typeof (dom))
	THEN 
		RETURN (compatible_level_type_and_instance ( 
			data_type_level_spec(dom),
			data_type_level_value_typeof(dom),
			val));
	ELSE 
		RETURN(FALSE);
	END_IF;
END_IF;

RETURN (FALSE);

END_FUNCTION; -- compatible_type_and_value


 FUNCTION collects_referenced_library_expressions(p_a : AGGREGATE OF
                                                         property_assignment) :
                                                  LIST[1:?] OF
                                                  library_expression;
  LOCAL
   assign_exp : LIST[0:?] OF library_expression;
  END_LOCAL;
  assign_exp := [];
  REPEAT i := 1 TO HIBOUND(p_a);
   IF EXISTS(p_a[i].its_value)
    THEN
     assign_exp := assign_exp + p_a[i].its_value;
   END_IF;
  END_REPEAT;
  RETURN (assign_exp);
 END_FUNCTION;
-- collects_referenced_library_expressions 

 FUNCTION collects_assigned_properties(p_a : AGGREGATE OF property_assignment) :
                                       LIST OF property_bsu;
  LOCAL
   assign_prop : LIST OF property_bsu;
--assigned properties of the 
--multiple_arity_class_instance_constructor
  END_LOCAL;
  assign_prop := [];
  REPEAT i := 1 TO HIBOUND(p_a);
   assign_prop := assign_prop + p_a[i].prop_def;
  END_REPEAT;
  RETURN (assign_prop);
 END_FUNCTION;
-- collects_assigned_properties 

 FUNCTION compatible_class_and_class(cl1 : class_bsu;cl2 : class_bsu) : LOGICAL
                                     ;
  IF (cl1.defined_by\basic_semantic_unit.code = cl2.defined_by\
     basic_semantic_unit.code) AND (cl1\basic_semantic_unit.code = cl2\
     basic_semantic_unit.code) AND (cl1\basic_semantic_unit.version >= cl2\
     basic_semantic_unit.version)
   THEN
    RETURN (TRUE);
  END_IF;
  IF (SIZEOF(cl2\basic_semantic_unit.definition) = 0)
   THEN
    RETURN (UNKNOWN);
  END_IF;
  IF (SIZEOF(cl2\basic_semantic_unit.definition) = 1) AND (NOT EXISTS(cl2\
     basic_semantic_unit.definition[1]\class.its_superclass))
   THEN
    RETURN (FALSE);
  END_IF;
  RETURN (compatible_class_and_class(cl1,cl2\basic_semantic_unit.definition[1]\
   class.its_superclass));
 END_FUNCTION;
-- compatible_class_and_class 

 FUNCTION compatible_level_type_and_instance(levels : LIST[1:4] OF UNIQUE level
                                             ;value_typeof : SET OF STRING;val 
                                             : level_spec_value) : BOOLEAN;
  LOCAL
   c_val : BOOLEAN;
  END_LOCAL;
  c_val := FALSE;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_LEVEL_SPEC_VALUE' IN TYPEOF(val)) AND 
     NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN value_typeof)
   THEN
    c_val := TRUE;
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_LEVEL_SPEC_VALUE' IN TYPEOF(val)) AND 
     NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' IN value_typeof)
   THEN
    c_val := TRUE;
  END_IF;
  RETURN (c_val AND (right_values_for_level_spec(levels,val)));
 END_FUNCTION;
-- compatible_level_type_and_instance 

 FUNCTION compatible_type_and_library_expression(dom : property_or_data_type_bsu
                                                 ;expr : library_expression) :
                                                 LOGICAL;
  LOCAL
   temp : SET[0:1] OF class_bsu;
  END_LOCAL;
  IF data_type_typeof(dom) = []
   THEN
    RETURN (UNKNOWN);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_EXPRESSION' IN TYPEOF(expr)
   THEN
    IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN data_type_typeof(dom)) AND
        (list_to_set(data_type_level_spec(dom)) = list_to_set(expr\
       level_spec_expression.levels)) AND (TYPEOF(expr\level_spec_expression.
       value_type) <= data_type_level_value_typeof(dom))
     THEN
      RETURN (TRUE);
     ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_EXPRESSION' IN TYPEOF(expr)
   THEN
    IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE' IN data_type_typeof
       (dom)) AND (data_type_type_name(dom) <= expr\entity_instance_expression.
       type_name)
     THEN
      RETURN (TRUE);
     ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_EXPRESSION' IN TYPEOF(expr)
   THEN
    IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN data_type_typeof(
       dom)) AND (SIZEOF(data_type_class_of(dom)) = 1)
     THEN
      temp := data_type_class_of(dom);
      RETURN (compatible_class_and_class(temp[1],expr.expr_type));
     ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (compatible_simple_type_and_expression(dom,expr));
 END_FUNCTION;
-- compatible_type_and_library_expression

FUNCTION compatible_variable_semantics_and_expression ( 
		sem: variable_semantics; 
		expr: expression  
		): LOGICAL; 
 
LOCAL 
	va: SET OF generic_variable; 
END_LOCAL; 
 
va := syntax_of (sem); 
IF SIZEOF (va) = 0  
THEN 
	RETURN (UNKNOWN); 
ELSE 
	REPEAT i := LOINDEX (va) TO HIINDEX (va); 
		IF ( NOT compatible_variable_and_expression (va[i], expr)) 
		THEN 
			RETURN (FALSE); 
		END_IF; 
	END_REPEAT; 
	RETURN (TRUE); 
END_IF;  
 
END_FUNCTION; -- compatible_variable_semantics_and_expression  



FUNCTION is_SQL_mappable_table_expression (arg: table_expression )  
		: LOGICAL; 
 
IF 	'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_TABLE_EXPRESSION'  
	IN TYPEOF (arg)  
THEN  
	IF 	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_VARIABLE'  
		IN TYPEOF(arg)) 
	THEN  
		RETURN (TRUE); 
	END_IF; 
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_LITERAL'  
		IN TYPEOF(arg)) 
	THEN 
		IF (SIZEOF ( USEDIN (arg\table_literal.the_value, 
			'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_SPECIFICATION' 
			+ '.TABLE_IDENTIFIER')) = 1) 
		THEN 
			RETURN (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+'.RDB_TABLE_SPECIFICATION')  
				IN TYPEOF (USEDIN (arg\table_literal.the_value, 
				'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')[1])); 
		ELSE 
			RETURN (UNKNOWN); 
		END_IF; 
	END_IF; 
	RETURN (FALSE); 	-- table_variable that is not 
				-- an RDB_table_variable 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNARY_TABLE_EXPRESSION'  
	IN TYPEOF(arg))  
THEN 
	RETURN (is_SQL_mappable_table_expression( 
			arg\unary_table_expression.operand)); 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SELECT_EXPRESSION'  
	IN TYPEOF(arg))  
THEN 
	RETURN (is_SQL_mappable_table_expression( 
			arg\select_expression.from_table) 
			AND is_SQL_mappable( 
			arg\select_expression.condition)); 
END_IF; 
 
IF 	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_TABLE_EXPRESSION'  
	IN TYPEOF(arg))  
THEN 
	RETURN (is_SQL_mappable_table_expression( 
		arg\binary_table_expression.operands[1]) 
		AND Is_SQL_mappable_table_expression( 
		arg\binary_table_expression.operands[2])); 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_TABLE_EXPRESSION'  
	IN TYPEOF(arg))  
THEN  
	REPEAT i :=1 TO SIZEOF  
(arg\multiple_arity_table_expression.operands); 
		IF NOT is_SQL_mappable_table_expression 
				(arg\multiple_arity_table_expression.operands[i])
		THEN
			RETURN (FALSE);
		END_IF;
	END_REPEAT;

	RETURN (TRUE);
END_IF;

RETURN(UNKNOWN);
END_FUNCTION; -- is_SQL_mappable_table_expression


 FUNCTION is_sql_mappable(arg : expression) : BOOLEAN;
   IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_NUMERIC_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (TRUE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SQL_MAPPABLE_DEFINED_FUNCTION' IN TYPEOF(arg
     )
   THEN
    RETURN (TRUE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg)
   THEN
    RETURN (is_sql_mappable(arg\unary_numeric_expression.operand));
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg))
   THEN
    RETURN (FALSE);
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINIMUM_FUNCTION' IN TYPEOF(arg))
   THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
     IF NOT is_sql_mappable(arg\multiple_arity_numeric_expression.operands[i])
      THEN
       RETURN (FALSE);
     END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg))
   THEN
    RETURN (is_sql_mappable(arg\binary_numeric_expression.operands[1]) AND 
     is_sql_mappable(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.POWER_EXPRESSION' IN TYPEOF(arg))
   THEN
    RETURN (FALSE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_BOOLEAN_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (TRUE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NOT_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (is_sql_mappable(arg\unary_generic_expression.operand));
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ODD_FUNCTION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.XOR_EXPRESSION' IN TYPEOF(arg))
   THEN
    RETURN (FALSE);
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AND_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.OR_EXPRESSION' IN TYPEOF(arg))
   THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_boolean_expression.operands);
     IF NOT is_sql_mappable(arg\multiple_arity_boolean_expression.operands[i])
      THEN
       RETURN (FALSE);
     END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.EQUALS_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (is_sql_mappable(arg\binary_generic_expression.operands[1]) AND 
     is_sql_mappable(arg\binary_generic_expression.operands[2]));
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_EQUAL' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_GREATER' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_GREATER_EQUAL' IN TYPEOF(arg)) OR
      ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_LESS' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_LESS_EQUAL' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPARISON_NOT_EQUAL' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LIKE_EXPRESSION' IN TYPEOF(arg))
   THEN
    RETURN (is_sql_mappable(arg\comparison_expression.operands[1]) AND 
     is_sql_mappable(arg\comparison_expression.operands[2]));
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (is_sql_mappable(arg\interval_expression.interval_low) AND 
     is_sql_mappable(arg\interval_expression.interval_high) AND is_sql_mappable
     (arg\interval_expression.interval_item));
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_DEFINED_FUNCTION' IN TYPEOF(arg))
     OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg)
     ) OR ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_DEFINED_FUNCTION' IN TYPEOF(arg
     ))
   THEN
    RETURN (FALSE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_STRING_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (TRUE);
  END_IF;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SUBSTRING_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CONCAT_EXPRESSION' IN TYPEOF(arg)) OR (
     'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.FORMAT_FUNCTION' IN TYPEOF(arg))
   THEN
    RETURN (FALSE);
  END_IF;
  RETURN (FALSE);
 END_FUNCTION;
-- is_SQL_mappable

 FUNCTION compatible_list_variable_semantics_and_expressions(sem : LIST[0:?] OF
                                                             variable_semantics
                                                             ;exprs : LIST[0:?]
                                                             OF expression) :
                                                             LOGICAL;
  LOCAL
   res : LOGICAL;
  END_LOCAL;
  IF SIZEOF(sem) <> SIZEOF(exprs)
   THEN
    RETURN (FALSE);
  END_IF;
  res := TRUE;
  REPEAT i := LOBOUND(sem) TO HIBOUND(sem);
   res := res AND compatible_variable_semantics_and_expression(sem[i],exprs[i])
          ;
  END_REPEAT;
  RETURN (res);
 END_FUNCTION;
-- compatible_list_variable_semantics_and_expressions 

 FUNCTION used_variables(arg : generic_expression) : SET OF generic_variable;
  LOCAL
   result : SET OF generic_variable := [];
  END_LOCAL;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.GENERIC_VARIABLE' IN TYPEOF(arg)
   THEN
    RETURN ([arg]);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNARY_GENERIC_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (used_variables(arg\unary_generic_expression.operand));
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_GENERIC_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (used_variables(arg\binary_generic_expression.operands[1]) + 
     used_variables(arg\binary_generic_expression.operands[2]));
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF
     (arg)
   THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_generic_expression.operands);
     result := result + used_variables(arg\multiple_arity_generic_expression.
               operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  RETURN ([]);
-- in this case the subtype shall not contain
-- any variable (see IP1 in generic_expression)
 END_FUNCTION;
-- used_variables

FUNCTION syntax_of (sem: variable_semantics ): SET OF generic_variable;
	
LOCAL
	env : BAG  OF environment;
	vars : SET OF generic_variable;
END_LOCAL;

env := USEDIN ( sem,
	'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENVIRONMENT.SEMANTICS');
vars := [];

REPEAT i := LOINDEX (env) TO HIINDEX (env); 
	vars := vars + env[i].syntactic_representation;
END_REPEAT;		

RETURN (vars);

END_FUNCTION; -- syntax_of


 FUNCTION compatible_list_variable_semantics_and_columns(sem : LIST[0:?] OF
                                                         variable_semantics;col
                                                          : LIST[0:?] OF column
                                                         ) : LOGICAL;
  LOCAL
   res : LOGICAL;
  END_LOCAL;
  IF SIZEOF(sem) <> SIZEOF(col)
   THEN
    RETURN (FALSE);
  END_IF;
  res := TRUE;
  REPEAT i := LOINDEX(col) TO HIINDEX(col);
   res := res AND compatible_column_and_variable_semantics(col[i],sem[i]);
  END_REPEAT;
  RETURN (res);
 END_FUNCTION;
-- compatible_list_variable_semantics_and_columns 

 FUNCTION bsu_of_property_semantics(v : property_semantics_or_path) :
                                    property_bsu;
  LOCAL
   prop : property_bsu;
  END_LOCAL;
  prop := v.the_property;
  IF EXISTS(v.its_own_property)
   THEN
    RETURN (bsu_of_property_semantics(v.its_own_property));
   ELSE
    RETURN (prop);
  END_IF;
 END_FUNCTION;
-- BSU_of_property_semantics

 FUNCTION collects_variables(v_sem : AGGREGATE OF variable_semantics) : SET OF
                             generic_variable;
  LOCAL
   l : SET OF generic_variable := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF(v_sem);
   l := l + syntax_of(v_sem[i]);
  END_REPEAT;
  RETURN (l);
 END_FUNCTION;
-- collects_variables

 FUNCTION used_tables_in_domain(arg : domain_restriction) : SET OF
                                table_identification;
  LOCAL
   result : SET OF table_identification := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF(arg.domains);
   IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(arg.domains[i
      ].guard)
    THEN
     result := result + used_table_literals(arg.domains[i].guard);
   END_IF;
   IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_DEFINED_DOMAIN' IN TYPEOF(arg.domains
      [i].domain)
    THEN
     result := result + used_table_literals(arg.domains[i].domain\
               table_defined_domain.from_table);
   END_IF;
   IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PREDICATE_DEFINED_DOMAIN' IN TYPEOF(arg.
      domains[i].domain)
    THEN
     result := result + used_table_literals(arg.domains[i].domain\
               predicate_defined_domain.constraint);
   END_IF;
   IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LIBRARY_EXPRESSION_DEFINED_VALUE' 
      IN TYPEOF(arg.domains[i].domain)
    THEN
     result := result + used_table_literals(arg.domains[i].domain\
               library_expression_defined_value.its_value);
   END_IF;
   IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_DEFINED_VALUE' IN TYPEOF(arg.domains[
      i].domain)
    THEN
     result := result + used_table_literals(arg.domains[i].domain\
               table_defined_value.from_table);
   END_IF;
  END_REPEAT;
  RETURN (result);
 END_FUNCTION;
-- used_tables_in_domain

 FUNCTION compatible_variable_and_library_expression(va : library_variable;expr
                                                      : library_expression) :
                                                     LOGICAL;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_EXPRESSION' IN TYPEOF(expr)
   THEN
    IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_VARIABLE' IN TYPEOF(va)) AND 
       ((list_to_set(va\level_spec_expression.levels)) = list_to_set(expr\
       level_spec_expression.levels)) AND (TYPEOF(va\level_spec_expression.
       value_type) <= TYPEOF(expr\level_spec_expression.value_type)))
     THEN
      RETURN (TRUE);
     ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_EXPRESSION' IN TYPEOF(expr)
   THEN
    IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_VARIABLE' IN TYPEOF(va)) 
       AND (va\entity_instance_expression.type_name <= expr\
       entity_instance_expression.type_name)
     THEN
      RETURN (TRUE);
     ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_EXPRESSION' IN TYPEOF(expr)
   THEN
    IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_VARIABLE' IN TYPEOF(va))
     THEN
      RETURN (compatible_class_and_class(va\class_instance_expression.expr_type
       ,expr\class_instance_expression.expr_type));
     ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (compatible_variable_and_expression(va,expr));
 END_FUNCTION;
-- compatible_variable_and_library_expression

 FUNCTION collects_var_sem(va : AGGREGATE OF generic_variable) : SET OF
                           variable_semantics;
  LOCAL
   l : SET OF variable_semantics := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF(va);
   l:= l + semantics_of(va[i]);
  END_REPEAT;
  RETURN (l);
 END_FUNCTION;
-- collects_var_sem

FUNCTION collects_columns (t: table_expression) : 
		LIST OF variable_semantics; 
 
LOCAL 
	res, tempo: LIST [0:?] OF variable_semantics:=[]; 
	x: BAG [1:1] OF table_specification; 
END_LOCAL; 
 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_VARIABLE'IN TYPEOF(t) 
THEN 
	RETURN( t\table_variable.structure);
END_IF; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_LITERAL' IN TYPEOF(t) 
THEN 
	x := USEDIN(t\table_literal.the_value,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
		+ '.TABLE_SPECIFICATION.TABLE_IDENTIFIER'); 
	RETURN(x[1].column_meaning);	 
END_IF; 

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NATURAL_JOIN_EXPRESSION' 
	IN TYPEOF(t) 
THEN 
	RETURN( 
	diff_columns(
		collects_columns(
			t\natural_join_expression.table_1), 
		collects_columns(
			t\natural_join_expression.table_2))); 
END_IF; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_TABLE_EXPRESSION' 
	IN TYPEOF(t)  
THEN 
	RETURN(collects_columns (t\binary_table_expression.operands[1])+ 
	collects_columns(t\binary_table_expression.operands[2])); 
END_IF; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_TABLE_EXPRESSION' IN  
TYPEOF(t) THEN 
	REPEAT i:=1 TO  
SIZEOF(t\multiple_arity_table_expression.operands); 
		res := res + 
	collects_columns(t\multiple_arity_table_expression.operands[i]); 
	END_REPEAT; 
	RETURN(res); 
END_IF; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SELECT_EXPRESSION' IN TYPEOF(t) 
THEN 
	RETURN(collects_columns  
(t\binary_generic_expression.operands[1])); 
END_IF; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROJECTION_EXPRESSION' IN TYPEOF(t)  
THEN 
	REPEAT i := 1 TO SIZEOF(t\projection_expression.argts_var); 
		tempo := tempo +t\projection_expression.argts_var[i]; 
	END_REPEAT; 
	RETURN(tempo); 
END_IF; 
 
RETURN([]); 
 
END_FUNCTION; -- collects_columns



FUNCTION compatible_types ( p1: property_or_data_type_BSU;
			p2: property_or_data_type_BSU)
			:LOGICAL;

LOCAL
	p1_domain, p2_domain: data_type;
END_LOCAL;

IF (NOT EXISTS(p1)) OR (NOT EXISTS(p2))
THEN
	RETURN(UNKNOWN); -- p1 or p2 indeterminate
END_IF;

(* case 1 *)

IF p1 = p2
THEN
	RETURN (TRUE);
END_IF;

(* case 2 *)

IF ((TYPEOF (p1) = TYPEOF (p2))
	AND (p1\basic_semantic_unit.code = p2.code) 
	AND (p1.name_scope\basic_semantic_unit.code = 
						p2.name_scope\basic_semantic_unit.code)
	AND (p1\basic_semantic_unit.version >= 
						p2\basic_semantic_unit.version))
THEN
	RETURN (TRUE);
END_IF;

(* case 8 *)

IF (SIZEOF(p1\basic_semantic_unit.definition)=0) 
	OR (SIZEOF(p2\basic_semantic_unit.definition)=0)
THEN 
	RETURN(UNKNOWN);
ELSE
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF 
(p1)
	THEN
		p1_domain := p1.definition [1]\property_DET.domain;
	ELSE
		p1_domain := 
p1.definition[1]\data_type_element.type_definition;
	END_IF;

	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF 
(p2)
	THEN
		p2_domain := p2.definition [1]\property_DET.domain;
	ELSE
		p2_domain := 
p2.definition[1]\data_type_element.type_definition;
	END_IF;
END_IF;

(* case 3 *)

IF p1_domain = p2_domain
THEN 
	RETURN(TRUE);
END_IF;

	(* case 4 *)

IF (NOT(SIZEOF(data_type_typeof(p1)) = 0)) 
	AND (data_type_typeof(p1)<=data_type_typeof(p2)) 
	AND (NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPLEX_TYPE' IN 
		data_type_typeof(p2)))
THEN 
	RETURN(TRUE);
END_IF;

(* case 5 *)

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN 
		data_type_typeof(p1)) 
	AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN 
		data_type_typeof(p2))
THEN 
	RETURN(compatible_subclass(data_type_class_of (p1)[1],
								data_type_class_of (p2)[1]));
	
END_IF;

(* case 6 *)

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE' IN 
		data_type_typeof(p1))
	AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE' IN 
		data_type_typeof(p2))
THEN 
	IF ((data_type_type_name (p1) <= data_type_type_name (p2))
		AND (data_type_type_name (p1) <> []))
	THEN 
		RETURN(TRUE);
	ELSE 
		RETURN(FALSE);
	END_IF;
END_IF;

(* case 7 *)

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN 
data_type_typeof(p1)) 
	AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN 
data_type_typeof(p2)) 
THEN 
	IF (data_type_level_spec (p1) = data_type_level_spec(p2)) 
		AND (data_type_level_value_typeof(p1) <> [])
		AND (data_type_level_value_typeof(p1) 
			<= data_type_level_value_typeof(p2))
	THEN 
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

(* case 8 *)

IF	((data_type_typeof(p1) = []) OR (data_type_typeof(p2) = []))
THEN
	RETURN (UNKNOWN);
ELSE
	RETURN (FALSE);
END_IF;

END_FUNCTION; -- compatible_types 


FUNCTION applicable_properties(
			cl: class_BSU;
			prop: AGGREGATE OF property_BSU): LOGICAL;

IF SIZEOF(prop) = 0
THEN
	RETURN(TRUE); 
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); 
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

prop := prop - list_to_set(cl.definition[1]\class.described_by);

IF 
'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.A_PRIORI_SEMANTICS_RELATIONSHIP' 
IN TYPEOF(cl.definition[1]) 
THEN
prop := prop - list_to_set(cl.definition[1]
	\a_priori_semantics_relationship.referenced_properties);
END_IF;

IF SIZEOF(Prop)=0 
THEN
	RETURN(TRUE);
ELSE 
	IF EXISTS (cl.definition[1]\class.its_superclass) 
	THEN
		RETURN (applicable_properties(cl.definition[1]
				\class.its_superclass, prop));
	ELSE
		RETURN (FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_properties


FUNCTION visible_documents (cl: class_BSU;
		doc: AGGREGATE OF document_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); 
END_IF;

REPEAT i := 1 TO SIZEOF(doc);
	IF doc[i].name_scope = cl
	THEN
		doc := doc - doc[i];
	END_IF;
END_REPEAT;

IF SIZEOF(doc) = 0 
THEN
	RETURN(TRUE); 
END_IF;

IF SIZEOF(cl.definition) = 0 
THEN
	RETURN(UNKNOWN);
END_IF;

IF EXISTS(cl.definition[1]\class.its_superclass) 
THEN
	RETURN (visible_documents(cl.definition[1]
			\class.its_superclass, doc));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- visible_documents 



FUNCTION get_property_BSU_from_property_semantics 
	(l : AGGREGATE OF variable_semantics): LIST[1:?] OF property_BSU; 
 
LOCAL 
	res: LIST[0:?] OF property_BSU:=[]; 
END_LOCAL; 
 
REPEAT i := 1 TO SIZEOF(l); 
	res := res + l[i]\property_semantics.the_property; 
END_REPEAT; 
 
RETURN(res); 
 
END_FUNCTION; -- get_property_BSU_from_property_semantics 




FUNCTION visible_tables (cl: class_BSU;
		tab: AGGREGATE OF table_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); 
END_IF;

REPEAT i := 1 TO SIZEOF(tab);
	IF tab[i].name_scope = cl
	THEN
		tab := tab - tab[i];
	END_IF;
END_REPEAT;

IF SIZEOF(tab) = 0 
THEN
	RETURN(TRUE); 
END_IF;

IF SIZEOF(cl.definition) = 0 
THEN
	RETURN(UNKNOWN);
END_IF;

IF EXISTS(cl.definition[1]\class.its_superclass) 
THEN
	RETURN (visible_tables(cl.definition[1]
			\class.its_superclass, tab));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- visible_tables

 FUNCTION prefix_ordered_class_list(classes : LIST[2:?] OF class_bsu) : BOOLEAN
                                    ;
  LOCAL
   prev : INTEGER;
   related_token : class_related_bsu;

-- items associated with
-- a class through a 
-- class_BSU_relationship
  END_LOCAL;
  REPEAT i := 2 TO SIZEOF(classes);
   prev := i;
   prev := prev - 1;

   IF SIZEOF(classes[i].definition) = 1
    THEN
     IF (EXISTS(classes[i].definition[1]\class.its_superclass)) AND (NOT ((
        classes[i].definition[1]\class.its_superclass) IN (makes_sub_list(
        classes,1,prev))))
      THEN
       RETURN (FALSE);
     END_IF;
     IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.A_PRIORI_SEMANTICS_RELATIONSHIP' 
	IN TYPEOF(classes[i].definition[1]))
      THEN
       IF (QUERY(x <* classes[i].definition[1]\a_priori_semantics_relationship.
          referenced_classes | NOT (x IN makes_sub_list(classes,1,prev))) <> [
          ])
        THEN
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF NOT (SIZEOF(classes[i].definition[1]\class.described_by) = 0)
      THEN
       IF makes_reference_outside(classes[i].definition[1]\class.described_by,
          makes_sub_list(classes,1,i))
        THEN
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.A_PRIORI_SEMANTICS_RELATIONSHIP' IN TYPEOF(classes[i].definition[1]))
      THEN
       IF makes_reference_outside(classes[i].definition[1]\
          a_priori_semantics_relationship.referenced_properties,makes_sub_list(
          classes,1,prev))
        THEN
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF NOT (SIZEOF(classes[i].definition[1]\class.defined_types) = 0)
      THEN
       IF makes_reference_outside(classes[i].definition[1]\class.defined_types,
          makes_sub_list(classes,1,i))
        THEN
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.A_PRIORI_SEMANTICS_RELATIONSHIP' IN TYPEOF(classes[i].definition[1]))
      THEN
       IF makes_reference_outside(classes[i].definition[1]\
          a_priori_semantics_relationship.referenced_data_types,makes_sub_list(
          classes,1,prev))
        THEN
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF NOT (SIZEOF(classes[i].definition[1]\class.associated_items) = 0)
      THEN
       REPEAT j := 1 TO SIZEOF(classes[i].definition[1]\class.associated_items)
              ;
        REPEAT k := 1 TO SIZEOF(classes[i].definition[1]\class.associated_items
               [j]\class_bsu_relationship.related_tokens);
         related_token := classes[i].definition[1]\class.associated_items[j]\
                          class_bsu_relationship.related_tokens[k];
         IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_BSU') IN (TYPEOF(
            related_token))) AND NOT (related_token\table_bsu.name_scope IN 
            makes_sub_list(classes,1,i))
          THEN
           RETURN (FALSE);
         END_IF;
         IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DOCUMENT_BSU') IN (
            TYPEOF(related_token))) AND NOT (related_token\document_bsu.
            name_scope IN makes_sub_list(classes,1,i))
          THEN
           RETURN (FALSE);
         END_IF;
        END_REPEAT;
       END_REPEAT;
     END_IF;
   END_IF;
  END_REPEAT;
  RETURN (TRUE);
 END_FUNCTION;
-- prefix_ordered_class_list


FUNCTION simple_type_data_type (type_spec: property_or_data_type_BSU 
						): LOGICAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN(UNKNOWN); -- type_spec is indeterminate
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_TYPE' IN 
	data_type_typeof (type_spec)
THEN
	RETURN (TRUE);
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.COMPLEX_TYPE' IN 
	data_type_typeof (type_spec)
THEN
	RETURN (FALSE);
END_IF;

RETURN (UNKNOWN);

END_FUNCTION; -- simple_type_data_type 


 FUNCTION compatible_list_library_types_and_columns(dom : LIST[0:?] OF
                                                    property_or_data_type_bsu;
                                                    col : LIST[0:?] OF column) :
                                                    LOGICAL;
  LOCAL
   res : LOGICAL;
  END_LOCAL;
  res := TRUE;
  IF SIZEOF(dom) <> SIZEOF(col)
   THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := LOINDEX(col) TO HIINDEX(col);
   IF data_type_typeof(dom[i]) = []
    THEN
     res := UNKNOWN;
    ELSE
     IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_COLUMN' IN TYPEOF(col[i])
      THEN
       IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' IN data_type_typeof(dom[i]))
           OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE' IN data_type_typeof(
          dom[i])) AND NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN 
          data_type_typeof(dom[i])))
        THEN
         ;
        ELSE
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_COLUMN' IN TYPEOF(col[i])
      THEN
       IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN data_type_typeof(dom[i])
          ) OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE' IN data_type_typeof
          (dom[i])) AND NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' IN 
          data_type_typeof(dom[i])))
        THEN
         ;
        ELSE
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_COLUMN' IN TYPEOF(col[i])
      THEN
       IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_TYPE' IN data_type_typeof(dom[i
          ])
        THEN
         ;
        ELSE
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_COLUMN' IN TYPEOF(col[i])
      THEN
       IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_TYPE' IN data_type_typeof(dom[i]
          )
        THEN
         ;
        ELSE
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_COLUMN' IN TYPEOF(col[i])
      THEN
       IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE' IN 
          data_type_typeof(dom[i])) AND (data_type_type_name(dom[i]) <= col[i]\
          entity_instance_column.type_name)
        THEN
         ;
        ELSE
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_COLUMN' IN TYPEOF(col[i])
      THEN
       IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN 
          data_type_typeof(dom[i])) AND (compatible_subclass(data_type_class_of
          (dom[i])[1],col[i]\class_instance_column.class_ref))
        THEN
         ;
        ELSE
         RETURN (FALSE);
       END_IF;
     END_IF;
     IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_COLUMN' IN TYPEOF(col[i])
      THEN
       IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN data_type_typeof(dom[i]
          ))
        THEN
         REPEAT j := LOBOUND(col[i].values) TO HIBOUND(col[i].values);
          IF NOT (compatible_level_type_and_instance(data_type_level_spec(dom[i
             ]),data_type_level_value_typeof(dom[i]),col[i].values[j]))
           THEN
            RETURN (FALSE);
          END_IF;
         END_REPEAT;
        ELSE
         RETURN (FALSE);
       END_IF;
     END_IF;
   END_IF;
  END_REPEAT;
  RETURN (res);
 END_FUNCTION;
-- compatible_list_library_types_and_columns 

FUNCTION visible_properties (cl: class_BSU;
		prop: AGGREGATE OF property_BSU): LOGICAL;

LOCAL 
	ok: BOOLEAN:=TRUE;
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); 
END_IF;

REPEAT i:=1 TO SIZEOF(prop);
IF NOT(prop[i] IN compute_known_visible_properties(cl)) 
	THEN ok:=FALSE; 
END_IF;
END_REPEAT;

IF NOT(ok) AND NOT(all_class_descriptions_reachable(cl)) 
	THEN RETURN(UNKNOWN);
END_IF;

IF NOT(ok) AND all_class_descriptions_reachable(cl)
	THEN RETURN(FALSE);
END_IF;

RETURN(TRUE);
END_FUNCTION; -- visible_properties




FUNCTION data_type_typeof (type_spec: property_or_data_type_BSU)
			: SET OF STRING;

LOCAL
	res: BOOLEAN;
	x: data_type;
END_LOCAL;

res := FALSE;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN 
	TYPEOF(type_spec)
THEN 
	IF NOT(SIZEOF(type_spec.definition)=0) 
	THEN 
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE 
	IF NOT(SIZEOF(type_spec.definition)=0) 
	THEN 
		x := type_spec.definition[1]
		\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF NOT (res) 
THEN 
	RETURN([]);
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x)
THEN 
	IF NOT(SIZEOF(x\named_type.referred_type.definition)=0)
	THEN
		RETURN (data_type_typeof(x\named_type.referred_type));
	ELSE
		RETURN ([]);
	END_IF;
ELSE
	RETURN(TYPEOF(x));
END_IF;

END_FUNCTION; -- data_type_typeof 



FUNCTION data_type_named_type(type_spec: property_or_data_type_BSU)
			: SET[0:1] OF data_type_BSU;

LOCAL
	res: BOOLEAN;
	s: SET[0:1] OF data_type_BSU;
	x: data_type;
END_LOCAL;

res := FALSE;
s := [ ];

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN 
	TYPEOF(type_spec)
THEN 
	IF NOT(SIZEOF(type_spec.definition)=0)
	THEN 
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE 
	IF NOT(SIZEOF(type_spec.definition)=0) 
	THEN 
		x:=type_spec.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res 	
THEN 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x)
	THEN 
		s :=s + x\named_type.referred_type;
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_named_type


 FUNCTION check_syn_length ( s: syn_name_type; s_length: INTEGER) 
									:BOOLEAN;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LABEL_WITH_LANGUAGE' IN TYPEOF(s) 
   THEN 
    RETURN (LENGTH(s\label_with_language.l) <= s_length); 
   ELSE
    RETURN (LENGTH(s) <= s_length); 
  END_IF;
 END_FUNCTION;
 -- check_syn_length 

 FUNCTION dimensions_for_si_unit(n : si_unit_name) : dimensional_exponents;
  CASE n OF
   metre : RETURN (dimensional_exponents(1.0,0.0,0.0,0.0,0.0,0.0,0.0));
   gram : RETURN (dimensional_exponents(0.0,1.0,0.0,0.0,0.0,0.0,0.0));
   second : RETURN (dimensional_exponents(0.0,0.0,1.0,0.0,0.0,0.0,0.0));
   ampere : RETURN (dimensional_exponents(0.0,0.0,0.0,1.0,0.0,0.0,0.0));
   kelvin : RETURN (dimensional_exponents(0.0,0.0,0.0,0.0,1.0,0.0,0.0));
   mole : RETURN (dimensional_exponents(0.0,0.0,0.0,0.0,0.0,1.0,0.0));
   candela : RETURN (dimensional_exponents(0.0,0.0,0.0,0.0,0.0,0.0,1.0));
   radian : RETURN (dimensional_exponents(0.0,0.0,0.0,0.0,0.0,0.0,0.0));
   steradian : RETURN (dimensional_exponents(0.0,0.0,0.0,0.0,0.0,0.0,0.0));
   hertz : RETURN (dimensional_exponents(0.0,0.0,- 1.0,0.0,0.0,0.0,0.0));
   newton : RETURN (dimensional_exponents(1.0,1.0,- 2.0,0.0,0.0,0.0,0.0));
   pascal : RETURN (dimensional_exponents(- 1.0,1.0,- 2.0,0.0,0.0,0.0,0.0));
   joule : RETURN (dimensional_exponents(2.0,1.0,- 2.0,0.0,0.0,0.0,0.0));
   watt : RETURN (dimensional_exponents(2.0,1.0,- 3.0,0.0,0.0,0.0,0.0));
   coulomb : RETURN (dimensional_exponents(0.0,0.0,1.0,1.0,0.0,0.0,0.0));
   volt : RETURN (dimensional_exponents(2.0,1.0,- 3.0,- 1.0,0.0,0.0,0.0));
   farad : RETURN (dimensional_exponents(- 2.0,- 1.0,4.0,1.0,0.0,0.0,0.0));
   ohm : RETURN (dimensional_exponents(2.0,1.0,- 3.0,- 2.0,0.0,0.0,0.0));
   siemens : RETURN (dimensional_exponents(- 2.0,- 1.0,3.0,2.0,0.0,0.0,0.0));
   weber : RETURN (dimensional_exponents(2.0,1.0,- 2.0,- 1.0,0.0,0.0,0.0));
   tesla : RETURN (dimensional_exponents(0.0,1.0,- 2.0,- 1.0,0.0,0.0,0.0));
   henry : RETURN (dimensional_exponents(2.0,1.0,- 2.0,- 2.0,0.0,0.0,0.0));
   degree_celsius : RETURN (dimensional_exponents(0.0,0.0,0.0,0.0,1.0,0.0,0.0))
                     ;
   lumen : RETURN (dimensional_exponents(0.0,0.0,0.0,0.0,0.0,0.0,1.0));
   lux : RETURN (dimensional_exponents(- 2.0,0.0,0.0,0.0,0.0,0.0,1.0));
   becquerel : RETURN (dimensional_exponents(0.0,0.0,- 1.0,0.0,0.0,0.0,0.0));
   gray : RETURN (dimensional_exponents(2.0,0.0,- 2.0,0.0,0.0,0.0,0.0));
   sievert : RETURN (dimensional_exponents(2.0,0.0,- 2.0,0.0,0.0,0.0,0.0));
  END_CASE;
 END_FUNCTION;

 FUNCTION valid_units(m : measure_with_unit) : BOOLEAN;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       1.0,0.0,0.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,1.0,0.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,0.0,1.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
     value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,0.0,0.0,1.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF
     (m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,0.0,0.0,0.0,1.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
     value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,0.0,0.0,0.0,0.0,1.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
     value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,0.0,0.0,0.0,0.0,0.0,1.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
     value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,0.0,0.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
     value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,0.0,0.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       2.0,0.0,0.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       3.0,0.0,0.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,0.0,0.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
     value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       1.0,0.0,0.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
     value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
       0.0,0.0,0.0,0.0,0.0,0.0,0.0)
     THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
 END_FUNCTION;

 FUNCTION normalise (arg : vector_or_direction) : vector_or_direction;

   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;

   IF NOT EXISTS (arg) THEN
     result := ?;
     (* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag > 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;

   LOCAL

     d : direction := NVL(normalise(ref_direction),

                          dummy_gri || direction([1.0,0.0]));

   END_LOCAL;



   RETURN([d, orthogonal_complement(d)]);

 END_FUNCTION;

FUNCTION build_axes(axis, ref_direction : direction) :

                                          LIST [3:3] OF direction;

   LOCAL

     d1, d2 : direction;

   END_LOCAL;

  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));

  d2 := first_proj_axis(d1, ref_direction);

  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);

END_FUNCTION;

FUNCTION cross_product (arg1, arg2 : direction) : vector;

  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;

  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
	    (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;

      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
END_FUNCTION;

 FUNCTION using_representations(item : representation_item) : SET OF
                                representation;
  LOCAL
   results : SET OF representation;
   result_bag : BAG OF representation;
   intermediate_items : SET OF representation_item;
   i : INTEGER;
  END_LOCAL;
-- Find the representations in which the item is used and add to the 
-- results set.
  result_bag := USEDIN(item,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION.ITEMS'
                );
  IF SIZEOF(result_bag) > 0
   THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
     results := results + result_bag[i];
    END_REPEAT;
  END_IF;
-- Find the set of representation_items in which item is used.
  intermediate_items := QUERY(z <* bag_to_set(USEDIN(item,'')) | 
                        'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION_ITEM' IN 
                        TYPEOF(z));
-- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0
   THEN
    REPEAT i := 1 TO HIINDEX(intermediate_items);
     results := results + using_representations(intermediate_items[i]);
    END_REPEAT;
  END_IF;
-- Return the set of representation in which the input item is
-- used directly and indirectly (through intervening representation_items).
  RETURN (results);
 END_FUNCTION;

 FUNCTION is_acyclic(arg : generic_expression) : BOOLEAN;
  RETURN (acyclic(arg,[]));
 END_FUNCTION;
-- is_acyclic

 FUNCTION compute_known_applicable_properties(cl : class_bsu) : SET OF
                                              property_bsu;
  LOCAL
   s : SET OF property_bsu := [];
  END_LOCAL;
  IF SIZEOF(cl.definition) = 0
   THEN
    RETURN (s);
   ELSE
    REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.described_by);
     s := s + cl.definition[1]\class.described_by[i];
    END_REPEAT;
    IF EXISTS(cl.definition[1]\class.its_superclass)
     THEN
      s := s + compute_known_applicable_properties(cl.definition[1]\class.
           its_superclass);
    END_IF;
    RETURN (s);
  END_IF;
 END_FUNCTION;

 FUNCTION compute_known_applicable_data_types(cl : class_bsu) : SET OF
                                              data_type_bsu;
  LOCAL
   s : SET OF data_type_bsu := [];
  END_LOCAL;
  IF SIZEOF(cl.definition) = 0
   THEN
    RETURN (s);
   ELSE
    REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.defined_types);
     s := s + cl.definition[1]\class.defined_types[i];
    END_REPEAT;
    IF EXISTS(cl.definition[1]\class.its_superclass)
     THEN
      s := s + compute_known_applicable_data_types(cl.definition[1]\class.
           its_superclass);
    END_IF;
    RETURN (s);
  END_IF;
 END_FUNCTION;

 FUNCTION acyclic_superclass_relationship(current : class_bsu;visited : SET OF
                                          class) : LOGICAL;
  IF SIZEOF(current.definition) = 1
   THEN
    IF current.definition[1] IN visited
     THEN
      RETURN (FALSE);
     ELSE
      IF EXISTS(current.definition[1]\class.its_superclass)
       THEN
        RETURN (acyclic_superclass_relationship(current.definition[1]\class.
         its_superclass,visited + current.definition[1]));
       ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;
   ELSE
    RETURN (UNKNOWN);
  END_IF;
 END_FUNCTION;
-- acyclic_superclass_relationship

 FUNCTION list_to_set(l : LIST[0:?] OF GENERIC : type_elem) : SET OF GENERIC :
                      type_elem;
  LOCAL
   s : SET OF GENERIC : type_elem := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF(l);
   s := s + l[i];
  END_REPEAT;
  RETURN (s);
 END_FUNCTION;
-- list_to_set

 FUNCTION check_label_length(l : translatable_label;l_length : INTEGER) :
                             BOOLEAN;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_LABEL' IN TYPEOF(l)
   THEN
    REPEAT i := 1 TO SIZEOF(l.labels);
     IF LENGTH(l.labels[i]) > l_length
      THEN
       RETURN (FALSE);
     END_IF;
    END_REPEAT;
    RETURN (TRUE);
   ELSE
    RETURN (LENGTH(l) <= l_length);
  END_IF;
 END_FUNCTION;
-- check_label_length 



FUNCTION allowed_properties (cl: class_BSU;
			prop: SET OF property_BSU)
			: LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); -- the class itself is indeterminate
END_IF;

IF NOT(all_class_descriptions_reachable(cl))
THEN 
	RETURN(UNKNOWN);
END_IF;

IF prop <= (list_to_set(provided_properties_list (cl)))
THEN 
	RETURN (TRUE);
ELSE 
	RETURN (FALSE);
END_IF;

END_FUNCTION; -- allowed_properties 




 FUNCTION gm_free_characteristics_list(cl : class_bsu) : LIST OF property_bsu;
  LOCAL
   selec : LIST OF property_bsu := [];
--non redefined properties
   def : LIST OF property_bsu;
--free defined characteristics
   redef : SET OF property_bsu;
--derived redefined properties
  END_LOCAL;
  def := free_defined_characteristics(cl);
  redef := derived_redefined_properties(cl);
  REPEAT i := 1 TO SIZEOF(def);
   IF NOT (def[i] IN redef)
    THEN
     selec := selec + def[i];
   END_IF;
  END_REPEAT;
  RETURN (selec);
 END_FUNCTION;
-- gm_free_characteristics_list 

 FUNCTION collects_assigned_instance_properties(props : SET[0:?] OF
                                                property_value) : SET OF
                                                property_bsu;
  LOCAL
   assign_prop : SET OF property_bsu;
--assigned properties of the dic_class_instance
  END_LOCAL;
  assign_prop := [];
  REPEAT i := 1 TO HIBOUND(props);
   assign_prop := assign_prop + props[i].prop_def;
  END_REPEAT;
  RETURN (assign_prop);
 END_FUNCTION;
-- collects_assigned_instance_properties



FUNCTION data_type_type_name(t: property_or_data_type_BSU)
			: SET [0:?] OF STRING;

LOCAL
	res: BOOLEAN;
	s: SET [0:1] OF STRING;
	x: data_type;
END_LOCAL;

res := FALSE;
s := [ ];

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(t)
THEN 
	IF NOT(SIZEOF(t.definition)=0) 
	THEN 
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE 
	IF NOT(SIZEOF(t.definition)=0) 
	THEN 
		x := t.definition[1]\data_type_element.type_definition;
		res:=TRUE;
	END_IF;
END_IF;

IF res 
THEN 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_TYPE'
		 IN TYPEOF(x)
	THEN 
		s := x\entity_instance_type.type_name;
	END_IF;

	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x)
	THEN 
		s := data_type_type_name(x\named_type.referred_type);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_type_name




FUNCTION data_type_class_of(type_spec: property_or_data_type_BSU)
			: SET[0:1] OF class_BSU;

LOCAL
	res: BOOLEAN;
	s: SET[0:1] OF class_BSU;
	x: data_type;
END_LOCAL;

res := FALSE;
s := [ ];

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN 
	TYPEOF(type_spec)
THEN 
	IF NOT(SIZEOF(type_spec.definition)=0) 
	THEN 
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE 
	IF NOT(SIZEOF(type_spec.definition)=0) 
	THEN 
		x := 
type_spec.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' IN 
		TYPEOF(x)
	THEN 
		s :=s+ x\class_instance_type.domain;
		RETURN(s);
	END_IF;

	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x) 
	THEN 
		s := data_type_class_of(x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_class_of



FUNCTION visible_properties_for_visible_tables (
		 rel : class_table_relationship) : LOGICAL;
		
		IF QUERY (table <* rel.related_tokens
		| SIZEOF ( table.definition) =0) <> []
		THEN
			RETURN (UNKNOWN);
		END_IF;

		RETURN (
			QUERY (table <* rel.related_tokens
			| (applicable_properties 
			(rel\class_BSU_relationship.relating_class
			.identified_by,
			get_property_BSU_from_property_semantics
			(table\basic_semantic_unit.definition[1]
			\table_element.column_meaning)) = FALSE)) = []);
END_FUNCTION;




FUNCTION data_type_level_spec (t: property_or_data_type_BSU)
			: LIST[0:4] OF UNIQUE Level;

LOCAL
	res: BOOLEAN;
	s: LIST[0:4] OF UNIQUE Level;
	x: data_type;
END_LOCAL;

res := FALSE;
s := [];

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(t)
THEN 
	IF NOT(SIZEOF(t.definition)=0) 
	THEN 
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE 
	IF NOT(SIZEOF(t.definition)=0)
	THEN 
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res 
THEN 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN TYPEOF(x)
	THEN
		s := x\level_type.levels;
	END_IF;

	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x)
	THEN
		s := data_type_level_spec(x\named_type.referred_type);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_level_spec 





FUNCTION data_type_level_value_typeof(t: property_or_data_type_BSU)
			: SET OF STRING;

LOCAL
	res: BOOLEAN;
	s: SET OF STRING;
	x: data_type;
END_LOCAL;

res := FALSE;
s := [];

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU' IN TYPEOF(t)
THEN 
	IF NOT(SIZEOF(t.definition)=0) 
	THEN 
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE 
	IF NOT(SIZEOF(t.definition)=0)
	THEN 
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res 
THEN 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_TYPE' IN TYPEOF(x)
	THEN 
		s := TYPEOF(x\level_type.value_type);
	END_IF;

	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NAMED_TYPE' IN TYPEOF(x)
	THEN 
		s := data_type_level_value_typeof(x\named_type
											.referred_type);
	END_IF;

END_IF;

RETURN(s);

END_FUNCTION; -- data_type_level_value_typeof




FUNCTION right_values_for_level_spec (
			levels: LIST [1:4] OF UNIQUE level;
			val: level_spec_value 
			):BOOLEAN;

LOCAL
	c_place: BOOLEAN;
	lev: SET [1:4] OF level;
END_LOCAL;

c_place	:= TRUE;
lev 	:= list_to_set(levels);

IF EXISTS (val.values[1]) 
THEN 
	IF level.min IN lev
	THEN lev:= lev - [level.min]; 
	ELSE c_place:= FALSE;
	END_IF;
END_IF;

IF EXISTS (val.values[2]) 
THEN 
	IF level.nom IN lev
	THEN lev:= lev -[level.nom]; 
	ELSE c_place:= FALSE;
	END_IF;
END_IF;

IF EXISTS (val.values[3]) 
THEN 
	IF level.typ IN lev
	THEN lev:= lev - [level.typ]; 
	ELSE c_place:= FALSE;
	END_IF;
END_IF;

IF EXISTS (val.values[4]) 
THEN 
	IF level.max IN lev
	THEN lev:= lev - [level.max]; 
	ELSE c_place:= FALSE;
	END_IF;
END_IF;

IF (c_place AND (SIZEOF(lev)=0))
THEN 
	RETURN(TRUE);
 ELSE 
	RETURN(FALSE);
END_IF;


END_FUNCTION; -- right_values_for_level_spec 


FUNCTION compatible_simple_type_and_expression( 
		dom:property_or_data_type_BSU; 
		expr: expression): LOGICAL; 
 
IF data_type_typeof(dom)= []  
THEN  
	RETURN(UNKNOWN); 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF (expr))  
AND is_int_expr (expr) 
THEN 
	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' IN  
	data_type_typeof (dom)) OR 
	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE' IN  
	data_type_typeof (dom)))  
	AND (NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN  
	data_type_typeof (dom)))  
	THEN  
		RETURN(TRUE); 
	ELSE  
		RETURN(FALSE); 
	END_IF; 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF (expr))  
AND NOT is_int_expr (expr) 
THEN 
	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_TYPE' IN  
	data_type_typeof (dom)) OR 
	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_TYPE' IN  
	data_type_typeof (dom)))  
	AND (NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_TYPE' IN  
	data_type_typeof (dom)))  
	THEN  
		RETURN(TRUE); 
	ELSE  
		RETURN(FALSE); 
	END_IF; 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION'  
IN TYPEOF (expr)) 
THEN 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_TYPE' IN  
		data_type_typeof (dom)  
	THEN 
		RETURN(TRUE); 
	ELSE 
		RETURN(FALSE);  
	END_IF; 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'  
IN TYPEOF (expr)) 
THEN 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_TYPE' IN  
		data_type_typeof (dom)  
	THEN 
		RETURN(TRUE); 
	ELSE 
		RETURN(FALSE);  
	END_IF; 
END_IF;	-- all simple types have been considered 
 
END_FUNCTION; -- compatible_simple_type_and_expression 

FUNCTION return_key (t: table_expression) 
		: SET [1:?] OF variable_semantics; 
LOCAL 
	res: SET [0:?] OF variable_semantics:=[]; 
	x: BAG[1:1] OF table_specification; 
END_LOCAL; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_VARIABLE'IN TYPEOF(t) 
THEN 
	RETURN(t\table_variable.its_key); 
END_IF; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_LITERAL' IN TYPEOF(t) 
THEN 
	x := USEDIN(t\table_literal.the_value,
		'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.' 
		+ 'TABLE_SPECIFICATION.TABLE_IDENTIFIER'); 
	RETURN (x[1]\table_specification.key);	 
END_IF; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SELECT_EXPRESSION' IN TYPEOF(t) 
THEN 
	RETURN (
		return_key(
		t\binary_generic_expression.operands[1])); 
END_IF; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROJECTION_EXPRESSION' IN TYPEOF(t)  
THEN 
	IF QUERY (col <* t\projection_expression.operand.the_key | NOT 
		(col IN t\projection_expression.argts_var)) <> [] 
	THEN 
		RETURN (list_to_set(t\table_expression.its_columns)); 
	ELSE  
		RETURN (t\projection_expression.operand.the_key); 
	END_IF; 
END_IF; 
 
IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTERSECT_TABLE_EXPRESSION' 
		IN TYPEOF(t)) 
	OR 
	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DIFFERENCE_TABLE_EXPRESSION' 
		IN TYPEOF(t))) 
THEN 
	RETURN (return_key(t\binary_table_expression.operands[1])); 
END_IF; 
 
IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNION_TABLE_EXPRESSION' 
		IN TYPEOF(t)) 
	OR 
	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NATURAL_JOIN_EXPRESSION' 
		IN TYPEOF(t))) 
THEN 
	RETURN (return_key(t\binary_table_expression.operands[1]) + 
	return_key(t\binary_table_expression.operands[2])); 
END_IF; 
 
IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_TABLE_EXPRESSION' IN  
TYPEOF(t) THEN 
	REPEAT i := 1 TO
	SIZEOF(t\multiple_arity_table_expression.operands); 
		res := res  
		+return_key(t\multiple_arity_table_expression.operands[i]);
	END_REPEAT; 
	RETURN (res); 
END_IF; 
 
RETURN([]); 
END_FUNCTION; -- return_key 


FUNCTION compatible_variable_and_expression( 
		va: generic_variable; 
		expr: expression): LOGICAL; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF (expr))  
AND is_int_expr (expr) 
THEN 
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_NUMERIC_VARIABLE' 
 IN TYPEOF(va))  
	THEN  
		RETURN(TRUE); 
	ELSE  
		RETURN(FALSE); 
	END_IF; 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF (expr)) 
 
THEN 
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_NUMERIC_VARIABLE' 
 IN TYPEOF(va)) 
	THEN  
		RETURN(TRUE); 
	ELSE  
		RETURN(FALSE); 
	END_IF; 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF (expr))  
THEN 
	IF('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_VARIABLE' 
 IN TYPEOF(va))  
	THEN 
		RETURN(TRUE); 
	ELSE 
		RETURN(FALSE);  
	END_IF; 
END_IF; 
 
IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_EXPRESSION'  
IN TYPEOF (expr)) 
THEN 
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VARIABLE' 
 IN TYPEOF(va))  
 
	THEN 
		RETURN(TRUE); 
	ELSE 
		RETURN(FALSE);  
	END_IF; 
END_IF; 
-- all simple types have been considered 
RETURN(UNKNOWN); 
END_FUNCTION; 	-- compatible_variable_and_expression 


 FUNCTION compatible_column_and_variable_semantics(col : column;sem :
                                                   variable_semantics) : LOGICAL
                                                   ;
  LOCAL
   va : SET OF generic_variable;
  END_LOCAL;
  va := syntax_of(sem);
  IF SIZEOF(va) = 0
   THEN
    RETURN (UNKNOWN);
   ELSE
    REPEAT i := LOINDEX(va) TO HIINDEX(va);
     IF (NOT compatible_column_and_variable(col,va[i]))
      THEN
       RETURN (FALSE);
     END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
 END_FUNCTION;
-- compatible_column_and_variable_semantics 

 FUNCTION used_table_literals(arg : generic_expression) : SET OF
                              table_identification;
  LOCAL
   result : SET OF table_identification := [];
  END_LOCAL;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TABLE_LITERAL' IN TYPEOF(arg)
   THEN
    RETURN ([arg\table_literal.the_value]);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNARY_GENERIC_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (used_table_literals(arg\unary_generic_expression.operand));
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_GENERIC_EXPRESSION' IN TYPEOF(arg)
   THEN
    RETURN (used_table_literals(arg\binary_generic_expression.operands[1]) + 
     used_table_literals(arg\binary_generic_expression.operands[2]));
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF
     (arg)
   THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_generic_expression.operands);
     result := result + used_table_literals(arg\
               multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  RETURN ([]);
 END_FUNCTION;
-- used_table_literals

 FUNCTION semantics_of(vars : generic_variable) : variable_semantics;
  RETURN (vars.interpretation.semantics);
 END_FUNCTION;
-- semantics_of 

 FUNCTION diff_columns(l1,l2 : LIST[1:?] OF variable_semantics) : LIST[1:?] OF
                       variable_semantics;
  REPEAT i := 1 TO SIZEOF(l2);
   IF l2[i] IN l1
    THEN
     ;
    ELSE
     l1 := l1 + l2[i];
   END_IF;
  END_REPEAT;
  RETURN (l1);
 END_FUNCTION;
-- diff_columns



FUNCTION compatible_subclass (c1, c2: class_BSU): LOGICAL;

IF (NOT EXISTS(c1)) OR (NOT EXISTS(c2))
THEN
	RETURN(UNKNOWN); -- c1 or c2 indeterminate
END_IF;

IF c1 = c2
THEN
	RETURN (TRUE);
END_IF;

IF((c1.code = c2.code) AND (c1.version >= c2.version)
		AND (c1.defined_by.code = c2.defined_by.code))
THEN
	RETURN (TRUE);
END_IF;

IF SIZEOF (c2.definition) = 0
THEN
	RETURN(UNKNOWN);
ELSE
	IF EXISTS(c2.definition[1]\class.its_superclass)
	THEN
		RETURN(compatible_subclass(c1, c2.definition[1]
			\class.its_superclass));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- compatible_subclass 




FUNCTION makes_sub_list(cla: LIST [1:?] OF class_BSU; 
			i, j: INTEGER): LIST [1:?] OF class_BSU; 
 
LOCAL 
	c: LIST [0:?] OF class_BSU:=[]; 
END_LOCAL; 
 
REPEAT k := i TO j;  
	c := c +cla[k]; 
END_REPEAT; 
 
RETURN(c); 
 
END_FUNCTION; -- makes_sub_list 

FUNCTION makes_reference_outside (
			p: AGGREGATE OF property_or_data_type_BSU;
			l: LIST[1:?] OF class_BSU): BOOLEAN;

LOCAL
	bool: BOOLEAN := FALSE;
	temp: SET[0:1] OF class_BSU;
END_LOCAL;

REPEAT j := 1 TO SIZEOF (p);
	IF ((('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
			IN TYPEOF (p[j]))
			AND (NOT (p[j]\property_BSU.name_scope IN l)))
		OR
			(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DATA_TYPE_BSU'
			IN TYPEOF (p[j]))
			AND (NOT (p[j]\data_type_BSU.name_scope IN l))))
	THEN
		bool := TRUE;
		RETURN(bool);
	END_IF;

	IF ((('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.PROPERTY_BSU'
			IN TYPEOF (p[j]))
			AND (NOT (SIZEOF(p[j]\basic_semantic_unit.definition)=0)))
		OR
			(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DATA_TYPE_BSU'
			IN TYPEOF (p[j]))
			AND (NOT (SIZEOF(p[j]\basic_semantic_unit.definition)=0))))
	THEN
		IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_TYPE' 
			IN data_type_typeof(p[j]))
		THEN
				temp := data_type_class_of(p[j]);
				IF  NOT (temp[1] IN l) 
				THEN 
					bool := bool OR TRUE ;
				ELSE 
					bool:= bool OR FALSE;
				END_IF;
		END_IF;
		IF SIZEOF (data_type_named_type (p[j])) = 1
		THEN
			bool := bool OR makes_reference_outside 
				(data_type_named_type(p[j]), l);
		END_IF;
	END_IF;
END_REPEAT;

RETURN (bool);
END_FUNCTION; -- makes_reference_outside 




FUNCTION visible_types (cl: class_BSU;
		typ: AGGREGATE OF data_type_BSU): LOGICAL;

LOCAL 
	ok: BOOLEAN:=TRUE;
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); 
END_IF;

REPEAT i:=1 TO SIZEOF(typ);
IF NOT(typ[i] IN compute_known_visible_data_types(cl)) 
	THEN ok:=FALSE; 
END_IF;
END_REPEAT;

IF NOT(ok) AND NOT(all_class_descriptions_reachable(cl)) 
	THEN RETURN(UNKNOWN);
END_IF;

IF NOT(ok) AND all_class_descriptions_reachable(cl)
	THEN RETURN(FALSE);
END_IF;

RETURN(TRUE);

END_FUNCTION; -- visible_types


 

FUNCTION applicable_types(
			cl: class_BSU;
			typ: AGGREGATE OF data_type_BSU): LOGICAL;

IF SIZEOF(typ) = 0
THEN
	RETURN(TRUE); 
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); 
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

typ := typ - cl.definition[1]\class.defined_types;

IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+ 
	'.A_PRIORI_SEMANTICS_RELATIONSHIP' 
	IN TYPEOF(cl.definition[1])) 
THEN
	typ := typ - 
		cl.definition[1]\a_priori_semantics_relationship
		.referenced_data_types;
END_IF;

IF SIZEOF(typ) = 0 
THEN
	RETURN(TRUE);
ELSE 
	IF EXISTS(cl.definition[1]\class.its_superclass) 
	THEN
		RETURN(applicable_types(cl.definition[1]
					\class.its_superclass, typ));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_types



FUNCTION exists_super (cl: class_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN (UNKNOWN); -- the class itself is indeterminate
END_IF;

IF (SIZEOF (cl.definition) = 0)
THEN
	RETURN (UNKNOWN);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN (TRUE);
	ELSE
		RETURN (FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- exists_super 



FUNCTION are_properties_not_in ( 
			opt_or_mand: AGGREGATE OF opt_or_mand_property_BSU; 
			prop: AGGREGATE OF property_BSU) 
			: BOOLEAN; 
 
IF (SIZEOF (QUERY (elt <* opt_or_mand| 
					(elt.property IN prop))) = 0)
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

 
END_FUNCTION; -- are_properties_not_in  




FUNCTION provided_properties_list (cl: class_BSU)
								: LIST OF property_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF NOT(all_class_descriptions_reachable(cl)) 
THEN 
	RETURN ([]); 	-- some dictionary_element are not available
ELSE
	RETURN (retrieve_provided_properties(cl, []));
END_IF;

END_FUNCTION; -- provided_properties_list 



FUNCTION super (cl: class_BSU): SET [0:1] OF class_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF (cl.definition) = 1)
THEN
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN ([cl.definition[1]\class.its_superclass]);
	END_IF;
END_IF;

RETURN ([]);

END_FUNCTION; -- super 




 FUNCTION selectable_properties_list(cl : class_bsu) : LIST OF property_bsu;
  LOCAL
   selec : LIST OF property_bsu := [];
--non redefined properties
   def : LIST OF property_bsu;
--selectable defined properties
   redef : SET OF property_bsu;
--derived redefined properties
  END_LOCAL;
  def := selectable_defined_properties(cl);
  redef := derived_redefined_properties(cl);
  REPEAT i := 1 TO SIZEOF(def);
   IF NOT (def[i] IN redef)
    THEN
     selec := selec + def[i];
   END_IF;
  END_REPEAT;
  RETURN (selec);
 END_FUNCTION;
-- selectable_properties_list 

 FUNCTION optional_properties_list(cl : class_bsu) : LIST OF property_bsu;
  LOCAL
   opt : LIST OF property_bsu := [];
-- non redefined properties
   def : LIST OF property_bsu;
-- optional defined properties
   redef : SET OF property_bsu;
-- mandatory redefined properties
  END_LOCAL;
  def := optional_defined_properties(cl);
  redef := mandatory_redefined_properties(cl);
  REPEAT i := 1 TO SIZEOF(def);
   IF NOT (def[i] IN redef)
    THEN
     opt := opt + def[i];
   END_IF;
  END_REPEAT;
  RETURN (opt);
 END_FUNCTION;
-- optional_properties_list 


FUNCTION applicable_tables (cl: class_BSU; 
			tab: AGGREGATE OF table_identification): LOGICAL;

IF SIZEOF(tab) = 0
THEN
	RETURN(TRUE); 
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); 
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

tab := tab - retrieve_tables (cl);

IF 
'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.A_PRIORI_SEMANTICS_RELATIONSHIP' 
	IN TYPEOF(cl.definition[1])
THEN
	tab:= tab-
cl.definition[1]\a_priori_semantics_relationship.referenced_tables;
END_IF;

IF SIZEOF(tab) = 0 
THEN
	RETURN(TRUE);
ELSE 
	IF EXISTS(cl.definition[1]\class.its_Superclass) 
	THEN
	RETURN(
		applicable_tables(cl.definition[1]\class.its_superclass, 
			tab));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_tables 



FUNCTION applicable_documents (cl: class_BSU;
			doc: AGGREGATE OF document_BSU): LOGICAL;

IF SIZEOF(doc) = 0 
THEN 
	RETURN(TRUE); 
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); 
END_IF;

IF SIZEOF(cl.definition) = 0 
THEN 
	RETURN(UNKNOWN);
END_IF;

doc := doc - retrieve_documents (cl);

IF 
'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.A_PRIORI_SEMANTICS_RELATIONSHIP' 
	IN TYPEOF(cl.definition[1])
THEN
	doc:= doc-
cl.definition[1]\a_priori_semantics_relationship.referenced_documents;
END_IF;

IF SIZEOF(doc) = 0 
THEN
	RETURN(TRUE);
ELSE 
	IF EXISTS(cl.definition[1]\class.its_superclass) 
	THEN 
		RETURN (applicable_documents(cl.definition[1]
		\class.its_superclass, doc));
	ELSE 
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_documents 

 FUNCTION acyclic_class_extension_definition(cl : class_bsu) : LOGICAL;
  LOCAL
   edges : SET OF domain_restriction;
   prop : LIST OF property_bsu;
   END_LOCAL;
  IF NOT all_class_descriptions_reachable(cl)
   THEN
    RETURN (UNKNOWN);
   ELSE
    prop := provided_properties_list(cl);
    edges := defined_domain(cl) + defined_derivation_function(cl);
    REPEAT i := LOINDEX(prop) TO HIINDEX(prop);
     IF NOT acyclic_order(prop[i],edges,[])
      THEN
       RETURN (FALSE);
     END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
 END_FUNCTION;
-- acyclic_class_extension_definition 

FUNCTION required_defined_properties (cl: class_BSU)
			: LIST OF property_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF NOT(all_class_descriptions_reachable(cl))
THEN
	RETURN ([]); 	-- some dictionary_element are not available
ELSE
	RETURN (retrieve_required_properties(cl, []));
END_IF;

END_FUNCTION; 
-- required_defined_properties


FUNCTION retrieve_required_properties (cl: class_BSU;
			pr: LIST OF property_BSU)
			: LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := pr;	-- end of the list
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF SIZEOF(cl.definition) = 0 		-- anormal case
THEN
	RETURN([]);
END_IF;

IF SIZEOF(cl.referenced_by) = 1 	-- new properties defined at this
 							--level
THEN
	REPEAT i := SIZEOF (cl.referenced_by[1]
			\model_class_extension.required_properties)
			TO 1 BY -1;
		prop := cl.referenced_by[1]
			 \model_class_extension.required_properties[i].property
			+ prop;	-- required properties of this class
	END_REPEAT;
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass))
THEN
	RETURN (prop);
ELSE
	RETURN (retrieve_required_properties(
			cl.definition[1]\class.its_superclass,
						prop));
END_IF;

END_FUNCTION; 
-- retrieve_required_properties

FUNCTION derived_properties_list(cl : class_bsu) : LIST OF property_bsu;

LOCAL
	deriv: LIST OF property_BSU := [];	--derived properties
	prov: LIST OF property_BSU;			--provided properties
	selec: LIST OF property_BSU;		--selectable properties
	req: LIST OF property_BSU;          --required properties
END_LOCAL;

prov := provided_properties_list (cl);
selec := selectable_properties_list (cl);
req := required_defined_properties (cl);

REPEAT i := 1 TO SIZEOF (prov);
	IF NOT(prov[i] IN selec) AND NOT (prov[i] IN req)
	THEN
		deriv := deriv + prov[i];
	END_IF;
END_REPEAT;

RETURN (deriv);

END_FUNCTION; 
-- derived_properties_list


FUNCTION defined_derivation_function (cl: class_BSU)
			: SET OF functional_domain_restriction;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF NOT(all_class_descriptions_reachable(cl)) 
THEN 
	RETURN ([]); 	-- some dictionary_element are not available
ELSE
	RETURN (retrieve_derivation_function(cl, []));
END_IF;

END_FUNCTION; -- defined_derivation_function 



 FUNCTION derive_dimensional_exponents(x : unit) : dimensional_exponents;
  LOCAL
   i : INTEGER;
   result : dimensional_exponents := dimensional_exponents(0.0,0.0,0.0,0.0,0.0,
   0.0,0.0);
  END_LOCAL;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DERIVED_UNIT' IN TYPEOF(x)
   THEN
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
     result.length_exponent := result.length_exponent + (x.elements[i].exponent
                                * x.elements[i].unit.dimensions.length_exponent
                               );
     result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x
                             .elements[i].unit.dimensions.mass_exponent);
     result.time_exponent := result.time_exponent + (x.elements[i].exponent * x
                             .elements[i].unit.dimensions.time_exponent);
     result.electric_current_exponent := result.electric_current_exponent + (x.
                                         elements[i].exponent * x.elements[i].
                                         unit.dimensions.
                                         electric_current_exponent);
     result.thermodynamic_temperature_exponent := result.
     thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[
                                                  i].unit.dimensions.
     thermodynamic_temperature_exponent);
     result.amount_of_substance_exponent := result.amount_of_substance_exponent
                                             + (x.elements[i].exponent * x.
                                            elements[i].unit.dimensions.
                                            amount_of_substance_exponent);
     result.luminous_intensity_exponent := result.luminous_intensity_exponent +
                                            (x.elements[i].exponent * x.
                                           elements[i].unit.dimensions.
                                           luminous_intensity_exponent);
    END_REPEAT;
-- x is a unitless or a named unit
   ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);
 END_FUNCTION;

 FUNCTION dimension_of(item : geometric_representation_item) : dimension_count;
  LOCAL
   x : SET OF representation;
   y : representation_context;
  END_LOCAL;
-- Find the set of representation in which the item is used. 
  x := using_representations(item);
-- Determines the dimension_count of the 
-- geometric_representation_context. Note that the 
-- RULE compatible_dimension ensures that the context_of_items
-- is of type geometric_representation_context and has
-- the same dimension_count for all values of x.
  y := x[1].context_of_items;
  RETURN (y\geometric_representation_context.coordinate_space_dimension);
 END_FUNCTION;

 FUNCTION orthogonal_complement(vec : direction) : direction;

  LOCAL

    result :  direction ;

  END_LOCAL;



  IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN

    RETURN(?);

  ELSE

    result := dummy_gri || direction([-vec.direction_ratios[2], vec.direction_ratios[1]]);

    RETURN(result);

  END_IF;

END_FUNCTION;

FUNCTION first_proj_axis(z_axis, arg : direction) : direction;

  LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;

  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF (z.direction_ratios <> [1.0,0.0,0.0]) THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;

 FUNCTION bag_to_set(the_bag : BAG OF GENERIC : intype) : SET OF GENERIC :
                     intype;
  LOCAL
   the_set : SET OF GENERIC : intype := [];

  END_LOCAL;
  IF SIZEOF(the_bag) > 0
   THEN
    REPEAT i := 1 TO HIINDEX(the_bag);
     the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;
  RETURN (the_set);
 END_FUNCTION;





FUNCTION superclass_of_item_is_item (
		 cl : item_class) : LOGICAL;
		
		IF NOT EXISTS (cl\class.its_superclass)
		THEN
			RETURN (TRUE);
		END_IF;
		
		IF SIZEOF (cl\class.its_superclass.definition) = 0
		THEN
			RETURN (UNKNOWN);
		END_IF;

		RETURN (
		('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS')
		IN TYPEOF (cl\class.its_superclass.definition[1]));
END_FUNCTION;	-- superclass_of_item_is_item




 FUNCTION acyclic(arg1 : generic_expression;arg2 : SET OF generic_expression) :
                  BOOLEAN;
  LOCAL
   result : BOOLEAN;
  END_LOCAL;
  IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.SIMPLE_GENERIC_EXPRESSION' IN TYPEOF(arg1))
   THEN
    RETURN (TRUE);
  END_IF;
  IF arg1 IN arg2
   THEN
    RETURN (FALSE);
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.UNARY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
   THEN
    RETURN (acyclic(arg1\unary_generic_expression.operand,arg2 + [arg1]));
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BINARY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
   THEN
    RETURN (acyclic(arg1\binary_generic_expression.operands[1],arg2 + [arg1]) 
     AND acyclic(arg1\binary_generic_expression.operands[2],arg2 + [arg1]));
  END_IF;
  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF
     (arg1)
   THEN
    result := TRUE;
    REPEAT i := 1 TO SIZEOF(arg1\multiple_arity_generic_expression.operands);
     result := result AND acyclic(arg1\multiple_arity_generic_expression.
               operands[i],arg2 + [arg1]);
    END_REPEAT;
    RETURN (result);
  END_IF;
 END_FUNCTION;
-- acyclic



FUNCTION free_defined_characteristics (cl: class_BSU)
			: LIST OF property_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF NOT(all_class_descriptions_reachable(cl)) 
THEN 
	RETURN ([]); 	-- some dictionary_element are not available
ELSE
	RETURN (retrieve_gm_free_characteristics(cl, []));
END_IF;

END_FUNCTION; -- free_defined_characteristics 



 FUNCTION derived_redefined_properties(cl : class_bsu) : SET OF property_bsu;
  IF NOT (all_class_descriptions_reachable(cl))
   THEN
    RETURN ([]);
-- some dictionary_element are not available
   ELSE
    RETURN (retrieve_derived_redefined_properties(cl,[]));
  END_IF;
 END_FUNCTION;
-- derived_redefined_properties 

FUNCTION compatible_column_and_variable (col: column;
		v: generic_variable)
		: LOGICAL;

(* The following express statements deal with simple types *)

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(v) 
THEN
	RETURN (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_COLUMN' 
		IN TYPEOF (col)) OR
		(('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_COLUMN'
		 IN TYPEOF (col)) 
		AND NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_COLUMN' 
		IN TYPEOF (col))));
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(v) 
THEN
	RETURN (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REAL_COLUMN' 
		IN TYPEOF (col)) 
		OR (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.NUMBER_COLUMN' 
		IN TYPEOF (col)) 
		AND NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.INTEGER_COLUMN' 
		IN TYPEOF (col))));
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_VARIABLE' IN TYPEOF(v) 
THEN
	RETURN ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.BOOLEAN_COLUMN' 
	IN TYPEOF (col));
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_VARIABLE' IN TYPEOF(v) 
THEN
	RETURN ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STRING_COLUMN'
	IN TYPEOF (col));
END_IF;

(* The following express statements deal with complex types *)

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_VARIABLE' IN 
	TYPEOF(v) 
THEN
	RETURN (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ENTITY_INSTANCE_COLUMN'
		IN TYPEOF (col))
		AND (v\entity_instance_expression.type_name
<= col\entity_instance_column.type_name));
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_VARIABLE' IN 
	TYPEOF(v) 
THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_INSTANCE_COLUMN' 
		IN TYPEOF (col))
	THEN 
		RETURN (compatible_class_and_class
			(v\class_instance_expression.expr_type, 
			col\class_instance_column.class_ref));
	ELSE 
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_VARIABLE'
 IN TYPEOF(v) THEN
	IF ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LEVEL_SPEC_COLUMN'
		IN TYPEOF (col))
	THEN 
		IF list_to_set(v\level_spec_expression.levels)
			 = list_to_set(col\level_spec_column.levels)
		THEN
			IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+'.INT_LEVEL_SPEC_VARIABLE' IN TYPEOF(v)) 
				AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+ 
				'.INT_LEVEL_SPEC_COLUMN' IN TYPEOF(col)))
			THEN
				RETURN (FALSE);
			END_IF;
			IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
				+'.REAL_LEVEL_SPEC_VARIABLE' IN TYPEOF(v)) 
				AND NOT('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+ 
				'.REAL_LEVEL_SPEC_COLUMN' IN TYPEOF(col)))
			THEN
				RETURN (FALSE);
			END_IF;
			RETURN (TRUE);
		ELSE
			RETURN (FALSE);
		END_IF;
	ELSE 
		RETURN (FALSE);
	END_IF;
END_IF;

RETURN (FALSE);

END_FUNCTION; -- compatible_column_and_variable 


FUNCTION retrieve_provided_properties (cl: class_BSU;
							pr: LIST OF property_BSU)
								: LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := pr;	--end of the list
END_LOCAL;


IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF SIZEOF(cl.definition) = 0 		-- anormal case
THEN
	RETURN([]);
END_IF;

IF SIZEOF(cl.referenced_by) = 1 	-- new properties defined at this 
							-- level
THEN 
	REPEAT i := SIZEOF (cl.referenced_by[1] 
		\model_class_extension.derived_properties) TO 1 BY -1;
		prop := cl.referenced_by[1] 
		\model_class_extension.derived_properties[i].property+prop;
	END_REPEAT;		-- derived properties of this class

	REPEAT i := SIZEOF (cl.referenced_by[1] 
			\model_class_extension.required_properties) TO 1 BY -1;
		prop := cl.referenced_by[1] 
			\model_class_extension.required_properties[i].property
			+ prop;	-- required properties of this class
	END_REPEAT;

	REPEAT i := SIZEOF (cl.referenced_by[1] 
		\model_class_extension.selectable_properties) TO 1 BY -1;
		prop := cl.referenced_by[1] 
			\model_class_extension.selectable_properties[i].property
			+ prop;	-- selectable properties of this class
	END_REPEAT;
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass)) 
THEN 
	RETURN (prop);
ELSE
	RETURN (retrieve_provided_properties(
			cl.definition[1]\class.its_superclass,prop));
END_IF;

END_FUNCTION; -- retrieve_provided_properties 




FUNCTION selectable_defined_properties (cl: class_BSU)
			: LIST OF property_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF NOT (all_class_descriptions_reachable(cl)) 
THEN 
	RETURN ([]); 	-- some dictionary_element are not available
ELSE
	RETURN (retrieve_selectable_properties(cl, []));
END_IF;

END_FUNCTION; -- selectable_defined_properties 




FUNCTION optional_defined_properties (cl: class_BSU)
								: LIST OF property_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF NOT (all_class_descriptions_reachable(cl)) 
THEN 
	RETURN ([]); 	-- some dictionary_element are not available
ELSE
	RETURN (retrieve_optional_properties(cl, []));
END_IF;

END_FUNCTION; -- optional_defined_properties 


FUNCTION mandatory_redefined_properties (cl: class_BSU)
			: SET OF property_BSU;


IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF NOT(all_class_descriptions_reachable(cl)) 
THEN 
	RETURN ([]); 	-- some dictionary_element are not available
ELSE
	RETURN (retrieve_mandatory_redefined_properties(cl, []));
END_IF;

END_FUNCTION; -- mandatory_redefined_properties 




FUNCTION retrieve_tables (cl: class_BSU): SET[0:?] OF table_BSU;
-- requires: { SIZEOF (cl.definition) <> O } 
 
LOCAL  

	s: SET[0:?] OF table_BSU; 
END_LOCAL; 
 
s := []; 
REPEAT i:= 1 TO SIZEOF(cl.definition[1]\class.associated_items); 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'
						+'.CLASS_TABLE_RELATIONSHIP'  
		IN TYPEOF(cl.definition[1]\class.associated_items[i]) 
	THEN  
		s := s + cl.definition[1]\class.associated_items[i] 
		\class_table_relationship.related_tokens; 
	END_IF; 
END_REPEAT; 
RETURN(s); 
 
END_FUNCTION; -- retrieve_tables  

FUNCTION retrieve_documents (cl: class_BSU): SET[0:?] OF document_BSU;
-- requires: { SIZEOF (cl.definition) <> O } 
 
LOCAL

	s: SET[0:?] OF document_BSU; 
END_LOCAL; 
 
s := []; 
REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.associated_items); 
	IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA'+ 
						'.CLASS_DOCUMENT_RELATIONSHIP'  
		IN TYPEOF(cl.definition[1]\class.associated_items[i]) 
	THEN  
		s := s+ cl.definition[1]\class.associated_items[i] 
		\class_document_relationship.related_tokens; 
	END_IF; 
END_REPEAT; 
 
RETURN(s); 
 
END_FUNCTION; -- retrieve_documents  




FUNCTION defined_domain (cl: class_BSU): SET OF domain_restriction;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF NOT (all_class_descriptions_reachable(cl)) 
THEN
	RETURN ([]); -- some dictionary_element are not available
ELSE
	RETURN (retrieve_domain(cl, []));
END_IF;

END_FUNCTION; -- defined_domain 



FUNCTION acyclic_order(p : property_bsu;edges : SET OF domain_restriction;
                        nodes : SET OF property_bsu) : BOOLEAN;
  LOCAL
   succ : SET OF property_bsu;
-- set of property_BSU that depends (recursively) on p
   out_edges : SET OF domain_restriction;
-- set of domain_restrictions that contain one of the 
-- property_BSU of the set nodes in the the_property attribute
-- of one of their assumes variable_semantics

  END_LOCAL;
  out_edges := QUERY(e <* edges | (QUERY(v <* e.assumes | v\property_semantics.
               the_property IN nodes) <> []));
  succ := [];
  REPEAT i := LOINDEX(out_edges) TO HIINDEX(out_edges);
   REPEAT j := LOINDEX(out_edges[i].defines) TO HIINDEX(out_edges[i].defines);
    succ := succ + out_edges[i].defines[j]\property_semantics.the_property;
   END_REPEAT;
  END_REPEAT;
-- p depends on itself:
  IF p IN succ
   THEN
    RETURN (FALSE);
  END_IF;
-- all the depending properties are reached
  IF succ <= nodes
   THEN
    RETURN (TRUE);
  END_IF;
  RETURN (acyclic_order(p,edges,nodes + succ));
 END_FUNCTION;
-- acyclic_order


FUNCTION retrieve_derivation_function (cl: class_BSU;
					d: SET OF functional_domain_restriction)
					: SET OF functional_domain_restriction;

LOCAL

	der: SET OF functional_domain_restriction := d; -- existing set
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;


IF SIZEOF(cl.definition)=0 -- anormal case
THEN 
	RETURN([]);
END_IF;

IF SIZEOF(cl.referenced_by) = 1 	-- new derivation_function defined at 
 							-- this level
THEN 
	REPEAT i := 1 TO SIZEOF (cl.referenced_by[1] 
			\model_class_extension.derivation);
		der := der + cl.referenced_by[1] 
			 \model_class_extension.derivation[i];
				-- derivation_function of this class
	END_REPEAT;
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass)) 
THEN 
	RETURN (der);
ELSE
	RETURN (retrieve_derivation_function(
			cl.definition[1]\class.its_superclass, der));
END_IF;

END_FUNCTION; -- retrieve_derivation_function 

FUNCTION scalar_times_vector (scalar : REAL; vec : vector_or_direction)

                                     : vector;

  LOCAL

    v      : direction;

    mag    : REAL;

    result : vector;

  END_LOCAL;



  IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN

    RETURN (?) ;

   ELSE

    IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF (vec) THEN

      v   := dummy_gri || direction(vec.orientation.direction_ratios);

      mag := scalar * vec.magnitude;

    ELSE

      v   := dummy_gri || direction(vec.direction_ratios);

      mag := scalar;

    END_IF;

    IF (mag < 0.0 ) THEN

      REPEAT i := 1 TO SIZEOF(v.direction_ratios);

        v.direction_ratios[i] := -v.direction_ratios[i];

      END_REPEAT;

      mag := -mag;

    END_IF;

    result := dummy_gri || vector(normalise(v), mag);

  END_IF;

  RETURN (result);

END_FUNCTION;

 FUNCTION dot_product(arg1,arg2 : direction) : REAL;
  LOCAL
   scalar : REAL;
   vec1,vec2 : direction;
   ndim : INTEGER;
  END_LOCAL;
  IF NOT EXISTS(arg1) OR NOT EXISTS(arg2)
   THEN
    scalar := ?;
   ELSE
    IF (arg1.dim <> arg2.dim)
     THEN
      scalar := ?;
     ELSE
      BEGIN
       vec1 := normalise(arg1);
       vec2 := normalise(arg2);
       ndim := arg1.dim;
       scalar := 0.0;
       REPEAT i := 1 TO ndim;
        scalar := scalar + vec1.direction_ratios[i] * vec2.direction_ratios[i];
       END_REPEAT;
      END;
    END_IF;
  END_IF;
  RETURN (scalar);
 END_FUNCTION;

FUNCTION vector_difference(arg1, arg2 : vector_or_direction) : vector;

  LOCAL

    result          : vector;

    res, vec1, vec2 : direction;

    mag, mag1, mag2 : REAL;

    ndim            : INTEGER;

  END_LOCAL;



  IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)

      THEN

    RETURN (?) ;

   ELSE

    BEGIN

      IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN

        mag1 := arg1.magnitude;

        vec1 := arg1.orientation;

      ELSE

        mag1 := 1.0;

        vec1 := arg1;

      END_IF;

      IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN

        mag2 := arg2.magnitude;

        vec2 := arg2.orientation;

      ELSE

        mag2 := 1.0;

        vec2 := arg2;

      END_IF;

      vec1 := normalise (vec1);

      vec2 := normalise (vec2);

      ndim := SIZEOF(vec1.direction_ratios);

      mag := 0.0;

      res := dummy_gri || direction(vec1.direction_ratios);

      REPEAT i := 1 TO ndim;

        res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +

                                    mag2*vec2.direction_ratios[i];

        mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);

      END_REPEAT;

      IF (mag > 0.0 ) THEN

      result := dummy_gri || vector( res, SQRT(mag));

      ELSE

        result := dummy_gri || vector( vec1,  0.0);

      END_IF;

    END;

  END_IF;

  RETURN (result);

END_FUNCTION;



FUNCTION no_extension_for_superclass (
		 cl : class_extension) : LOGICAL;
		
		IF SIZEOF (
		cl\content_item.dictionary_definition.definition) = 0
		THEN
			RETURN (UNKNOWN);
		END_IF;

		RETURN (
		cl\content_item.dictionary_definition.definition[1]
		\class.subclasses=[]);
END_FUNCTION;	-- no_extension_for_superclass






FUNCTION retrieve_gm_free_characteristics (cl: class_BSU;
			pr: LIST OF property_BSU)
			: LIST OF property_BSU;

LOCAL

	prop: LIST OF property_BSU := pr;	--end of the list
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF SIZEOF(cl.definition) = 0 		-- anormal case
THEN
	RETURN([]);
END_IF;

IF SIZEOF(cl.referenced_by) = 1 	-- new properties defined at this
 							-- level
THEN 
	IF NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ITEM_CLASS_EXTENSION'
			IN TYPEOF(cl.referenced_by[1])) -- anormal case
	THEN
		RETURN([]);				-- anormal case
	END_IF;

	REPEAT i := SIZEOF (cl.referenced_by[1] 
			\item_class_extension.free_characteristics) TO 1 BY -1;
		prop := cl.referenced_by[1] 
			\item_class_extension.free_characteristics[i].property
			+ prop;	-- free characteristics of this class
	END_REPEAT;
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass)) 
THEN 
	RETURN (prop);
ELSE
	RETURN (retrieve_gm_free_characteristics(
			cl.definition[1]\class.its_superclass, prop));
END_IF;

END_FUNCTION; -- retrieve_gm_free_characteristics 




FUNCTION retrieve_derived_redefined_properties (cl: class_BSU;
			pr:SET OF property_BSU)
			: SET OF property_BSU;

LOCAL
	prop: SET OF property_BSU := pr;	-- already computed set
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF SIZEOF(cl.definition) = 0 		-- anormal case
THEN
	RETURN([]);
END_IF;

IF SIZEOF(cl.referenced_by) = 1 	-- new properties redefined at 
							-- this level
THEN 
	prop := prop + cl.referenced_by[1] 
		\model_class_extension.new_derived_prop;
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass)) 
THEN 
	RETURN (prop);
ELSE
	RETURN (retrieve_derived_redefined_properties(
		 cl.definition[1]\class.its_superclass, prop));
END_IF;

END_FUNCTION; -- retrieve_derived_redefined_properties 



FUNCTION retrieve_selectable_properties (cl: class_BSU;
			pr: LIST OF property_BSU)
			: LIST OF property_BSU;

LOCAL

	prop: LIST OF property_BSU := pr;	-- end of the list
END_LOCAL;


IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF SIZEOF(cl.definition) = 0 		-- anormal case
	THEN RETURN([]);
END_IF;

IF SIZEOF(cl.referenced_by) = 1 	-- new properties defined at this
 						--level
THEN 
	REPEAT i := SIZEOF (cl.referenced_by[1] 
			\model_class_extension.selectable_properties)
			TO 1 BY -1;
		prop := cl.referenced_by[1] 
			\model_class_extension.selectable_properties[i].property
			+ prop;	-- selectable properties of this class
	END_REPEAT;
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass)) 
THEN 
	RETURN (prop);
ELSE
	RETURN (retrieve_selectable_properties(
			cl.definition[1]\class.its_superclass, prop));
END_IF;

END_FUNCTION; -- retrieve_selectable_properties 



FUNCTION retrieve_optional_properties (cl: class_BSU;
			pr: LIST OF property_BSU)
			: LIST OF property_BSU;

LOCAL

	prop: LIST OF property_BSU := pr;	-- end of the list
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF SIZEOF(cl.definition) = 0 		-- anormal case
THEN
	RETURN([]);
END_IF;

IF SIZEOF(cl.referenced_by) = 1 	-- new properties defined at this
 							-- level
THEN 
	REPEAT i := SIZEOF (cl.referenced_by[1] 
			\model_class_extension.derived_properties)
			TO 1 BY -1;
		IF (cl.referenced_by[1] 
		
	\model_class_extension.derived_properties[i].is_optional)
		THEN
			prop := cl.referenced_by[1] 
			\model_class_extension.derived_properties[i].property
			 + prop;
		END_IF;
	END_REPEAT;		-- derived optional properties of this class

	REPEAT i := SIZEOF (cl.referenced_by[1] 
			\model_class_extension.selectable_properties) TO 1 BY -
1;
		IF (cl.referenced_by[1] 
		\model_class_extension.selectable_properties[i].is_optional)
		THEN
			prop := cl.referenced_by[1] 
			\model_class_extension.selectable_properties[i].property
			+ prop;		--selectable optional properties 	
		END_IF;
	END_REPEAT;
END_IF;

IF NOT (EXISTS(cl.definition[1]\class.its_superclass)) 
THEN 
	RETURN (prop);
ELSE
	RETURN (retrieve_optional_properties(
			cl.definition[1]\class.its_superclass,prop));
END_IF;

END_FUNCTION; -- retrieve_optional_properties 



FUNCTION retrieve_mandatory_redefined_properties (
			cl: class_BSU;
			pr: SET OF property_BSU)
			: SET OF property_BSU;

LOCAL
	prop: SET OF property_BSU := pr;	--already computed set	
END_LOCAL;


IF NOT EXISTS(cl)
THEN
	RETURN ([]); -- the class itself is indeterminate
END_IF;

IF SIZEOF(cl.definition) = 0 		-- anormal case
THEN
	RETURN([]);
END_IF;

IF SIZEOF(cl.referenced_by) = 1 	-- new properties redefined at this
 							--level
THEN 
	prop := prop + cl.referenced_by[1] 
				\model_class_extension.new_mandatory_prop;
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass)) 
THEN 
	RETURN (prop);
ELSE
	RETURN (retrieve_mandatory_redefined_properties(
				cl.definition[1]\class.its_superclass, prop));
END_IF;

END_FUNCTION; -- retrieve_mandatory_redefined_properties 



 FUNCTION retrieve_domain(cl : class_bsu;d : SET OF domain_restriction) : SET OF
                          domain_restriction;
  LOCAL

   dom : SET OF domain_restriction := d;
-- existing set
  END_LOCAL;
  IF SIZEOF(cl.definition) = 0
   THEN
    RETURN ([]);
  END_IF;
  IF SIZEOF(cl.referenced_by) = 1
   THEN
    REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]\model_class_extension.
           class_extension);
     dom := dom + cl.referenced_by[1]\model_class_extension.class_extension[i];
-- domain of this class
    END_REPEAT;
  END_IF;
  IF NOT (EXISTS(cl.definition[1]\class.its_superclass))
   THEN
    RETURN (dom);
   ELSE
    RETURN (retrieve_domain(cl.definition[1]\class.its_superclass,dom));
  END_IF;
 END_FUNCTION;
-- retrieve_domain 

FUNCTION sub_list_until(cla: LIST [1:?] OF class_BSU;
			cl: class_BSU): LIST [1:?] OF class_BSU; 
 
LOCAL 

	c: LIST [0:?] OF class_BSU := []; 
END_LOCAL; 
 
REPEAT k := 1 TO SIZEOF(cla); 
	c := c + cla[k]; 
	IF cla[k] :=: cl
	THEN 
		ESCAPE; 
	END_IF; 
END_REPEAT; 
 
RETURN(c); 
 
END_FUNCTION; -- sub_list_until

 FUNCTION item_in_context(item : representation_item;cntxt :
                          representation_context) : BOOLEAN;
  LOCAL
    
    y : BAG OF representation_item;
  END_LOCAL;
-- If there is one or more representation using both the item 
-- and cntxt return true.
  IF SIZEOF(USEDIN(item,'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION.ITEMS') * 
     cntxt.representations_in_context) > 0
   THEN
    RETURN (TRUE);
-- Determine the bag of representation_items that reference
-- item.
   ELSE
    y := QUERY(z <* USEDIN(item,'') | 
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
-- Ensure that the set is not empty.
    IF SIZEOF(y) > 0
     THEN
      REPEAT i := 1 TO HIINDEX(y);
       IF item_in_context(y[i],cntxt)
        THEN
         RETURN (TRUE);
       END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
-- Return false when all possible branches have been checked
-- with no success.
  RETURN (FALSE);
 END_FUNCTION;

 RULE single_language_assignment FOR (global_language_assignment);
  WHERE
   SIZEOF(global_language_assignment) <= 1;
 END_RULE;

 RULE no_forward_reference_from_table_rule FOR (dictionary,table_element);
  WHERE
   wr1 : QUERY(dic <* dictionary | QUERY(tab <* table_element | 
         makes_reference_outside(get_property_bsu_from_property_semantics(tab\
         table_specification.column_meaning),sub_list_until(dic.
         contained_classes,tab\table_specification.table_identifier\table_bsu.
         name_scope))) <> []) = [];
 END_RULE;
-- no_forward_reference_from_table_rule

 RULE assert_oneof_for_table FOR (table_element);
  WHERE
   wr1 : QUERY(temp <* table_element | NOT (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_ELEMENT' IN TYPEOF
         (temp)) AND ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.RDB_TABLE_SPECIFICATION' IN
          TYPEOF(temp))) = [];
 END_RULE;
-- assert_oneof_for_table 

 RULE assert_oneof_for_library FOR (library);
  WHERE
   wr1 : QUERY(temp <* library | NOT ('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.LIBRARY_IN_STANDARD_FORMAT' IN TYPEOF(temp)) AND (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.DICTIONARY_IN_STANDARD_FORMAT' IN TYPEOF(temp))) = [];
 END_RULE;
-- assert_oneof_for_library

 RULE unique_http_directory_name_per_supplier_rule FOR (http_class_directory);
  WHERE
   wr1 : QUERY(dir_1 <* http_class_directory | QUERY(dir_2 <*
         http_class_directory | (dir_1.name = dir_2.name) AND (dir_1.class.
         defined_by = dir_2.class.defined_by)) <> [dir_1]) = [];
 END_RULE;
-- unique_http_directory_name_per_supplier_rule

 RULE http_directory_refers_to_bsu_related_class_rule FOR (http_file,
      class_bsu_related_content);
  WHERE
   wr1 : QUERY(http_f <* http_file | ((
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_BSU_RELATED_CONTENT' IN TYPEOF(
         http_f\external_file_unit.unit_of.content_of.content_of)) AND (http_f.
         http_directory.class <> http_f\external_file_unit.unit_of.content_of.
         content_of\content_item.dictionary_definition))) = [];
 END_RULE;
-- http_directory_refers_to_bsu_related_class_rule

 RULE http_directory_refers_to_class_extension_rule FOR (http_file,
      class_extension_external_item);
  WHERE
   wr1 : QUERY(http_f <* http_file | (
         'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.CLASS_EXTENSION_EXTERNAL_ITEM' IN TYPEOF
         (http_f\external_file_unit.unit_of.content_of.content_of)) AND (http_f
         .http_directory.class <> http_f\external_file_unit.unit_of.content_of.
         content_of\class_extension_external_item.belongs_to\content_item.
         dictionary_definition)) = [];
 END_RULE;
-- http_directory_refers_to_class_extension_rule 

 RULE unambiguous_not_translated_content_rule FOR (
      not_translated_external_content,global_language_assignment);
  WHERE
   wr1 : (SIZEOF(not_translated_external_content) = 0) OR (SIZEOF(
         global_language_assignment) = 1);
 END_RULE;
-- unambiguous_not_translated_content_rule

 RULE compatible_dimension FOR (cartesian_point,direction,
                                representation_context,
                                geometric_representation_context);
  WHERE
   wr1 : SIZEOF(QUERY(x <* cartesian_point | SIZEOF(QUERY(y <*
         geometric_representation_context | item_in_context(x,y) AND (HIINDEX(x
         .coordinates) <> y.coordinate_space_dimension))) > 0)) = 0;
   wr2 : SIZEOF(QUERY(x <* direction | SIZEOF(QUERY(y <*
         geometric_representation_context | item_in_context(x,y) AND (HIINDEX(x
         .direction_ratios) <> y.coordinate_space_dimension))) > 0)) = 0;
 END_RULE;
-- compatible_dimension

 RULE no_content_without_DET_rule FOR (basic_semantic_unit);
  WHERE
   wr1 : QUERY (bsu <* basic_semantic_unit |(SIZEOF (bsu.referenced_by) = 1)
         AND (SIZEOF (bsu.definition) = 0)) = [];
 END_RULE;
-- no_content_without_DET_rule


RULE illustration_is_not_a_referenced_graphics_rule FOR
	(graphics );
WHERE
WR1: QUERY (icon <* graphics|
	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.REFERENCED_GRAPHICS'
	IN TYPEOF( icon))
	AND
	('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.ILLUSTRATION'
	IN TYPEOF( icon)))
	= [];
END_RULE; -- illustration_is_not_a_referenced_graphics_rule

RULE imported_documents_are_visible_or_applicable_rule FOR (
		a_priori_semantics_relationship, document_element);
WHERE
	WR1: QUERY (rel <* a_priori_semantics_relationship  
		| QUERY ( doc <* rel.referenced_documents
		| QUERY ( cl <* rel.referenced_classes
		| NOT visible_documents (cl, [doc])
		AND NOT applicable_documents (cl, [doc])) 
		= rel.referenced_classes) <> [] ) 
	 = [];
END_RULE; -- imported_documents_are_visible_or_applicable_rule



(* Standard data requirements for the library integrated information model 24-1 *)

RULE allowed_reference_to_LIIM_24_1_rule FOR (
	library_iim_id);
 WHERE
 WR1: QUERY( liim_id <* library_iim_id |
		((liim_id\data_exchange_specification_id.status = 'WD')
			OR
		(liim_id\data_exchange_specification_id.status = 'CD')
			OR
		(liim_id\data_exchange_specification_id.status = 'DIS')
			OR
		(liim_id\data_exchange_specification_id.status = 'FDIS')
			OR
		(liim_id\data_exchange_specification_id.status = 'IS')
		)
		AND
		(liim_id\data_exchange_specification_id.name 
		= 'ISO_13584_24_1')
		AND
		is_correct_liim_24_1_application_value(liim_id)
		AND
		(QUERY( efp <* liim_id\data_exchange_specification_id
		.external_file_protocols 
		|NOT (is_extended_liim_24_1_application_value(liim_id)) 
		 AND 
		 NOT(compliant_external_file_protocol_24_1([efp]))
		) = []
		)
		)
	 = QUERY( liim_id <* library_iim_id | 
		(liim_id\data_exchange_specification_id.name = 	
		'ISO_13584_101'));
END_RULE; -- allowed_reference_to_LIIM_24_1_rule


FUNCTION compliant_http_protocol_24_1(ef : external_file_protocol): BOOLEAN;
  LOCAL 
    ok : BOOLEAN := TRUE ;
  END_LOCAL ;
	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.HTTP_PROTOCOL' IN TYPEOF(ef)) AND
		(ef.organisation.id = 'IAB') AND
		(ef.organisation.name = 'Internet Architecture Board') AND
		(ef.protocol_name = 'HTTP') AND
		(ef.designation.preferred_name 
		= 'Hypertext Transfer Protocol') )
    THEN 
	  IF 'ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.TRANSLATED_LABEL' 
		IN TYPEOF(ef.designation.short_name) 
	  THEN
		REPEAT i:= 1 TO SIZEOF(ef.designation.short_name
					\translated_label.labels);
			IF (ef.designation.short_name\translated_label.labels[i] LIKE 'RFC####&') 
			THEN 
				ok := ok AND TRUE;
			ELSE 
				ok := ok AND FALSE;
			END_IF;		
		END_REPEAT ;
		RETURN(OK) ;
	  ELSE
		IF ef.designation.short_name
			LIKE 'RFC####&' 
		THEN 
			RETURN(TRUE);
		ELSE
			RETURN(FALSE);
		END_IF;	 
	  END_IF ;
    ELSE
		RETURN(FALSE);
	END_IF;

END_FUNCTION; -- compliant_http_protocol_24_1


FUNCTION compliant_8859_1_protocol_24_1(ef : external_file_protocol): BOOLEAN;

	IF (('ISO13584_G_M_IIM_LIBRARY_IMPLICIT_SCHEMA.STANDARD_DATA_PROTOCOL' IN TYPEOF(ef)) AND
		(ef.organisation.id = 'ISO') AND
		(ef.organisation.name 
		= 'International Organisation for Standardization') AND
		(ef.protocol_name = 'ISO_8859_1') AND
		(ef.designation.preferred_name 
		= 'Latin alphabet No 1') AND
		(ef.designation.short_name = 'ISO 8859-1'))
	THEN 
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
END_IF ;
END_FUNCTION;


FUNCTION compliant_external_file_protocol_24_1
	(S : SET [0:?] OF external_file_protocol) : BOOLEAN;

	REPEAT i := 1 TO SIZEOF(S) ;
		IF NOT (compliant_8859_1_protocol_24_1 (S[i]) 
			OR compliant_http_protocol_24_1 (S[i]))
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;

	RETURN(TRUE);

END_FUNCTION; -- compliant_external_file_protocol_24_1


FUNCTION is_correct_liim_24_1_application_value
			(liim_id : library_iim_id) : BOOLEAN ;

 IF EXISTS(liim_id\data_exchange_specification_id.application) 
	AND
	((liim_id\data_exchange_specification_id.application[1]='1')
			OR
	 (liim_id\data_exchange_specification_id.application[1]='2')
			OR
	 (liim_id\data_exchange_specification_id.application[1]='3')
			OR
	 (liim_id\data_exchange_specification_id.application[1]='4')
			OR
	 (liim_id\data_exchange_specification_id.application[1]='5')
			OR
	 (liim_id\data_exchange_specification_id.application[1]='6'))
	AND
	((liim_id\data_exchange_specification_id.application LIKE '#')
			OR
	 (liim_id\data_exchange_specification_id.application LIKE '#E'))
	THEN 
		RETURN(TRUE);
	ELSE 
		RETURN(FALSE);
	END_IF;
END_FUNCTION; -- is_correct_liim_24_1_application_value


FUNCTION is_extended_liim_24_1_application_value
			(liim_id : library_iim_id) : BOOLEAN ;
	IF EXISTS(liim_id\data_exchange_specification_id.application) 
		AND (liim_id\data_exchange_specification_id.application LIKE '#E')
	THEN 
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_FUNCTION;  -- is_extended_liim_24_1_application_value

END_SCHEMA; -- ISO13584_g_m_iim_library_implicit_schema





















