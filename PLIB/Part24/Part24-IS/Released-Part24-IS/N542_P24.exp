
SCHEMA ISO13584_instance_resource_schema;
 (* V 1.1 2003-10-20*)


REFERENCE FROM ISO13584_IEC61360_dictionary_schema
	(all_class_descriptions_reachable,
	basic_semantic_unit,
	class,
	class_BSU,
	condition_det,
	content_item,
	data_type_BSU,
	definition_available_implies,
	dependent_p_det,
	is_subclass,
	level,
	list_to_set,
	non_quantitative_code_type,
	non_quantitative_int_type,
	property_BSU,
	version_type);

REFERENCE FROM ISO13584_IEC61360_language_resource_schema
	(translatable_label,
	present_translations);

REFERENCE FROM ISO13584_extended_dictionary_schema
	(a_priori_semantic_relationship,
	abstract_functional_model_class,
	applicable_properties,
	data_type_class_of,
	data_type_level_spec,
	data_type_level_value_typeof,
	data_type_type_name,
	data_type_typeof,
	functional_view_v_c_v,
	data_type_non_quantitative_code_type,
	data_type_non_quantitative_int_type);

REFERENCE FROM ISO13584_library_content_schema
	(allowed_properties,
	explicit_functional_model_class_extension,
	explicit_item_class_extension,
	functional_model_class_extension,
	fm_free_model_properties_list,
	item_class_extension,
	gm_identification_characteristics_list,
	method_variables,
	selectable_properties_list);

REFERENCE FROM ISO13584_external_file_schema
	(program_reference,
	representation_reference,
	property_value_external_item);

REFERENCE FROM geometry_schema
	(axis1_placement,
	axis2_placement_2d,
	axis2_placement_3d,
	placement);

REFERENCE FROM representation_schema
	(representation,
	representation_context,
	representation_item);

REFERENCE FROM product_definition_schema
	(product,
	product_category,
	product_definition,
	product_definition_formation);

REFERENCE FROM product_property_definition_schema
	(property_definition);

USE FROM person_organization_schema
	(address,
	organization,
	person,
	person_and_organization,
	personal_address,
	organizational_address );

USE FROM date_time_schema
	(date,
	date_and_time,
	local_time,
	calendar_date,
	ordinal_date,
	week_of_year_and_day_date);

REFERENCE FROM geometry_schema
	(geometric_representation_context);

ENTITY null_value;
END_ENTITY; -- null_value

TYPE primitive_value = SELECT(
	simple_value,
	complex_value);
END_TYPE; -- primitive_value

TYPE null_or_primitive_value = SELECT(
	null_value,
	primitive_value);
END_TYPE; -- null_or_primitive_value

TYPE simple_value = SELECT(
	number_value,
	translatable_string_value,
	boolean_value);
END_TYPE; -- simple_value

TYPE null_or_simple_value = SELECT(
	null_value,
	simple_value);
END_TYPE; -- null_or_simple_value

TYPE number_value = SELECT(
	integer_value,
	real_value);
END_TYPE; -- nunmber_value

TYPE null_or_number_value = SELECT(
	null_value,
	number_value);
END_TYPE; -- nunmber_value

TYPE integer_value = INTEGER;
END_TYPE; -- integer_value

TYPE null_or_integer_value = SELECT(
	null_value,
	integer_value);
END_TYPE; -- null_or_integer_value

TYPE real_value = REAL;
END_TYPE; -- real_value

TYPE null_or_real_value = SELECT(
	null_value,
	real_value);
END_TYPE; -- null_or_real_value

TYPE boolean_value = BOOLEAN;
END_TYPE; -- boolean_value

TYPE null_or_boolean_value = SELECT(
	null_value,
	boolean_value);
END_TYPE; -- null_or_boolean_value

TYPE translatable_string_value = SELECT(string_value,
	translated_string_value);
END_TYPE; -- translatable_string_value

ENTITY translated_string_value; 
	string_values: LIST [1:?] OF string_value;
	languages: present_translations; 
WHERE
	WR1: SIZEOF(string_values) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_string_value

TYPE string_value = STRING;
END_TYPE; -- string_value

TYPE null_or_translatable_string_value = SELECT(
	null_value,
	translatable_string_value);
END_TYPE; -- null_or_translatable_string_value

TYPE complex_value = SELECT(
	entity_instance_value,
	level_spec_value,
	dic_class_instance);
END_TYPE; -- complex_value

TYPE null_or_complex_value = SELECT(
	null_value,
	complex_value);
END_TYPE; -- null_or_complex_value

TYPE entity_instance_value = SELECT(
	defined_entity_instance_value,
	controlled_entity_instance_value,
	uncontrolled_entity_instance_value);
END_TYPE; -- entity_instance_value

TYPE null_or_entity_instance_value = SELECT(
	null_value,
	entity_instance_value);
END_TYPE; -- null_or_entity_instance_value

TYPE defined_entity_instance_value = SELECT(
	placement,
	axis1_placement,
	axis2_placement_2d,
	axis2_placement_3d);
END_TYPE; -- defined_entity_instance_value

TYPE controlled_entity_instance_value = SELECT(
	STEP_entity_instance_value,
	PLIB_entity_instance_value);
END_TYPE; -- controlled_entity_instance_value

TYPE STEP_entity_instance_value = SELECT(
	product_category,
	product,
	product_definition,
	product_definition_formation,
	property_definition,
	person_organization_select,
	representation,
	representation_context,
	geometric_representation_context,
	representation_item,
	date,
	date_and_time,
	local_time,
	calendar_date,
	ordinal_date,
	week_of_year_and_day_date,
	person, 
	organization,
	person_and_organization,
	address,
	personal_address,
	organizational_address );
END_TYPE; -- STEP_entity_instance_value

TYPE PLIB_entity_instance_value = SELECT(
	program_reference,
	representation_reference,
	property_value_external_item);
END_TYPE; -- PLIB_entity_instance_value

ENTITY uncontrolled_entity_instance_value
ABSTRACT SUPERTYPE;
END_ENTITY; -- uncontrolled_entity_instance_value

TYPE property_or_data_type_BSU = SELECT(
	property_BSU,
	data_type_BSU);
END_TYPE; -- property_or_data_type_BSU

ENTITY level_spec_value
ABSTRACT SUPERTYPE OF(ONEOF(
	int_level_spec_value,
	real_level_spec_value));
	values: ARRAY [1:4] OF OPTIONAL NUMBER;
END_ENTITY; -- level_spec_value

TYPE null_or_level_spec_value = SELECT(
	null_value,
	level_spec_value);
END_TYPE; -- null_or_level_spec_value

ENTITY int_level_spec_value
SUBTYPE OF(level_spec_value);
	SELF\level_spec_value.values: ARRAY [1:4] OF OPTIONAL INTEGER;
END_ENTITY; -- int_level_spec_value

TYPE null_or_int_level_spec_value = SELECT(
	null_value,
	int_level_spec_value);
END_TYPE; -- null_or_int_level_spec_value

ENTITY real_level_spec_value
SUBTYPE OF(level_spec_value);
	SELF\level_spec_value.values: ARRAY [1:4] OF OPTIONAL REAL;
END_ENTITY; -- real_level_spec_value

TYPE null_or_real_level_spec_value = SELECT(
	null_value,
	real_level_spec_value);
END_TYPE; -- null_or_real_level_spec_value

ENTITY dic_class_instance
ABSTRACT SUPERTYPE OF(ONEOF(dic_item_instance,
		dic_f_model_instance, dic_f_view_instance));
	class_def: class_BSU;
	properties: LIST [0:?] OF property_value;
	case_of: SET [0:?] OF class_BSU;
WHERE
	WR1: (QUERY(prop <* SELF.properties | 
		NOT((applicable_properties(
		SELF.class_def, [prop.prop_def])))) = [ ]);
	WR2: QUERY(prop <* SELF.properties
		| (SIZEOF(QUERY (prop1 <* SELF.properties
		| prop1.prop_def = prop.prop_def)) = 1))
		= SELF.properties;
	WR3: check_property_values_translations(QUERY(prop_val <* 
		properties | 'ISO13584_INSTANCE_RESOURCE_SCHEMA.' +
		'TRANSLATED_STRING_VALUE' IN TYPEOF(prop_val.its_value)));
END_ENTITY; -- dic_class_instance

TYPE null_or_dic_class_instance = SELECT(
	null_value,
	dic_class_instance);
END_TYPE; -- null_or_dic_class_instance

ENTITY dic_item_instance
SUPERTYPE OF(ONEOF(dic_component_instance,
	dic_material_instance,
	dic_feature_instance) ANDOR lib_item_instance)
SUBTYPE OF(dic_class_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
	WR2: QUERY(prop <* SELF.properties
		| (SIZEOF(prop.prop_def.definition) = 1)
		AND (('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
		'.DEPENDENT_P_DET')
		IN TYPEOF(prop.prop_def.definition[1]))
		AND (prop.prop_def.definition[1]\dependent_P_DET.depends_on
		>= collects_property_context(prop.prop_def, SELF)))
		= [];
	WR3: compatible_item_caseof_with_class_definition(SELF);
END_ENTITY; -- dic_item_instance

ENTITY dic_component_instance
SUPERTYPE OF(lib_component_instance)
SUBTYPE OF(dic_item_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
END_ENTITY; -- dic_component_instance

ENTITY dic_material_instance
SUPERTYPE OF(lib_material_instance)
SUBTYPE OF(dic_item_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
END_ENTITY; -- dic_material_instance

ENTITY dic_feature_instance
SUPERTYPE OF(lib_feature_instance)
SUBTYPE OF(dic_item_instance);
WHERE
	WR1: check_class_type_for_dic_item_instance(SELF);
END_ENTITY; -- dic_feature_instance

ENTITY lib_item_instance
SUPERTYPE OF(ONEOF(lib_component_instance,
	lib_material_instance, lib_feature_instance))
SUBTYPE OF(dic_item_instance);
	supplier_identification: OPTIONAL STRING;
	supplier_designation: OPTIONAL translatable_label;
	user_identification: OPTIONAL STRING;
	user_designation: OPTIONAL translatable_label;
	is_global_id: BOOLEAN;
	source_class_content: OPTIONAL version_type;
END_ENTITY; -- lib_item_instance

ENTITY lib_component_instance
SUBTYPE OF(dic_component_instance, lib_item_instance);
END_ENTITY; -- lib_component_instance

ENTITY lib_material_instance
SUBTYPE OF(dic_material_instance, lib_item_instance);
END_ENTITY; -- lib_material_instance

ENTITY lib_feature_instance
SUBTYPE OF(dic_feature_instance, lib_item_instance);
END_ENTITY; -- lib_feature_instance

ENTITY dic_f_model_instance
SUPERTYPE OF(lib_f_model_instance)
SUBTYPE OF(dic_class_instance);
WHERE
	WR1: check_class_type_for_dic_f_model_instance(SELF);
	WR2: compatible_model_caseof_with_class_definition(SELF);
END_ENTITY; -- dic_f_model_instance

ENTITY lib_f_model_instance
SUBTYPE OF(dic_f_model_instance);
END_ENTITY; -- lib_f_model_instance

ENTITY dic_f_view_instance
SUBTYPE OF(dic_class_instance, representation);
	generated_by: OPTIONAL dic_f_model_instance;
	view_of: OPTIONAL dic_item_instance;
DERIVE
	SELF\dic_class_instance.case_of: SET OF class_BSU := [];
WHERE
	WR1: check_class_type_for_dic_f_view_instance(SELF);
	WR2: NOT all_class_descriptions_reachable(
		SELF\dic_class_instance.class_def)
		OR (QUERY(prop <* functional_view_v_c_v(
		SELF\dic_class_instance.class_def)
		| SIZEOF(QUERY(prop2 <* SELF.properties
		| prop2.prop_def = prop))<>1) = []);
	WR3: correct_view_from_model(SELF);
END_ENTITY; -- dic_f_view_instance

ENTITY property_value;
	its_value: OPTIONAL primitive_value;
	prop_def: property_BSU;
WHERE
	WR1: (EXISTS(SELF.its_value) AND (compatible_type_and_value(
		SELF.prop_def, SELF.its_value)))
		OR NOT EXISTS(SELF.its_value);
END_ENTITY; -- property_value

ENTITY context_dependent_property_value
SUBTYPE OF(property_value);
	the_context: LIST[1:?] OF property_value;
WHERE
	WR1: QUERY(c <* SELF.the_context | NOT(is_condition_det(c)))
		= [];
	WR2: is_dependent_p_det(SELF\property_value.prop_def);
	WR3: all_context_parameters_referenced(SELF);
END_ENTITY; -- context_dependent_property_value

RULE valued_properties_are_allowed_for_implicit_spec_rule FOR 
	(lib_item_instance, item_class_extension);
LOCAL
	allowed_valued_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF (SIZEOF(lib_item_instance[i]\dic_class_instance.class_def
		.referenced_by) = 1)
	THEN
		IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
			'.ITEM_CLASS_EXTENSION' IN TYPEOF(lib_item_instance[i]\
			dic_class_instance.class_def.referenced_by[1]))
		THEN
			allowed_valued_properties := allowed_valued_properties 
			AND (QUERY(prop <* lib_item_instance[i].properties |
			NOT((allowed_properties(lib_item_instance[i]\
			dic_class_instance.class_def, [prop.prop_def])))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: allowed_valued_properties;
END_RULE; -- valued_properties_are_allowed_for_implicit_spec_rule

RULE valued_properties_are_allowed_for_explicit_spec_rule FOR
	(lib_item_instance, explicit_item_class_extension);
LOCAL
	allowed_valued_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF SIZEOF(lib_item_instance[i]\dic_class_instance.class_def
		.referenced_by) = 1
	THEN
		IF ('ISO13584_LIBRARY_CONTENT_SCHEMA' +
			'.EXPLICIT_ITEM_CLASS_EXTENSION' IN
			TYPEOF(lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			allowed_valued_properties := allowed_valued_properties 
			AND (QUERY(prop <* lib_item_instance[i].properties 
			| NOT((applicable_properties(
			lib_item_instance[i]\dic_class_instance
			.class_def, [prop.prop_def])))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: allowed_valued_properties;
END_RULE; -- valued_properties_are_allowed_for_explicit_spec_rule

RULE identification_properties_are_valued_for_implicit_spec_rule FOR
	(lib_item_instance, item_class_extension);
LOCAL
	valued_identification_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF (SIZEOF(lib_item_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1)
	THEN
		IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
			'.ITEM_CLASS_EXTENSION' IN
			TYPEOF(lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			valued_identification_properties := 
			valued_identification_properties
			AND (NOT all_class_descriptions_reachable(
			lib_item_instance[i]\dic_class_instance.class_def)
			OR (QUERY(prop <* 
			gm_identification_characteristics_list(
			lib_item_instance[i]\dic_class_instance.class_def) 
			| NOT(prop IN collects_assigned_instance_properties
			(list_to_set(lib_item_instance[i]\
			dic_class_instance.properties)))) = []));
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: valued_identification_properties;
END_RULE;-- identification_properties_are_valued_for_implicit_spec_rule

RULE identification_properties_are_valued_for_explicit_spec_rule FOR
	(lib_item_instance, explicit_item_class_extension);
LOCAL
	valued_identification_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_item_instance);
	IF SIZEOF(lib_item_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1
	THEN
		IF ('ISO13584_LIBRARY_CONTENT_SCHEMA' +
			'.EXPLICIT_ITEM_CLASS_EXTENSION' IN
			TYPEOF(lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			valued_identification_properties := 
			valued_identification_properties
			AND (QUERY(prop <*
			lib_item_instance[i]\dic_class_instance.
			class_def.referenced_by[1].instance_identification 
			| NOT(prop IN collects_assigned_instance_properties
			(list_to_set(lib_item_instance[i]\
			dic_class_instance.properties)))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: valued_identification_properties;
END_RULE; --identification_properties_are_valued_for_explicit_spec_rule

RULE fm_valued_properties_are_allowed_for_implicit_spec_rule FOR
	(lib_f_model_instance, functional_model_class_extension);
LOCAL
	allowed_valued_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_f_model_instance);
	IF (SIZEOF(lib_f_model_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1)
	THEN
		IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
			'.FUNCTIONAL_MODEL_CLASS_EXTENSION' IN
			TYPEOF(lib_f_model_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			allowed_valued_properties := allowed_valued_properties 
			AND (QUERY(prop <* lib_f_model_instance[i].properties
			| NOT((allowed_properties(lib_f_model_instance[i]\
			dic_class_instance.class_def, [prop.prop_def])))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: allowed_valued_properties;
END_RULE; -- fm_valued_properties_are_allowed_for_implicit_spec_rule

RULE fm_valued_properties_are_allowed_for_explicit_spec_rule FOR(
	lib_f_model_instance,
	explicit_functional_model_class_extension);
LOCAL
	allowed_valued_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_f_model_instance);
	IF SIZEOF(lib_f_model_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1
	THEN
		IF ('ISO13584_LIBRARY_CONTENT_SCHEMA' +
			'.EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION' IN
			TYPEOF(lib_f_model_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			allowed_valued_properties := allowed_valued_properties
			AND(QUERY(prop <* lib_f_model_instance[i].properties 
			| NOT((applicable_properties(
			lib_f_model_instance[i]\dic_class_instance.
			class_def, [prop.prop_def])))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: allowed_valued_properties;
END_RULE; -- fm_valued_properties_are_allowed_for_explicit_spec_rule

RULE fm_free_properties_are_valued_for_implicit_spec_rule FOR
	(lib_f_model_instance, functional_model_class_extension);
LOCAL
	valued_free_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_f_model_instance);
	IF (SIZEOF(lib_f_model_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1)
	THEN
		IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
			'.FUNCTIONAL_MODEL_CLASS_EXTENSION' IN TYPEOF(
			lib_f_model_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			valued_free_properties := valued_free_properties
			AND (NOT all_class_descriptions_reachable(
			lib_f_model_instance[i]\dic_class_instance.class_def)
			OR (QUERY(prop <* 
			fm_free_model_properties_list(
			lib_f_model_instance[i]\dic_class_instance.
			class_def) | NOT(prop IN
			collects_assigned_instance_properties(
			list_to_set(lib_f_model_instance[i]\
			dic_class_instance.properties)))) = []));
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR1: valued_free_properties;
END_RULE; -- fm_free_properties_are_valued_for_implicit_spec_rule

RULE fm_free_properties_are_valued_for_explicit_spec_rule FOR(
	lib_f_model_instance, explicit_functional_model_class_extension);
LOCAL
	valued_free_properties: LOGICAL := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(lib_f_model_instance);
	IF SIZEOF(lib_f_model_instance[i]\dic_class_instance.
		class_def.referenced_by) = 1
	THEN
		IF ('ISO13584_LIBRARY_CONTENT_SCHEMA' +
			'.EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION' IN
			TYPEOF(lib_f_model_instance[i]\dic_class_instance.
			class_def.referenced_by[1]))
		THEN
			valued_free_properties := valued_free_properties
			AND (QUERY(prop <* lib_f_model_instance[i]\
			dic_class_instance.class_def.referenced_by[1].
			instance_identification |
			NOT(prop IN collects_assigned_instance_properties(
			list_to_set(lib_f_model_instance[i]\
			dic_class_instance.properties)))) = []);
		END_IF;
	END_IF;
END_REPEAT;

WHERE
	WR: valued_free_properties;
END_RULE; -- fm_free_properties_are_valued_for_explicit_spec_rule

FUNCTION compatible_class_and_class(cl1:class_BSU; 
	cl2:class_BSU): LOGICAL;

IF (cl1.defined_by\basic_semantic_unit.code =
	cl2.defined_by\basic_semantic_unit.code) AND
	(cl1\basic_semantic_unit.code =
	cl2\basic_semantic_unit.code) AND
	(cl1\basic_semantic_unit.version >=
	cl2\basic_semantic_unit.version)
THEN 
	RETURN(TRUE);
END_IF;

IF (SIZEOF(cl2\basic_semantic_unit.definition) = 0)
THEN 
	RETURN(UNKNOWN);
END_IF;

IF (SIZEOF(cl2\basic_semantic_unit.definition) = 1)
	AND (NOT EXISTS(cl2\basic_semantic_unit.
	definition[1]\class.its_superclass))
THEN 
	RETURN(FALSE);
END_IF;

RETURN(compatible_class_and_class(cl1, cl2\basic_semantic_unit.
	definition[1]\class.its_superclass));

END_FUNCTION; -- compatible_class_and_class

FUNCTION right_values_for_level_spec(
	levels: LIST [1:4] OF UNIQUE level;
	val: level_spec_value): BOOLEAN;

LOCAL
	c_place: BOOLEAN;
	lev: SET [1:4] OF level;
END_LOCAL;

c_place := TRUE;
lev := list_to_set(levels);

IF EXISTS(val.values[1])
THEN
	IF level.min IN lev
	THEN 
		lev := lev - [level.min];
	ELSE 
		c_place := FALSE;
	END_IF;
END_IF;

IF EXISTS(val.values[2])
THEN
	IF level.nom IN lev
	THEN 
		lev := lev - [level.nom];
	ELSE 
		c_place := FALSE;
	END_IF;
END_IF;

IF EXISTS(val.values[3])
THEN
	IF level.typ IN lev
	THEN 
		lev := lev - [level.typ];
	ELSE 
		c_place := FALSE;
	END_IF;
END_IF;

IF EXISTS(val.values[4])
THEN
	IF level.max IN lev
	THEN 
		lev := lev - [level.max];
	ELSE 
		c_place := FALSE;
	END_IF;
END_IF;

IF (c_place)
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- right_values_for_level_spec

FUNCTION compatible_level_type_and_instance(
	levels: LIST [1:4] OF UNIQUE level; value_typeof: SET OF STRING;
	val: level_spec_value): BOOLEAN;

LOCAL
	c_val: BOOLEAN;
END_LOCAL;

c_val := FALSE;

IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.INT_LEVEL_SPEC_VALUE'
	IN TYPEOF(val))
	AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_TYPE' IN 	value_typeof)
THEN
	c_val := TRUE;
END_IF;

IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.REAL_LEVEL_SPEC_VALUE'
	IN TYPEOF(val))
	AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_TYPE'
	IN value_typeof)
THEN
	c_val := TRUE;
END_IF;

RETURN(c_val AND (right_values_for_level_spec(levels, val)));

END_FUNCTION; -- compatible_level_type_and_instance

FUNCTION compatible_type_and_value(dom: property_or_data_type_BSU;
	val: primitive_value): LOGICAL;

LOCAL
	temp: SET[0:1] OF class_BSU;
	set_string: SET OF STRING := [];
	set_integer: SET OF INTEGER := [];
	code_type: non_quantitative_code_type;
	int_type: non_quantitative_int_type;
END_LOCAL;

IF data_type_typeof(dom) = []
THEN 
	RETURN(UNKNOWN);
END_IF;



IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.INTEGER_VALUE' IN TYPEOF(val))
THEN
	IF (('ISO13584_IEC61360_DICTIONARY_SCHEMA.' + 
		'NON_QUANTITATIVE_INT_TYPE' IN data_type_typeof(dom))
		AND (SIZEOF(data_type_non_quantitative_int_type(dom)) = 1))
	THEN
		set_integer := [];
		int_type := data_type_non_quantitative_int_type(dom)[1];

		REPEAT j := 1 TO SIZEOF(code_type.domain.its_values);
			set_integer := set_integer + 
				code_type.domain.its_values[j].value_code;
		END_REPEAT;
		
		RETURN(val IN set_integer);

	ELSE
		RETURN(('ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_TYPE'
			IN data_type_typeof(dom)) OR
			(('ISO13584_IEC61360_DICTIONARY_SCHEMA.NUMBER_TYPE'
			IN data_type_typeof(dom))
			AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_TYPE'
			IN data_type_typeof(dom))));
	END_IF;
END_IF;

IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.REAL_VALUE' IN TYPEOF(val))
THEN
	RETURN(('ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_TYPE'
		IN data_type_typeof(dom)) OR
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.NUMBER_TYPE'
		IN data_type_typeof(dom))
		AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_TYPE'
		IN data_type_typeof(dom))));
END_IF;

IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.NUMBER_VALUE' IN TYPEOF(val))
THEN
	RETURN('ISO13584_IEC61360_DICTIONARY_SCHEMA.NUMBER_TYPE'
		IN data_type_typeof(dom));
END_IF;

IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.BOOLEAN_VALUE' IN TYPEOF(val))
THEN
	RETURN('ISO13584_IEC61360_DICTIONARY_SCHEMA.BOOLEAN_TYPE'
		IN data_type_typeof(dom));
END_IF;

IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.TRANSLATABLE_STRING_VALUE' 
	IN TYPEOF(val))
THEN
	IF (('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
		'.NON_QUANTITATIVE_CODE_TYPE') IN  data_type_typeof(dom))
	THEN
		IF (SIZEOF(data_type_non_quantitative_code_type(dom)) = 1)
		THEN
			set_string := [];
			code_type := 
				data_type_non_quantitative_code_type(dom)[1];

			REPEAT j := 1 TO SIZEOF(code_type.domain.its_values);
				set_string := set_string + 
					code_type.domain.its_values[j].value_code;
			END_REPEAT;

			RETURN(('ISO13584_INSTANCE_RESOURCE_SCHEMA.STRING_VALUE' 
				IN TYPEOF(val)) AND (val IN set_string));

		ELSE
			RETURN(UNKNOWN);
		END_IF;
	ELSE
		RETURN('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
			'.STRING_TYPE' IN data_type_typeof(dom));
	END_IF;
END_IF;



IF 'ISO13584_INSTANCE_RESOURCE_SCHEMA.ENTITY_INSTANCE_VALUE'
	IN TYPEOF(val)
THEN
	IF 'ISO13584_INSTANCE_RESOURCE_SCHEMA' +
		'.UNCONTROLLED_ENTITY_INSTANCE_VALUE'
		IN TYPEOF(val)
	THEN
		RETURN(UNKNOWN);
	END_IF;
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN data_type_typeof(dom))
AND (SIZEOF(data_type_type_name(dom)) <> 0)
		AND (data_type_type_name(dom) <= TYPEOF(val))
	THEN 
		RETURN(TRUE);
	ELSE 
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_INSTANCE_RESOURCE_SCHEMA.DIC_CLASS_INSTANCE'
	IN TYPEOF(val) 
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE'
		IN data_type_typeof(dom))
		AND (SIZEOF(data_type_class_of(dom)) <> 0)
	THEN
		temp := data_type_class_of(dom);
		RETURN(compatible_class_and_class(temp[1],
			val\dic_class_instance.class_def));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF 'ISO13584_INSTANCE_RESOURCE_SCHEMA.LEVEL_SPEC_VALUE' IN TYPEOF(val) THEN	
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.LEVEL_TYPE'
		IN data_type_typeof(dom))
	THEN
		RETURN(compatible_level_type_and_instance(
			data_type_level_spec(dom),
			data_type_level_value_typeof(dom),
			val));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

RETURN(FALSE);

END_FUNCTION; -- compatible_type_and_value

FUNCTION collects_assigned_instance_properties(
	props: SET [0:?] OF property_value): SET OF property_BSU;

LOCAL
	assign_prop: SET OF property_BSU;
		-- assigned properties of the dic_class_instance
END_LOCAL;

assign_prop := [];

REPEAT i := 1 TO SIZEOF(props);
	assign_prop := assign_prop + props[i].prop_def;
END_REPEAT;

RETURN(assign_prop);

END_FUNCTION; -- collects_assigned_instance_properties

FUNCTION correct_view_from_model(fv: dic_f_view_instance): LOGICAL;

IF NOT EXISTS(fv.generated_by)
THEN
	RETURN(UNKNOWN);
END_IF;

IF NOT(SIZEOF(fv.generated_by\dic_class_instance.class_def.
	definition) = 1)
THEN
	RETURN(UNKNOWN);
ELSE
	RETURN(fv.generated_by\dic_class_instance.class_def
		.definition[1].created_view = 
		fv\dic_class_instance.class_def);
END_IF;

END_FUNCTION; -- correct_view_from_model

FUNCTION is_condition_det(prop: property_value): LOGICAL;

IF(SIZEOF(prop.prop_def.definition) > 0) THEN
	RETURN('ISO13584_IEC61360_DICTIONARY_SCHEMA.CONDITION_DET'
		IN TYPEOF(prop.prop_def.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- is_condition_det

FUNCTION is_dependent_p_det(prop: property_bsu): LOGICAL;

IF(SIZEOF(prop.definition) > 0) THEN
	RETURN('ISO13584_IEC61360_DICTIONARY_SCHEMA.DEPENDENT_P_DET'
		IN TYPEOF(prop.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- is_dependent_p_det

FUNCTION all_context_parameters_referenced(
	cdpv: context_dependent_property_value): LOGICAL;

IF(SIZEOF(cdpv\property_value.prop_def.definition) > 0) THEN
	RETURN(cdpv\property_value.prop_def.definition[1]\
		dependent_p_det.depends_on
		>= collects_assigned_instance_properties(
		list_to_set(cdpv.the_context)));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- all_context_parameters_referenced

FUNCTION collects_property_context(prop: property_BSU;
	inst: dic_class_instance): SET OF property_BSU;

LOCAL
	assigned_context_parameters: SET OF property_BSU;
		--assigned context parameters of the dic_class_instance
	correct: BOOLEAN; --prop belongs to inst properties
END_LOCAL;

assigned_context_parameters := [];
correct := FALSE;

REPEAT i := 1 TO SIZEOF(inst.properties);

	IF inst.properties[i].prop_def :=: prop
	THEN 
		correct := TRUE;
	END_IF;

	IF ((SIZEOF(inst.properties[i].prop_def.definition) = 0)
		OR ((SIZEOF(inst.properties[i].prop_def.definition) = 1)
	AND (('ISO13584_IEC61630_DICTIONARY_SCHEMA.CONDITION_DET')
	IN TYPEOF(inst.properties[i].prop_def.definition[1]))))
	THEN 
		assigned_context_parameters := assigned_context_parameters
			+ inst.properties[i].prop_def;
	END_IF;

	IF (('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
	'.CONTEXT_DEPENDENT_PROPERTY_VALUE') IN 
	TYPEOF(inst.properties[i]))
	THEN 
		assigned_context_parameters := assigned_context_parameters
			+ collects_assigned_instance_properties(list_to_set(
			inst.properties[i].the_context));
	END_IF;

END_REPEAT;

IF NOT correct
THEN
	assigned_context_parameters := [];
END_IF;

RETURN(assigned_context_parameters);

END_FUNCTION; -- collects_property_context

FUNCTION check_class_type_for_dic_item_instance(
	dic_cl: dic_item_instance): LOGICAL;

IF (SIZEOF(dic_cl.class_def.definition) = 1) THEN

	IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.' +
		'DIC_COMPONENT_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN(('ISO13584_IEC61360_DICTIONARY_SCHEMA'
				+ '.COMPONENT_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1])));
	END_IF;

	IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.' +
		'DIC_MATERIAL_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN(('ISO13584_IEC61360_DICTIONARY_SCHEMA'
				+ '.MATERIAL_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1])));
	END_IF;

	IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.' +
		'DIC_FEATURE_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
				+ '.FEATURE_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1]));
	END_IF;

	IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.' +
		'DIC_ITEM_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN(('ISO13584_IEC61360_DICTIONARY_SCHEMA'
				+ '.ITEM_CLASS'
				IN TYPEOF(dic_cl.class_def.definition[1])));
	END_IF;

ELSE
	RETURN(UNKNOWN);
END_IF;
END_FUNCTION; -- check_class_type_for_dic_item_instance


FUNCTION check_class_type_for_dic_f_model_instance(
	dic_cl: dic_f_model_instance): LOGICAL;

IF (SIZEOF(dic_cl.class_def.definition) = 1)
THEN
	RETURN (('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+ '.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(dic_cl.class_def.definition[1])));
ELSE
	RETURN(UNKNOWN);
END_IF;
END_FUNCTION; -- check_class_type_for_dic_f_model_instance


FUNCTION check_class_type_for_dic_f_view_instance(
	dic_cl: dic_f_view_instance): LOGICAL;

IF (SIZEOF(dic_cl.class_def.definition) = 1)
THEN
	IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA' +
		'.DIC_F_VIEW_INSTANCE') IN TYPEOF(dic_cl)
	THEN
			RETURN('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
			+ '.FUNCTIONAL_VIEW_CLASS'
			IN TYPEOF(dic_cl.class_def.definition[1]));
	END_IF;

ELSE
	RETURN(UNKNOWN);
END_IF;
END_FUNCTION; -- check_class_type_for_dic_f_view_instance

FUNCTION check_property_values_translations(props: 
	LIST OF property_value): LOGICAL;
LOCAL
	translated_string_values: SET OF translated_string_value := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(props);
	translated_string_values := 
		translated_string_values + props[i].its_value;
END_REPEAT;

RETURN(same_translations(translated_string_values));

END_FUNCTION; -- check_property_values_translations

FUNCTION same_translations(translated_string_values: SET OF 
	translated_string_value): LOGICAL;
LOCAL
	comp: translated_string_value;
END_LOCAL;

IF (SIZEOF(translated_string_values) <> 0)
THEN
	comp := translated_string_values[1];
	REPEAT i := 2 TO SIZEOF(translated_string_values);
		IF (translated_string_values[i].languages <> 
			comp.languages)
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;

	RETURN(TRUE);
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- same_translations

FUNCTION compatible_item_caseof_with_class_definition(
	inst: dic_item_instance): LOGICAL;

IF (SIZEOF(inst.case_of) > 0)
THEN
	IF (SIZEOF(inst.class_def.definition) = 1)
	THEN
		RETURN ( inst.case_of 
				<=  item_caseof_closure( [inst.class_def]));
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- compatible_item_caseof_with_class_definition

FUNCTION compatible_model_caseof_with_class_definition(
	inst: dic_f_model_instance): LOGICAL;

IF (SIZEOF(inst.case_of) > 0)
THEN
	IF (SIZEOF(inst.class_def.definition) = 1)
	THEN
		RETURN ( inst.case_of 
				<=  model_caseof_closure( [inst.class_def]));
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- compatible_model_caseof_with_class_definition


FUNCTION superclass_closure (
	current: SET OF class_BSU)    -- which classes
	:SET OF class_BSU;  -- all their superclasses or ?
 LOCAL
       superclasses : SET OF class_BSU := [];
 END_LOCAL;

        compute_superclass_closure (current, superclasses);
        RETURN (superclasses);

END_FUNCTION; -- superclass_closure


PROCEDURE compute_superclass_closure (
	current: SET OF class_BSU;    	-- new superclasses
	var visited: SET OF class_BSU); -- already known superclasses

IF EXISTS(current)  THEN
	IF SIZEOF(current) <> 0 THEN
		REPEAT i := 1 TO SIZEOF(current);
			IF SIZEOF (current[i].definition) = 0
	          THEN 	visited := ?;  
					-- all superclasses cannot be computed
	                	SKIP;
	          ELSE
	            IF  EXISTS 
				(current[i].definition[1]\class.its_superclass)
	               AND NOT
				(current[i].definition[1]\class.its_superclass 
				IN visited)
	             THEN 	visited := visited 
				+ [ current[i].definition[1]\class.its_superclass];
				compute_superclass_closure( 
				[current[i].definition[1]\class.its_superclass]
				, visited );
	        		END_IF;
			END_IF;
		 END_REPEAT;
	END_IF;
ELSE
     visited := ?;       -- all superclasses cannot be computed
END_IF;
END_PROCEDURE; -- compute_superclass_closure


FUNCTION item_caseof_closure (
	current: SET OF class_BSU)    -- which classes
	:SET OF class_BSU;  -- all classes they are caseof or ?
 LOCAL
       caseof : SET OF class_BSU 
			:= next_item_caseof(superclass_closure (current));
 END_LOCAL;
        compute_item_caseof_closure (caseof, caseof);
        RETURN (caseof);
END_FUNCTION; -- item_caseof_closure


FUNCTION next_item_caseof (
	current: SET OF class_BSU)    -- which classes
	:SET OF class_BSU;  -- classes they are directly caseof or ?
 LOCAL
       caseof : SET OF class_BSU := [];
 END_LOCAL;
	IF  EXISTS(current) THEN
 		REPEAT i := 1 TO SIZEOF(current);
			IF SIZEOF (current[i].definition) = 0
                	THEN 	caseof := ?;       
				-- all classes they are caseof cannot be computed
                		SKIP;
                	ELSE
				IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA.' 
					+'ITEM_CLASS_CASE_OF' IN
					TYPEOF(current[i].definition[1]))
                	THEN 	caseof := caseof 
						+ current[i].definition[1]
						\item_class_case_of.is_case_of;
         			END_IF;
			END_IF;
		END_REPEAT;
        	RETURN (caseof);
	ELSE
	  	RETURN (?); -- all classes they are caseof cannot be computed
	END_IF;
END_FUNCTION; -- next_item_caseof


PROCEDURE compute_item_caseof_closure (
	current: SET OF class_BSU;    	-- last found caseof
	var visited: SET OF class_BSU); 
		-- already known classes that are caseof (including current)
 LOCAL
       next : SET OF class_BSU ;        	-- computed new caseof
 END_LOCAL;
 IF  EXISTS(current) THEN
	IF SIZEOF(current) <> 0 THEN
        	next := superclass_closure (current);-- caseof by inheritance
		next := next_item_caseof ( next )+ next;
								-- and caseof by transitivity
		REPEAT i := 1 TO SIZEOF(next);
                	IF  NOT  (next[i] IN visited)
                 	THEN
				  visited := visited + next[i] ;
				  compute_item_caseof_closure([next[i]], visited );
        			END_IF;
		 END_REPEAT;
	END_IF;
ELSE
	visited := ?;       
-- all classes that are caseof cannot be computed
END_IF;
END_PROCEDURE; -- compute_item_caseof_closure


FUNCTION model_caseof_closure (
	current: SET OF class_BSU)    -- which classes
	:SET OF class_BSU;  -- all classes they are caseof or ?
 LOCAL
       caseof : SET OF class_BSU 
			:= next_model_caseof(superclass_closure (current));
 END_LOCAL;
        compute_model_caseof_closure (caseof, caseof);
        RETURN (caseof);
END_FUNCTION; -- model_caseof_closure


FUNCTION next_model_caseof (
	current: SET OF class_BSU)    -- which classes
	:SET OF class_BSU;  -- classes they are directly caseof or ?
 LOCAL
       caseof : SET OF class_BSU := [];
 END_LOCAL;
	IF  EXISTS(current) THEN
 		REPEAT i := 1 TO SIZEOF(current);
			IF SIZEOF (current[i].definition) = 0
                	THEN 	caseof := ?;       
				-- all classes they are caseof cannot be computed
                		SKIP;
                	ELSE
				IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA.' 
					+'ABSTRACT_FUNCTIONAL_MODEL_CLASS' IN
					TYPEOF(current[i].definition[1]))
                	THEN 	caseof := caseof 
						+ current[i].definition[1]
						\abstract_functional_model_class.case_of;
         			END_IF;
			END_IF;
		END_REPEAT;
        	RETURN (caseof);
	ELSE
	  	RETURN (?); -- all classes they are caseof cannot be computed
	END_IF;
END_FUNCTION; -- next_model_caseof


PROCEDURE compute_model_caseof_closure (
	current: SET OF class_BSU;    	-- last found caseof
	var visited: SET OF class_BSU); 
		-- already known classes that are caseof (including current)
 LOCAL
       next : SET OF class_BSU ;        	-- computed new caseof
 END_LOCAL;
 IF  EXISTS(current) THEN
	IF SIZEOF(current) <> 0 THEN
        	next := superclass_closure (current);-- caseof by inheritance
		next := next_model_caseof ( next )+ next;
								-- and caseof by transitivity
		REPEAT i := 1 TO SIZEOF(next);
                	IF  NOT  (next[i] IN visited)
                 	THEN
				  visited := visited + next[i] ;
				  compute_model_caseof_closure([next[i]],visited );
        			END_IF;
		 END_REPEAT;
	END_IF;
ELSE
	visited := ?;       
-- all classes that are caseof cannot be computed
END_IF;
END_PROCEDURE; -- compute_model_caseof_closure



END_SCHEMA; -- ISO13584_instance_resource_schema


SCHEMA ISO13584_library_expressions_schema;

REFERENCE FROM ISO13584_IEC61360_dictionary_schema
	(class_BSU,
	definition_available_implies,
	level,
	list_to_set,
	number_type,
	property_BSU);

REFERENCE FROM ISO13584_generic_expressions_schema
	(binary_generic_expression,
	environment,
	generic_expression,
	generic_literal,
	generic_variable,
	multiple_arity_generic_expression,
	simple_generic_expression,
	unary_generic_expression,
	variable_semantics);

REFERENCE FROM ISO13584_expressions_schema
	(boolean_defined_function,
	expression,
	is_int_expr,
	variable);

REFERENCE FROM ISO13584_instance_resource_schema
	(compatible_class_and_class,
	compatible_level_type_and_instance,
	dic_class_instance,
	entity_instance_value,
	int_level_spec_value,
	level_spec_value,
	property_or_data_type_BSU,
	real_level_spec_value);

REFERENCE FROM ISO13584_extended_dictionary_schema
	(applicable_properties,
	data_type_class_of,
	data_type_level_spec,
	data_type_level_value_typeof,
	data_type_type_name,
	data_type_typeof);

TYPE library_expression = SELECT(
	expression,
	level_spec_expression,
	entity_instance_expression,
	class_instance_expression);
END_TYPE; -- library_expression

TYPE library_variable = SELECT(
	variable,
	level_spec_variable,
	entity_instance_variable,
	class_instance_variable);
END_TYPE; -- library_variable

ENTITY level_spec_expression
ABSTRACT SUPERTYPE OF(simple_level_spec_expression)
SUBTYPE OF(generic_expression);
	levels: LIST[1:4] OF UNIQUE level;
	value_type: number_type;
END_ENTITY; -- level_spec_expression

ENTITY simple_level_spec_expression
ABSTRACT SUPERTYPE OF(ONEOF(
	level_spec_variable,
	level_spec_literal))
SUBTYPE OF(level_spec_expression, simple_generic_expression);
END_ENTITY; -- simple_level_spec_expression

ENTITY level_spec_variable
ABSTRACT SUPERTYPE OF(ONEOF(
	int_level_spec_variable,
	real_level_spec_variable))
SUBTYPE OF(simple_level_spec_expression, generic_variable);
END_ENTITY; -- level_spec_variable

ENTITY int_level_spec_variable
SUBTYPE OF(level_spec_variable);
WHERE
	WR1: 'ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_TYPE'
		IN TYPEOF(SELF\level_spec_expression.value_type);
END_ENTITY; -- int_level_spec_variable

ENTITY real_level_spec_variable
SUBTYPE OF(level_spec_variable);
WHERE
	WR1: 'ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_TYPE'
		IN TYPEOF(SELF\level_spec_expression.value_type);
END_ENTITY; -- real_level_spec_variable

ENTITY level_spec_literal
ABSTRACT SUPERTYPE OF(ONEOF(
	int_level_spec_literal,
	real_level_spec_literal))
SUBTYPE OF(simple_level_spec_expression, generic_literal);
	the_value: level_spec_value;
WHERE
	WR1: compatible_level_type_and_instance(
		SELF\level_spec_expression.levels,
		TYPEOF(SELF\level_spec_expression.value_type),
		SELF.the_value);
END_ENTITY; -- level_spec_literal

ENTITY int_level_spec_literal
SUBTYPE OF(level_spec_literal);
	SELF\level_spec_literal.the_value: int_level_spec_value;
WHERE
	WR1: 'ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_TYPE'
		IN TYPEOF(SELF\level_spec_expression.value_type);
	WR2: compatible_level_type_and_instance(
		SELF\level_spec_expression.levels,
		['ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_TYPE'],
		SELF.the_value);
END_ENTITY; -- int_level_spec_literal

ENTITY real_level_spec_literal
SUBTYPE OF(level_spec_literal);
	SELF\level_spec_literal.the_value: real_level_spec_value;
WHERE
	WR1: 'ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_TYPE'
		IN TYPEOF(SELF\level_spec_expression.value_type);
	WR2: compatible_level_type_and_instance(
		SELF\level_spec_expression.levels,
		['ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_TYPE'],
		SELF.the_value);
END_ENTITY; -- real_level_spec_literal

ENTITY entity_instance_expression
ABSTRACT SUPERTYPE OF(simple_entity_instance_expression)
SUBTYPE OF(generic_expression);
	type_name: SET [1:?] OF STRING;
END_ENTITY; -- entity_instance_expression

ENTITY simple_entity_instance_expression
ABSTRACT SUPERTYPE OF(ONEOF(
	entity_instance_variable,
	entity_instance_literal))
SUBTYPE OF(entity_instance_expression, simple_generic_expression);
END_ENTITY; -- simple_entity_instance_expression

ENTITY entity_instance_variable
SUBTYPE OF(simple_entity_instance_expression, generic_variable);
END_ENTITY; -- entity_instance_variable

ENTITY entity_instance_literal
SUBTYPE OF(simple_entity_instance_expression, generic_literal);
	the_value: entity_instance_value;
WHERE
	WR1: (SELF\entity_instance_expression.type_name
		<= TYPEOF(SELF.the_value))
		OR (('ISO13584_INSTANCE_RESOURCE_SCHEMA'
		+ '.UNCONTROLLED_ENTITY_INSTANCE_VALUE')
		IN TYPEOF(SELF.the_value));
END_ENTITY; -- entity_instance_literal

ENTITY class_instance_expression
ABSTRACT SUPERTYPE OF(ONEOF(
	simple_class_instance_expression,
	unary_class_instance_expression,
	binary_class_instance_expression,
	multiple_arity_class_instance_expression))
SUBTYPE OF(generic_expression);
	expr_type: class_BSU;
END_ENTITY; -- class_instance_expression

ENTITY simple_class_instance_expression
ABSTRACT SUPERTYPE OF(ONEOF(
	class_instance_variable,
	class_instance_literal))
SUBTYPE OF(class_instance_expression, simple_generic_expression);
END_ENTITY; -- simple_class_instance_expression

ENTITY class_instance_variable
SUBTYPE OF(simple_class_instance_expression, generic_variable);
END_ENTITY; -- class_instance_variable

ENTITY class_instance_literal
SUBTYPE OF(simple_class_instance_expression, generic_literal);
	the_value: dic_class_instance;
WHERE
	WR1: compatible_class_and_class(
		SELF\class_instance_expression.expr_type,
		SELF.the_value\dic_class_instance.class_def);
END_ENTITY; -- class_instance_literal

ENTITY class_instance_constructor
ABSTRACT SUPERTYPE OF(ONEOF(
	unary_class_instance_constructor,
	binary_class_instance_constructor,
	multiple_arity_class_instance_constructor))
SUBTYPE OF(class_instance_expression);
	properties: SET [1:?] OF property_assignment;
WHERE
	WR1: definition_available_implies
		(SELF\class_instance_expression.expr_type,
		applicable_properties(
		SELF\class_instance_expression.expr_type,
		list_to_set(collects_assigned_properties(SELF.properties))));
END_ENTITY; -- class_instance_constructor

ENTITY property_assignment;
	its_value: OPTIONAL library_expression;
	prop_def: property_BSU;
WHERE
	WR1: (EXISTS(SELF.its_value) AND
		(compatible_type_and_library_expression(
		SELF.prop_def, SELF.its_value)))
		OR NOT EXISTS(SELF.its_value);
END_ENTITY; -- property_assignment

ENTITY unary_class_instance_expression
ABSTRACT SUPERTYPE OF(unary_class_instance_constructor)
SUBTYPE OF(class_instance_expression, unary_generic_expression);
END_ENTITY; -- unary_class_instance_expression

ENTITY binary_class_instance_expression
ABSTRACT SUPERTYPE OF(binary_class_instance_constructor)
SUBTYPE OF(class_instance_expression, binary_generic_expression);
END_ENTITY; -- binary_class_instance_expression

ENTITY multiple_arity_class_instance_expression
ABSTRACT SUPERTYPE OF(multiple_arity_class_instance_constructor)
SUBTYPE OF(class_instance_expression,
	multiple_arity_generic_expression);
END_ENTITY; -- multiple_arity_class_instance_expression

ENTITY unary_class_instance_constructor
SUBTYPE OF(class_instance_constructor,
	unary_class_instance_expression);
	SELF\class_instance_constructor.properties:
		SET [1:1] OF property_assignment;
DERIVE
	SELF\unary_generic_expression.operand: library_expression
		:= collects_referenced_library_expressions(
		SELF.properties)[1];
END_ENTITY; -- unary_class_instance_constructor

ENTITY binary_class_instance_constructor
SUBTYPE OF(class_instance_constructor,
	binary_class_instance_expression);
	SELF\class_instance_constructor.properties: 
		SET [2:2] OF property_assignment;
DERIVE
	SELF\binary_generic_expression.operands:
		LIST [2:2] OF library_expression
		:= collects_referenced_library_expressions(SELF.properties);
WHERE
	WR1: SIZEOF(list_to_set(collects_assigned_properties(
		SELF.properties)))
		= SIZEOF(collects_assigned_properties(SELF.properties));
END_ENTITY; -- binary_class_instance_constructor

ENTITY multiple_arity_class_instance_constructor
SUBTYPE OF(class_instance_constructor,
	multiple_arity_class_instance_expression);
	SELF\class_instance_constructor.properties: 
		SET [2:?] OF property_assignment;
DERIVE
	SELF\multiple_arity_generic_expression.operands:
		LIST [2:?] OF library_expression
		:= collects_referenced_library_expressions(SELF.properties);
WHERE
	WR1: SIZEOF(list_to_set(collects_assigned_properties(
		SELF.properties)))
		= SIZEOF(collects_assigned_properties(SELF.properties));
END_ENTITY; -- multiple_arity_class_instance_constructor

ENTITY exists_value
SUBTYPE OF(unary_generic_expression, boolean_defined_function);
	for_variable: library_variable;
DERIVE
	SELF\unary_generic_expression.operand: generic_expression
		:= SELF.for_variable;
END_ENTITY; -- exists_value

ENTITY instance_comparison_equal
SUBTYPE OF(binary_generic_expression, boolean_defined_function);
WHERE
	WR1: ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.LIBRARY_EXPRESSION' IN
		TYPEOF (SELF\binary_generic_expression.operands[1]))
		AND ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.LIBRARY_EXPRESSION'
		IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY; -- instance_comparison_equal

RULE two_fold_variable_representation_rule FOR(variable_semantics);
WHERE
	WR1: QUERY(vs <* variable_semantics
		| SIZEOF(syntax_of(vs)) > 1) = [];
END_RULE; -- two_fold_variable_representation_rule

FUNCTION syntax_of(sem: variable_semantics): SET OF generic_variable;
	
LOCAL
	env: BAG OF environment;
	vars: SET OF generic_variable;
END_LOCAL;

env := USEDIN(sem,
	'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.ENVIRONMENT.SEMANTICS');
vars := [];

REPEAT i := LOINDEX(env) TO HIINDEX(env);
	vars := vars + env[i].syntactic_representation;
END_REPEAT;		

RETURN(vars);

END_FUNCTION; -- syntax_of

FUNCTION semantics_of(vars: generic_variable): variable_semantics;
	
RETURN(vars.interpretation.semantics);

END_FUNCTION; -- semantics_of

FUNCTION collects_assigned_properties(
	p_a: AGGREGATE OF property_assignment): LIST OF property_BSU;

LOCAL
	assign_prop: LIST OF property_BSU;
	-- assigned properties of the
	-- multiple_arity_class_instance_constructor
END_LOCAL;

assign_prop := [];

REPEAT i := 1 TO SIZEOF(p_a);
	assign_prop := assign_prop + p_a[i].prop_def;
END_REPEAT;

RETURN(assign_prop);

END_FUNCTION; -- collects_assigned_properties

FUNCTION collects_referenced_library_expressions(
	p_a: AGGREGATE OF property_assignment)
	: LIST [1:?] OF library_expression;

LOCAL
	assign_exp: LIST [0:?] OF library_expression := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(p_a);
	IF EXISTS(p_a[i].its_value)
	THEN
		assign_exp := assign_exp + p_a[i].its_value;
	END_IF;
END_REPEAT;

RETURN(assign_exp);

END_FUNCTION; -- collects_referenced_library_expressions


FUNCTION compatible_simple_type_and_expression(
	dom: property_or_data_type_BSU; expr: expression): LOGICAL;

IF (data_type_typeof(dom) = [])
THEN
	RETURN(UNKNOWN);
END_IF;

IF (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(expr))
	AND is_int_expr(expr))
THEN
	IF (('ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_TYPE' IN 
		data_type_typeof(dom)) OR
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.NUMBER_TYPE' IN
		data_type_typeof(dom))
		AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_TYPE' IN
		data_type_typeof(dom))))
	THEN 
		RETURN(TRUE);
	ELSE 
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(expr))
	AND NOT is_int_expr(expr)
THEN
	IF (('ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_TYPE' IN
		data_type_typeof(dom)) OR
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.NUMBER_TYPE' IN
		data_type_typeof(dom))
		AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_TYPE' IN
		data_type_typeof(dom))))
	THEN 
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(expr))
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.BOOLEAN_TYPE' IN 
		data_type_typeof(dom))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(expr))
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.STRING_TYPE' IN
		data_type_typeof(dom))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF; -- all simple types have been considered

END_FUNCTION; -- compatible_simple_type_and_expression

FUNCTION compatible_type_and_library_expression(
	dom: property_or_data_type_BSU; 
	expr: library_expression): LOGICAL;

LOCAL
	temp: SET[0:1] OF class_BSU;
END_LOCAL;

IF (data_type_typeof(dom) = [])
THEN 
	RETURN(UNKNOWN);
END_IF;


IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.LEVEL_SPEC_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.LEVEL_TYPE'
		IN data_type_typeof(dom))
		AND (list_to_set(data_type_level_spec(dom))
		= list_to_set(expr\level_spec_expression.levels))
		AND (TYPEOF(expr\level_spec_expression.value_type)
		<= data_type_level_value_typeof(dom))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;


IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.ENTITY_INSTANCE_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN data_type_typeof(dom))
		AND (data_type_type_name(dom)
		<= expr\entity_instance_expression.type_name)
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;


IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.CLASS_INSTANCE_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE'
		IN data_type_typeof(dom)) AND
		(SIZEOF(data_type_class_of(dom)) = 1)
	THEN
		temp := data_type_class_of(dom);
		RETURN(compatible_class_and_class(
			temp[1], expr\class_instance_expression.expr_type));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;


RETURN(compatible_simple_type_and_expression(dom, expr));

END_FUNCTION; -- compatible_type_and_library_expression

FUNCTION compatible_variable_and_expression(va: generic_variable;
	expr: expression): LOGICAL;

IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(expr))
	AND is_int_expr(expr)
THEN
	IF ('ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE'
		IN TYPEOF(va))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(expr))

THEN
	IF ('ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE'
		IN TYPEOF(va))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(expr))
THEN
	IF('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_VARIABLE' IN TYPEOF(va))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_EXPRESSIONS_SCHEMA.STRING_VARIABLE' IN TYPEOF(va))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

-- all simple types have been considered
RETURN(UNKNOWN);

END_FUNCTION; -- compatible_variable_and_expression

FUNCTION compatible_variable_and_library_expression(
	va: library_variable; expr: library_expression): LOGICAL;


IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.LEVEL_SPEC_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF (('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.LEVEL_SPEC_VARIABLE'
		IN TYPEOF(va))
		AND ((list_to_set(va\level_spec_expression.levels))
		= list_to_set(expr\level_spec_expression.levels))
		AND (TYPEOF(va\level_spec_expression.value_type)
		<= TYPEOF(expr\level_spec_expression.value_type)))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;


IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.ENTITY_INSTANCE_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.ENTITY_INSTANCE_VARIABLE'
		IN TYPEOF(va))
		AND (va\entity_instance_expression.type_name
		<= expr\entity_instance_expression.type_name)
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;


IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.CLASS_INSTANCE_EXPRESSION'
	IN TYPEOF(expr))
THEN
	IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.CLASS_INSTANCE_VARIABLE'
		IN TYPEOF(va))
	THEN
		RETURN(compatible_class_and_class(
			va\class_instance_expression.expr_type,
			expr\class_instance_expression.expr_type));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;


RETURN(compatible_variable_and_expression(va, expr));

END_FUNCTION; -- compatible_variable_and_library_expression

END_SCHEMA; -- ISO13584_library_expressions_schema

SCHEMA ISO13584_table_resource_schema;

REFERENCE FROM ISO13584_IEC61360_dictionary_schema
	(class_BSU,
	date_type,
	level,
	list_to_set,
	revision_len,
	revision_type,
	value_format_len,
	value_format_type);

REFERENCE FROM ISO13584_generic_expressions_schema
	(binary_generic_expression,
	generic_expression,
	generic_literal,
	generic_variable,
	multiple_arity_generic_expression,
	simple_generic_expression,
	unary_generic_expression,
	used_variables,
	variable_semantics);

REFERENCE FROM ISO13584_expressions_schema
	(boolean_defined_function,
	expression,
	is_sql_mappable,
	SQL_mappable_defined_function,
	variable);

REFERENCE FROM ISO13584_instance_resource_schema
	(boolean_value,
	compatible_class_and_class,
	complex_value,
	dic_class_instance,
	entity_instance_value,
	int_level_spec_value,
	integer_value,
	level_spec_value,
	null_or_boolean_value,
	null_or_complex_value,
	null_or_dic_class_instance,
	null_or_entity_instance_value,
	null_or_int_level_spec_value,
	null_or_integer_value,
	null_or_level_spec_value,
	null_or_number_value,
	null_or_primitive_value,
	null_or_real_level_spec_value,
	null_or_real_value,
	null_or_simple_value,
	null_or_translatable_string_value,
	number_value,
	primitive_value,
	real_level_spec_value,
	real_value,
	right_values_for_level_spec,
	same_translations,
	simple_value,
	string_value,
	translatable_string_value,
	translated_string_value);

REFERENCE FROM ISO13584_library_expressions_schema
	(class_instance_expression,
	compatible_variable_and_expression,
	entity_instance_expression,
	entity_instance_variable,
	level_spec_expression,
	level_spec_variable,
	semantics_of,
	syntax_of);

ENTITY table_identification
ABSTRACT SUPERTYPE;
WHERE
	WR1: SIZEOF(USEDIN(SELF,
		'ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_SPECIFICATION'
		+ '.TABLE_IDENTIFIER'))
		<= 1;
	WR2: SIZEOF(USEDIN(SELF,
		'ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_EXTENSION'
		+ '.TABLE_IDENTIFIER')) <= 1;
END_ENTITY; -- table_identification

ENTITY table_specification
SUPERTYPE OF(RDB_table_specification);
	table_identifier: table_identification;
	column_meaning: LIST[1:?] OF UNIQUE variable_semantics;
	key: SET[1:?] OF variable_semantics;
WHERE
	WR1: SELF.key <= list_to_set(SELF.column_meaning);
END_ENTITY; -- table_specification

ENTITY RDB_table_specification
SUBTYPE OF(table_specification);
WHERE
	WR1: QUERY(col <* SELF\table_specification.column_meaning |
		QUERY(v <* syntax_of(col) |
		NOT('ISO13584_EXPRESSIONS_SCHEMA.VARIABLE'
			IN TYPEOF(v))) <> []) = [];
	WR2: (SIZEOF(USEDIN(SELF\table_specification.table_identifier,
		'ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_EXTENSION' +
		'.TABLE_IDENTIFIER')) = 0)
		OR ('ISO13584_TABLE_RESOURCE_SCHEMA.RDB_TABLE_EXTENSION'
		IN TYPEOF(USEDIN(SELF\table_specification.table_identifier,
		'ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_EXTENSION'+
		'.TABLE_IDENTIFIER')[1]));
END_ENTITY; -- RDB_table_specification

ENTITY table_extension
SUPERTYPE OF(rdb_table_extension);
	table_identifier: table_identification;
	content: LIST[1:?] OF UNIQUE column;
	revision_of_content: revision_type;
	content_revision_date: date_type;
WHERE
	WR1: QUERY(col <* SELF.content | SIZEOF(col.values) <>
		SIZEOF(SELF.content[1].values)) = [];
	WR2: (SIZEOF(USEDIN(SELF.table_identifier,
		'ISO13584_TABLE_RESOURCE_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')) = 0) OR
		compatible_list_variable_semantics_and_columns(
		USEDIN(SELF.table_identifier,
		'ISO13584_TABLE_RESOURCE_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')[1].
		column_meaning, SELF.content);
	WR3: (SIZEOF(USEDIN(SELF.table_identifier,
		'ISO13584_TABLE_RESOURCE_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')) = 0) OR
		no_null_values_in_key_columns(USEDIN(SELF.table_identifier,
		'ISO13584_TABLE_RESOURCE_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')[1].
		column_meaning, USEDIN(SELF.table_identifier,
		'ISO13584_TABLE_RESOURCE_SCHEMA' +
		'.TABLE_SPECIFICATION.TABLE_IDENTIFIER')[1].
		key, SELF.content);
	WR4: same_translations_for_table_extension(SELF.content);
END_ENTITY; -- table_extension

ENTITY RDB_table_extension
SUBTYPE OF(table_extension);
	SELF\table_extension.content: LIST[1:?] OF UNIQUE simple_column;
WHERE
	WR1: (SIZEOF(USEDIN(SELF\table_extension.table_identifier,
		'ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_SPECIFICATION' +
		'.TABLE_IDENTIFIER')) = 0) OR
		('ISO13584_TABLE_RESOURCE_SCHEMA.RDB_TABLE_SPECIFICATION'
		IN TYPEOF(USEDIN(SELF\table_extension.table_identifier,
		'ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_SPECIFICATION' +
		'.TABLE_IDENTIFIER')[1]));
END_ENTITY; -- RDB_table_extension

ENTITY column
ABSTRACT SUPERTYPE OF(ONEOF(simple_column, complex_column));
	values: LIST [1:?] OF null_or_primitive_value;
INVERSE
	belongs_to: table_extension FOR content;
END_ENTITY; -- column

ENTITY simple_column
ABSTRACT SUPERTYPE OF(ONEOF(boolean_column, formatted_column))
SUBTYPE OF(column);
	SELF\column.values: LIST [1:?] OF null_or_simple_value;
END_ENTITY; -- simple_column

ENTITY boolean_column
SUBTYPE OF(simple_column);
	SELF\column.values: LIST [1:?] OF null_or_boolean_value;
END_ENTITY; -- boolean_column

ENTITY formatted_column
ABSTRACT SUPERTYPE OF(ONEOF(number_column, string_column))
SUBTYPE OF(simple_column);
	value_format: OPTIONAL value_format_type;
END_ENTITY; -- formatted_column

ENTITY number_column
ABSTRACT SUPERTYPE OF(ONEOF(real_column, integer_column))
SUBTYPE OF(formatted_column);
	SELF\column.values: LIST [1:?] OF null_or_number_value;
END_ENTITY; -- number_column

ENTITY real_column
SUBTYPE OF(number_column);
	SELF\column.values: LIST [1:?] OF null_or_real_value;
WHERE
	WR1: NOT(EXISTS(SELF\formatted_column.value_format)) OR(
		(SELF\formatted_column.value_format) LIKE 'NR2*');
END_ENTITY; -- real_column

ENTITY integer_column
SUBTYPE OF(number_column);
	SELF\column.values: LIST [1:?] OF null_or_integer_value;
WHERE
	WR1: NOT(EXISTS(SELF\formatted_column.value_format)) OR(
		(SELF\formatted_column.value_format) LIKE 'NR1*');
END_ENTITY; -- integer_column

ENTITY string_column
SUBTYPE OF(formatted_column);
	SELF\column.values: LIST [1:?] OF 
			null_or_translatable_string_value;
WHERE
	WR1: NOT (EXISTS(SELF\formatted_column.value_format)) OR (
		(((SELF\formatted_column.value_format) LIKE 'A*')
		OR ((SELF\formatted_column.value_format) LIKE 'M*')
		OR ((SELF\formatted_column.value_format) LIKE 'N*')
		OR ((SELF\formatted_column.value_format) LIKE 'X*'))
		AND NOT((SELF\formatted_column.value_format) LIKE 'NR*'));
	WR2: same_translations_for_string_values(SELF\column.values);
END_ENTITY; -- string_column

ENTITY complex_column
ABSTRACT SUPERTYPE OF(ONEOF(level_spec_column,
	entity_instance_column,
	class_instance_column))
SUBTYPE OF(column);
	SELF\column.values: LIST [1:?] OF null_or_complex_value;
END_ENTITY; -- complex_column

ENTITY level_spec_column
ABSTRACT SUPERTYPE OF(ONEOF(
	int_level_spec_column, real_level_spec_column))
SUBTYPE OF(complex_column);
	levels: LIST [1:4] OF UNIQUE level;
	SELF\column.values: LIST [1:?] OF null_or_level_spec_value;
WHERE
	WR1: QUERY(inst <* SELF\column.values
		| NOT right_values_for_level_spec(SELF.levels, inst)) = [];
END_ENTITY; -- level_spec_column

ENTITY int_level_spec_column
SUBTYPE OF(level_spec_column);
	SELF\column.values: LIST [1:?] OF null_or_int_level_spec_value;
END_ENTITY; -- int_level_spec_column

ENTITY real_level_spec_column
SUBTYPE OF(level_spec_column);
	SELF\column.values: LIST [1:?] OF null_or_real_level_spec_value;
END_ENTITY; -- real_level_spec_column

ENTITY entity_instance_column
SUBTYPE OF(complex_column);
	type_name: SET [1:?] OF STRING;
	SELF\column.values: LIST [1:?] OF null_or_entity_instance_value;
WHERE
	WR1: QUERY(inst <* SELF\column.values
		| (NOT('ISO13584_INSTANCE_RESOURCE_SCHEMA.NULL_VALUE'
		IN TYPEOF(inst)))
		AND (NOT(SELF.type_name <= TYPEOF(inst)))) = [];
END_ENTITY; -- entity_instance_column

ENTITY class_instance_column
SUBTYPE OF(complex_column);
	class_ref: class_BSU;
	SELF\column.values: LIST [1:?] OF null_or_dic_class_instance;
WHERE
	WR1: QUERY(inst <* SELF\column.values
		| (NOT('ISO13584_INSTANCE_RESOURCE_SCHEMA.NULL_VALUE'
		IN TYPEOF(inst)))
		AND (NOT compatible_class_and_class(SELF.class_ref,
		inst\dic_class_instance.class_def))) = [];
END_ENTITY; -- class_instance_column

ENTITY table_expression
ABSTRACT SUPERTYPE OF(ONEOF(simple_table_expression,
	unary_table_expression,
	binary_table_expression,
	multiple_arity_table_expression,
	select_expression))
SUBTYPE OF(generic_expression);
DERIVE
	its_columns: LIST[1:?] OF variable_semantics
		:= collects_columns(SELF);
	the_key: SET[1:?] OF variable_semantics := return_key(SELF);
	is_SQL_mappable: LOGICAL
		:= is_SQL_mappable_table_expression(SELF);
WHERE
	WR1: QUERY(sem <* its_columns
		| SIZEOF(QUERY(sem_2 <* its_columns
		| sem_2 :=: sem)) <> 1) = [];
END_ENTITY; -- table_expression

ENTITY column_traversal_variable_semantics
SUBTYPE OF(variable_semantics);
	ctxt: table_expression;
	domain: variable_semantics;
WHERE
	WR1: SELF.domain IN SELF.ctxt.its_columns;
	WR2: (SIZEOF(USEDIN(SELF,'ISO13584_GENERIC_EXPRESSIONS_SCHEMA'
		+'.ENVIRONMENT.SEMANTICS')) = 0)
		OR compatible_variable_semantics_and_expression(
		SELF.domain,USEDIN(SELF,'ISO13584_GENERIC_EXPRESSIONS_SCHEMA'
		+'.ENVIRONMENT.SEMANTICS')[1].syntactic_representation);
END_ENTITY; -- column_traversal_variable_semantics

ENTITY unary_table_expression
ABSTRACT SUPERTYPE OF(projection_expression)
SUBTYPE OF(table_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: table_expression;
END_ENTITY; -- unary_table_expression

ENTITY binary_table_expression
ABSTRACT SUPERTYPE OF(ONEOF(set_table_expression,
	natural_join_expression))
SUBTYPE OF(table_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands:
		LIST [2:2] OF table_expression;
END_ENTITY; -- binary_table_expression

ENTITY multiple_arity_table_expression
ABSTRACT SUPERTYPE OF(multiple_arity_cartesian_product)
SUBTYPE OF(table_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands:
		LIST [2:?] OF table_expression;
END_ENTITY; -- multiple_arity_table_expression

ENTITY simple_table_expression
ABSTRACT SUPERTYPE OF(ONEOF(
	table_variable,
	table_literal))
SUBTYPE OF(table_expression, simple_generic_expression);
END_ENTITY; -- simple_table_expression

ENTITY table_variable
SUPERTYPE OF(RDB_table_variable)
SUBTYPE OF(simple_table_expression, generic_variable);
	structure: LIST [1:?] OF variable_semantics;
	its_key: SET [1:?] OF variable_semantics;
WHERE
	WR1: SELF.its_key <= list_to_set(SELF.structure);
END_ENTITY; -- table_variable

ENTITY RDB_table_variable
SUBTYPE OF(table_variable);
WHERE
	WR1: QUERY(col <* SELF\table_expression.its_columns |
		QUERY(v <* syntax_of(col) |
		NOT('ISO13584_EXPRESSIONS_SCHEMA.VARIABLE'
		IN TYPEOF(v))) <> []) = [];
END_ENTITY; -- RDB_table_variable

ENTITY table_literal
SUBTYPE OF(simple_table_expression, generic_literal);
	the_value: table_identification;
WHERE
	WR1: SIZEOF(USEDIN(SELF.the_value,
		'ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_SPECIFICATION'
		+ '.TABLE_IDENTIFIER')) = 1;
END_ENTITY; -- table_literal

ENTITY set_table_expression
ABSTRACT SUPERTYPE OF(ONEOF(
	union_table_expression,
	intersect_table_expression,
	difference_table_expression))
SUBTYPE OF(binary_table_expression);
WHERE
	WR1: SELF\binary_generic_expression.operands[1]
		\table_expression.its_columns =
		SELF\binary_generic_expression.operands[2]
		\table_expression.its_columns;
END_ENTITY; -- set_table_expression

ENTITY union_table_expression
SUBTYPE OF(set_table_expression);
END_ENTITY; -- union_table_expression

ENTITY intersect_table_expression
SUBTYPE OF(set_table_expression);

END_ENTITY; -- intersect_table_expression

ENTITY difference_table_expression
SUBTYPE OF(set_table_expression);
END_ENTITY; -- difference_table_expression

ENTITY multiple_arity_cartesian_product
SUBTYPE OF(multiple_arity_table_expression);
	SELF\multiple_arity_generic_expression.operands:
		LIST [2:?] OF table_expression;
END_ENTITY; -- multiple_arity_cartesian_product

ENTITY in_RDB_table_boolean_expression
SUBTYPE OF(multiple_arity_generic_expression,
		boolean_defined_function,
		SQL_mappable_defined_function);
DERIVE
	from_table: generic_expression :=
		SELF\multiple_arity_generic_expression.operands[1];
	tuple: LIST[1:?] OF generic_expression
		:= QUERY(element <* SELF\multiple_arity_generic_expression
		.operands | 'ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION'
		IN TYPEOF(element));
WHERE
	WR1: ('ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_EXPRESSION'
		IN TYPEOF(from_table))
		AND is_sql_mappable_table_expression(from_table);
	WR2: SIZEOF(QUERY(simple_expr <*
		QUERY(expr <* SELF\multiple_arity_generic_expression.operands 
		| ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION'
		IN TYPEOF(expr))) | is_sql_mappable(simple_expr)))
		= SIZEOF(SELF\multiple_arity_generic_expression.operands)- 1;
	WR3: SIZEOF(from_table\table_expression.its_columns)
		= SIZEOF(tuple);
	WR4: compatible_list_variable_semantics_and_expressions
		(SELF.from_table\table_expression.its_columns, SELF.tuple);
	WR5: QUERY(e <* tuple | QUERY(v <* used_variables(e)
		| ('ISO13584_TABLE_RESOURCE_SCHEMA'
		+ '.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS')
		IN TYPEOF(v.interpretation.semantics)) <> []) = [];
END_ENTITY; -- in_RDB_table_boolean_expression

ENTITY select_expression
SUBTYPE OF(table_expression, binary_generic_expression);
DERIVE
	from_table: generic_expression :=
		SELF\binary_generic_expression.operands[1];
	condition: generic_expression :=
		SELF\binary_generic_expression.operands[2];
WHERE
	WR1: 'ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_EXPRESSION'
		IN TYPEOF(SELF.from_table);
	WR2: 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION'
		IN TYPEOF(SELF.condition);
	WR3: QUERY(va <* used_variables(SELF.condition) |
		NOT('ISO13584_EXPRESSIONS_SCHEMA.VARIABLE'
		IN TYPEOF(va))) = [];
	WR4: QUERY(v <* used_variables(SELF.condition) |
		(NOT(check_iterator_context(SELF, v)) OR NOT
		check_iterator_domain_uniqueness(SELF, v))) = [];
END_ENTITY; -- select_expression

ENTITY projection_expression
SUBTYPE OF(unary_table_expression);
	argts_var: SET[1:?] OF variable_semantics;
DERIVE
	from_table: table_expression :=
		SELF\unary_table_expression.operand;
WHERE
	WR1: SELF.argts_var <= list_to_set(SELF\unary_table_expression.
		operand.its_columns);
END_ENTITY; -- projection_expression

ENTITY natural_join_expression
SUBTYPE OF(binary_table_expression);
DERIVE
	table_1: table_expression :=
		SELF\binary_table_expression.operands[1];
	table_2: table_expression :=
		SELF\binary_table_expression.operands[2];
WHERE
	WR1: SIZEOF(list_to_set(table_1\table_expression.its_columns) *
		list_to_set(table_2\table_expression.its_columns)) > 0;
END_ENTITY; -- natural_join_expression

FUNCTION compatible_column_and_variable(col: column;
	v: generic_variable): LOGICAL;



IF ('ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(v))
THEN
	RETURN(('ISO13584_TABLE_RESOURCE_SCHEMA.INTEGER_COLUMN'
		IN TYPEOF(col)) OR
		(('ISO13584_TABLE_RESOURCE_SCHEMA.NUMBER_COLUMN'
		IN TYPEOF(col))
		AND NOT('ISO13584_TABLE_RESOURCE_SCHEMA.REAL_COLUMN'
		IN TYPEOF(col))));
END_IF;

IF ('ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(v))
THEN
	RETURN(('ISO13584_TABLE_RESOURCE_SCHEMA.REAL_COLUMN'
		IN TYPEOF(col))
		OR (('ISO13584_TABLE_RESOURCE_SCHEMA.NUMBER_COLUMN'
		IN TYPEOF(col))
		AND NOT('ISO13584_TABLE_RESOURCE_SCHEMA.INTEGER_COLUMN'
		IN TYPEOF(col))));
END_IF;

IF ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_VARIABLE' IN TYPEOF(v))
THEN
	RETURN('ISO13584_TABLE_RESOURCE_SCHEMA.BOOLEAN_COLUMN'
	IN TYPEOF(col));
END_IF;

IF ('ISO13584_EXPRESSIONS_SCHEMA.STRING_VARIABLE' IN TYPEOF(v))
THEN
	RETURN('ISO13584_TABLE_RESOURCE_SCHEMA.STRING_COLUMN'
	IN TYPEOF(col));
END_IF;



IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.ENTITY_INSTANCE_VARIABLE')
	IN TYPEOF(v)
THEN
	RETURN(('ISO13584_TABLE_RESOURCE_SCHEMA.ENTITY_INSTANCE_COLUMN'
		IN TYPEOF(col))
		AND (v\entity_instance_expression.type_name
<= col\entity_instance_column.type_name));
END_IF;

IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.CLASS_INSTANCE_VARIABLE')
	IN TYPEOF(v)
THEN
	IF ('ISO13584_TABLE_RESOURCE_SCHEMA.CLASS_INSTANCE_COLUMN'
		IN TYPEOF(col))
	THEN
		RETURN(compatible_class_and_class
			(v\class_instance_expression.expr_type,
			col\class_instance_column.class_ref));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

IF ('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA.LEVEL_SPEC_VARIABLE')
	IN TYPEOF(v) THEN
	IF ('ISO13584_TABLE_RESOURCE_SCHEMA.LEVEL_SPEC_COLUMN'
		IN TYPEOF(col))
	THEN
		IF (list_to_set(v\level_spec_expression.levels)
			= list_to_set(col\level_spec_column.levels))
		THEN
			IF (('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA'
				+'.INT_LEVEL_SPEC_VARIABLE' IN TYPEOF(v))
				AND NOT('ISO13584_TABLE_RESOURCE_SCHEMA' +
				'.INT_LEVEL_SPEC_COLUMN' IN TYPEOF(col)))
			THEN
				RETURN(FALSE);
			END_IF;
			IF (('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA'
				+'.REAL_LEVEL_SPEC_VARIABLE' IN TYPEOF(v))
				AND NOT('ISO13584_TABLE_RESOURCE_SCHEMA' +
				'.REAL_LEVEL_SPEC_COLUMN' IN TYPEOF(col)))
			THEN
				RETURN(FALSE);
			END_IF;
			RETURN(TRUE);
		ELSE
			RETURN(FALSE);
		END_IF;
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

RETURN(FALSE);

END_FUNCTION; -- compatible_column_and_variable

FUNCTION compatible_column_and_variable_semantics(col: column;
	sem: variable_semantics): LOGICAL;

LOCAL
	va: SET OF generic_variable;
END_LOCAL;

va := syntax_of(sem);
IF SIZEOF(va) = 0
THEN
	RETURN(UNKNOWN);
ELSE
	REPEAT i := LOINDEX(va) TO HIINDEX(va);
		IF (NOT compatible_column_and_variable(col, va[i]))
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- compatible_column_and_variable_semantics

FUNCTION compatible_list_variable_semantics_and_columns(
	sem: LIST [0:?] of variable_semantics;
	col: LIST [0:?] of column): LOGICAL;

LOCAL
	res: LOGICAL;
END_LOCAL;

IF SIZEOF(sem) <> SIZEOF(col)
THEN
	RETURN(FALSE);
END_IF;

res := TRUE;	

REPEAT i := LOINDEX(col) TO HIINDEX(col);
	res := res AND
		compatible_column_and_variable_semantics(col[i], sem[i]);
END_REPEAT;

RETURN(res);

END_FUNCTION; -- compatible_list_variable_semantics_and_columns

FUNCTION compatible_variable_semantics_and_expression(
	sem: variable_semantics; expr: expression): LOGICAL;

LOCAL
	va: SET OF generic_variable;
END_LOCAL;

va := syntax_of(sem);
IF SIZEOF(va) = 0
THEN
	RETURN(UNKNOWN);
ELSE
	REPEAT i := LOINDEX(va) TO HIINDEX(va);
		IF (NOT compatible_variable_and_expression(va[i], expr))
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- compatible_variable_semantics_and_expression

FUNCTION compatible_list_variable_semantics_and_expressions(
	sem: LIST [0:?] of variable_semantics;
	exprs: LIST [0:?] of expression): LOGICAL;

LOCAL
	res: LOGICAL;
END_LOCAL;

IF SIZEOF(sem) <> SIZEOF(exprs)
THEN
	RETURN(FALSE);
END_IF;

res := TRUE;

REPEAT i := 1 TO SIZEOF(sem);
	res := res AND
	compatible_variable_semantics_and_expression(sem[i], exprs[i]);
END_REPEAT;

RETURN(res);

END_FUNCTION; -- compatible_list_variable_semantics_and_expressions

FUNCTION collects_columns(t: table_expression):
	LIST OF variable_semantics;

LOCAL
	res, tempo: LIST [0:?] OF variable_semantics := [];
	x: BAG [1:1] OF table_specification;
END_LOCAL;


IF ('ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_VARIABLE'IN TYPEOF(t))
THEN
	RETURN(t\table_variable.structure);
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_LITERAL' IN TYPEOF(t))
THEN
	x := USEDIN(t\table_literal.the_value,
		'ISO13584_TABLE_RESOURCE_SCHEMA'
		+ '.TABLE_SPECIFICATION.TABLE_IDENTIFIER');
	RETURN(x[1].column_meaning);	
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.NATURAL_JOIN_EXPRESSION'
	IN TYPEOF(t))
THEN
	RETURN(
	diff_columns(collects_columns(
		t\natural_join_expression.table_1),
		collects_columns(
		t\natural_join_expression.table_2)));
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.BINARY_TABLE_EXPRESSION'
	IN TYPEOF(t))
THEN
	RETURN(collects_columns(t\binary_table_expression.operands[1])+
	collects_columns(t\binary_table_expression.operands[2]));
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.MULTIPLE_ARITY_TABLE_EXPRESSION')
	IN TYPEOF(t) THEN
	REPEAT i := 1 TO
			SIZEOF(t\multiple_arity_table_expression.operands);
		res := res +
			collects_columns(t\multiple_arity_table_expression
			.operands[i]);
	END_REPEAT;
	RETURN(res);
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.SELECT_EXPRESSION' IN TYPEOF(t))
THEN
	RETURN(collects_columns(
		t\binary_generic_expression.operands[1]));
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.PROJECTION_EXPRESSION' 
	IN TYPEOF(t))
THEN
	REPEAT i := 1 TO SIZEOF(t\projection_expression.argts_var);
		tempo := tempo +t\projection_expression.argts_var[i];
	END_REPEAT;
	RETURN(tempo);
END_IF;

RETURN([]);

END_FUNCTION; -- collects_columns

FUNCTION diff_columns(l1, l2:LIST [1:?] OF variable_semantics):
	LIST [1:?] OF variable_semantics;

REPEAT i := 1 TO SIZEOF(l2);
	IF NOT(l2[i] IN l1)
	THEN
		l1 := l1 + l2[i];
	END_IF;
END_REPEAT;

RETURN(l1);
END_FUNCTION; -- diff_columns

FUNCTION return_key(t: table_expression): 
	SET [1:?] OF variable_semantics;

LOCAL
	res: SET [0:?] OF variable_semantics := [];
	x: BAG[1:1] OF table_specification;
END_LOCAL;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_VARIABLE'IN TYPEOF(t))
THEN
	RETURN(t\table_variable.its_key);
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_LITERAL' IN TYPEOF(t))
THEN
	x := USEDIN(t\table_literal.the_value,
		'ISO13584_TABLE_RESOURCE_SCHEMA.'
		+ 'TABLE_SPECIFICATION.TABLE_IDENTIFIER');
	RETURN(x[1]\table_specification.key);	
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.SELECT_EXPRESSION' IN TYPEOF(t))
THEN
	RETURN(return_key(t\binary_generic_expression.operands[1]));
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.PROJECTION_EXPRESSION' 
	IN TYPEOF(t))
THEN
	IF QUERY(col <* t\projection_expression.from_table.the_key | NOT
		(col IN t\projection_expression.argts_var)) <> []
	THEN
		RETURN(list_to_set(t\table_expression.its_columns));
	ELSE
		RETURN(t\projection_expression.from_table.the_key);
	END_IF;
END_IF;

IF (('ISO13584_TABLE_RESOURCE_SCHEMA.INTERSECT_TABLE_EXPRESSION'
		IN TYPEOF(t))
	OR
	('ISO13584_TABLE_RESOURCE_SCHEMA.DIFFERENCE_TABLE_EXPRESSION'
		IN TYPEOF(t)))
THEN
	RETURN(return_key(t\binary_table_expression.operands[1]));
END_IF;

IF (('ISO13584_TABLE_RESOURCE_SCHEMA.UNION_TABLE_EXPRESSION'
		IN TYPEOF(t))
	OR
	('ISO13584_TABLE_RESOURCE_SCHEMA.NATURAL_JOIN_EXPRESSION'
		IN TYPEOF(t)))
THEN
	RETURN(return_key(t\binary_table_expression.operands[1]) +
	return_key(t\binary_table_expression.operands[2]));
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.MULTIPLE_ARITY_TABLE_EXPRESSION' 
	IN TYPEOF(t))
THEN
	REPEAT i := 1 TO
	SIZEOF(t\multiple_arity_table_expression.operands);
		res := res
		+ return_key(t\multiple_arity_table_expression.operands[i]);
	END_REPEAT;
	RETURN(res);
END_IF;

RETURN([]);

END_FUNCTION; -- return_key

FUNCTION is_SQL_mappable_table_expression(
	arg: table_expression): LOGICAL;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.SIMPLE_TABLE_EXPRESSION'
	IN TYPEOF(arg))
THEN
	IF ('ISO13584_TABLE_RESOURCE_SCHEMA.RDB_TABLE_VARIABLE'
		IN TYPEOF(arg))
	THEN
		RETURN(TRUE);
	END_IF;
	IF ('ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_LITERAL'
		IN TYPEOF(arg))
	THEN
		IF (SIZEOF(USEDIN(arg\table_literal.the_value,
			'ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_SPECIFICATION'
			+ '.TABLE_IDENTIFIER')) = 1)
		THEN
			RETURN(('ISO13584_TABLE_RESOURCE_SCHEMA'
				+ '.RDB_TABLE_SPECIFICATION')
				IN TYPEOF(USEDIN(arg\table_literal.the_value,
				'ISO13584_TABLE_RESOURCE_SCHEMA'
				+ '.TABLE_SPECIFICATION.TABLE_IDENTIFIER')[1]));
		ELSE
			RETURN(UNKNOWN);
		END_IF;
	END_IF;
	RETURN(FALSE); -- table_variable that is not RDB_table_variable
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.UNARY_TABLE_EXPRESSION'
	IN TYPEOF(arg))
THEN
	RETURN(is_SQL_mappable_table_expression(
		arg\unary_table_expression.operand));
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.SELECT_EXPRESSION'
	IN TYPEOF(arg))
THEN
	RETURN(is_SQL_mappable_table_expression(
		arg\select_expression.from_table)
		AND is_SQL_mappable(arg\select_expression.condition));
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.BINARY_TABLE_EXPRESSION'
	IN TYPEOF(arg))
THEN
	RETURN(is_SQL_mappable_table_expression(
		arg\binary_table_expression.operands[1])
		AND Is_SQL_mappable_table_expression(
		arg\binary_table_expression.operands[2]));
END_IF;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.MULTIPLE_ARITY_TABLE_EXPRESSION'
	IN TYPEOF(arg))
THEN
	REPEAT i := 1 TO SIZEOF
		(arg\multiple_arity_table_expression.operands);
		IF NOT is_SQL_mappable_table_expression
			(arg\multiple_arity_table_expression.operands[i])
		THEN
			RETURN(FALSE);
		END_IF;
	END_REPEAT;
	
	RETURN(TRUE);
END_IF;

RETURN(UNKNOWN);

END_FUNCTION; -- is_SQL_mappable_table_expression

FUNCTION used_table_literals(arg: generic_expression):
	SET OF table_identification;

LOCAL
	result: SET OF table_identification := [];
END_LOCAL;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.TABLE_LITERAL' IN TYPEOF(arg))
THEN
	RETURN([arg\table_literal.the_value]);
END_IF;

IF ('ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION')
	IN TYPEOF(arg)
THEN
	RETURN(used_table_literals(
		arg\unary_generic_expression.operand));
END_IF;

IF ('ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF(arg))
THEN
	RETURN(used_table_literals(arg\binary_generic_expression
		.operands[1]) + used_table_literals(
		arg\binary_generic_expression.operands[2]));
END_IF;

IF ('ISO13584_GENERIC_EXPRESSIONS_SCHEMA.' + 
	'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg))
THEN
	REPEAT i := 1 TO 
		SIZEOF(arg\multiple_arity_generic_expression.operands);
		result := result + used_table_literals(
			arg\multiple_arity_generic_expression.operands[i]);
	END_REPEAT;
	RETURN(result);
END_IF;

RETURN([]);

END_FUNCTION; -- used_table_literals

FUNCTION check_iterator_context(expr: select_expression;
	v: generic_variable): LOGICAL;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA' +
	'.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS' IN
	TYPEOF(v.interpretation.semantics))
THEN
	IF (v.interpretation.semantics\
		column_traversal_variable_semantics.ctxt:<>: expr.from_table)
	THEN
		RETURN(FALSE);
	ELSE
		RETURN(TRUE);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- check_iterator_context

FUNCTION check_iterator_domain_uniqueness(expr: select_expression; 
	v: generic_variable): LOGICAL;

LOCAL
	vars: SET OF generic_variable := [];
	res: SET OF generic_variable := [];
END_LOCAL;

IF ('ISO13584_TABLE_RESOURCE_SCHEMA.'
	+ 'COLUMN_TRAVERSAL_VARIABLE_SEMANTICS' IN
	TYPEOF(v.interpretation.semantics))
THEN
	vars := used_variables(expr.condition);

	REPEAT i := 1 TO SIZEOF(vars);
		IF ('ISO13584_TABLE_RESOURCE_SCHEMA' +
			'.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS' IN
			TYPEOF(vars[i].interpretation.semantics))
		THEN
			IF (vars[i].interpretation.semantics\
				column_traversal_variable_semantics.domain
				:=: v.interpretation.semantics\
				column_traversal_variable_semantics.domain)
			THEN
				res := res + vars[i];
			END_IF;
		END_IF;
	END_REPEAT;

	RETURN(SIZEOF(res) = 1);
END_IF;
	
RETURN(UNKNOWN);

END_FUNCTION; -- check_iterator_domain_uniqueness

FUNCTION no_null_values_in_key_columns(
	the_columns: LIST[1:?] OF variable_semantics;
	the_key: SET[1:?] OF variable_semantics;
	the_values: LIST[1:?] OF column): BOOLEAN;
LOCAL
	sem: variable_semantics;
	result: BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(the_columns);
	sem := the_columns[i];
	IF(sem IN the_key) THEN
		REPEAT j := 1 TO SIZEOF(the_values[i].values);
			IF('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
				'.NULL_VALUE' IN TYPEOF(the_values[i].values[j]))
			THEN
				result := FALSE;
			END_IF;
		END_REPEAT;
	END_IF;
END_REPEAT;

RETURN(result);

END_FUNCTION; -- no_null_values_in_key_columns

FUNCTION same_translations_for_string_values(string_values:
	LIST OF null_or_translatable_string_value): LOGICAL;
LOCAL
	translated_values: SET OF translated_string_value := [];
	not_translated_values: LIST OF string_value := [];
END_LOCAL;

	translated_values := list_to_set(QUERY(val <* string_values |
		'ISO13584_INSTANCE_RESOURCE_SCHEMA.TRANSLATED_STRING_VALUE'
		IN TYPEOF(val)));
	not_translated_values := QUERY(val <* string_values |
		'ISO13584_INSTANCE_RESOURCE_SCHEMA.STRING_VALUE'
		IN TYPEOF(val));

	IF (SIZEOF(translated_values) <> 0)
	THEN
		IF (SIZEOF(not_translated_values) <> 0)
		THEN
			RETURN(FALSE);
		ELSE
			RETURN(same_translations(translated_values));
		END_IF;
	ELSE
		RETURN(UNKNOWN);
	END_IF;
END_FUNCTION; -- same_translations_for_string_values

FUNCTION same_translations_for_table_extension(
	content: LIST[1:?] OF column): BOOLEAN;
LOCAL
	translated_values: SET OF translated_string_value := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(content[1].values);
	translated_values := 
		get_translated_string_values_of_tuple(content, i);
	IF NOT(same_translations(translated_values))
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- same_translations_for_table_extension

FUNCTION get_translated_string_values_of_tuple(
	content: LIST[1:?] OF column; index: INTEGER): 
	SET OF translated_string_value;
LOCAL
	translated_values: SET OF translated_string_value := [];
END_LOCAL;

IF (index > SIZEOF(content[1].values))  -- abnormal case
THEN
	RETURN([]);
END_IF;

REPEAT i := 1 TO SIZEOF(content);
	IF ('ISO13584_INSTANCE_RESOURCE_SCHEMA.TRANSLATED_STRING_VALUE'
		IN TYPEOF(content[i].values[index]))
	THEN
		translated_values := translated_values + 
			content[i].values[index];
	END_IF;
END_REPEAT;

RETURN(translated_values);

END_FUNCTION; -- get_translated_string_values_of_tuple

END_SCHEMA; --ISO13584_table_resource_schema

SCHEMA ISO13584_variable_semantics_schema;

REFERENCE FROM ISO13584_IEC61360_dictionary_schema
	(property_BSU);

REFERENCE FROM ISO13584_generic_expressions_schema
	(variable_semantics);

REFERENCE FROM ISO13584_library_expressions_schema
	(compatible_type_and_library_expression,
	syntax_of);

REFERENCE FROM ISO13584_extended_dictionary_schema
	(applicable_properties,
	data_type_typeof,
	data_type_class_of);


TYPE property_semantics_or_path = SELECT(
	property_semantics,
	sub_property_path);
END_TYPE; -- property_semantics_or_path

ENTITY property_semantics
ABSTRACT SUPERTYPE OF(ONEOF(
	self_property_semantics,
	open_view_property_semantics))
SUBTYPE OF(variable_semantics);
	the_property: property_BSU;
	its_own_property: OPTIONAL sub_property_path;
WHERE
	WR1: check_property_semantics(SELF);
END_ENTITY; -- property_semantics

ENTITY sub_property_path;
	the_property: property_BSU;
	its_own_property: OPTIONAL sub_property_path;
WHERE
	WR1: (NOT(EXISTS(SELF.its_own_property)))
		OR (data_type_typeof(SELF.the_property) = [])
		OR
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE'
		IN data_type_typeof(SELF.the_property))
		AND applicable_properties(data_type_class_of(
		SELF.the_property)[1],[SELF.its_own_property.the_property]));
END_ENTITY; -- sub_property_path

ENTITY self_variable_semantics
ABSTRACT SUPERTYPE OF(ONEOF(
	self_property_semantics,
	self_class_variable_semantics))
SUBTYPE OF(variable_semantics);
END_ENTITY; -- self_variable_semantics

ENTITY self_property_semantics
ABSTRACT SUPERTYPE OF(ONEOF(
	self_property_value_semantics,
	self_property_name_semantics))
SUBTYPE OF(self_variable_semantics, property_semantics);
END_ENTITY; -- self_property_semantics

ENTITY self_property_value_semantics
SUBTYPE OF(self_property_semantics);
WHERE
	WR1: QUERY(v <* syntax_of(SELF)
		| NOT compatible_type_and_library_expression(
		BSU_of_property_semantics(SELF), v)) = [];
END_ENTITY; -- self_property_value_semantics

ENTITY self_property_name_semantics
ABSTRACT SUPERTYPE OF(ONEOF(
	self_property_preferred_name_semantics,
	self_property_short_name_semantics,
	self_property_code_semantics,
	self_property_version_semantics,
	self_property_class_code_semantics,
	self_property_class_supplier_code_semantics,
	self_property_class_version_semantics))
SUBTYPE OF(self_property_semantics);
WHERE
	WR1: QUERY(v <* syntax_of(SELF)
		| NOT('ISO13584_EXPRESSIONS_SCHEMA.STRING_VARIABLE'
		IN TYPEOF(v))) = [];
END_ENTITY; -- self_property_name_semantics

ENTITY self_property_preferred_name_semantics
SUBTYPE OF(self_property_name_semantics);
END_ENTITY; -- self_property_preferred_name_semantics

ENTITY self_property_short_name_semantics
SUBTYPE OF(self_property_name_semantics);
END_ENTITY; -- self_property_short_name_semantics

ENTITY self_property_code_semantics
SUBTYPE OF(self_property_name_semantics);
END_ENTITY; -- self_property_code_semantics

ENTITY self_property_version_semantics
SUBTYPE OF(self_property_name_semantics);
END_ENTITY; -- self_property_version_semantics

ENTITY self_property_class_code_semantics
SUBTYPE OF(self_property_name_semantics);
END_ENTITY; -- self_property_class_code_semantics

ENTITY self_property_class_supplier_code_semantics
SUBTYPE OF(self_property_name_semantics);
END_ENTITY; -- self_property_class_supplier_code_semantics

ENTITY self_property_class_version_semantics
SUBTYPE OF(self_property_name_semantics);
END_ENTITY; -- self_property_class_version_semantics

ENTITY self_class_variable_semantics
ABSTRACT SUPERTYPE OF(self_class_name_semantics)
SUBTYPE OF(self_variable_semantics);
END_ENTITY; -- self_class_variable_semantics

ENTITY self_class_name_semantics
ABSTRACT SUPERTYPE OF(ONEOF(
	self_class_preferred_name_semantics,
	self_class_short_name_semantics,
	self_class_code_semantics,
	self_class_supplier_code_semantics,
	self_class_version_semantics))
SUBTYPE OF(self_class_variable_semantics);
WHERE
	WR1: SIZEOF(QUERY(v <* syntax_of(SELF) | NOT
		('ISO13584_EXPRESSIONS_SCHEMA.STRING_VARIABLE'
		IN TYPEOF(v)))) = 0;
END_ENTITY; -- self_class_name_semantics

ENTITY self_class_preferred_name_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_preferred_name_semantics

ENTITY self_class_short_name_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_short_name_semantics

ENTITY self_class_code_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_code_semantics

ENTITY self_class_supplier_code_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_supplier_code_semantics

ENTITY self_class_version_semantics
SUBTYPE OF(self_class_name_semantics);
END_ENTITY; -- self_class_version_semantics

ENTITY open_view_variable_semantics
ABSTRACT SUPERTYPE OF(open_view_property_semantics)
SUBTYPE OF(variable_semantics);
END_ENTITY; -- open_view_variable_semantics

ENTITY open_view_property_semantics
ABSTRACT SUPERTYPE OF(open_view_property_value_semantics)
SUBTYPE OF(open_view_variable_semantics, property_semantics);
END_ENTITY; -- open_view_property_semantics

ENTITY open_view_property_value_semantics
SUBTYPE OF(open_view_property_semantics);
WHERE
	WR1: SIZEOF(QUERY(v <* syntax_of(SELF)
		| NOT compatible_type_and_library_expression(
		BSU_of_property_semantics(SELF), v))) = 0;
END_ENTITY; -- open_view_property_value_semantics

FUNCTION BSU_of_property_semantics(v: property_semantics_or_path):
	property_BSU;

LOCAL
	prop: property_BSU;
END_LOCAL;

prop := v.the_property;

IF EXISTS(v.its_own_property)
THEN
	RETURN(BSU_of_property_semantics(v.its_own_property));
ELSE
	RETURN(prop);
END_IF;

END_FUNCTION; -- BSU_of_property_semantics

FUNCTION check_property_semantics(sem: property_semantics): LOGICAL;

LOCAL
	res: LOGICAL;
END_LOCAL;

IF (EXISTS(sem.its_own_property)) AND 	NOT(data_type_typeof(sem.the_property) = [])
THEN
	res := ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE'
		IN data_type_typeof(sem.the_property))
		AND applicable_properties(data_type_class_of(
		sem.the_property)[1], [sem.its_own_property.the_property]);

	RETURN(res);
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- check_property_semantics

END_SCHEMA; -- ISO13584_variable_semantics_schema

SCHEMA ISO13584_domain_resource_schema;

REFERENCE FROM ISO13584_IEC61360_dictionary_schema
	(class_BSU,
	is_subclass,
	list_to_set);

REFERENCE FROM ISO13584_generic_expressions_schema
	(generic_variable,
	variable_semantics,
	used_variables);

REFERENCE FROM ISO13584_expressions_schema
	(boolean_expression,
	literal_number,
	numeric_expression);

REFERENCE FROM ISO13584_library_expressions_schema
	(class_instance_expression,
	compatible_variable_and_library_expression,
	library_expression,
	semantics_of,
	syntax_of);

REFERENCE FROM ISO13584_table_resource_schema
	(collects_columns,
	column_traversal_variable_semantics,
	table_expression,
	table_identification,
	used_table_literals);

REFERENCE FROM ISO13584_external_file_schema
	(message);

TYPE boolean_expression_or_others = SELECT(
	boolean_expression,
	others);
END_TYPE; -- boolean_expression_or_others

ENTITY others;
END_ENTITY; -- others

ENTITY domain_restriction
SUPERTYPE OF(functional_domain_restriction);
	defines: SET[1:?] OF variable_semantics;
	assumes: SET[0:?] OF variable_semantics;
	domains: SET[1:?] OF guarded_simple_domain;
	constraint_description: OPTIONAL message;
DERIVE
	base_tables: SET [0:?] OF table_identification
		:= used_tables_in_domain(SELF);
WHERE
	WR1: SIZEOF(QUERY(g <* SELF.domains |
		'ISO13584_DOMAIN_RESOURCE_SCHEMA.OTHERS'
		IN TYPEOF(g.guard))) = 1;
END_ENTITY; -- domain_restriction

ENTITY guarded_simple_domain;
	guard: boolean_expression_or_others;
	domain: simple_domain;
INVERSE
	item_of: domain_restriction FOR domains;
WHERE
	WR1: variables_belong_to_assumes(SELF);
END_ENTITY; -- guarded_simple_domain

ENTITY simple_domain
ABSTRACT SUPERTYPE OF(ONEOF(table_defined_domain,
	type_defined_domain,
	subclass_defined_domain,
	constant_range_defined_domain,
	variable_range_defined_domain,
	predicate_defined_domain,
	simple_functional_domain));
INVERSE
	referenced_by: guarded_simple_domain FOR domain;
END_ENTITY; -- simple_domain

ENTITY table_defined_domain
SUBTYPE OF(simple_domain);
	from_table: table_expression;
WHERE
	WR1: SELF\simple_domain.referenced_by.item_of.defines
		<= list_to_set(collects_columns(SELF.from_table));
	WR2: QUERY(sem <* collects_var_sem(
		used_variables(SELF.from_table))
		| NOT((sem IN
		(SELF\simple_domain.referenced_by.item_of.assumes
		+ SELF\simple_domain.referenced_by.item_of.defines))
		OR ((('ISO13584_TABLE_RESOURCE_SCHEMA'
		+ '.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS')
		IN TYPEOF(sem))) AND
		(sem\column_traversal_variable_semantics.domain
		IN collects_columns(SELF.from_table)))) = [];
END_ENTITY; -- table_defined_domain

ENTITY type_defined_domain
SUBTYPE OF(simple_domain);
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by
		.item_of.defines) = 1;
END_ENTITY; -- type_defined_domain

ENTITY subclass_defined_domain
SUBTYPE OF(simple_domain);
	from_class: class_BSU;
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines) 
		= 1;
	WR2: QUERY(va <* collects_variables(
		SELF\simple_domain.referenced_by.item_of.defines)
		| NOT('ISO13584_LIBRARY_EXPRESSIONS_SCHEMA'
		+ '.CLASS_INSTANCE_VARIABLE' IN TYPEOF(va))) = [];
	WR3: QUERY(va <* collects_variables(
		SELF\simple_domain.referenced_by.item_of.defines)
		| NOT is_subclass(SELF.from_class.definition[1],
		va\class_instance_expression.expr_type.definition[1])) = [];
END_ENTITY; -- subclass_defined_domain

ENTITY constant_range_defined_domain
SUBTYPE OF(simple_domain);
	minimal: literal_number;
	maximal: literal_number;
	step: OPTIONAL literal_number;
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines)
		= 1;
	WR2: minimal.the_value <= maximal.the_value;
	WR3: QUERY(va <* collects_variables(
		SELF\simple_domain.referenced_by.item_of.defines) | NOT
		('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_VARIABLE'
		IN TYPEOF(va))) = [];
	WR4: (NOT EXISTS(SELF.step)) OR (SELF.step.the_value > 0);
END_ENTITY; -- constant_range_defined_domain

ENTITY variable_range_defined_domain
SUBTYPE OF(simple_domain);
	minimal: numeric_expression;
	maximal: numeric_expression;
	step: OPTIONAL numeric_expression;
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines)
		= 1;
	WR2: collects_var_sem(used_variables(SELF.minimal)
		+ used_variables(SELF.maximal))
		<= SELF\simple_domain.referenced_by.item_of.assumes;
	WR3: NOT(EXISTS(SELF.step)) OR
		(collects_var_sem(used_variables(SELF.step))
		<= SELF\simple_domain.referenced_by.item_of.assumes);
	WR4: QUERY(va <* collects_variables
		(SELF\simple_domain.referenced_by.item_of.defines)
		| NOT('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_VARIABLE'
		IN TYPEOF(va))) = [];
END_ENTITY; -- variable_range_defined_domain

ENTITY predicate_defined_domain
SUBTYPE OF(simple_domain);
	constraint: boolean_expression;
WHERE
	WR1: collects_var_sem(used_variables(SELF.constraint))
		<= SELF\simple_domain.referenced_by.item_of.defines +
		SELF\simple_domain.referenced_by.item_of.assumes;
END_ENTITY; -- predicate_defined_domain

ENTITY functional_domain_restriction
SUBTYPE OF(domain_restriction);
	SELF\domain_restriction.domains: 
		SET[1:?] OF guarded_functional_domain;
END_ENTITY; -- functional_domain_restriction

ENTITY guarded_functional_domain
SUBTYPE OF(guarded_simple_domain);
	SELF\guarded_simple_domain.domain: simple_functional_domain;
END_ENTITY; -- guarded_functional_domain

ENTITY simple_functional_domain
ABSTRACT SUPERTYPE OF(ONEOF(
	library_expression_defined_value,
	table_defined_value,
	null_defined_value))
SUBTYPE OF(simple_domain);
END_ENTITY; -- simple_functional_domain

ENTITY library_expression_defined_value
SUBTYPE OF(simple_functional_domain);
	its_value: library_expression;
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines)
		= 1;
	WR2: QUERY(va <* collects_variables
		(SELF\simple_domain.referenced_by.item_of.defines)
		| NOT compatible_variable_and_library_expression
		(va, SELF.its_value)) = [];
	WR3: collects_var_sem(used_variables(SELF.its_value))
		<= SELF\simple_domain.referenced_by.item_of.assumes;
END_ENTITY; -- library_expression_defined_value

ENTITY table_defined_value
SUBTYPE OF(simple_functional_domain);
	from_table: table_expression;
WHERE
	WR1: SELF\simple_domain.referenced_by.item_of.defines
		<= list_to_set(SELF.from_table\table_expression.its_columns);
	WR2: SELF\simple_domain.referenced_by.item_of.assumes
		>= SELF.from_table\table_expression.the_key;
	WR3: QUERY(sem <* collects_var_sem(
		used_variables(SELF.from_table))
		| NOT((sem IN
		(SELF\simple_domain.referenced_by.item_of.assumes
		+ SELF\simple_domain.referenced_by.item_of.defines))
		OR ((('ISO13584_TABLE_RESOURCE_SCHEMA'
		+ '.COLUMN_TRAVERSAL_VARIABLE_SEMANTICS')
		IN TYPEOF(sem))) AND
		(sem\column_traversal_variable_semantics.domain
		IN collects_columns(from_table)))) = [];
END_ENTITY; -- table_defined_value

ENTITY null_defined_value
SUBTYPE OF(simple_functional_domain);
WHERE
	WR1: SIZEOF(SELF\simple_domain.referenced_by.item_of.defines) 
		= 1;
END_ENTITY; -- null_defined_value

FUNCTION collects_variables(v_sem: AGGREGATE OF variable_semantics):
	SET OF generic_variable;

LOCAL
	l: SET OF generic_variable := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(v_sem);
	l := l + syntax_of(v_sem[i]);
END_REPEAT;

RETURN(l);

END_FUNCTION; -- collects_variables

FUNCTION collects_var_sem(va: AGGREGATE OF generic_variable):
	SET OF variable_semantics;

LOCAL
	l: SET OF variable_semantics := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(va);
	l := l + semantics_of(va[i]);
END_REPEAT;

RETURN(l);

END_FUNCTION; -- collects_var_sem

FUNCTION used_tables_in_domain(arg: domain_restriction):
	SET OF table_identification;

LOCAL
	result: SET OF table_identification := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(arg.domains);
	IF ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION'
		IN TYPEOF(arg.domains[i].guard))
	THEN
		result := result + used_table_literals
			(arg.domains[i].guard);
	END_IF;

	IF ('ISO13584_DOMAIN_RESOURCE_SCHEMA.TABLE_DEFINED_DOMAIN'
		IN TYPEOF(arg.domains[i].domain))
	THEN
		result := result + used_table_literals
			(arg.domains[i].domain\table_defined_domain.from_table);
	END_IF;

	IF ('ISO13584_DOMAIN_RESOURCE_SCHEMA.PREDICATE_DEFINED_DOMAIN'
		IN TYPEOF(arg.domains[i].domain))
	THEN
		result := result + used_table_literals(
		arg.domains[i].domain\predicate_defined_domain.constraint);
	END_IF;

	IF ('ISO13584_DOMAIN_RESOURCE_SCHEMA'
		+'.LIBRARY_EXPRESSION_DEFINED_VALUE' IN TYPEOF(
		arg.domains[i].domain))
	THEN
		result := result + used_table_literals(
			arg.domains[i].domain\library_expression_defined_value
			.its_value);
	END_IF;

	IF ('ISO13584_DOMAIN_RESOURCE_SCHEMA.TABLE_DEFINED_VALUE'
		IN TYPEOF(arg.domains[i].domain))
	THEN
		result := result + used_table_literals
			(arg.domains[i].domain\table_defined_value.from_table);
	END_IF;
END_REPEAT;

RETURN(result);

END_FUNCTION; -- used_tables_in_domain

FUNCTION used_variables_in_domain(arg: domain_restriction):
	SET OF generic_variable;

LOCAL
	result: SET OF generic_variable := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(arg.domains);
	IF ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION'
		IN TYPEOF(arg.domains [i].guard))
	THEN
		result := result + used_variables(arg.domains [i].guard);
	END_IF;

	IF ('ISO13584_DOMAIN_RESOURCE_SCHEMA.TABLE_DEFINED_DOMAIN'
		IN TYPEOF(arg.domains [i].domain))
	THEN
		result := result + used_variables(
			arg.domains [i].domain\table_defined_domain
			.from_table);
	END_IF;

	IF ('ISO13584_DOMAIN_RESOURCE_SCHEMA.PREDICATE_DEFINED_DOMAIN'
		IN TYPEOF(arg.domains [i].domain))
	THEN
		result := result + used_variables(
			arg.domains[i].domain\predicate_defined_domain
			.constraint);
	END_IF;

	IF ('ISO13584_DOMAIN_RESOURCE_SCHEMA' +
						'.LIBRARY_EXPRESSION_DEFINED_VALUE'
		IN TYPEOF(arg.domains [i].domain))
	THEN
		result := result + used_variables(
			arg.domains[i].domain\
			library_expression_defined_value.its_value);
	END_IF;

	IF ('ISO13584_DOMAIN_RESOURCE_SCHEMA.TABLE_DEFINED_VALUE'
		IN TYPEOF(arg.domains [i].domain))
	THEN
		result := result + used_variables(
			arg.domains [i].domain\table_defined_value.from_table);
	END_IF;
END_REPEAT;

RETURN(result);

END_FUNCTION; -- used_variables_in_domain

FUNCTION variables_belong_to_assumes(gsd: guarded_simple_domain):
	LOGICAL;

IF ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION')
	IN TYPEOF(gsd)
THEN
	RETURN(collects_var_sem(used_variables(gsd.guard)) 
		<= gsd.item_of.assumes);
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- variables_belong_to_assumes

END_SCHEMA; -- ISO13584_domain_resource_schema

SCHEMA ISO13584_extended_dictionary_schema;

REFERENCE FROM ISO13584_IEC61360_dictionary_schema
	(all_class_descriptions_reachable,
	basic_semantic_unit,
	class,
	class_BSU,
	class_BSU_relationship,
	class_instance_type,
	class_related_BSU,
	code_type,
	component_class,
	compute_known_visible_data_types,
	compute_known_visible_properties,
	content_item,
	data_type,
	data_type_BSU,
	data_type_element,
	definition_available_implies,
	definition_type,
	dictionary_element,
	document,
	entity_instance_type,
	graphics,
	item_class,
	item_names,
	level,
	level_type,
	list_to_set,
	material_class,
	named_type,
	non_quantitative_code_type,
	non_quantitative_int_type,
	note_type,
	property_BSU,
	property_DET,
	remark_type,
	revision_type,
	sep_cv,
	sep_id,
	supplier_BSU,
	supplier_BSU_relationship,
	supplier_element,
	supplier_related_BSU,
	value_domain,
	version_type);

REFERENCE FROM ISO13584_IEC61360_language_resource_schema
	(present_translations);

REFERENCE FROM ISO13584_generic_expressions_schema
	(variable_semantics);

REFERENCE FROM ISO13584_instance_resource_schema
	(compatible_level_type_and_instance,
	property_or_data_type_BSU);

REFERENCE FROM ISO13584_table_resource_schema
	(class_instance_column,
	column,
	entity_instance_column,
	RDB_table_extension,
	RDB_table_specification,
	table_extension,
	table_identification,
	table_specification);

REFERENCE FROM ISO13584_variable_semantics_schema
	(property_semantics,
	self_property_semantics);

REFERENCE FROM ISO13584_external_file_schema
	(external_file_protocol,
	simple_program_protocol);

REFERENCE FROM date_time_schema
	(year_number);

REFERENCE FROM support_resource_schema
	(identifier,
	label);

REFERENCE FROM person_organization_schema
	(organization ,
	person);

REFERENCE FROM application_context_schema
	(application_protocol_definition);

CONSTANT
	element_code_len: INTEGER := 14;

	dictionary_code_len: INTEGER := 80;
END_CONSTANT;

TYPE document_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= element_code_len;
END_TYPE; -- document_code_type

TYPE program_library_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= element_code_len;
END_TYPE; -- program_library_code_type

TYPE table_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= element_code_len;
END_TYPE; -- table_code_type

TYPE absolute_URL_type = identifier;
WHERE
	WR1: SELF LIKE '*://*';
END_TYPE; -- absolute_URL_type

TYPE dictionary_code_type = code_type;
WHERE
	WR1: LENGTH(SELF) <= dictionary_code_len;
END_TYPE; -- dictionary_code_type

ENTITY dictionary_identification;
	code: dictionary_code_type;
	version: version_type;
	revision: revision_type;
	defined_by: supplier_bsu;
DERIVE
	absolute_id: identifier :=
		defined_by.absolute_id + sep_id + code + sep_cv + version;
INVERSE
	definition: SET [0:1] of dictionary FOR identified_by;
UNIQUE
	UR1: absolute_id;
END_ENTITY;

ENTITY dictionary
SUPERTYPE OF(dictionary_in_standard_format);
	identified_by: OPTIONAL dictionary_identification; 
	is_complete: OPTIONAL BOOLEAN;
	updates: OPTIONAL dictionary_identification; 
	update_agreement: OPTIONAL identifier;
	referenced_dictionaries: SET [0:?] OF dictionary_identification;
	responsible_supplier: supplier_BSU;
	library_structure: library_iim_identification;
	base_protocols: SET [0:?] OF external_file_protocol;
	supported_vep: SET [0:?] OF 
		view_exchange_protocol_identification;
	referred_suppliers: SET [1:?] OF supplier_BSU;
	contained_classes: LIST [0:?] OF UNIQUE class_BSU;
	a_posteriori_semantic_relationships: SET [0:?] OF
		a_posteriori_semantic_relationship;
	names: item_names;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
WHERE
	WR1: prefix_ordered_class_list(SELF.contained_classes);
	WR2: (EXISTS(identified_by) AND EXISTS(is_complete))
		OR (NOT(EXISTS(identified_by)) AND NOT(EXISTS(is_complete)));
	WR3: NOT(EXISTS(identified_by)) OR
		(SELF.identified_by.defined_by = SELF.responsible_supplier);
	WR4: NOT(EXISTS(updates)) OR
		(EXISTS(identified_by) AND (is_complete = FALSE));
	WR5: NOT(EXISTS(update_agreement)) OR EXISTS(updates);
	WR6: NOT(EXISTS(updates)) OR
		((updates.code = identified_by.code)
		AND (updates.defined_by = identified_by.defined_by) 
		AND (updates.version <= identified_by.version) 
		AND (NOT(updates.version = identified_by.version) OR
		(updates.revision < identified_by.revision)));
END_ENTITY; -- dictionary

ENTITY dictionary_in_standard_format
SUBTYPE OF(dictionary);
WHERE
	WR1: QUERY(int <* SELF\dictionary.base_protocols
		| ((SIZEOF(QUERY(vep <* SELF\dictionary.supported_vep
		| int IN vep\data_exchange_specification_identification
		.external_file_protocols)) = 0) AND NOT(int IN
		SELF\dictionary.library_structure
		.external_file_protocols))) = [];
END_ENTITY; -- dictionary_in_standard_format

ENTITY data_exchange_specification_identification
ABSTRACT SUPERTYPE OF(ONEOF(library_iim_identification, 
	view_exchange_protocol_identification));
	source_document_identifier: OPTIONAL identifier;
	status: label;
	name: identifier;
	date: year_number;
	application: OPTIONAL identifier;
	level: OPTIONAL identifier;
	external_file_protocols: SET [0:?] OF external_file_protocol;
END_ENTITY; -- data_exchange_specification_identification

ENTITY library_iim_identification
SUBTYPE OF(data_exchange_specification_identification);
END_ENTITY; -- library_iim_identification

ENTITY view_exchange_protocol_identification
SUBTYPE OF(data_exchange_specification_identification);
	referenced_ISO10303_AP: OPTIONAL application_protocol_definition;
END_ENTITY; -- view_exchange_protocol_identification

ENTITY representation_type
	SUBTYPE OF(entity_instance_type);
WHERE
	WR1:'REPRESENTATION_SCHEMA.REPRESENTATION'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- representation_type

ENTITY geometric_representation_context_type
	SUBTYPE OF(entity_instance_type);
WHERE
	WR1:'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- geometric_representation_context_type

ENTITY representation_reference_type
	SUBTYPE OF(entity_instance_type);
WHERE
	WR1:'ISO13584_EXTERNAL_FILE_SCHEMA.REPRESENTATION_REFERENCE'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- representation_reference_type

ENTITY program_reference_type
	SUBTYPE OF(entity_instance_type);
WHERE
	WR1: 'ISO13584_EXTERNAL_FILE_SCHEMA.PROGRAM_REFERENCE'
		IN SELF\entity_instance_type.type_name;
END_ENTITY; -- program_reference_type

ENTITY program_library_BSU
SUBTYPE OF(supplier_related_BSU);
	defined_by: supplier_BSU;
	SELF\basic_semantic_unit.code: program_library_code_type;
DERIVE
	absolute_id: identifier := defined_by.dic_identifier
		+ sep_id + dic_identifier;
INVERSE
	associated_to_supplier: supplier_BSU_relationship 
		FOR related_tokens;
UNIQUE
	UR1: absolute_id;
WHERE
	WR1: defined_by :=: associated_to_supplier.
		relating_supplier\dictionary_element.identified_by;
END_ENTITY; -- program_library_BSU

ENTITY table_BSU
SUBTYPE OF(class_related_BSU, table_identification);
	name_scope: class_BSU;
	SELF\basic_semantic_unit.code: table_code_type;
DERIVE
	absolute_id: identifier:= name_scope.
		defined_by.dic_identifier + sep_id
		+ name_scope.dic_identifier + sep_id
		+ dic_identifier;
UNIQUE
	UR1: absolute_id;
END_ENTITY; -- table_BSU

ENTITY document_BSU
SUBTYPE OF(class_related_BSU);
	name_scope: class_BSU;
	SELF\basic_semantic_unit.code: document_code_type;
DERIVE
	absolute_id: identifier :=
		name_scope.defined_by.dic_identifier + sep_id
		+ name_scope.dic_identifier + sep_id
		+ dic_identifier;
INVERSE
	associate_to_class: class_BSU_relationship FOR related_tokens;
UNIQUE
	UR1: absolute_id;
END_ENTITY; -- document_BSU

ENTITY supplier_program_library_relationship
SUBTYPE OF(supplier_BSU_relationship);
	SELF\supplier_BSU_relationship.related_tokens:
		SET [1:?] OF program_library_BSU;
END_ENTITY; -- supplier_program_library_relationship

ENTITY class_table_relationship
SUBTYPE OF(class_BSU_relationship);
	SELF\class_BSU_relationship.related_tokens: 
		SET [1:?] OF table_BSU;
WHERE
	WR1: applicable_properties_for_applicable_tables(SELF);
	WR2: visible_tables(SELF\class_BSU_relationship.relating_class.
		identified_by, SELF.related_tokens);
END_ENTITY; -- class_table_relationship

ENTITY class_document_relationship
SUBTYPE OF(class_BSU_relationship);
	SELF\class_BSU_relationship.related_tokens: 
		SET [1:?] OF document_BSU;
WHERE
	WR1: visible_documents(
		SELF\class_BSU_relationship.relating_class.identified_by,
		SELF.related_tokens);
END_ENTITY; -- class_document_relationship

ENTITY representation_P_DET
SUBTYPE OF(property_DET);
WHERE
	WR1: NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.CONDITION_DET'
		IN TYPEOF(SELF)) AND
		NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.DEPENDENT_P_DET'
		IN TYPEOF(SELF)) AND
		NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
		'.NON_DEPENDENT_P_DET' IN TYPEOF(SELF));
END_ENTITY; -- representation_P_DET

ENTITY supplier_related_dictionary_element
ABSTRACT SUPERTYPE OF(program_library_element)
SUBTYPE OF(dictionary_element);
	SELF\dictionary_element.identified_by: supplier_related_BSU;
	names: item_names;
	definition: definition_type;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
END_ENTITY; -- supplier_related_dictionary_element

ENTITY class_related_dictionary_element
ABSTRACT SUPERTYPE OF(ONEOF(table_element, document_element))
SUBTYPE OF(dictionary_element);
	SELF\dictionary_element.identified_by: class_related_BSU;
	names: item_names;
	definition: definition_type;
	note: OPTIONAL note_type;
	remark: OPTIONAL remark_type;
END_ENTITY; -- class_related_dictionary_element

ENTITY program_library_element
SUBTYPE OF(supplier_related_dictionary_element);
	SELF\dictionary_element.identified_by: program_library_BSU;
END_ENTITY; -- program_library_element

ENTITY table_element
SUBTYPE OF(class_related_dictionary_element, table_specification);
	SELF\dictionary_element.identified_by: table_BSU;
	SELF\table_specification.column_meaning: 
		LIST [1:?] OF UNIQUE self_property_semantics;
	SELF\table_specification.key: 
		SET [1:?] OF self_property_semantics;
DERIVE
	SELF\table_specification.table_identifier: table_BSU
		:= SELF.identified_by;
WHERE	
	WR1: QUERY (temp <* SELF.column_meaning
		| NOT visible_properties(
		SELF\dictionary_element.identified_by.name_scope,
		get_property_BSU_from_property_semantics([temp]))
		AND NOT applicable_properties(
		SELF\dictionary_element.identified_by.name_scope,
		list_to_set(get_property_BSU_from_property_semantics(
		[temp])))) = [];
END_ENTITY; -- table_element

ENTITY RDB_table_element
SUBTYPE OF(table_element, RDB_table_specification);
WHERE
	WR1: QUERY(temp <* SELF.column_meaning
		| simple_type_data_type(temp\property_semantics.the_property)
		= FALSE) = [];
END_ENTITY; -- RDB_table_element

ENTITY document_element
SUPERTYPE OF(ONEOF(
	document_element_with_http_access,
	document_element_with_translated_http_access))
SUBTYPE OF(class_related_dictionary_element);
	SELF\dictionary_element.identified_by: document_BSU;
	authors: OPTIONAL LIST [1:?] OF person;
	publishing_organisation: organization;
END_ENTITY; -- document_element

ENTITY document_element_with_http_access
SUBTYPE OF(document_element);
	remote_location: absolute_URL_type;
END_ENTITY; -- document_element_with_http_access

ENTITY document_element_with_translated_http_access
SUBTYPE OF(document_element);
	remote_locations: LIST [1:?] OF absolute_URL_type;
	languages: present_translations;
WHERE
	WR1: SIZEOF(remote_locations) = SIZEOF(languages.language_codes);
END_ENTITY; -- document_element_with_translated_http_access

ENTITY referenced_document
SUBTYPE OF(document);
	document_reference: document_BSU;
WHERE
	WR1: NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
		'.IDENTIFIED_DOCUMENT' IN TYPEOF(SELF));
END_ENTITY; -- referenced_document

ENTITY referenced_graphics
SUBTYPE OF(graphics);
	graphics_reference: document_BSU;
END_ENTITY; -- referenced_graphics

ENTITY feature_class
SUBTYPE OF(item_class);
WHERE
	WR1: NOT(('ISO13584_IEC61360_DICTIONARY_SCHEMA.'
		+ 'COMPONENT_CLASS') IN TYPEOF(SELF));
	WR2: NOT(('ISO13584_IEC61360_DICTIONARY_SCHEMA.'
		+ 'MATERIAL_CLASS') IN TYPEOF(SELF));
END_ENTITY; -- feature_class

ENTITY a_priori_semantic_relationship
ABSTRACT SUPERTYPE OF(ONEOF(
	item_class_case_of,
	fm_class_view_of,
	functional_model_class))
SUBTYPE OF(class);
	referenced_classes: SET [1:?] OF class_BSU;
	referenced_properties: LIST [0:?] OF property_BSU;
	referenced_data_types: SET [0:?] OF data_type_BSU;
	referenced_tables: SET [0:?] OF table_BSU;
	referenced_documents: SET [0:?] OF document_BSU;
END_ENTITY; -- a_priori_semantic_relationship

ENTITY abstract_functional_model_class
ABSTRACT SUPERTYPE OF(ONEOF(functional_model_class,
	fm_class_view_of))
SUBTYPE OF(class);
	created_view: class_BSU;
	v_c_v_range: SET [0:?] OF view_control_variable_range;
	imported_properties_from_view: LIST [0:?] OF property_BSU;
	imported_types_from_view: SET [0:?] OF data_type_BSU;
	imported_tables_from_view: SET [0:?] OF table_BSU;
	imported_documents_from_view: SET [0:?] OF document_BSU;
	case_of: SET [0:?] OF class_BSU;
	imported_properties_from_models: LIST [0:?] OF property_BSU;
	imported_types_from_models: SET [0:?] OF data_type_BSU;
	imported_tables_from_models: SET [0:?] OF table_BSU;
	imported_documents_from_models: SET [0:?] OF document_BSU;
WHERE
	WR1: created_view_is_functional_view(SELF.created_view);
	WR2: QUERY(v_c_v <* SELF.v_c_v_range
		| NOT applicable_properties(SELF.created_view,
		[v_c_v.parameter_type])) = [];
	WR3: QUERY(v_c_v <* SELF.v_c_v_range
		| NOT(v_c_v.parameter_type
		IN SELF.imported_properties_from_view)) = [];
	WR4: NOT EXISTS(SELF\class.its_superclass)
		OR ('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(SELF\class.its_superclass));
	WR5: QUERY(v_c_v <* SELF.v_c_v_range
		| SIZEOF(QUERY(v_c_v_2 <* SELF.v_c_v_range
		| v_c_v.parameter_type = v_c_v_2.parameter_type)) <> 1) = [];
	WR6: QUERY(prop <* SELF\class.described_by
		| definition_available_implies(prop,
		('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.REPRESENTATION_P_DET') IN TYPEOF(prop.definition[1])))
		= SELF\class.described_by;
	WR7: QUERY(cl <* SELF.case_of
		| definition_available_implies(cl,
		('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.ABSTRACT_FUNCTIONAL_MODEL_CLASS') 
		IN TYPEOF(cl.definition[1])))
		= SELF.case_of;
END_ENTITY; -- abstract_functional_model_class

ENTITY functional_model_class
SUBTYPE OF(a_priori_semantic_relationship,
	abstract_functional_model_class);
DERIVE
	SELF\a_priori_semantic_relationship.referenced_classes:
		SET [1:?] OF class_BSU :=
		[SELF\abstract_functional_model_class.created_view]
		+ SELF\abstract_functional_model_class.case_of;
	SELF\a_priori_semantic_relationship.referenced_properties:
		LIST [0:?] OF property_BSU :=
		SELF\abstract_functional_model_class
			.imported_properties_from_view
		+ SELF\abstract_functional_model_class
			.imported_properties_from_models;
	SELF\a_priori_semantic_relationship.referenced_data_types:
		SET [0:?] OF data_type_BSU :=
		SELF\abstract_functional_model_class
			.imported_types_from_view
		+ SELF\abstract_functional_model_class
			.imported_types_from_models;
	SELF\a_priori_semantic_relationship.referenced_tables:
		SET [0:?] OF table_BSU :=
		SELF\abstract_functional_model_class
			.imported_tables_from_view
		+ SELF\abstract_functional_model_class
			.imported_tables_from_models;
	SELF\a_priori_semantic_relationship.referenced_documents:
		SET [0:?] OF document_BSU :=
		SELF\abstract_functional_model_class
			.imported_documents_from_view
		+ SELF\abstract_functional_model_class
			.imported_documents_from_models;
END_ENTITY; -- functional_model_class

ENTITY fm_class_view_of
SUBTYPE OF(a_priori_semantic_relationship,
	abstract_functional_model_class);
	view_of: class_BSU;
	imported_properties_from_item: LIST [0:?] OF property_BSU;
	imported_types_from_item: SET [0:?] OF data_type_BSU;
	imported_tables_from_item: SET [0:?] OF table_BSU;
	imported_documents_from_item: SET [0:?] OF document_BSU;
DERIVE
	SELF\a_priori_semantic_relationship.referenced_classes:
		SET [2:2] OF class_BSU :=
		[SELF\abstract_functional_model_class.created_view,
		SELF.view_of] + SELF\abstract_functional_model_class.case_of;
	SELF\a_priori_semantic_relationship.referenced_properties:
		LIST [0:?] OF property_BSU :=
		SELF\abstract_functional_model_class
		.imported_properties_from_view
		+ SELF\abstract_functional_model_class
		.imported_properties_from_models
		+ SELF.imported_properties_from_item;
	SELF\a_priori_semantic_relationship.referenced_data_types:
		SET [0:?] OF data_type_BSU :=
		SELF\abstract_functional_model_class
		.imported_types_from_view
		+ SELF\abstract_functional_model_class
		.imported_types_from_models
		+ SELF.imported_types_from_item;
	SELF\a_priori_semantic_relationship.referenced_tables:
		SET [0:?] OF table_BSU :=
		SELF\abstract_functional_model_class
		.imported_tables_from_view
		+ SELF\abstract_functional_model_class
		.imported_tables_from_models
		+ SELF.imported_tables_from_item;
	SELF\a_priori_semantic_relationship.referenced_documents:
		SET [0:?] OF document_BSU :=
		SELF\abstract_functional_model_class
		.imported_documents_from_view
		+ SELF\abstract_functional_model_class
		.imported_documents_from_models
		+ SELF.imported_documents_from_item;
WHERE
	WR1: check_view_of_instance_datatype(SELF);
END_ENTITY; -- fm_class_view_of

ENTITY functional_view_class
SUPERTYPE OF(non_instantiable_functional_view_class)
SUBTYPE OF(class);
	representation_type: OPTIONAL STRING;
	view_control_variables: LIST [0:?] OF UNIQUE property_BSU;
	view_properties: LIST [0:?] OF UNIQUE property_BSU;
DERIVE
	SELF\class.described_by: LIST [0:?] OF UNIQUE property_BSU
		:= SELF.view_control_variables + SELF.view_properties;
WHERE
	WR1: QUERY(v_c_v <* SELF.view_control_variables
		| NOT((data_type_typeof(v_c_v) = [])
		OR (('ISO13584_IEC61360_DICTIONARY_SCHEMA'
		+ '.NON_QUANTITATIVE_INT_TYPE' IN data_type_typeof(v_c_v))
		AND ordered_index_value(
		data_type_non_quantitative_int_type(v_c_v)[1].domain))))
		= [];
	WR2: NOT EXISTS(SELF.representation_type)
		OR ('_SCHEMA.' LIKE SELF.representation_type);
	WR3: NOT EXISTS(SELF\class.its_superclass)
		OR (('ISO13584_EXTENDED_DICTIONARY_SCHEMA.'
		+ 'FUNCTIONAL_VIEW_CLASS')
		IN TYPEOF(SELF\class.its_superclass));
	WR4: QUERY(prop <* SELF\class.described_by
		| definition_available_implies(prop,
		('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.REPRESENTATION_P_DET') IN TYPEOF(prop.definition[1])))
		= SELF\class.described_by;
END_ENTITY; -- functional_view_class

ENTITY non_instantiable_functional_view_class
SUBTYPE OF(functional_view_class);
DERIVE
	SELF\functional_view_class.view_properties
		: LIST [0:?] OF UNIQUE property_BSU := [];
WHERE
	WR1: NOT EXISTS(SELF\functional_view_class.representation_type);
END_ENTITY; -- non_instantiable_functional_view_class

ENTITY view_control_variable_range;
	parameter_type: property_BSU;
	range_lobound: INTEGER;
	range_hibound: INTEGER;
WHERE
	WR1: (data_type_typeof(SELF.parameter_type) = [])
		OR ('ISO13584_IEC61360_DICTIONARY_SCHEMA'
		+ '.NON_QUANTITATIVE_INT_TYPE'
		IN data_type_typeof(SELF.parameter_type));
	WR2: SELF.range_lobound <= SELF.range_hibound;
	WR3: view_control_variables_attributes_belong_to_domain(SELF);
END_ENTITY; -- view_control_variable_range

ENTITY item_class_case_of
SUPERTYPE OF(ONEOF(component_class_case_of,
	material_class_case_of,
	feature_class_case_of))
SUBTYPE OF(item_class, a_priori_semantic_relationship);
	is_case_of: SET [1:?] OF class_BSU;
	imported_properties: LIST [0:?] OF property_BSU;
	imported_types: SET [0:?]OF data_type_BSU;
	imported_tables: SET [0:?] OF table_BSU;
	imported_documents: SET [0:?] OF document_BSU;
DERIVE
	SELF\a_priori_semantic_relationship.referenced_classes:
		SET [1:?] OF class_BSU
		:= SELF.is_case_of;
	SELF\a_priori_semantic_relationship.referenced_properties:
		LIST [0:?] OF property_BSU := SELF.imported_properties;
	SELF\a_priori_semantic_relationship.referenced_data_types:
		SET [0:?] OF data_type_BSU := SELF.imported_types;
	SELF\a_priori_semantic_relationship.referenced_tables:
		SET [0:?] OF table_BSU := SELF.imported_tables;
	SELF\a_priori_semantic_relationship.referenced_documents:
		SET [0:?] OF document_BSU := SELF.imported_documents;
WHERE
	WR1: superclass_of_item_is_item(SELF);
	WR2: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- item_class_case_of

ENTITY component_class_case_of
SUBTYPE OF(item_class_case_of, component_class);
WHERE
	WR1: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- component_class_case_of

ENTITY material_class_case_of
SUBTYPE OF(item_class_case_of, material_class);
WHERE
	WR1: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- material_class_case_of

ENTITY feature_class_case_of
SUBTYPE OF(item_class_case_of, feature_class);
WHERE
	WR1: check_is_case_of_referenced_classes_definition(SELF);
END_ENTITY; -- feature_class_case_of

ENTITY a_posteriori_semantic_relationship
ABSTRACT SUPERTYPE OF(ONEOF(a_posteriori_case_of,
	a_posteriori_view_of));
END_ENTITY; -- a_posteriori_semantic_relationship

ENTITY a_posteriori_case_of
SUBTYPE OF(a_posteriori_semantic_relationship);
	source: class_BSU;
	is_case_of: class_BSU;
	corresponding_properties: SET [0:?] OF 
		LIST [2:2] OF property_BSU;
WHERE
	WR1: definition_available_implies(SELF.source,
		('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.source.definition[1]))
		OR (('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		 + '.ABSTRACT_FUNCTIONAL_MODEL_CLASS')
		IN TYPEOF(SELF.source.definition[1])));
	WR2: definition_available_implies(SELF.source,
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.source.definition[1]))
		AND (definition_available_implies(SELF.is_case_of,
		('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.source.definition[1])))))
		OR (('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		 + '.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(SELF.source.definition[1]))
		AND (definition_available_implies(SELF.is_case_of,
		('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		 + '.ABSTRACT_FUNCTIONAL_MODEL_CLASS'
		IN TYPEOF(SELF.source.definition[1]))))));
	WR3: QUERY(couple <* SELF.corresponding_properties
		| NOT compatible_types(couple[1], couple[2])) = [];
	WR4: QUERY(couple <* SELF.corresponding_properties
		| (NOT applicable_properties(SELF.source,[couple[1]])
		OR NOT applicable_properties(SELF.is_case_of,[couple [2]])))
		= [];
END_ENTITY; -- a_posteriori_case_of

ENTITY a_posteriori_view_of
SUBTYPE OF(a_posteriori_semantic_relationship);
	functional_model: class_BSU;
	is_view_of: class_BSU;
	corresponding_properties: SET [0:?] OF
		LIST [2:2] OF property_BSU;
WHERE
	WR1: definition_available_implies(SELF.functional_model,
		('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.FUNCTIONAL_MODEL_CLASS' IN TYPEOF(
		SELF.functional_model.definition[1])));
	WR2: definition_available_implies(SELF.is_view_of,
		('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS'
		IN TYPEOF(SELF.is_view_of.definition[1])));
	WR3: QUERY(couple <* SELF.corresponding_properties
		| NOT compatible_types(couple [1], couple [2])) = [];
	WR4: QUERY(couple <* SELF.corresponding_properties
		| (NOT applicable_properties(
		SELF.functional_model,[couple[1]]) OR NOT
		applicable_properties(SELF.is_view_of,[couple [2]]))) = [];
END_ENTITY; -- a_posteriori_view_of

ENTITY table_content
SUBTYPE OF(content_item, table_extension);
	SELF\content_item.dictionary_definition: table_BSU;
DERIVE
	SELF\table_extension.table_identifier: table_bsu
		:= SELF\content_item.dictionary_definition;
WHERE
	WR1: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_EXTENDED_DICTIONARY_SCHEMA.TABLE_ELEMENT'
		IN TYPEOF(SELF\content_item.dictionary_definition.
		definition[1]));
	WR2: compatible_content_and_specification(SELF);
END_ENTITY; -- table_content

ENTITY RDB_table_content
SUBTYPE OF(table_content, RDB_table_extension);
WHERE
	WR1: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_EXTENDED_DICTIONARY_SCHEMA.RDB_TABLE_ELEMENT'
		IN TYPEOF(SELF\content_item.dictionary_definition.
		definition[1]));
END_ENTITY; -- RDB_table_content

RULE representation_properties_for_model_and_view_rule 
	FOR(property_DET);
WHERE
	WR1: QUERY(prop <* property_DET
		| (SIZEOF(prop.identified_by.name_scope.definition) = 1)
		AND (('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.FUNCTIONAL_MODEL_CLASS' IN TYPEOF(
		prop.identified_by.name_scope.definition))
		OR ('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.FUNCTIONAL_VIEW_CLASS' IN TYPEOF(
		prop.identified_by.name_scope.definition)))
		AND NOT('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.REPRESENTATION_P_DET' IN TYPEOF(prop))
		) = [];
END_RULE; -- representation_properties_for_model_and_view_rule

RULE allowed_named_type_usage_rule FOR(class);
LOCAL
	named_type_usage_allowed: LOGICAL := TRUE;
	is_app: LOGICAL;
	prop: property_bsu;
	cl: class;
	dtnt: SET[0:1] OF data_type_bsu := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(class);
	cl := class[i];
	REPEAT j := 1 TO SIZEOF(class[i].described_by);
		prop := cl.described_by[j];
		dtnt := data_type_named_type(prop);
		
		IF (SIZEOF(dtnt) = 1) THEN
			is_app := applicable_types(cl.identified_by, dtnt);
			IF (NOT is_app) THEN
				named_type_usage_allowed := FALSE;
			END_IF;
		END_IF;
	END_REPEAT;
END_REPEAT;

WHERE
	WR1: named_type_usage_allowed;
END_RULE; -- allowed_named_type_usage_rule

RULE assert_oneof_for_table_rule FOR(table_element);
WHERE
	WR1: QUERY(temp <* table_element |
		NOT('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+ '.RDB_TABLE_ELEMENT' IN TYPEOF(temp))
		AND ('ISO13584_TABLE_RESOURCE_SCHEMA.RDB_TABLE_SPECIFICATION'
		IN TYPEOF(temp))) = [];
END_RULE; -- assert_oneof_for_table_rule

RULE assert_oneof_for_class_rule FOR(class);
WHERE
	WR1: QUERY(cl <* class |
		('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS'
		IN TYPEOF(cl))
		AND (('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.ABSTRACT_FUNCTIONAL_MODEL_CLASS') IN TYPEOF(cl))) = [];
	WR2: QUERY(cl <* class |
		('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS'
		IN TYPEOF(cl))
		AND (('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+ '.FUNCTIONAL_VIEW_CLASS') IN TYPEOF(cl))) = [];
	WR3: QUERY(cl <* class |
		(('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+ '.ABSTRACT_FUNCTIONAL_MODEL_CLASS')
		IN TYPEOF(cl))
		AND (('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.FUNCTIONAL_VIEW_CLASS') IN TYPEOF(cl))) = [];
END_RULE; -- assert_oneof_for_class_rule

RULE no_forward_reference_from_table_rule FOR(
		dictionary, table_element);
WHERE
	WR1: QUERY(dic <* dictionary | QUERY(tab <* table_element
		| makes_reference_outside(
		get_property_BSU_from_property_semantics(
		tab\table_specification.column_meaning),
		sub_list_until(dic.contained_classes,
		tab\table_specification.table_identifier\
		table_BSU.name_scope))) <> []) = [];
END_RULE; -- no_forward_reference_from_table_rule

RULE imported_properties_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, property_DET);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(prop <* rel.referenced_properties
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_properties(cl, [prop])
		AND NOT applicable_properties(cl, [prop]))
		= rel.referenced_classes) = []) 
		= a_priori_semantic_relationship;
END_RULE; -- imported_properties_are_visible_or_applicable_rule

RULE imported_data_types_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, data_type_element);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(typ <* rel.referenced_data_types
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_types(cl, [typ])
		AND NOT applicable_types(cl, [typ]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_data_types_are_visible_or_applicable_rule

RULE imported_tables_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, table_element);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(tab <* rel.referenced_tables
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_tables(cl, [tab])
		AND NOT applicable_tables(cl, [tab]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_tables_are_visible_or_applicable_rule

RULE imported_documents_are_visible_or_applicable_rule FOR(
	a_priori_semantic_relationship, document_element);
WHERE
	WR1: QUERY(rel <* a_priori_semantic_relationship
		| QUERY(doc <* rel.referenced_documents
		| QUERY(cl <* rel.referenced_classes
		| NOT visible_documents(cl, [doc])
		AND NOT applicable_documents(cl, [doc]))
		= rel.referenced_classes) = [])
		= a_priori_semantic_relationship;
END_RULE; -- imported_documents_are_visible_or_applicable_rule

FUNCTION visible_properties(cl: class_BSU;
	prop: AGGREGATE OF property_BSU): LOGICAL;

LOCAL
	ok: BOOLEAN := TRUE;
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := 1 to SIZEOF(prop);
	IF NOT(prop[i] IN compute_known_visible_properties(cl))
		THEN ok := FALSE;
	END_IF;
END_REPEAT;

IF NOT(ok) AND NOT(all_class_descriptions_reachable(cl))
	THEN RETURN(UNKNOWN);
END_IF;

IF NOT(ok) AND all_class_descriptions_reachable(cl)
	THEN RETURN(FALSE);
END_IF;

RETURN(TRUE);

END_FUNCTION; -- visible_properties

FUNCTION visible_types(cl: class_BSU;
	typ: AGGREGATE OF data_type_BSU): LOGICAL;

LOCAL
	ok: BOOLEAN := TRUE;
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := 1 to SIZEOF(typ);
IF NOT(typ[i] IN compute_known_visible_data_types(cl))
	THEN ok := FALSE;
END_IF;
END_REPEAT;

IF NOT(ok) AND NOT(all_class_descriptions_reachable(cl))
	THEN RETURN(UNKNOWN);
END_IF;

IF NOT(ok) AND all_class_descriptions_reachable(cl)
	THEN RETURN(FALSE);
END_IF;

RETURN(TRUE);

END_FUNCTION; -- visible_types

FUNCTION visible_tables(cl: class_BSU;
	tab: AGGREGATE OF table_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := SIZEOF(tab) TO 1 BY -1;
	IF tab[i].name_scope = cl
	THEN
		tab := tab - tab[i];
	END_IF;
END_REPEAT;

IF SIZEOF(tab) = 0
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

IF EXISTS(cl.definition[1]\class.its_superclass)
THEN
	RETURN(visible_tables(cl.definition[1]
		\class.its_superclass, tab));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- visible_tables

FUNCTION visible_documents(cl: class_BSU;
	doc: AGGREGATE OF document_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := SIZEOF(doc) TO 1 BY -1;
	IF doc[i].name_scope = cl
	THEN
		doc := doc - doc[i];
	END_IF;
END_REPEAT;

IF SIZEOF(doc) = 0
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

IF EXISTS(cl.definition[1]\class.its_superclass)
THEN
	RETURN(visible_documents(cl.definition[1]
		\class.its_superclass, doc));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- visible_documents

FUNCTION applicable_properties(cl: class_BSU;
	prop: AGGREGATE OF property_BSU): LOGICAL;

IF SIZEOF(prop) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

prop := prop - list_to_set(cl.definition[1]\class.described_by);

IF 'ISO13584_EXTENDED_DICTIONARY_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1])
THEN
	prop := prop - list_to_set(cl.definition[1]
		\a_priori_semantic_relationship.referenced_properties);
END_IF;

IF SIZEOF(prop) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(applicable_properties(cl.definition[1]
			\class.its_superclass, prop));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_properties

FUNCTION applicable_types(cl: class_BSU;
	typ: AGGREGATE OF data_type_BSU): LOGICAL;

IF SIZEOF(typ) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

typ := typ - cl.definition[1]\class.defined_types;

IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1]))
THEN
	typ := typ -
		cl.definition[1]\a_priori_semantic_relationship
		.referenced_data_types;
END_IF;

IF SIZEOF(typ) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(applicable_types(cl.definition[1]
			\class.its_superclass, typ));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_types

FUNCTION applicable_tables(cl: class_BSU;
	tab: AGGREGATE OF table_identification): LOGICAL;

IF SIZEOF(tab) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

tab := tab - retrieve_tables(cl);

IF 'ISO13584_EXTENDED_DICTIONARY_SCHEMA' +
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1])
THEN
	tab := tab - cl.definition[1]\a_priori_semantic_relationship
		.referenced_tables;
END_IF;

IF SIZEOF(tab) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
	RETURN(
		applicable_tables(cl.definition[1]\class.its_superclass,
			tab));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_tables

FUNCTION retrieve_tables(cl: class_BSU): SET[0:?] OF table_BSU;
-- requires: { SIZEOF(cl.definition) <> O }

LOCAL
	s: SET[0:?] OF table_BSU := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.associated_items);
	IF 'ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(cl.definition[1]\class.associated_items[i])
	THEN
		s := s + cl.definition[1]\class.associated_items[i]
			.related_tokens;
	END_IF;
END_REPEAT;
RETURN(s);

END_FUNCTION; -- retrieve_tables

FUNCTION applicable_documents(cl: class_BSU;
	doc: AGGREGATE OF document_BSU): LOGICAL;

IF SIZEOF(doc) = 0
THEN
	RETURN(TRUE);
END_IF;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

doc := doc - retrieve_documents(cl);

IF 'ISO13584_EXTENDED_DICTIONARY_SCHEMA' + 
	'.A_PRIORI_SEMANTIC_RELATIONSHIP' IN TYPEOF(cl.definition[1])
THEN
	Doc := doc - cl.definition[1]\a_priori_semantic_relationship.
		referenced_documents;
END_IF;

IF SIZEOF(doc) = 0
THEN
	RETURN(TRUE);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(applicable_documents(cl.definition[1]
			\class.its_superclass, doc));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- applicable_documents

FUNCTION retrieve_documents(cl: class_BSU): SET[0:?] OF document_BSU;
-- requires: { SIZEOF(cl.definition) <> O }

LOCAL
	s: SET[0:?] OF document_BSU := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.associated_items);
	IF 'ISO13584_EXTENDED_DICTIONARY_SCHEMA' + 
		'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(cl.definition[1]\class.associated_items[i])
	THEN
		s := s+ cl.definition[1]\class.associated_items[i]
			\class_document_relationship.related_tokens;
	END_IF;
END_REPEAT;

RETURN(s);

END_FUNCTION; -- retrieve_documents

FUNCTION makes_reference_outside (
	p: AGGREGATE OF property_or_data_type_BSU;
	l: LIST[1:?] OF class_BSU): BOOLEAN;

LOCAL
	bool: BOOLEAN := FALSE;
	temp: SET[0:1] OF class_BSU := [];
END_LOCAL;

REPEAT j := 1 TO SIZEOF(p);
	IF ((('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(p[j]\property_bsu.name_scope IN l)))
		OR
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.DATA_TYPE_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(p[j]\data_type_bsu.name_scope IN l))))
	THEN
		bool := TRUE;
		RETURN(bool);
	END_IF;

	IF ((('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(SIZEOF(p[j]\basic_semantic_unit.definition) = 0)))
		OR
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.DATA_TYPE_BSU'
		IN TYPEOF(p[j]))
		AND (NOT(SIZEOF(p[j]\basic_semantic_unit.definition) = 0))))
	THEN
		IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE'
			IN data_type_typeof(p[j]))
		THEN
			temp := data_type_class_of(p[j]);
			IF NOT(temp[1] IN l)
			THEN
				bool := bool OR TRUE ;
			ELSE
				bool := bool OR FALSE;
			END_IF;
		END_IF;

		IF SIZEOF(data_type_named_type(p[j])) = 1
		THEN
			bool := bool OR makes_reference_outside
				(data_type_named_type(p[j]), l);
		END_IF;
	END_IF;
END_REPEAT;

RETURN(bool);

END_FUNCTION; -- makes_reference_outside

FUNCTION prefix_ordered_class_list(classes: LIST[2:?] OF class_BSU):
	BOOLEAN;

LOCAL
	related_token: class_related_BSU;	-- items associated with
		-- a class through a class_BSU_relationship
END_LOCAL;

REPEAT i := 1 TO SIZEOF(classes);

	IF SIZEOF(classes[i].definition) = 1
	THEN

		IF (EXISTS(classes[i].definition[1]\class.its_superclass))
			AND (NOT((classes[i].definition[1]\class.its_superclass)
			IN (makes_sub_list(classes, 1, i - 1))))
		THEN
			RETURN(FALSE);
		END_IF;

		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA'+
			'.A_PRIORI_SEMANTIC_RELATIONSHIP'
			IN TYPEOF(classes[i].definition[1]))
		THEN
			IF (QUERY(x <* classes[i].definition[1]
			\a_priori_semantic_relationship.
			referenced_classes | NOT(x IN makes_sub_list(
			classes, 1, i - 1))) <> [])
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF NOT(SIZEOF(classes[i].definition[1]\class.described_by)
			= 0)
		THEN
			IF (makes_reference_outside(classes[i].definition[1]
				\class.described_by, makes_sub_list(
				classes, 1, i)))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA'+
			'.A_PRIORI_SEMANTIC_RELATIONSHIP'
			IN TYPEOF(classes[i].definition[1]))
		THEN
			IF makes_reference_outside(classes[i].definition[1]\
			a_priori_semantic_relationship.referenced_properties,
			makes_sub_list(classes, 1, i - 1))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF NOT(SIZEOF(classes[i].definition[1]\class.defined_types) 
			= 0)
		THEN
			IF makes_reference_outside(classes[i].definition[1]\
				class.defined_types, makes_sub_list
				(classes, 1, i))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA'+
			'.A_PRIORI_SEMANTIC_RELATIONSHIP'
			IN TYPEOF(classes[i].definition[1]))
		THEN
			IF makes_reference_outside(classes[i].definition[1]\
			a_priori_semantic_relationship.referenced_data_types,
			makes_sub_list(classes, 1, i - 1))
			THEN
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF NOT(SIZEOF(classes[i].definition[1]\
			class.associated_items) = 0)
		THEN
			REPEAT j := 1 TO SIZEOF(classes[i].definition[1]
			\class.associated_items);
				REPEAT k := 1 TO SIZEOF(classes[i].definition[1]
				\class.associated_items[j]
				\class_BSU_relationship.related_tokens);

					related_token := classes[i].definition[1]
						\class.associated_items[j]
						\class_BSU_relationship.related_tokens[k];

					IF (('ISO13584_EXTENDED_DICTIONARY_SCHEMA'+
						'.TABLE_BSU') IN (TYPEOF(related_token)))
						AND NOT(related_token\table_BSU.name_scope
						IN makes_sub_list(classes, 1, i))
					THEN
						RETURN(FALSE);
					END_IF;

					IF (('ISO13584_EXTENDED_DICTIONARY_SCHEMA'+
						'.DOCUMENT_BSU')
						IN (TYPEOF(related_token)))
						AND NOT(related_token\document_BSU
						.name_scope IN makes_sub_list
						(classes, 1, i))
					THEN
						RETURN(FALSE);
					END_IF;
				END_REPEAT;
			END_REPEAT;
		END_IF;
	END_IF;
END_REPEAT;

RETURN(TRUE);
END_FUNCTION; -- prefix_ordered_class_list

FUNCTION functional_view_v_c_v(cl: class_BSU): LIST OF property_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- cl is indeterminate
END_IF;

IF NOT(all_class_descriptions_reachable(cl))
THEN
	RETURN([]); -- some dictionary_element are not available
END_IF;

IF NOT('ISO13584_EXTENDED_DICTIONARY_SCHEMA.FUNCTIONAL_VIEW_CLASS' IN
	TYPEOF(cl.definition[1]))
THEN
	RETURN([]);
END_IF;

RETURN(retrieve_functional_view_v_c_v(cl, []));

END_FUNCTION; -- functional_view_v_c_v

FUNCTION retrieve_functional_view_v_c_v(cl: class_BSU;
	pr: LIST OF property_BSU): LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := pr;
END_LOCAL;

IF SIZEOF(cl.definition) = 0 -- abnormal case
	THEN RETURN([]);
END_IF;

IF NOT('ISO13584_EXTENDED_DICTIONARY_SCHEMA.FUNCTIONAL_VIEW_CLASS' IN
	TYPEOF(cl.definition[1]))
THEN
	RETURN([]);
END_IF;

IF SIZEOF(cl.definition) = 1
THEN
	prop := prop + cl.definition[1]
		\functional_view_class.view_control_variables;
				-- view_control_variables of this class
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass))
THEN
	RETURN(prop);
ELSE
	RETURN(retrieve_functional_view_v_c_v(
		cl.definition[1]\class.its_superclass, prop));
END_IF;

END_FUNCTION; -- retrieve_functional_view_v_c_v

FUNCTION data_type_named_type(type_spec: property_or_data_type_BSU):
	SET[0:1] OF data_type_BSU;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET[0:1] OF data_type_BSU := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\data_type_element
			.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NAMED_TYPE' 
		IN TYPEOF(x))
	THEN
		s := s + x\named_type.referred_type;
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_named_type

FUNCTION data_type_typeof(type_spec: property_or_data_type_BSU):
	SET OF STRING;

LOCAL
	res: BOOLEAN := FALSE;
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]
			\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF NOT(res)
THEN
	RETURN([]);
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NAMED_TYPE' IN TYPEOF(x))
THEN
	IF NOT(SIZEOF(x\named_type.referred_type.definition) = 0)
	THEN
		RETURN(data_type_typeof(x\named_type.referred_type));
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN(TYPEOF(x));
END_IF;

END_FUNCTION; -- data_type_typeof

FUNCTION data_type_class_of(type_spec: property_or_data_type_BSU):
	SET[0:1] OF class_BSU;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET[0:1] OF class_BSU := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\data_type_element
			.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE' IN
		TYPEOF(x))
	THEN
		s := s + x\class_instance_type.domain;
		RETURN(s);
	END_IF;

	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NAMED_TYPE' 
		IN TYPEOF(x))
	THEN
		s := data_type_class_of(x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_class_of

FUNCTION data_type_type_name(t: property_or_data_type_BSU):
	SET [0:?] OF STRING;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET [0:1] OF STRING := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU' IN TYPEOF(t))
THEN
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN TYPEOF(x))
	THEN
		s := x\entity_instance_type.type_name;
	END_IF;

	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NAMED_TYPE' 
		IN TYPEOF(x))
	THEN
		s := data_type_type_name(x\named_type.referred_type);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_type_name

FUNCTION data_type_level_spec(t: property_or_data_type_BSU):
	LIST[0:4] OF UNIQUE Level;

LOCAL
	res: BOOLEAN := FALSE;
	s: LIST[0:4] OF UNIQUE level := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU' IN TYPEOF(t))
THEN
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.LEVEL_TYPE' 
		IN TYPEOF(x))
	THEN
		s := x\level_type.levels;
	END_IF;

	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NAMED_TYPE' 
		IN TYPEOF(x))
	THEN
		s := data_type_level_spec(x\named_type.referred_type);
	END_IF;
END_IF;

RETURN(s);

END_FUNCTION; -- data_type_level_spec

FUNCTION data_type_level_value_typeof(t: property_or_data_type_BSU):
	SET OF STRING;

LOCAL
	res: BOOLEAN := FALSE;
	s: SET OF STRING := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(t)
THEN
	RETURN([]); -- t is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU' IN TYPEOF(t))
THEN
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(t.definition) = 0)
	THEN
		x := t.definition[1]\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.LEVEL_TYPE' 
		IN TYPEOF(x))
	THEN
		s := TYPEOF(x\level_type.value_type);
	END_IF;

	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NAMED_TYPE' 
		IN TYPEOF(x))
	THEN
		s := data_type_level_value_typeof(
			x\named_type.referred_type);
	END_IF;

END_IF;

RETURN(s);

END_FUNCTION; -- data_type_level_value_typeof

FUNCTION simple_type_data_type(type_spec: property_or_data_type_BSU):
	LOGICAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN(UNKNOWN); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.SIMPLE_TYPE' IN
	data_type_typeof(type_spec))
THEN
	RETURN(TRUE);
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.COMPLEX_TYPE' IN
	data_type_typeof(type_spec))
THEN
	RETURN(FALSE);
END_IF;

RETURN(UNKNOWN);

END_FUNCTION; -- simple_type_data_type

FUNCTION complex_type_data_type(type_spec: property_or_data_type_BSU):
	LOGICAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN(UNKNOWN); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.COMPLEX_TYPE' 
	IN data_type_typeof(type_spec))
THEN
	RETURN(TRUE);
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.SIMPLE_TYPE' IN
	data_type_typeof(type_spec))
THEN
	RETURN(FALSE);
END_IF;

RETURN(UNKNOWN);

END_FUNCTION; -- complex_type_data_type

FUNCTION compatible_subclass(c1, c2: class_BSU): LOGICAL;

IF (NOT EXISTS(c1)) OR (NOT EXISTS(c2))
THEN
	RETURN(UNKNOWN); -- c1 or c2 indeterminate
END_IF;

IF c1 = c2
THEN
	RETURN(TRUE);
END_IF;

IF ((c1.code = c2.code) AND (c1.version >= c2.version)
	AND (c1.defined_by.code = c2.defined_by.code))
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(c2.definition) = 0
THEN
	RETURN(UNKNOWN);
ELSE
	IF EXISTS(c2.definition[1]\class.its_superclass)
	THEN
		RETURN(compatible_subclass(c1, c2.definition[1]
			\class.its_superclass));
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- compatible_subclass

FUNCTION compatible_types(p1: property_or_data_type_BSU;
	p2: property_or_data_type_BSU): LOGICAL;

LOCAL
	p1_domain, p2_domain: data_type;
END_LOCAL;

IF (NOT EXISTS(p1)) OR (NOT EXISTS(p2))
THEN
	RETURN(UNKNOWN); -- p1 or p2 indeterminate
END_IF;



IF p1 = p2
THEN
	RETURN(TRUE);
END_IF;



IF ((TYPEOF(p1) = TYPEOF(p2))
	AND (p1\basic_semantic_unit.code = p2.code)
	AND (p1.name_scope\basic_semantic_unit.code =
		p2.name_scope\basic_semantic_unit.code)
	AND (p1\basic_semantic_unit.version >=
		p2\basic_semantic_unit.version))
THEN
	RETURN(TRUE);
END_IF;



IF (SIZEOF(p1\basic_semantic_unit.definition) = 0)
	OR (SIZEOF(p2\basic_semantic_unit.definition) = 0)
THEN
	RETURN(UNKNOWN);
ELSE
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p1))
	THEN
		p1_domain := p1.definition [1]\property_DET.domain;
	ELSE
		p1_domain := p1.definition[1]\data_type_element
			.type_definition;
	END_IF;

	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU'
		IN TYPEOF(p2))
	THEN
		p2_domain := p2.definition [1]\property_DET.domain;
	ELSE
		p2_domain := p2.definition[1]\data_type_element
			.type_definition;
	END_IF;
END_IF;



IF p1_domain = p2_domain
THEN
	RETURN(TRUE);
END_IF;



IF (NOT(SIZEOF(data_type_typeof(p1)) = 0))
	AND (data_type_typeof(p1)<= data_type_typeof(p2))
	AND (NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.COMPLEX_TYPE' IN
	data_type_typeof(p2)))
THEN
	RETURN(TRUE);
END_IF;



IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE' IN
	data_type_typeof(p1))
	AND ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE' IN
	data_type_typeof(p2))
THEN
	RETURN(compatible_subclass(data_type_class_of(p1)[1],
		data_type_class_of(p2)[1]));	
END_IF;



IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.ENTITY_INSTANCE_TYPE' IN
	data_type_typeof(p1))
	AND ('ISO13584_IEC61360_DICTIONARY_SCHEMA.ENTITY_INSTANCE_TYPE' 
	IN data_type_typeof(p2))
THEN
	IF ((data_type_type_name(p1) <= data_type_type_name(p2))
		AND (data_type_type_name(p1) <> []))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.LEVEL_TYPE' IN
	data_type_typeof(p1))
	AND ('ISO13584_IEC61360_DICTIONARY_SCHEMA.LEVEL_TYPE' IN
	data_type_typeof(p2))
THEN
	IF (data_type_level_spec(p1) = data_type_level_spec(p2))
		AND (data_type_level_value_typeof(p1) <> [])
		AND (data_type_level_value_typeof(p1)
		<= data_type_level_value_typeof(p2))
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;



IF ((data_type_typeof(p1) = []) OR (data_type_typeof(p2) = []))
THEN
	RETURN(UNKNOWN);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- compatible_types

FUNCTION ordered_index_value(x: value_domain): BOOLEAN;

REPEAT i := LOBOUND(x.its_values) TO SIZEOF(x.its_values);
	IF x.its_values[i].value_code <> x.its_values[i-1].value_code + 1
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- ordered_index_value

FUNCTION makes_sub_list(cla: LIST [1:?] OF class_BSU;
	i, j: INTEGER): LIST [1:?] OF class_BSU;

LOCAL
	c: LIST [0:?] OF class_BSU := [];
END_LOCAL;

REPEAT k := i TO j;
	c := c + cla[k];
END_REPEAT;

RETURN(c);

END_FUNCTION; -- makes_sub_list

FUNCTION sub_list_until(cla: LIST [1:?] OF class_BSU;
	cl: class_BSU): LIST [1:?] OF class_BSU;

LOCAL
	c: LIST [0:?] OF class_BSU := [];
END_LOCAL;

REPEAT k := 1 TO SIZEOF(cla);
	c := c + cla[k];
	IF cla[k] :=: cl
	THEN
		ESCAPE;
	END_IF;
END_REPEAT;

RETURN(c);

END_FUNCTION; -- sub_list_until

FUNCTION get_property_BSU_from_property_semantics(
	l: AGGREGATE OF variable_semantics): LIST[1:?] OF property_BSU;

LOCAL
	res: LIST[0:?] OF property_BSU := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(l);
	res := res + l[i]\property_semantics.the_property;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- get_property_BSU_from_property_semantics

FUNCTION compatible_list_library_types_and_columns(
	dom: LIST [0:?] of property_or_data_type_BSU;
	col: LIST [0:?] of column): LOGICAL;

LOCAL
	res: LOGICAL := TRUE;
	set_string: SET OF STRING := [];
	set_integer: SET OF INTEGER := [];
	code_type: non_quantitative_code_type;
	int_type: non_quantitative_int_type;
END_LOCAL;

IF SIZEOF(dom) <> SIZEOF(col)
THEN
	RETURN(FALSE);
END_IF;

REPEAT i := LOINDEX(col) TO HIINDEX(col);
	IF data_type_typeof(dom[i]) = []
	THEN 
		res := UNKNOWN;
	ELSE
		IF ('ISO13584_TABLE_RESOURCE_SCHEMA.INTEGER_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ((('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
				'.NON_QUANTITATIVE_INT_TYPE') IN 
				data_type_typeof(dom[i]))
				AND (SIZEOF(data_type_non_quantitative_int_type(
				dom[i])) = 1))
			THEN
				set_integer := [];
				int_type := data_type_non_quantitative_int_type(
					dom[i])[1];
				REPEAT j :=1 TO SIZEOF(int_type.domain.its_values);
					set_integer := set_integer 
						+ int_type.domain.its_values[j]
						.value_code;
				END_REPEAT;
				REPEAT j := 1 TO SIZEOF(col[i].values);
					IF (('INTEGER' IN TYPEOF(col[i].values[j]))
						AND NOT (col[i].values[j] IN set_integer))
					THEN
						RETURN (FALSE);
					END_IF;
				END_REPEAT;
			ELSE
				IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_TYPE'
					IN data_type_typeof(dom[i]))
					OR (('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
					'.NUMBER_TYPE' IN data_type_typeof(dom[i]))
					AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA'
					+ '.REAL_TYPE' IN data_type_typeof(dom[i])))
				THEN
					;
				ELSE
					RETURN(FALSE);
				END_IF;
			END_IF;
		END_IF;

		IF ('ISO13584_TABLE_RESOURCE_SCHEMA.REAL_COLUMN' 
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_TYPE'
				IN data_type_typeof(dom[i]))
				OR (('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
				'.NUMBER_TYPE' IN data_type_typeof(dom[i]))
				AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
				'.INT_TYPE' IN data_type_typeof(dom[i])))
			THEN
				;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_TABLE_RESOURCE_SCHEMA.BOOLEAN_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.BOOLEAN_TYPE'
				IN data_type_typeof(dom[i]))
			THEN
				;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_TABLE_RESOURCE_SCHEMA.STRING_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ((('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
				'.NON_QUANTITATIVE_CODE_TYPE') IN 
				data_type_typeof(dom[i]))
				AND (SIZEOF(data_type_non_quantitative_code_type(
				dom[i])) = 1))
			THEN
				set_string := [];
				code_type := data_type_non_quantitative_code_type(
					dom[i])[1];
				REPEAT j:=1 TO SIZEOF(code_type.domain.its_values);
					set_string := set_string 
						+ code_type.domain.its_values[j]
						.value_code;
				END_REPEAT;
				REPEAT j := 1 TO SIZEOF(col[i].values);
					IF ((('STRING' IN TYPEOF(col[i].values[j]))
						AND NOT (col[i].values[j] IN set_string))
						OR ('ISO13584_INSTANCE_RESOURCE_SCHEMA' 
						+ '.TRANSLATED_STRING_VALUE' IN 
						TYPEOF(col[i].values[j])))
					THEN
						RETURN (FALSE);
					END_IF;
				END_REPEAT;
			ELSE
				IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
					'.STRING_TYPE' IN data_type_typeof(dom[i]))
				THEN
					;
				ELSE
					RETURN(FALSE);
				END_IF;
			END_IF;
		END_IF;

		IF ('ISO13584_TABLE_RESOURCE_SCHEMA.ENTITY_INSTANCE_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
				'.ENTITY_INSTANCE_TYPE' IN 
				data_type_typeof(dom[i]))
				AND (data_type_type_name(dom[i]) <= col[i]\
				entity_instance_column.type_name)
				
			THEN
				;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_TABLE_RESOURCE_SCHEMA.CLASS_INSTANCE_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
				'.CLASS_INSTANCE_TYPE' IN data_type_typeof(dom[i]))
				AND (compatible_subclass(
				data_type_class_of(dom[i])[1], 
				col[i]\class_instance_column.class_ref))
			THEN
				;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;

		IF ('ISO13584_TABLE_RESOURCE_SCHEMA.LEVEL_SPEC_COLUMN'
			IN TYPEOF(col[i]))
		THEN
			IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.LEVEL_TYPE'
				IN data_type_typeof(dom[i]))
			THEN
			
				REPEAT j := 1 TO SIZEOF(col[i].values);
					IF NOT(compatible_level_type_and_instance(
						data_type_level_spec(dom[i]),
						data_type_level_value_typeof(dom[i]),
						col[i].values[j]))
					THEN
						RETURN(FALSE);
					END_IF;
				END_REPEAT;
			ELSE
				RETURN(FALSE);
			END_IF;
		END_IF;
	END_IF;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- compatible_list_library_types_and_columns

FUNCTION data_type_non_quantitative_int_type(
	type_spec: property_or_data_type_BSU):
	SET [0:1] OF non_quantitative_int_type;
LOCAL
	res: BOOLEAN := FALSE;
	s: SET [0:1] OF non_quantitative_int_type := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\
		data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA'+
		'.NON_QUANTITATIVE_INT_TYPE') IN TYPEOF(x)
	THEN
		s := s + x;
		RETURN(s);
	END_IF;

	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NAMED_TYPE')
		IN TYPEOF(x)
	THEN
		s := data_type_non_quantitative_int_type(
			x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN([]);

END_FUNCTION; -- data_type_non_quantitative_int_type

FUNCTION data_type_non_quantitative_code_type(
	type_spec: property_or_data_type_BSU):
	SET [0:1] OF non_quantitative_code_type;
LOCAL
	res: BOOLEAN := FALSE;
	s: SET [0:1] OF non_quantitative_code_type := [];
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\
		data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF res
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA'+
		'.NON_QUANTITATIVE_CODE_TYPE') IN TYPEOF(x)
	THEN
		s := s + x;
		RETURN(s);
	END_IF;

	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NAMED_TYPE')
		IN TYPEOF(x)
	THEN
		s := data_type_non_quantitative_code_type(
			x\named_type.referred_type);
		RETURN(s);
	END_IF;
END_IF;

RETURN([]);

END_FUNCTION; -- data_type_non_quantitative_code_type

FUNCTION applicable_properties_for_applicable_tables(
	rel: class_table_relationship): LOGICAL;
LOCAL
	table: table_bsu;
	cl: class_bsu;
	props: LIST OF property_bsu := [];
	res: LOGICAL := TRUE;
END_LOCAL;	
	
IF QUERY(table <* rel.related_tokens
	| SIZEOF(table.definition) = 0) <> []
THEN
	RETURN(UNKNOWN);
END_IF;

REPEAT i := 1 TO SIZEOF(rel.related_tokens);
	table := rel.related_tokens[i];
	cl := rel\class_BSU_relationship.relating_class.identified_by;
	props := get_property_BSU_from_property_semantics(
		table\basic_semantic_unit.definition[1]
		\table_element.column_meaning);
	res := res AND applicable_properties(cl, list_to_set(props));
END_REPEAT;

RETURN(res);

END_FUNCTION; -- visible_properties_for_visible_tables

FUNCTION superclass_of_item_is_item(cl: item_class): LOGICAL;

IF NOT EXISTS(cl\class.its_superclass)
THEN
	RETURN(TRUE);
END_IF;

IF SIZEOF(cl\class.its_superclass.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

RETURN(('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS')
	IN TYPEOF(cl\class.its_superclass.definition[1]));

END_FUNCTION; -- superclass_of_item_is_item

FUNCTION compatible_content_and_specification(
	tab: table_content): LOGICAL;

IF SIZEOF(tab\content_item.dictionary_definition.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

RETURN(compatible_list_library_types_and_columns(
	get_property_BSU_from_property_semantics(
	tab\content_item.dictionary_definition.definition[1]\
	table_specification.column_meaning),
	tab\table_extension.content));

END_FUNCTION; -- compatible_content_and_specification

FUNCTION check_view_of_instance_datatype(
	fmc_view_of: fm_class_view_of): LOGICAL;

IF (SIZEOF(fmc_view_of.view_of.definition) = 1)
THEN
	RETURN('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS'
		IN TYPEOF(fmc_view_of.view_of.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- check_view_of_instance_datatype

FUNCTION view_control_variables_attributes_belong_to_domain(
	vcv_range: view_control_variable_range): LOGICAL;

IF (data_type_typeof(vcv_range.parameter_type) <> [])
THEN
	RETURN((data_type_non_quantitative_int_type(
		vcv_range.parameter_type)[1].domain
		.its_values[1].value_code <= vcv_range.range_lobound)
		AND (vcv_range.range_hibound <=
		data_type_non_quantitative_int_type(
		vcv_range.parameter_type)[1].domain
		.its_values[HIINDEX(data_type_non_quantitative_int_type(
		vcv_range.parameter_type)[1].domain.its_values)].value_code)
	);
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- view_control_variables_attributes_belong_to_domain

FUNCTION created_view_is_functional_view(cl: class_BSU): LOGICAL;

IF (SIZEOF(cl\basic_semantic_unit.definition) = 1) THEN
	RETURN('ISO13584_EXTENDED_DICTIONARY_SCHEMA' + 
		'.FUNCTIONAL_VIEW_CLASS' 
		IN TYPEOF(cl\basic_semantic_unit.definition[1]));
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- created_view_is_functional_view

FUNCTION check_is_case_of_referenced_classes_definition(
	cl: item_class_case_of): BOOLEAN;
LOCAL 
	class_def_ok: BOOLEAN := TRUE;
	done: BOOLEAN := FALSE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.is_case_of);
	IF (SIZEOF(cl.is_case_of[i].definition) = 1)
	THEN
		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA' + 
			'.COMPONENT_CLASS_CASE_OF' IN TYPEOF(cl))
		THEN
			IF (NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
				'.COMPONENT_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
			done := TRUE;
		END_IF;
		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA' + 
			'.FEATURE_CLASS_CASE_OF' IN TYPEOF(cl))
		THEN
			IF (NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
				'.FEATURE_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
			done := TRUE;
		END_IF;
		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA' + 
			'.MATERIAL_CLASS_CASE_OF' IN TYPEOF(cl))
		THEN
			IF (NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
				'.MATERIAL_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
			done := TRUE;
		END_IF;
		IF (('ISO13584_EXTENDED_DICTIONARY_SCHEMA' + 
			'.ITEM_CLASS_CASE_OF' IN TYPEOF(cl))
			AND (NOT done))
		THEN
			IF (NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
				'.ITEM_CLASS'
				IN TYPEOF(cl.is_case_of[i].definition[1])))
			THEN
				class_def_ok := FALSE;
			END_IF;
		END_IF;
		
		done := FALSE;
	END_IF;
END_REPEAT;

RETURN(class_def_ok);

END_FUNCTION; -- check_is_case_of_referenced_classes_definition

END_SCHEMA; -- ISO13584_extended_dictionary_schema

SCHEMA ISO13584_library_content_schema;

REFERENCE FROM ISO13584_IEC61360_dictionary_schema
	(all_class_descriptions_reachable,
	basic_semantic_unit,
	class,
	class_BSU,
	code_type,
	content_item,
	data_type,
	data_type_element,
	definition_available_implies,
	dictionary_element,
	int_measure_type,
	level_type,
	list_to_set,
	named_type,
	non_quantitative_int_type,
	property_BSU,
	property_DET,
	real_measure_type,
	revision_type,
	value_format_type,
	version_type);

REFERENCE FROM ISO13584_variable_semantics_schema
	(property_semantics);

REFERENCE FROM ISO13584_domain_resource_schema
	(domain_restriction,
	functional_domain_restriction);

REFERENCE FROM ISO13584_extended_dictionary_schema
	(abstract_functional_model_class,
	applicable_properties,
	applicable_tables,
	data_exchange_specification_identification,
	data_type_non_quantitative_int_type,
	data_type_type_name,
	data_type_typeof,
	dictionary_identification,
	dictionary,
	dictionary_in_standard_format,
	fm_class_view_of,
	get_property_BSU_from_property_semantics,
	library_iim_identification,
	functional_view_class,
	functional_view_v_c_v,
	view_control_variable_range,
	view_exchange_protocol_identification);

REFERENCE FROM ISO13584_external_file_schema
	(A6_illustration,
	A9_illustration,
	class_extension_external_item,
	dictionary_external_item,
	external_file_protocol,
	external_item,
	illustration,
	illustration_type,
	linked_interface_program_protocol,
	message,
	program_reference);

REFERENCE FROM ISO13584_library_expressions_schema
	(class_instance_constructor,
	collects_assigned_properties);

REFERENCE FROM ISO13584_method_schema
	(method);

REFERENCE FROM ISO13584_instance_resource_schema
	(context_dependent_property_value,
	dic_class_instance,
	dic_f_model_instance,
	primitive_value,
	property_or_data_type_BSU,
	property_value,
	same_translations,
	translated_string_value);

REFERENCE FROM ISO13584_expressions_schema
	(string_expression);

REFERENCE FROM measure_schema
	(amount_of_substance_unit,
	area_unit,
	context_dependent_unit,
	conversion_based_unit,
	derived_unit,
	derive_dimensional_exponents,
	derived_unit_element,
	dimensional_exponents,
	electric_current_unit,
	global_unit_assigned_context,
	length_unit,
	luminous_intensity_unit,
	mass_unit,
	named_unit,
	plane_angle_unit,
	ratio_unit,
	si_unit,
	solid_angle_unit,
	thermodynamic_temperature_unit,
	time_unit,
	unit,
	volume_unit);

REFERENCE FROM representation_schema
	(representation);

TYPE classification_value = INTEGER;
END_TYPE; -- classification_value

ENTITY library
SUPERTYPE OF(library_in_standard_format)
SUBTYPE OF(dictionary);
	linked_interfaces: SET [0:?] OF external_file_protocol;
WHERE
	WR1: QUERY(class <* SELF\dictionary.contained_classes |
		referenced_veps_exist_in_supported_veps(
		SELF, class)) = [];
	WR2: QUERY(class <* SELF.contained_classes |
		referenced_protocols_exist_in_supported_protocols(
		SELF, class)) = [];
	WR3: QUERY(int <* SELF.linked_interfaces
		| NOT(('ISO13584_EXTERNAL_FILE_SCHEMA'+
		'.LINKED_INTERFACE_PROGRAM_PROTOCOL')
		IN TYPEOF(int))) = [];
END_ENTITY; -- library

ENTITY library_in_standard_format
SUBTYPE OF(library, dictionary_in_standard_format);
WHERE
	WR1: QUERY(int <* SELF\library.linked_interfaces
		| SIZEOF(QUERY(vep <* SELF\dictionary.supported_vep
		| int\external_file_protocol.base_protocol IN
		vep\data_exchange_specification_identification
		.external_file_protocols)) = 0) = [];
END_ENTITY; -- library_in_standard_format

ENTITY class_extension
ABSTRACT SUPERTYPE OF(ONEOF(model_class_extension))
SUBTYPE OF(content_item);
	SELF\content_item.dictionary_definition: class_BSU;
END_ENTITY; -- class_extension

ENTITY opt_or_mand_property_BSU;
	property: property_BSU;
	is_optional: BOOLEAN;
	displayable: BOOLEAN;
END_ENTITY; -- opt_or_mand_property_BSU

ENTITY property_classification;
	its_value: classification_value;
	prop_def: property_BSU;
END_ENTITY; -- property_classification

ENTITY property_value_recommended_presentation;
	prop_def: property_BSU; 
	recommended_presentation_unit: unit;
	recommended_presentation_format: value_format_type;
WHERE
	WR1: presentation_unit_is_correct(SELF.prop_def,
		SELF.recommended_presentation_unit);
END_ENTITY;

ENTITY model_class_extension
ABSTRACT SUPERTYPE OF(ONEOF(
	implicit_model_class_extension, 
	explicit_model_class_extension))
SUBTYPE OF(class_extension);
	referenced_external_items: SET [0:?] OF
		class_extension_external_item;
	used_protocols: SET [0:?] OF external_file_protocol;
	referenced_view_exchange_protocol: LIST [0:?] OF
		view_exchange_protocol_identification;
	content_version: OPTIONAL version_type;
	content_revision: OPTIONAL revision_type;
	recommended_presentation: SET [0:?] OF
		property_value_recommended_presentation;
	classification: SET [0:?] OF property_classification;
WHERE
	WR1: QUERY(item <* SELF.referenced_external_items
		| NOT(item\external_item.used_protocol
		IN SELF.used_protocols)) = [];
	WR2: QUERY (prop <* classification | NOT 
		applicable_properties(SELF\content_item.
		dictionary_definition, [prop.prop_def])) = [];
	WR3: (EXISTS (SELF.content_version) 
		AND EXISTS (SELF.content_revision))
		OR (NOT EXISTS (SELF.content_version) 
		AND NOT EXISTS (SELF.content_revision));
END_ENTITY; -- model_class_extension

ENTITY explicit_model_class_extension
ABSTRACT SUPERTYPE OF(ONEOF(explicit_item_class_extension, 
		explicit_functional_model_class_extension))
SUBTYPE OF(model_class_extension);
	instance_identification: LIST[1:?] OF UNIQUE property_BSU;
	population: LIST[1:?] OF UNIQUE dic_class_instance;
	table_like: BOOLEAN;
WHERE
	WR1: NOT table_like OR (QUERY(inst <* SELF.population |
		NOT same_order_for_properties(population[1].properties,
		inst.properties)) = []);
	WR2: applicable_properties(
		SELF\content_item.dictionary_definition,
		list_to_set(SELF.instance_identification));
	WR3: all_properties_are_applicable(SELF);
	WR4: same_string_values_translations_for_class_extension(SELF);
	WR5: QUERY(inst <* SELF.population |
		inst.class_def :<>: SELF\content_item.dictionary_definition) 
		= [];
	WR6: QUERY(inst <* SELF.population | NOT(
		QUERY(prop <* inst.properties | NOT(EXISTS(prop.its_value)) 
		AND (prop.prop_def IN SELF.instance_identification)) = [])) 
		= [];
END_ENTITY; -- explicit_model_class_extension

ENTITY explicit_item_class_extension
SUBTYPE OF(explicit_model_class_extension);
	access_icon: OPTIONAL A9_illustration;
	content_msg: OPTIONAL message;
	create_icon: LIST [0:?] OF A6_illustration;
	create_msg: OPTIONAL message;
	class_presentation_on_paper: LIST [0:?] OF illustration;
	class_presentation_on_screen: LIST [0:?] OF illustration;
WHERE
	WR1: QUERY(inst <* SELF\explicit_model_class_extension.population
		| NOT('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
		'.DIC_ITEM_INSTANCE' IN TYPEOF(inst))) = [];
	WR2: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS' IN TYPEOF(
		(SELF\content_item.dictionary_definition.definition[1])));
	WR3: NOT(EXISTS(SELF.access_icon)) OR (SELF.access_icon IN
		SELF\model_class_extension.referenced_external_items);
	WR4: NOT(EXISTS(SELF.content_msg)) OR (SELF.content_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR5: list_to_set(SELF.create_icon)
		<= SELF\model_class_extension.referenced_external_items;
	WR6: NOT(EXISTS(SELF.create_msg)) OR (SELF.create_msg IN 
		SELF\model_class_extension.referenced_external_items);
	WR7: list_to_set(SELF.class_presentation_on_paper)
		<= SELF\model_class_extension.referenced_external_items;
	WR8: list_to_set(SELF.class_presentation_on_screen)
		<= SELF\model_class_extension.referenced_external_items;
	WR9: QUERY(icon <* SELF.class_presentation_on_paper |
		(NOT EXISTS(icon.width)) OR (icon.kind_of_content
		= illustration_type.not_static_picture)) = [];
	WR10: QUERY(icon <* SELF.class_presentation_on_screen |
		(NOT EXISTS(icon.width))) = [];
END_ENTITY; -- explicit_item_class_extension

ENTITY explicit_functional_model_class_extension
SUBTYPE OF(explicit_model_class_extension);
	measure_unit: OPTIONAL global_unit_assigned_context;
	required_item_values: SET [0:?] OF property_bsu;
	referenced_representation: OPTIONAL property_bsu;
	available_views_icon: OPTIONAL A6_illustration;
	available_views_msg: OPTIONAL message;
	context_param_icon: LIST [0:?] OF A6_illustration;
	context_param_msg: OPTIONAL message;
WHERE
	WR1:definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_EXTENDED_DICTIONARY_SCHEMA'+
		'.ABSTRACT_FUNCTIONAL_MODEL_CLASS' IN TYPEOF
		(SELF\content_item.dictionary_definition.definition[1]));
	WR2: required_values_are_non_dependent_p_det(SELF);
	WR3: required_values_are_imported_properties(SELF);
	WR4: SELF.required_item_values <= list_to_set(
		SELF\explicit_model_class_extension.instance_identification);
	WR5: NOT(EXISTS(SELF.available_views_icon)) 
		OR (SELF.available_views_icon IN
		SELF\model_class_extension.referenced_external_items);
	WR6: NOT(EXISTS(SELF.available_views_msg)) 
		OR (SELF.available_views_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR7: list_to_set(SELF.context_param_icon) <=
		SELF\model_class_extension.referenced_external_items;
	WR8: NOT(EXISTS(SELF.context_param_msg)) 
		OR (SELF.context_param_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR9: exists_representation_for_instanciable_view(SELF);
	WR10: all_view_control_variables_belong_to_each_view(SELF);
	WR11: QUERY(a_view <* SELF\explicit_model_class_extension.
		population | NOT('ISO13584_INSTANCE_RESOURCE_SCHEMA' + 
		'.DIC_F_MODEL_INSTANCE' IN TYPEOF(a_view))) = [];
	WR12: all_vcvs_belong_to_instance_identification(SELF);
	WR13: NOT EXISTS(referenced_representation)
		OR (QUERY(inst <* SELF.population | NOT 
		(is_provided_once_property_value(
		inst, referenced_representation))) = []);
	WR14: NOT EXISTS(referenced_representation)
		OR (QUERY(inst <* SELF.population | NOT 
		(number_of_instance_representations(
		inst) = 1)) = []);
	WR15: EXISTS(referenced_representation)
		OR (QUERY(inst <* SELF.population | NOT 
		(number_of_instance_representations(
		inst) = 0)) = []);
	WR16: NOT EXISTS(referenced_representation)
		OR (SIZEOF(referenced_representation.definition) = 0)
		OR NOT ('ISO13584_EXTENDED_DICTIONARY_SCHEMA.' +
		'PROGRAM_REFERENCE_TYPE' IN
		data_type_typeof(referenced_representation))
		OR (QUERY(inst <* SELF.population | NOT
		(correct_parameters_for_explicit_program(
		inst, referenced_representation))) = []);
END_ENTITY; -- explicit_functional_model_class_extension

ENTITY implicit_model_class_extension
ABSTRACT SUPERTYPE OF(ONEOF(item_class_extension, functional_model_class_extension))
SUBTYPE OF(model_class_extension);
	selectable_properties: LIST [0:?] OF UNIQUE 
		opt_or_mand_property_BSU;
	required_properties: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	derived_properties: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	class_extension: SET [0:?] OF domain_restriction;
	derivation: SET [0:?] OF functional_domain_restriction;
	filters: SET [0:?] OF domain_restriction;
WHERE
	WR1: QUERY(opt_or_mand <* SELF.selectable_properties
		| NOT applicable_properties
		(SELF\content_item.dictionary_definition,
		[opt_or_mand.property])) = [];
	WR2: QUERY(opt_or_mand <* SELF.derived_properties
		| NOT applicable_properties
		(SELF\content_item.dictionary_definition,
		[opt_or_mand.property])) = [];
	WR3: (QUERY(dom <* 
		(SELF.class_extension + SELF.derivation + SELF.filters)
		| (QUERY(sem <* dom.assumes 
		| NOT('ISO13584_VARIABLE_SEMANTICS_SCHEMA' 
		+ '.SELF_PROPERTY_SEMANTICS' IN TYPEOF(sem))) <> [])) = [])
		AND
		(QUERY(dom <* SELF.filters
		| (QUERY(sem <* dom.defines
		| NOT('ISO13584_VARIABLE_SEMANTICS_SCHEMA' 
		+ '.SELF_PROPERTY_SEMANTICS' IN TYPEOF(sem))) <> [])) = []);
	WR4: QUERY(dom <* (SELF.class_extension + SELF.derivation)
		| QUERY(sem <* dom.defines 
		| NOT('ISO13584_VARIABLE_SEMANTICS_SCHEMA'
		+'.SELF_PROPERTY_VALUE_SEMANTICS' IN TYPEOF(sem))
		OR EXISTS(sem.its_own_property))
		<> []) = [];
	WR5: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition) OR (QUERY(dom <*
		(SELF.class_extension + SELF.derivation + SELF.filters)
		| (QUERY(sem <* dom.assumes
		| NOT(sem\property_semantics.the_property IN
		provided_properties_list(SELF.dictionary_definition))) 
		<> [])) = []);
	WR6: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition) OR (QUERY(dom <* 
		(SELF.class_extension + SELF.filters)
		| (QUERY(sem <* dom.defines
		| NOT(sem\property_semantics.the_property IN
		selectable_properties_list(SELF.dictionary_definition))) 
		<> [])) = []);
	WR7: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition) OR (QUERY(dom <*
		(SELF.class_extension + SELF.derivation + SELF.filters)
		| (QUERY(tab <* dom.base_tables | NOT applicable_tables(
		SELF.dictionary_definition, [tab])) <> [])) = []);
	WR8: acyclic_class_extension_definition(
		SELF.dictionary_definition);
	WR9: QUERY(prop <* SELF.selectable_properties
		| SIZEOF(QUERY(choi <* SELF.class_extension
		| (prop.property IN get_property_BSU_from_property_semantics(
		choi\domain_restriction.defines)))) <> 1) = [];
	WR10: QUERY(prop <* SELF.derived_properties
		| SIZEOF(QUERY(f <* SELF.derivation
		| (prop.property IN get_property_BSU_from_property_semantics(
		f.defines)))) <> 1) = [];
	WR11: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition) OR (QUERY(f <* SELF.derivation
		| (QUERY(prop <* f.defines
		| NOT(get_property_BSU_from_property_semantics([prop])[1]
		IN derived_properties_list(SELF.dictionary_definition))) 
		<> [])) = []);
	WR12: NOT all_class_descriptions_reachable(
		SELF.dictionary_definition)
		OR (QUERY(prop <* derived_properties_list(
		SELF.dictionary_definition)
		| SIZEOF(QUERY(f <* defined_derivation_function(
		SELF.dictionary_definition) | QUERY(sem <* f.defines
		| sem\property_semantics.the_property = prop) <> [])) 
		<> 1) = []);
	WR13: QUERY(filt <* filters | NOT(EXISTS(
		filt.constraint_description))) = [];
	WR14: QUERY(dom_1 <* class_extension | NOT(QUERY(dom_2 <* 
		dom_1.domains | 'ISO13584_DOMAIN_RESOURCE_SCHEMA' +
		'.PREDICATE_DEFINED_DOMAIN' IN TYPEOF(dom_2.domain)) = [])
		) = [];
	WR15: QUERY(prop <* SELF.required_properties | 
		prop.is_optional) = [];
END_ENTITY; -- implicit_model_class_extension

ENTITY item_class_extension
SUBTYPE OF(implicit_model_class_extension);
	selection_context_parameters: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	identification_characteristics: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	derived_characteristics: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	context_dependent_characteristics: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	identified_item: BOOLEAN;
	supplier_identification: OPTIONAL string_expression;
	supplier_designation: OPTIONAL string_expression;
	access_icon: OPTIONAL A9_illustration;
	content_msg: OPTIONAL message;
	create_icon: LIST [0:?] OF A6_illustration;
	create_msg: OPTIONAL message;
	class_presentation_on_paper: LIST [0:?] OF illustration;
	class_presentation_on_screen: LIST [0:?] OF illustration;
DERIVE
	SELF\implicit_model_class_extension.selectable_properties:
		LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= SELF.selection_context_parameters
		+ SELF.identification_characteristics;
	SELF\implicit_model_class_extension.derived_properties:
		LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= SELF.derived_characteristics
		+ SELF.context_dependent_characteristics;
	SELF\implicit_model_class_extension.required_properties:
		LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= [];
WHERE
	WR1: definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS' IN
		TYPEOF((SELF\content_item.dictionary_definition.
		definition[1])));
	WR2: QUERY(elt <* SELF.selection_context_parameters |
		in_typeof('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
		'.CONDITION_DET', elt)) = SELF.selection_context_parameters;
	WR3: QUERY(elt <* SELF.identification_characteristics |
		in_typeof('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
		'.NON_DEPENDENT_P_DET', elt)) = 
		SELF.identification_characteristics;
	WR4: QUERY(elt <* SELF.identification_characteristics |
		(data_type_typeof(elt.property) <> [])
		AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
		'.SIMPLE_TYPE' IN data_type_typeof(elt.property))
		AND NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
		'.CLASS_INSTANCE_TYPE' IN data_type_typeof(elt.property))		) = [];
	WR5: QUERY(elt <* SELF.derived_characteristics |
		in_typeof('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
		'.NON_DEPENDENT_P_DET', elt)) = SELF.derived_properties;
	WR6: QUERY(elt <* SELF.context_dependent_characteristics |
		in_typeof('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
		'.DEPENDENT_P_DET', elt)) = 
		SELF.context_dependent_characteristics;
	WR7: NOT(EXISTS(SELF.access_icon)) OR (SELF.access_icon IN
		SELF\model_class_extension.referenced_external_items);
	WR8: NOT(EXISTS(SELF.content_msg)) OR (SELF.content_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR9: list_to_set(SELF.create_icon)
		<= SELF\model_class_extension.referenced_external_items;
	WR10: NOT(EXISTS(SELF.create_msg)) OR (SELF.create_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR11: list_to_set(SELF.class_presentation_on_paper)
		<= SELF\model_class_extension.referenced_external_items;
	WR12: list_to_set(SELF.class_presentation_on_screen)
		<= SELF\model_class_extension.referenced_external_items;
	WR13: QUERY(icon <* SELF.class_presentation_on_paper |
		(NOT EXISTS(icon.width)) OR (icon.kind_of_content
		= illustration_type.not_static_picture)) = [];
	WR14: QUERY(icon <* SELF.class_presentation_on_screen |
		(NOT EXISTS(icon.width))) = [];
END_ENTITY; -- item_class_extension

ENTITY functional_model_class_extension
SUBTYPE OF(implicit_model_class_extension);
	measure_unit: OPTIONAL global_unit_assigned_context;
	required_item_characteristics: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	free_model_properties: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	representation_properties: LIST [0:?] OF UNIQUE
		opt_or_mand_property_BSU;
	method_variables: SET [0:?] OF opt_or_mand_property_BSU;
	referenced_representation: SET [0:?] OF representation;
	provided_methods: SET [0:?] OF method;
	available_views_icon: OPTIONAL A6_illustration;
	available_views_msg: OPTIONAL message;
	context_param_icon: LIST [0:?] OF A6_illustration;
	context_param_msg: OPTIONAL message;
DERIVE
	SELF\implicit_model_class_extension.selectable_properties
		: LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= SELF.free_model_properties;
	SELF\implicit_model_class_extension.required_properties
		: LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= SELF.required_item_characteristics;
	SELF\implicit_model_class_extension.derived_properties
		:LIST [0:?] OF UNIQUE opt_or_mand_property_BSU
		:= SELF.representation_properties;
WHERE
	WR1:definition_available_implies(
		SELF\content_item.dictionary_definition,
		'ISO13584_EXTENDED_DICTIONARY_SCHEMA.'+
		'ABSTRACT_FUNCTIONAL_MODEL_CLASS' IN TYPEOF
		(SELF\content_item.dictionary_definition.definition[1]));
	WR2: required_properties_are_non_dependent_p_det(SELF);
	WR3: required_properties_are_imported_properties(SELF);
	WR4: QUERY(elt <* SELF.method_variables |
		in_typeof('ISO13584_EXTENDED_DICTIONARY_SCHEMA' +
		'.REPRESENTATION_P_DET', elt)) = SELF.method_variables;
	WR5: QUERY(elt <* SELF.method_variables |
		applicable_properties(
		SELF\content_item.dictionary_definition,[elt.property]))
		= SELF.method_variables;
	WR6: NOT(EXISTS(SELF.available_views_icon)) 
		OR (SELF.available_views_icon IN
		SELF\model_class_extension.referenced_external_items);
	WR7: NOT(EXISTS(SELF.available_views_msg)) 
		OR (SELF.available_views_msg IN
		SELF\model_class_extension.referenced_external_items);
	WR8: list_to_set(SELF.context_param_icon) <=
		SELF\model_class_extension.referenced_external_items;
	WR9: NOT(EXISTS(SELF.context_param_msg)) 
		OR (SELF.context_param_msg IN
		SELF\model_class_extension.referenced_external_items);
END_ENTITY; -- functional_model_class_extension

RULE assert_oneof_for_library_rule FOR(library);
WHERE
	WR1: QUERY(temp <* library |
		NOT('ISO13584_LIBRARY_CONTENT_SCHEMA'
		+ '.LIBRARY_IN_STANDARD_FORMAT'
		IN TYPEOF(temp))
		AND('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+ '.DICTIONARY_IN_STANDARD_FORMAT'
		IN TYPEOF(temp))) = [];

END_RULE; -- assert_oneof_for_library_rule

RULE declared_created_views_are_created_rule FOR(
	functional_model_class_extension, functional_view_class);
WHERE
	WR1: QUERY(a_model <* functional_model_class_extension |
		(computable_set_of_created_views_from_model
		(a_model\content_item.dictionary_definition)) AND
		NOT((declared_created_views(
			a_model\content_item.dictionary_definition)
		<= (created_views_by_methods(a_model\content_item
		.dictionary_definition))))) = [];

END_RULE; -- declared_created_views_are_created_rule

RULE complete_identification_for_instance_rule FOR(
	class_instance_constructor);
WHERE
	WR1: (QUERY(inst <* class_instance_constructor |
		NOT(definition_available_implies(inst.expr_type,
		(SIZEOF(inst.expr_type.referenced_by) = 0) OR
		('ISO13584_LIBRARY_CONTENT_SCHEMA.' + 
		'IMPLICIT_MODEL_CLASS_EXTENSION'
		IN TYPEOF(inst.expr_type.referenced_by[1])))))
		= []);
	WR2: (QUERY(inst <* class_instance_constructor |
		QUERY(prop <*
		(list_to_set(collects_assigned_properties(inst.properties)) -
		list_to_set(optional_properties_list(inst.expr_type))) |
		NOT(EXISTS(prop.its_value))) = []) =[]);
		
END_RULE; -- complete_identification_for_instance_rule

RULE complete_identification_for_item_instance_rule FOR(
	class_instance_constructor, item_class_extension);
WHERE
	WR1: QUERY(inst <* class_instance_constructor |
		NOT(
		definition_available_implies(inst.expr_type,
		(SIZEOF(inst.expr_type.referenced_by) = 0) OR
		(('ISO13584_LIBRARY_CONTENT_SCHEMA.ITEM_CLASS_EXTENSION'
		IN TYPEOF(inst.expr_type.referenced_by[1]))
		AND (collects_assigned_properties(inst.properties)
		= (gm_identification_characteristics_list(inst.expr_type))))
		))) = [];
END_RULE; -- complete_identification_for_item_instance_rule

RULE complete_identification_for_model_instance_rule FOR(
	class_instance_constructor, functional_model_class_extension);
WHERE
	WR1: (QUERY(inst <* class_instance_constructor |
		NOT(
		definition_available_implies(inst.expr_type,
		(('ISO13584_LIBRARY_CONTENT_SCHEMA.'
		+ 'FUNCTIONAL_MODEL_CLASS_EXTENSION'
		IN TYPEOF(inst.expr_type.referenced_by[1]))
		AND (collects_assigned_properties(inst.properties)
		= fm_free_model_properties_list(inst.expr_type))))
		)) = []);
END_RULE; -- complete_identification_for_model_instance_rule

RULE all_views_available_for_each_component_rule FOR (
	explicit_model_class_extension, 
	explicit_functional_model_class_extension);
WHERE
	WR1: QUERY(a_model <* explicit_functional_model_class_extension |
		NOT(all_views_available_for_components(a_model\content_item
		.dictionary_definition))) = [];

END_RULE; -- all_views_available_for_each_component_rule

FUNCTION acyclic_class_extension_definition(cl: class_BSU): LOGICAL;

LOCAL	
	edges: SET OF domain_restriction;
	prop: LIST OF property_BSU;
END_LOCAL;

prop := provided_properties_list(cl);
edges := defined_domain(cl) + defined_derivation_function(cl);

REPEAT i := LOINDEX(prop) TO HIINDEX(prop);
	IF NOT acyclic_order(prop[i], edges, [])
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- acyclic_class_extension_definition

FUNCTION acyclic_order(p: property_BSU;
	edges: SET OF domain_restriction;
	nodes: SET OF property_BSU): BOOLEAN;

LOCAL	
	succ: SET OF property_BSU := [];
	-- set of property_BSU that depends (recursively) on p
	out_edges: SET OF domain_restriction;
	-- set of domain_restrictions that contain one of the
	-- property_BSU of the set nodes in the the_property attribute
	-- of one of their assumes variable_semantics
END_LOCAL;

out_edges := QUERY(e <* edges | (QUERY(v <* e.assumes
	| v\property_semantics.the_property IN nodes) <> []));

REPEAT i := LOINDEX(out_edges) TO HIINDEX(out_edges);

	REPEAT j := LOINDEX(out_edges[i].defines)
		TO HIINDEX(out_edges[i].defines);
		succ := succ + out_edges[i].defines[j]
			\property_semantics.the_property;
	END_REPEAT;

END_REPEAT;

-- p depends on itself:
IF p IN succ
THEN
	RETURN(FALSE);
END_IF;

-- all the depending properties are reached
IF succ <= nodes
THEN
	RETURN(TRUE);
END_IF;

RETURN(acyclic_order(p, edges, nodes + succ));

END_FUNCTION; -- acyclic_order

FUNCTION defined_domain(cl: class_BSU): SET OF domain_restriction;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	RETURN(cl.referenced_by[1]\implicit_model_class_extension.
		class_extension);
ELSE
	RETURN([]);
END_IF;

END_FUNCTION; -- defined_domain

FUNCTION defined_derivation_function(cl: class_BSU):
	SET OF functional_domain_restriction;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	RETURN(cl.referenced_by[1]
		\implicit_model_class_extension.derivation);
ELSE
	RETURN([]);
END_IF;

END_FUNCTION; -- defined_derivation_function

FUNCTION allowed_properties(cl: class_BSU; 
	prop: SET OF property_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); -- the class itself is indeterminate
END_IF;

IF (prop <= (list_to_set(provided_properties_list(cl))))
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- allowed_properties

FUNCTION provided_properties_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	provided_prop: LIST OF opt_or_mand_property_BSU := [];
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	provided_prop := 
		cl.referenced_by[1]\implicit_model_class_extension.
			derived_properties
		+ cl.referenced_by[1]\implicit_model_class_extension.
			required_properties
		+ cl.referenced_by[1]\implicit_model_class_extension.
			selectable_properties;

	REPEAT i := 1 TO SIZEOF(provided_prop);
		prop := prop + provided_prop[i].property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- provided_properties_list

FUNCTION provided_properties_or_method_variables(cl: class_BSU):
	SET OF property_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

RETURN(method_variables(cl) + provided_properties_list(cl));

END_FUNCTION; -- provided_properties_or_method_variables

FUNCTION selectable_properties_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
			\implicit_model_class_extension.selectable_properties);
		prop := prop + cl.referenced_by[1]\
		implicit_model_class_extension.selectable_properties[i].
		property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- selectable_properties_list

FUNCTION required_defined_properties(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
			\implicit_model_class_extension.required_properties);
		prop := prop + cl.referenced_by[1]\
			implicit_model_class_extension.required_properties[i].
			property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- required_defined_properties

FUNCTION derived_properties_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
			\implicit_model_class_extension.derived_properties);
		prop := prop + cl.referenced_by[1]
			\implicit_model_class_extension.derived_properties[i].
			property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- derived_properties_list

FUNCTION optional_properties_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
		\implicit_model_class_extension.derived_properties);
		IF (cl.referenced_by[1]\implicit_model_class_extension
			.derived_properties[i].is_optional)
		THEN
			prop := prop + cl.referenced_by[1]
				\implicit_model_class_extension.
				derived_properties[i].property;
		END_IF;
	END_REPEAT; -- derived optional properties of this class

	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
		\implicit_model_class_extension.selectable_properties);
		IF (cl.referenced_by[1]\implicit_model_class_extension
			.selectable_properties[i].is_optional)
		THEN
			prop := prop + cl.referenced_by[1]
				\implicit_model_class_extension.
				selectable_properties[i].property;
		END_IF;
	END_REPEAT; -- selectable optional properties of this class
END_IF;

RETURN(prop);

END_FUNCTION; -- optional_properties_list

FUNCTION method_variables(cl: class_BSU): SET OF property_BSU;

LOCAL
	prop: SET OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF NOT('ISO13584_LIBRARY_CONTENT_SCHEMA.'
		+ 'FUNCTIONAL_MODEL_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1])) -- abnormal case
	THEN
		RETURN([]);
	ELSE
		REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
			\functional_model_class_extension.method_variables);
			prop := prop + cl.referenced_by[1]\
				functional_model_class_extension.
				method_variables[i].property;
		END_REPEAT;
	END_IF;
END_IF;

RETURN(prop);

END_FUNCTION; -- method_variables

FUNCTION gm_identification_characteristics_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF NOT('ISO13584_LIBRARY_CONTENT_SCHEMA.ITEM_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1])) -- abnormal case
	THEN
		RETURN([]); -- abnormal case
	END_IF;
	
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
		\item_class_extension.identification_characteristics);
		prop := prop + cl.referenced_by[1]
			\item_class_extension.identification_characteristics[i]
			.property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- gm_identification_characteristics_list

FUNCTION fm_free_model_properties_list(cl: class_BSU):
	LIST OF property_BSU;

LOCAL
	prop: LIST OF property_BSU := [];
END_LOCAL;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF NOT('ISO13584_LIBRARY_CONTENT_SCHEMA'
		+ '.FUNCTIONAL_MODEL_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1])) -- normal case
	THEN
		RETURN([]); -- abnormal case
	END_IF;
	
	REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
		\functional_model_class_extension.free_model_properties);
		prop := prop + cl.referenced_by[1]
			\functional_model_class_extension
			.free_model_properties[i].property;
	END_REPEAT;
END_IF;

RETURN(prop);

END_FUNCTION; -- fm_free_model_properties_list

FUNCTION exists_super(cl: class_BSU): LOGICAL;

IF NOT EXISTS(cl)
THEN
	RETURN(UNKNOWN); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.definition) = 0)
THEN
	RETURN(UNKNOWN);
ELSE
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN(TRUE);
	ELSE
		RETURN(FALSE);
	END_IF;
END_IF;

END_FUNCTION; -- exists_super

FUNCTION super(cl: class_BSU): SET[0:1] OF class_BSU;

IF NOT EXISTS(cl)
THEN
	RETURN([]); -- the class itself is indeterminate
END_IF;

IF (SIZEOF(cl.definition) = 1)
THEN
	IF EXISTS(cl.definition[1]\class.its_superclass)
	THEN
		RETURN([cl.definition[1]\class.its_superclass]);
	END_IF;
END_IF;

RETURN([]);

END_FUNCTION; -- super

FUNCTION is_in_v_c_v_range(p: property_BSU;
	l: SET OF view_control_variable_range): BOOLEAN;

IF (SIZEOF(QUERY(elt <* l | elt.parameter_type = p)) = 1)
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- is_in_v_c_v_range

FUNCTION get_v_c_v_range(p: property_BSU;
	l: SET OF view_control_variable_range):
	view_control_variable_range;

LOCAL
	x: SET OF view_control_variable_range;
END_LOCAL;

x := QUERY(elt <* l | elt.parameter_type = p);

RETURN(x[1]);

END_FUNCTION; -- get_v_c_v_range

FUNCTION all_v_c_v_range_available(l: LIST OF property_BSU):
	BOOLEAN;
LOCAL
	res: BOOLEAN:= TRUE;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(l);
	IF NOT(SIZEOF(data_type_non_quantitative_int_type(l[i])) = 1)
	THEN
		res := FALSE;
	END_IF;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- all_v_c_v_range_available

FUNCTION make_ordered_list_of_v_c_v_range(
	l: LIST OF property_BSU;
	l_range: SET OF view_control_variable_range):
	LIST OF view_control_variable_range;
LOCAL
	y: view_control_variable_range;
	res: LIST OF view_control_variable_range:=[];
	s: SET[0:1] OF non_quantitative_int_type;
	x: non_quantitative_int_type;
END_LOCAL;

IF NOT all_v_c_v_range_available(l)
THEN
	RETURN([]);
END_IF;

REPEAT i := 1 TO SIZEOF(l);
	IF is_in_v_c_v_range(l[i], l_range)
	THEN
		res := res + get_v_c_v_range(l[i], l_range);
	ELSE
		s := data_type_non_quantitative_int_type(l[i]);
		x := s[1];
		y := view_control_variable_range(l[i], 
			x.domain.its_values[1].value_code, 
			x.domain.its_values[1].value_code + 
			SIZEOF(x.domain.its_values) - 1);
		res := res + y;
	END_IF;
END_REPEAT;

RETURN(res);

END_FUNCTION; -- make_ordered_list_of_v_c_v_range

FUNCTION cdr_list(l: LIST [2:?] OF GENERIC: type_elem):
	LIST OF GENERIC: type_elem;

LOCAL
	cdr: LIST OF GENERIC: type_elem := [];
END_LOCAL;

REPEAT i := 2 TO SIZEOF(l);
	cdr := cdr + l[i];
END_REPEAT;

RETURN(cdr);

END_FUNCTION; -- cdr_list

FUNCTION make_tuple(l: LIST[1:?] of view_control_variable_range):
	SET [1:?] OF LIST[1:?] OF INTEGER;

LOCAL
	result: SET OF LIST OF INTEGER := [];
	list_sub_tuple: SET OF LIST OF INTEGER;
END_LOCAL;

IF SIZEOF(l) = 1 THEN
	REPEAT i := l[1]\view_control_variable_range.range_lobound TO
		l[1]\view_control_variable_range.range_hibound;
		result := [[i]] + result;
	END_REPEAT;
ELSE
	list_sub_tuple := make_tuple(cdr_list(l));
	REPEAT i := 1 TO SIZEOF(list_sub_tuple);	-- for each subtuple
		REPEAT j := l[1]\view_control_variable_range.range_lobound
			TO l[1]\view_control_variable_range.range_hibound;
			-- creates one new tuple for each value of l[1]
			result := result + [j + list_sub_tuple[i]];
		END_REPEAT;
	END_REPEAT;
END_IF;

RETURN(result);

END_FUNCTION; -- make_tuple

FUNCTION computable_set_of_created_views_from_model(
	cl: class_BSU): BOOLEAN;

IF NOT EXISTS(cl)
THEN
	RETURN(FALSE); -- the class itself is indeterminate
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
	RETURN(FALSE);
END_IF;

IF SIZEOF(cl.referenced_by) = 0
THEN
	RETURN(FALSE);
END_IF;
IF NOT('ISO13584_EXTENDED_DICTIONARY_SCHEMA.'+
	'ABSTRACT_FUNCTIONAL_MODEL_CLASS' IN TYPEOF(cl.definition[1]))
THEN
	RETURN(FALSE);
END_IF;
IF NOT('ISO13584_LIBRARY_CONTENT_SCHEMA.'+
	'FUNCTIONAL_MODEL_CLASS_EXTENSION' IN TYPEOF(
	cl.referenced_by[1]))
	AND NOT ('ISO13584_LIBRARY_CONTENT_SCHEMA.'+
	'EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION' IN TYPEOF(
	cl.referenced_by[1]))
THEN
	RETURN(FALSE);
END_IF;

IF SIZEOF(functional_view_v_c_v(cl.definition[1]
	\abstract_functional_model_class.created_view)) = 0
THEN
	RETURN(FALSE);
END_IF;

RETURN(all_v_c_v_range_available(functional_view_v_c_v(cl.definition[1]
	\abstract_functional_model_class.created_view)));

END_FUNCTION; -- computable_set_of_created_views_from_model

FUNCTION declared_created_views(cl: class_BSU):
	SET OF LIST OF INTEGER;

LOCAL
	res: SET OF LIST OF INTEGER:=[];
	v_c_vs: LIST OF view_control_variable_range;
END_LOCAL;

IF NOT computable_set_of_created_views_from_model(cl)
THEN
	RETURN([]);
END_IF;

v_c_vs := make_ordered_list_of_v_c_v_range(functional_view_v_c_v(
	cl.definition[1]\abstract_functional_model_class.created_view),
	cl.definition[1]\abstract_functional_model_class.v_c_v_range);

res := make_tuple(v_c_vs);

RETURN(res);

END_FUNCTION; -- declared_created_views

FUNCTION created_views_by_methods(cl: class_BSU):
	SET OF LIST OF INTEGER;
LOCAL
	res: SET OF LIST OF INTEGER:=[];
	v_c_vs: LIST OF view_control_variable_range;
END_LOCAL;

IF NOT computable_set_of_created_views_from_model(cl)
THEN
	RETURN([]);
END_IF;

REPEAT i := 1 TO SIZEOF(cl.referenced_by[1]
	\functional_model_class_extension.provided_methods);
	v_c_vs := make_ordered_list_of_v_c_v_range(
		functional_view_v_c_v(cl.definition[1]
		\abstract_functional_model_class.created_view),
		cl.referenced_by[1]\functional_model_class_extension
		.provided_methods[i].specification.v_c_v_range);
	res := res + make_tuple(v_c_vs);
END_REPEAT;

RETURN(res);

END_FUNCTION; -- created_views_by_methods

FUNCTION in_typeof(typ: STRING; elt: opt_or_mand_property_BSU):
	LOGICAL;

IF SIZEOF(elt.property.definition) = 1 THEN
	RETURN(typ IN TYPEOF(elt.property.definition [1]));
ELSE
	RETURN(TRUE);
END_IF;

END_FUNCTION; -- in_typeof

FUNCTION referenced_veps_exist_in_supported_veps(
	lib: library; cl: class_BSU): LOGICAL;
LOCAL
	class_extension: SET [0:1] OF content_item :=
		cl\basic_semantic_unit.referenced_by;
	class_extension_referenced_veps: SET OF
		view_exchange_protocol_identification;
	dictionary_supported_veps: SET OF 
		view_exchange_protocol_identification;
	tmp: LOGICAL;
END_LOCAL;

IF (SIZEOF(class_extension) = 1)
THEN
	class_extension_referenced_veps :=
		list_to_set(class_extension[1]\model_class_extension
		.referenced_view_exchange_protocol);
	dictionary_supported_veps := lib\dictionary.supported_vep;
	tmp := (class_extension_referenced_veps <=
		dictionary_supported_veps);
	RETURN(('ISO13584_LIBRARY_CONTENT_SCHEMA.MODEL_CLASS_EXTENSION'
		IN TYPEOF(class_extension[1]))
		AND NOT(tmp));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- referenced_veps_exist_in_supported_veps

FUNCTION referenced_protocols_exist_in_supported_protocols(
	lib: library; cl: class_BSU): LOGICAL;
LOCAL
	class_extension: SET [0:1] OF content_item :=
		cl\basic_semantic_unit.referenced_by;
END_LOCAL;

IF SIZEOF(class_extension) = 1
THEN
	RETURN(('ISO13584_LIBRARY_CONTENT_SCHEMA' +
		'.MODEL_CLASS_EXTENSION' IN TYPEOF(class_extension))
		AND
		(SIZEOF(QUERY(pr <* class_extension[1]\model_class_extension
		.referenced_external_items | NOT(
		pr\external_item.used_protocol IN
		lib\dictionary.base_protocols)
		AND NOT(pr\external_item.used_protocol IN
		lib.linked_interfaces))) <> 0));
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- referenced_protocols_exist_in_supported_protocols

FUNCTION required_properties_are_non_dependent_p_det(
	fm_class_ext: functional_model_class_extension): LOGICAL;

LOCAL
	res: LOGICAL := TRUE;
	prop: property_bsu;
END_LOCAL;

IF (SIZEOF(fm_class_ext.required_item_characteristics) <> 0)
THEN
	IF (SIZEOF(fm_class_ext\content_item.
		dictionary_definition.definition) = 1)
	THEN
		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA' +
			'.FM_CLASS_VIEW_OF') IN 
			TYPEOF(fm_class_ext\content_item
			.dictionary_definition.definition[1])
		THEN
			REPEAT i := 1 TO SIZEOF(fm_class_ext.
							required_item_characteristics);
				prop := fm_class_ext.
					required_item_characteristics[i].property;

				IF (SIZEOF(prop.definition) = 1)
				THEN
					IF NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' +
						'.NON_DEPENDENT_P_DET' IN 
						TYPEOF(prop.definition[1]))
					THEN
						res := FALSE;
					END_IF;
				ELSE
					res := res AND UNKNOWN;
				END_IF;

			END_REPEAT;
		ELSE
			res := FALSE;
		END_IF;
	ELSE
		res := UNKNOWN;
	END_IF;
END_IF;

RETURN(res);

END_FUNCTION; -- required_properties_are_non_dependent_p_det

FUNCTION required_properties_are_imported_properties(
	fm_class_ext: functional_model_class_extension): LOGICAL;

LOCAL
	res: LOGICAL := TRUE;
	prop: property_bsu;
END_LOCAL;

IF (SIZEOF(fm_class_ext.required_item_characteristics) <> 0)
THEN
	IF (SIZEOF(fm_class_ext\content_item.dictionary_definition.
		definition) = 1)
	THEN
		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA' +
			'.FM_CLASS_VIEW_OF') IN 
			TYPEOF(fm_class_ext\content_item
			.dictionary_definition.definition[1])
		THEN
			REPEAT i := 1 TO SIZEOF(fm_class_ext.
							required_item_characteristics);
				prop := fm_class_ext.
					required_item_characteristics[i].property;

				IF NOT(prop IN fm_class_ext\content_item.
					dictionary_definition.definition[1]\
					fm_class_view_of.
					imported_properties_from_item)
				THEN
					res := FALSE;
				END_IF;

			END_REPEAT;
		ELSE
			res := FALSE;
		END_IF;
	ELSE
		res := UNKNOWN;
	END_IF;
END_IF;

RETURN(res);

END_FUNCTION; -- required_properties_are_imported_properties

FUNCTION same_order_for_properties(
	first, current: LIST [1:?] OF property_value): BOOLEAN;

IF SIZEOF(first) = SIZEOF(current)
THEN ;
ELSE	RETURN(FALSE);
END_IF;

REPEAT i := 1 TO SIZEOF(first);
	IF NOT (first[i].prop_def = current[i].prop_def)
	THEN
		RETURN(FALSE);
	END_IF;

	IF (('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
		'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
		IN TYPEOF(first[i]))
	THEN
		IF NOT(('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
			'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
			IN TYPEOF(current[i]))
		THEN
			RETURN(FALSE);
		END_IF;

		IF NOT same_order_for_properties(
			first[i]\context_dependent_property_value.the_context,
			current[i]\context_dependent_property_value.
			the_context)
		THEN
			RETURN(FALSE);
		END_IF;
	END_IF;

	IF (('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
		'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
		IN TYPEOF(current[i]))
	THEN
		IF NOT(('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
			'.CONTEXT_DEPENDENT_PROPERTY_VALUE')
			IN TYPEOF(first[i]))
		THEN
			RETURN(FALSE);
		END_IF;
	END_IF;

	IF (('ISO13584_INSTANCE_RESOURCE_SCHEMA' +
		'.DIC_CLASS_INSTANCE') IN TYPEOF (first[i].its_value))
	THEN 
		IF NOT 
			same_order_for_properties(first[i].its_value.properties,
								current[i].its_value.properties)
		THEN RETURN (FALSE);
		END_IF;
	END_IF;

END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- same_order_for_properties

FUNCTION all_properties_are_applicable(
	expl: explicit_model_class_extension): LOGICAL;

LOCAL
	inst: dic_class_instance;
	prop_val: property_value;
	res: LOGICAL := TRUE;
END_LOCAL;	

REPEAT i := 1 TO SIZEOF(expl.population);
	inst := expl.population[i];
	REPEAT j := 1 TO SIZEOF(inst.properties);
		prop_val := inst.properties[j];
		res := res AND applicable_properties(expl\
			content_item.dictionary_definition, 
			[prop_val.prop_def]);
	END_REPEAT;

END_REPEAT;

RETURN(res);

END_FUNCTION; -- all_properties_are_applicable

FUNCTION required_values_are_non_dependent_p_det(
	fm_class_ext: explicit_functional_model_class_extension): 
	LOGICAL;

LOCAL
	res: LOGICAL := TRUE;
	prop: property_bsu;
END_LOCAL;

IF (SIZEOF(fm_class_ext.required_item_values) <> 0)
THEN
	IF (SIZEOF(fm_class_ext\content_item.dictionary_definition.
		definition) = 1)
	THEN
		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA' +
			'.FM_CLASS_VIEW_OF') IN 
			TYPEOF(fm_class_ext\content_item
			.dictionary_definition.definition[1])
		THEN
			REPEAT i := 1 TO SIZEOF(
					fm_class_ext.required_item_values);
				prop := fm_class_ext.required_item_values[i];

				IF (SIZEOF(prop.definition) = 1)
				THEN
					IF NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' 
						+ '.NON_DEPENDENT_P_DET' IN 
						TYPEOF(prop.definition[1]))
					THEN
						res := FALSE;
					END_IF;
				ELSE
					res := res AND UNKNOWN;
				END_IF;
			END_REPEAT;
		ELSE
			res := FALSE;
		END_IF;
	ELSE
		res := UNKNOWN;
	END_IF;
END_IF;

RETURN(res);

END_FUNCTION; -- required_values_are_non_dependent_p_det

FUNCTION required_values_are_imported_properties(
	fm_class_ext: explicit_functional_model_class_extension): 
	LOGICAL;

LOCAL
	res: LOGICAL := TRUE;
	prop: property_bsu;
END_LOCAL;

IF (SIZEOF(fm_class_ext.required_item_values) <> 0)
THEN
	IF (SIZEOF(fm_class_ext\content_item.dictionary_definition.
		definition) = 1)
	THEN
		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA' +
			'.FM_CLASS_VIEW_OF') IN 
			TYPEOF(fm_class_ext\content_item
			.dictionary_definition.definition[1])
		THEN
			REPEAT i := 1 TO SIZEOF(
					fm_class_ext.required_item_values);
				prop := fm_class_ext.required_item_values[i];

				IF NOT(prop IN fm_class_ext\content_item.
					dictionary_definition.definition[1]\
					fm_class_view_of.
					imported_properties_from_item)
				THEN
					res := FALSE;
				END_IF;
			END_REPEAT;
		ELSE
			res := FALSE;
		END_IF;
	ELSE
		res := UNKNOWN;
	END_IF;
END_IF;

RETURN(res);

END_FUNCTION; -- required_values_are_imported_properties

FUNCTION data_type_of_BSU(type_spec: property_or_data_type_BSU):
	SET[0:1] OF data_type;
LOCAL
	res: BOOLEAN := FALSE;
	x: data_type;
END_LOCAL;

IF NOT EXISTS(type_spec)
THEN
	RETURN([]); -- type_spec is indeterminate
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.PROPERTY_BSU' IN
	TYPEOF(type_spec))
THEN
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]\property_DET.domain;
		res := TRUE;
	END_IF;
ELSE
	IF NOT(SIZEOF(type_spec.definition) = 0)
	THEN
		x := type_spec.definition[1]
			\data_type_element.type_definition;
		res := TRUE;
	END_IF;
END_IF;

IF NOT(res)
THEN
	RETURN([]);
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NAMED_TYPE' IN TYPEOF(x))
THEN
	IF NOT(SIZEOF(x\named_type.referred_type.definition) = 0)
	THEN
		RETURN(data_type_of_BSU(x\named_type.referred_type));
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([x]);
END_IF;

END_FUNCTION; -- data_type_of_BSU

FUNCTION presentation_unit_is_correct(prop: property_BSU; 
	to_unit: unit): LOGICAL;
LOCAL
	prop_domain: data_type;
	prop_typeof: SET OF STRING := [];
END_LOCAL;

IF (SIZEOF(prop\basic_semantic_unit.definition) = 0)
THEN
	RETURN(UNKNOWN);
END_IF;

prop_typeof := data_type_typeof(prop);

IF (prop_typeof = []) -- some DET not present
THEN
	RETURN(UNKNOWN);
END_IF;

prop_domain := data_type_of_BSU(prop)[1]; -- not empty

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_MEASURE_TYPE' IN
	TYPEOF(prop_domain))
THEN
	RETURN(derive_dimensional_exponents(to_unit) = 
		derive_dimensional_exponents(prop_domain\
		int_measure_type.unit.structured_representation));
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_MEASURE_TYPE' IN
	TYPEOF(prop_domain))
THEN
	RETURN(derive_dimensional_exponents(to_unit) = 
		derive_dimensional_exponents(prop_domain\
		real_measure_type.unit.structured_representation));
END_IF;

IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.LEVEL_TYPE' IN
	TYPEOF(prop_domain))
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.INT_MEASURE_TYPE' IN
		TYPEOF(prop_domain\level_type.value_type))
	THEN
		RETURN(derive_dimensional_exponents(to_unit) = 
			derive_dimensional_exponents(
			prop_domain\level_type.value_type
			.unit.structured_representation));
	END_IF;
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.REAL_MEASURE_TYPE' IN
		TYPEOF(prop_domain\level_type.value_type))
	THEN
		RETURN(derive_dimensional_exponents(to_unit) = 
			derive_dimensional_exponents(
			prop_domain\level_type.value_type
			.unit.structured_representation));
	END_IF;
END_IF;

RETURN(FALSE);

END_FUNCTION; -- presentation_unit_is_correct

FUNCTION exists_representation_for_instanciable_view(
	ext: explicit_functional_model_class_extension): LOGICAL;
LOCAL
	cpt: INTEGER := 0;
	prop_val: property_value;
END_LOCAL;

IF (SIZEOF(ext.dictionary_definition.definition) = 1)
THEN
	IF (SIZEOF(ext.dictionary_definition.definition[1]\
		abstract_functional_model_class.created_view.definition) = 1)
	THEN
		IF (NOT('ISO13584_EXTENDED_DICTIONARY_SCHEMA.' +
			'NON_INSTANTIABLE_FUNCTIONAL_VIEW_CLASS' IN TYPEOF(
			ext.dictionary_definition.definition[1]\
			abstract_functional_model_class.created_view.
			definition[1])))
		THEN
			RETURN(EXISTS(ext.referenced_representation)
					AND
					(('ISO13584_EXTERNAL_FILE_SCHEMA.' + 
					'PROGRAM_REFERENCE' IN 
					data_type_type_name(
					ext.referenced_representation))
					OR ('ISO13584_EXTERNAL_FILE_SCHEMA.' + 
					'REPRESENTATION_REFERENCE' IN 
					data_type_type_name(
					ext.referenced_representation))
					OR ('REPRESENTATION_SCHEMA.' + 
					'REPRESENTATION' IN 
					data_type_type_name(
					ext.referenced_representation)))) ;
		ELSE
			RETURN(NOT EXISTS(ext.referenced_representation));
		END_IF;
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- exists_representation_for_instanciable_view

FUNCTION is_provided_once_property_value(
		a_model: dic_class_instance;
		prop: property_or_data_type_BSU): BOOLEAN;
LOCAL
	cpt: INTEGER := 0;
END_LOCAL;

IF NOT (('ISO13584_IEC61360_DICTIONARY_SCHEMA.' +
	'PROPERTY_BSU') IN TYPEOF (prop))
THEN
	RETURN(FALSE);		
END_IF;

REPEAT i := 1 TO SIZEOF(a_model.properties);
	IF ((prop = a_model.properties[i].prop_def) AND
		EXISTS(a_model.properties[i].its_value))
	THEN
		cpt := cpt + 1;
	END_IF;
END_REPEAT;
RETURN (cpt = 1);
END_FUNCTION; -- is_provided_once_property_value

FUNCTION number_of_instance_representations(
		a_model: dic_class_instance): INTEGER;
LOCAL
	cpt: INTEGER := 0;
	prop_val: property_value;
END_LOCAL;

REPEAT i := 1 TO SIZEOF(a_model.properties);
	prop_val := a_model.properties[i];
	IF data_type_typeof(prop_val.prop_def) = []
	THEN
		RETURN(?);
	END_IF;
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.' + 
		'ENTITY_INSTANCE_TYPE' IN 
		data_type_typeof(prop_val.prop_def)) 
	THEN
		IF (('ISO13584_EXTERNAL_FILE_SCHEMA.' + 
			'PROGRAM_REFERENCE' IN 
			data_type_type_name(prop_val.prop_def))
			OR ('ISO13584_EXTERNAL_FILE_SCHEMA.' + 
			'REPRESENTATION_REFERENCE' IN 
			data_type_type_name(prop_val.prop_def))
			OR ('REPRESENTATION_SCHEMA.' + 
			'REPRESENTATION' IN 
			data_type_type_name(prop_val.prop_def)))
		THEN
			cpt := cpt + 1;
		END_IF;
	END_IF;
END_REPEAT;

RETURN(cpt);

END_FUNCTION; -- number_of_instance_representations

FUNCTION correct_parameters_for_explicit_program(
		a_model: dic_class_instance;
		prop: property_BSU): BOOLEAN;

IF NOT('ISO13584_EXTENDED_DICTIONARY_SCHEMA.' +
		'PROGRAM_REFERENCE_TYPE' IN
		data_type_typeof(prop))
THEN
	RETURN (FALSE); --not a program
END_IF;

REPEAT i := 1 TO SIZEOF(a_model.properties);
	IF (prop = a_model.properties[i].prop_def)
	THEN	--characteristics of the program_reference
		IF EXISTS(a_model.properties[i].its_value) AND
			('ISO13584_EXTERNAL_FILE_SCHEMA.' +
			'PROGRAM_REFERENCE' IN
			TYPEOF(a_model.properties[i].its_value)) AND
			(SIZEOF(a_model.properties[i].its_value.
			out_parameters) = 0)
			AND (SIZEOF(a_model.properties[i].its_value.
			inout_parameters) = 0) AND
			(QUERY (in_p <* a_model.properties[i].its_value.
			in_parameters
			| NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.' +
			'PROPERTY_BSU' IN TYPEOF (in_p))
			OR NOT is_provided_once_property_value(
			a_model, in_p)) = [])
		THEN
			RETURN(TRUE); --correct program_reference
		ELSE
			RETURN(FALSE); --not correct program_reference
		END_IF;
	END_IF;
END_REPEAT;

RETURN(FALSE); -- program_reference was not found

END_FUNCTION; -- correct_parameters_for_explicit_program

FUNCTION get_dic_item_instances_from_required_item_properties(
	cl: class_bsu): SET OF LIST OF primitive_value;
LOCAL
	required_props: LIST OF property_bsu := [];
	definition: fm_class_view_of;
	content: explicit_functional_model_class_extension;
	item_bsu: class_bsu;
	item_content: explicit_item_class_extension;
	result: SET OF LIST OF primitive_value := [];
END_LOCAL;

IF (SIZEOF(cl.definition) = 1)
THEN
	IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA.FM_CLASS_VIEW_OF'
		IN TYPEOF(cl.definition[1]))
	THEN
		definition := cl.definition[1];
		item_bsu := definition.view_of;
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF ('ISO13584_LIBRARY_CONTENT_SCHEMA.' + 
		'EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1]))
	THEN
		content := cl.referenced_by[1];
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

IF (SIZEOF(item_bsu.referenced_by) = 1)
THEN
	IF ('ISO13584_LIBRARY_CONTENT_SCHEMA.' + 
		'EXPLICIT_MODEL_CLASS_EXTENSION'
		IN TYPEOF(item_bsu.referenced_by[1]))
	THEN
		item_content := item_bsu.referenced_by[1];
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

required_props := get_list_of_required_properties(definition, 
	content.required_item_values);
result := properties_projection_on_population(required_props, 
	item_content.population);

RETURN(result);

END_FUNCTION; -- get_dic_item_instances_from_imported_item_properties

FUNCTION get_list_of_required_properties(cl: fm_class_view_of; 
	required_properties: SET OF property_bsu)
	: LIST OF property_bsu;
LOCAL
	result: LIST OF property_bsu := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(cl.imported_properties_from_item);
	IF (cl.imported_properties_from_item[i] IN required_properties)
	THEN
		result := result + cl.imported_properties_from_item[i];
	END_IF;
END_REPEAT;

RETURN(result);

END_FUNCTION; -- get_list_of_required_properties

FUNCTION properties_projection_on_population(
	properties: LIST OF property_bsu;
	population: LIST OF dic_class_instance)
	: SET OF LIST OF primitive_value;
LOCAL
	result: SET OF LIST OF INTEGER := [];
	tuple: LIST OF INTEGER := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(population);
	REPEAT j := 1 TO SIZEOF(properties);
		REPEAT k := 1 TO SIZEOF(population[i].properties);
			IF (population[i].properties[k].prop_def = 
				properties[j]) 
			THEN
				tuple := tuple + 
					population[i].properties[k].its_value;
			END_IF;
		END_REPEAT;
	END_REPEAT;
	result := result + tuple;
	tuple := [];
END_REPEAT;

RETURN(result);

END_FUNCTION; -- properties_projection_on_population

FUNCTION all_views_available_for_components(cl: class_bsu): LOGICAL;
LOCAL
	components_views: SET OF LIST OF INTEGER := [];
	component_view: LIST OF INTEGER := [];
	components: SET OF LIST OF INTEGER := [];
	declared_views: SET OF LIST OF INTEGER := [];
	definition: fm_class_view_of;
	content: explicit_functional_model_class_extension;
END_LOCAL;

IF (SIZEOF(cl.definition) = 1)
THEN
	IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA.FM_CLASS_VIEW_OF'
		IN TYPEOF(cl.definition[1]))
	THEN
		definition := cl.definition[1];
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF ('ISO13584_LIBRARY_CONTENT_SCHEMA.' + 
		'EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1]))
	THEN
		content := cl.referenced_by[1];
	ELSE
		RETURN(UNKNOWN);
	END_IF;
ELSE
	RETURN(UNKNOWN);
END_IF;
-- id x vcvs in model
components_views := available_components_views(cl);
-- id in item
components := get_dic_item_instances_from_required_item_properties(cl);
-- vcv tuples in declaration
declared_views := declared_created_views(cl);

IF (SIZEOF(components) <> 0)
THEN
	REPEAT i := 1 TO SIZEOF(components);
		REPEAT j := 1 TO SIZEOF(declared_views);
			component_view := components[i] + declared_views[j];
			IF NOT(component_view IN components_views)
			THEN
				RETURN(FALSE);
			END_IF;
		END_REPEAT;
	END_REPEAT;

	RETURN(TRUE);
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- all_views_available_for_components

FUNCTION available_components_views(cl: class_bsu): SET OF LIST OF INTEGER;
LOCAL
	required_props: LIST OF property_bsu := [];
	vcvs: LIST OF property_bsu := [];
	view_properties: LIST OF property_bsu := [];
	definition: fm_class_view_of;
	content: explicit_functional_model_class_extension;
	result: SET OF LIST OF INTEGER := [];
END_LOCAL;

	IF (SIZEOF(cl.definition) = 1)
	THEN
		IF ('ISO13584_EXTENDED_DICTIONARY_SCHEMA.FM_CLASS_VIEW_OF'
			IN TYPEOF(cl.definition[1]))
		THEN
			definition := cl.definition[1];
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

IF (SIZEOF(cl.referenced_by) = 1)
THEN
	IF ('ISO13584_LIBRARY_CONTENT_SCHEMA.' + 
		'EXPLICIT_FUNCTIONAL_MODEL_CLASS_EXTENSION'
		IN TYPEOF(cl.referenced_by[1]))
	THEN
		content := cl.referenced_by[1];
	ELSE
		RETURN([]);
	END_IF;
ELSE
	RETURN([]);
END_IF;

vcvs := functional_view_v_c_v(definition\
	abstract_functional_model_class.created_view);

IF (SIZEOF(vcvs) <> 0)
THEN
	required_props := get_list_of_required_properties(definition, 
		content.required_item_values);
	view_properties := required_props + vcvs;
	result := properties_projection_on_population(view_properties, 
		content.population);
END_IF;

RETURN(result);

END_FUNCTION; -- available_components_views


FUNCTION all_view_control_variables_belong_to_each_view(
	class_ext: explicit_model_class_extension): LOGICAL;
LOCAL
	created_view: class_bsu;
	cl: class_bsu;
	vcvs: SET OF property_bsu;
	i, max: INTEGER;
	result: LOGICAL := TRUE;
END_LOCAL;

cl := class_ext\content_item.dictionary_definition;

IF (SIZEOF(cl.definition) = 1)
THEN
	created_view := cl.definition[1]\
		abstract_functional_model_class.created_view;
	vcvs := list_to_set(functional_view_v_c_v(created_view));

	IF (SIZEOF(created_view.definition) = 1)
	THEN
		IF (SIZEOF(vcvs) > 0)
		THEN
			i := 1;
			max := SIZEOF(class_ext.population);
			REPEAT WHILE((i <= max) AND (result));
				result := 
				check_all_view_control_variables_belong_to_view(
					vcvs, class_ext.population[i]);
				i := i + 1;
			END_REPEAT;

		ELSE
			result := TRUE;
		END_IF;

	ELSE
		result := UNKNOWN;
	END_IF;

	RETURN(result);
ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- all_view_control_variables_belong_to_each_view


FUNCTION check_all_view_control_variables_belong_to_view(
	vcvs: SET OF property_bsu;
	a_view: dic_f_model_instance): LOGICAL;

LOCAL
	used_properties: SET OF property_bsu := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(a_view.properties);
	used_properties := used_properties + 
		a_view.properties[i].prop_def;
END_REPEAT;

RETURN(vcvs <= used_properties);

END_FUNCTION; -- check_all_view_control_variables_belong_to_view


FUNCTION all_vcvs_belong_to_instance_identification(
	class_ext: explicit_model_class_extension): LOGICAL;
LOCAL
	vcvs: SET OF property_bsu := [];
	created_view: class_bsu;
	cl: class_bsu;
END_LOCAL;

cl := class_ext\content_item.dictionary_definition;

IF (SIZEOF(cl.definition) = 1)
THEN
	created_view := cl.definition[1]\
		abstract_functional_model_class.created_view;
	vcvs := list_to_set(functional_view_v_c_v(created_view));

	IF (SIZEOF(created_view.definition) = 1)
	THEN
		RETURN(vcvs <= list_to_set(class_ext\
			explicit_model_class_extension.
			instance_identification));
	ELSE
		RETURN(UNKNOWN);
	END_IF;

ELSE
	RETURN(UNKNOWN);
END_IF;

END_FUNCTION; -- vcvs_and_required_properties_belong_to_identification

FUNCTION same_string_values_translations_for_class_extension(
	class_ext: explicit_model_class_extension): LOGICAL;
LOCAL
	comp: SET OF translated_string_value := [];
	translated_property_values: LIST OF property_value := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(class_ext.population);
	translated_property_values := QUERY(prop_val <*
		class_ext.population[i].properties |
		'ISO13584_INSTANCE_RESOURCE_SCHEMA.' +
		'TRANSLATED_STRING_VALUE' IN
		TYPEOF(prop_val.its_value));
	IF (SIZEOF(translated_property_values) <> 0)
	THEN
		comp := comp + translated_property_values[1].its_value;
	END_IF;
END_REPEAT;

RETURN(same_translations(comp));

END_FUNCTION; -- same_string_values_translations_for_class_extension

END_SCHEMA; -- ISO13584_library_content_schema

SCHEMA ISO13584_external_file_schema;

REFERENCE FROM ISO13584_IEC61360_dictionary_schema
	(basic_semantic_unit,
	class_BSU,
	class_related_BSU,
	content_item,
	definition_available_implies,
	graphics,
	item_names,
	list_to_set,
	revision_type,
	supplier_BSU,
	supplier_element,
	supplier_related_BSU,
	version_len);

REFERENCE FROM ISO13584_IEC61360_language_resource_schema
	(global_language_assignment,
	language_code,
	present_translations);

REFERENCE FROM ISO13584_instance_resource_schema
	(property_or_data_type_BSU);

REFERENCE FROM ISO13584_extended_dictionary_schema
	(absolute_url_type,
	document_BSU,
	program_library_BSU);

REFERENCE FROM ISO13584_library_content_schema
	(model_class_extension);

REFERENCE FROM support_resource_schema
	(identifier,
	label);

REFERENCE FROM person_organization_schema
	(organization);

REFERENCE FROM measure_schema
	(length_measure,
	length_measure_with_unit);


CONSTANT
	compiler_version_length: INTEGER := 9;

	external_file_address_length: INTEGER := 18;

	external_item_code_length: INTEGER := 128;

	http_file_name_length: INTEGER := 128;

	http_directory_name_length: INTEGER := 128;
END_CONSTANT;

TYPE external_file_address = identifier;
WHERE
	WR1: LENGTH(SELF) <= external_file_address_length;
	WR2: NOT(SELF LIKE '* *');
END_TYPE; -- external_file_address

TYPE external_item_code_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= external_item_code_length;
	WR2: NOT(SELF LIKE '* *');
END_TYPE; -- external_item_code_type

TYPE http_file_name_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= http_file_name_length;
	WR2: NOT(SELF LIKE '* *');
	WR3: NOT(SELF LIKE '*.*.*');
	WR4: ((NOT(SELF LIKE '*.*'))
		AND (LENGTH(SELF) <= http_file_name_length - 4))
		OR ((SELF LIKE '*.?')
		AND (LENGTH(SELF) <= http_file_name_length - 2))
		OR ((SELF LIKE '*.??')
		AND (LENGTH(SELF) <= http_file_name_length - 1))
		OR (SELF LIKE '*.???');
END_TYPE; -- http_file_name_type

TYPE http_directory_name_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= http_directory_name_length;
	WR2: NOT(SELF LIKE '* *');
END_TYPE; -- http_directory_name_type

TYPE MIME_type = identifier;
WHERE
	WR1: NOT(SELF LIKE '* *');
END_TYPE; -- MIME_type

TYPE MIME_subtype = identifier;
WHERE
	WR1: NOT(SELF LIKE '* *');
END_TYPE; -- MIME_subtype

TYPE IAB_RFC = INTEGER;
WHERE
	WR1: SELF > 0;
END_TYPE; -- IAB_RFC

TYPE character_set_type = identifier;
END_TYPE; -- character_set_type

TYPE content_encoding_type = identifier;
WHERE
	WR1: (SELF = '7bit') OR (SELF = '8bit') OR (SELF = 'binary') 
		OR (SELF = 'quoted-printable') OR (SELF = 'base64');
END_TYPE; -- content_encoding_type

TYPE program_status = ENUMERATION OF(source, compiled);
END_TYPE; -- program_status

TYPE program_reference_name_type = identifier;
END_TYPE; -- program_reference_name_type

TYPE compiler_version_type = identifier;
WHERE
	WR1: LENGTH(SELF) <= compiler_version_length;
	WR2: control_compiler_version_format(SELF);
END_TYPE; -- compiler_version_type

TYPE illustration_type = ENUMERATION OF(
	schematic_drawing, realistic_picture, not_static_picture);
END_TYPE; -- illustration_type

ENTITY external_file_protocol
ABSTRACT SUPERTYPE OF(
	(ONEOF(standard_protocol, non_standard_protocol))
	ANDOR (ONEOF(program_protocol, data_protocol)));
	organisation: organization;
	country: OPTIONAL identifier;
	protocol_name: identifier;
	protocol_version: identifier;
	level: OPTIONAL identifier;
	designation: item_names;
	base_protocol: OPTIONAL program_protocol;
WHERE
	WR1: (NOT(SELF.protocol_name LIKE '* *'))
		AND (NOT(SELF.protocol_name LIKE '*.*'))
		AND (NOT(SELF.protocol_name LIKE '*-*'));
	WR2: NOT(SELF.protocol_version LIKE '* *');
END_ENTITY; -- external_file_protocol

ENTITY standard_protocol
ABSTRACT SUPERTYPE OF(ONEOF(standard_simple_program_protocol,
	standard_data_protocol))
SUBTYPE OF(external_file_protocol);
END_ENTITY; -- standard_protocol

ENTITY non_standard_protocol
ABSTRACT SUPERTYPE OF(ONEOF(non_standard_simple_program_protocol,
	non_standard_data_protocol))
SUBTYPE OF(external_file_protocol);
END_ENTITY; -- non_standard_protocol

ENTITY data_protocol
ABSTRACT SUPERTYPE OF(ONEOF(standard_data_protocol,
	non_standard_data_protocol))
SUBTYPE OF(external_file_protocol);
END_ENTITY; -- data_protocol

ENTITY program_protocol
ABSTRACT SUPERTYPE OF(ONEOF(
	linked_interface_program_protocol,
	simple_program_protocol))
SUBTYPE OF(external_file_protocol);
END_ENTITY; -- program_protocol

ENTITY simple_program_protocol
ABSTRACT SUPERTYPE OF(ONEOF(standard_simple_program_protocol,
	non_standard_simple_program_protocol))
SUBTYPE OF(program_protocol);
	language: identifier;
	status: program_status;
	compiler_supplier: OPTIONAL organization;
	compiler_name: OPTIONAL identifier;
	compiler_version: OPTIONAL compiler_version_type;
WHERE
	WR1: ((SELF.status = source)
		AND (NOT(EXISTS(SELF.compiler_supplier)))
		AND (NOT(EXISTS(SELF.compiler_name)))
		AND (NOT(EXISTS(SELF.compiler_version))))
		OR ((SELF.status = compiled)
		AND (EXISTS(SELF.compiler_supplier))
		AND (EXISTS(SELF.compiler_name))
		AND (EXISTS(SELF.compiler_version)));

END_ENTITY; -- simple_program_protocol

ENTITY standard_simple_program_protocol
SUBTYPE OF(standard_protocol, simple_program_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- standard_simple_program_protocol

ENTITY non_standard_simple_program_protocol
SUBTYPE OF(non_standard_protocol, simple_program_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- non_standard_simple_program_protocol

ENTITY linked_interface_program_protocol
SUBTYPE OF(program_protocol);
	link_libraries: SET [1:?] OF program_library_BSU;
WHERE
	WR1: QUERY(pl <* SELF.link_libraries
		| (SIZEOF(pl\basic_semantic_unit.referenced_by) > 0)
		AND (pl\basic_semantic_unit.referenced_by[1]
		\external_item.used_protocol <> SELF.base_protocol)) = [];
	WR2: NOT('ISO13584_EXTERNAL_FILE_SCHEMA.STANDARD_PROTOCOL'
		IN TYPEOF(SELF)) AND
		NOT('ISO13584_EXTERNAL_FILE_SCHEMA.NON_STANDARD_PROTOCOL'
		IN TYPEOF(SELF));
	WR3: EXISTS(base_protocol)
		AND ('ISO13584_EXTERNAL_FILE_SCHEMA.PROGRAM_PROTOCOL'
		IN TYPEOF(base_protocol));
END_ENTITY; -- linked_interface_program_protocol

ENTITY standard_data_protocol
SUBTYPE OF(data_protocol, standard_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- standard_data_protocol

ENTITY non_standard_data_protocol
SUBTYPE OF(data_protocol, non_standard_protocol);
WHERE
	WR1: NOT EXISTS(SELF\external_file_protocol.base_protocol);
END_ENTITY; -- non_standard_data_protocol

ENTITY http_protocol
SUBTYPE OF(standard_data_protocol);
	http_RFC: IAB_RFC;
END_ENTITY; -- http_protocol

ENTITY external_item
ABSTRACT SUPERTYPE OF(ONEOF(dictionary_external_item,
	class_extension_external_item,
	property_value_external_item));
	used_protocol: external_file_protocol;
	content: external_content;
END_ENTITY; -- external_item

ENTITY dictionary_external_item
ABSTRACT SUPERTYPE OF(ONEOF(supplier_BSU_related_content,
	class_BSU_related_content))
SUBTYPE OF(content_item, external_item);
	revision: revision_type;
END_ENTITY; -- dictionary_external_item

ENTITY supplier_BSU_related_content
ABSTRACT SUPERTYPE OF(program_library_content)
SUBTYPE OF(dictionary_external_item);
	SELF\content_item.dictionary_definition: supplier_related_BSU;
END_ENTITY; -- supplier_BSU_related_content

ENTITY program_library_content
SUBTYPE OF(supplier_BSU_related_content);
	SELF\content_item.dictionary_definition: program_library_BSU;
	SELF\external_item.used_protocol: program_protocol;
END_ENTITY; -- program_library_content

ENTITY class_BSU_related_content
ABSTRACT SUPERTYPE OF(document_content)
SUBTYPE OF(dictionary_external_item);
	SELF\content_item.dictionary_definition: class_related_BSU;
END_ENTITY; -- class_BSU_related_content

ENTITY document_content
SUBTYPE OF(class_BSU_related_content);
	SELF\content_item.dictionary_definition: document_BSU;
	SELF\external_item.used_protocol: data_protocol;
END_ENTITY; -- document_content

ENTITY class_extension_external_item
ABSTRACT SUPERTYPE OF(ONEOF(dialogue_resource,
	representation_reference, program_reference))
SUBTYPE OF(external_item);
	code: external_item_code_type;
INVERSE
	belongs_to: model_class_extension FOR referenced_external_items;
UNIQUE
	UR1: code, belongs_to;
END_ENTITY; -- class_extension_external_item

ENTITY representation_reference
SUBTYPE OF(class_extension_external_item);
	SELF\external_item.used_protocol: data_protocol;
	representation_id: OPTIONAL label;
END_ENTITY; -- representation_reference

ENTITY program_reference
SUBTYPE OF(class_extension_external_item);
	SELF\external_item.used_protocol: program_protocol;
	syntactical_name: program_reference_name_type;
	in_parameters: LIST [0:?] OF property_or_data_type_BSU;
	out_parameters: LIST [0:?] OF property_or_data_type_BSU;
	inout_parameters: LIST [0:?] OF property_or_data_type_BSU;
END_ENTITY; -- program_reference

ENTITY dialogue_resource
ABSTRACT SUPERTYPE OF(ONEOF(message, illustration))
SUBTYPE OF(class_extension_external_item);
	SELF\external_item.used_protocol: data_protocol;
END_ENTITY; -- dialogue_resource

ENTITY message
SUBTYPE OF(dialogue_resource);
END_ENTITY; -- message

ENTITY illustration
SUPERTYPE OF(ONEOF(A6_illustration, A9_illustration))
SUBTYPE OF(dialogue_resource, graphics);
	kind_of_content: illustration_type;
	width: OPTIONAL length_measure_with_unit;
	height: OPTIONAL length_measure_with_unit;
WHERE
	WR1: (NOT EXISTS(SELF.width) AND NOT EXISTS(SELF.height))
		OR (EXISTS(SELF.width) AND EXISTS(SELF.height));
END_ENTITY; -- illustration

ENTITY A6_illustration
SUBTYPE OF(illustration);
END_ENTITY; -- A6_illustration

ENTITY A9_illustration
SUBTYPE OF(illustration);
END_ENTITY; -- A9_illustration

ENTITY property_value_external_item
SUBTYPE OF(external_item);
END_ENTITY; -- property_value_external_item

RULE unique_http_file_name_per_supplier_element_rule FOR(
	supplier_BSU);
WHERE
	WR1: QUERY(sup_BSU <* supplier_BSU | (SIZEOF
		(sup_BSU.definition) = 1) AND
		(QUERY(fil_1 <* supplier_associated_http_files(sup_BSU)
		| QUERY(fil_2 <* supplier_associated_http_files(sup_BSU)
		| fil_1.http_file_name = fil_2.http_file_name)
		<> [fil_1]) <> []))
		= [];
END_RULE; -- unique_http_file_name_per_supplier_element_rule

RULE unique_http_directory_name_per_supplier_rule FOR(
	http_class_directory);
WHERE
	WR1: QUERY(dir_1 <* http_class_directory
		| QUERY(dir_2 <* http_class_directory
		| (dir_1.name = dir_2.name) AND
		(dir_1.class.defined_by = dir_2.class.defined_by))
		<> [dir_1])
		= [];
END_RULE; -- unique_http_directory_name_per_supplier_rule

RULE no_http_directory_for_supplier_related_file_rule FOR(
	http_file, supplier_bsu_related_content);
WHERE
	WR1: QUERY(http_f <* http_file |
		(('ISO13584_EXTERNAL_FILE_SCHEMA' + 
		'.SUPPLIER_BSU_RELATED_CONTENT'
		IN TYPEOF(http_f\external_file_unit.unit_of
		.content_of.content_of))
		AND EXISTS(http_f.http_directory))) = [];
END_RULE; -- no_http_directory_for_supplier_related_file_rule

RULE http_directory_refers_to_bsu_related_class_rule FOR(
	http_file, class_bsu_related_content);
WHERE
	WR1: QUERY(http_f <* http_file | 	
		(('ISO13584_EXTERNAL_FILE_SCHEMA' + 
		'.CLASS_BSU_RELATED_CONTENT'
		IN TYPEOF(http_f\external_file_unit.unit_of
		.content_of.content_of))
		AND (http_f.http_directory.class <> http_f\
		external_file_unit.unit_of.content_of.content_of
		\content_item.dictionary_definition.name_scope))) = [];
END_RULE; -- http_directory_refers_to_bsu_related_class_rule

RULE http_directory_refers_to_class_extension_rule FOR(
	http_file, class_extension_external_item);
WHERE
	WR1: QUERY(http_f <* http_file |
		('ISO13584_EXTERNAL_FILE_SCHEMA' +
		'.CLASS_EXTENSION_EXTERNAL_ITEM'
		IN TYPEOF(http_f\external_file_unit.unit_of
		.content_of.content_of))
		AND (http_f.http_directory.class <> http_f\
		external_file_unit.unit_of.content_of.content_of
		\class_extension_external_item.belongs_to
		\content_item.dictionary_definition)) = [];
END_RULE; -- http_directory_refers_to_class_extension_rule

RULE illustration_is_not_a_referenced_graphics_rule FOR(
	graphics);
WHERE
	WR1: QUERY(icon <* graphics |
		('ISO13584_EXTENDED_DICTIONARY_SCHEMA.REFERENCED_GRAPHICS'
		IN TYPEOF(icon))
		AND ('ISO13584_EXTERNAL_FILE_SCHEMA.ILLUSTRATION'
		IN TYPEOF(icon))) = [];
END_RULE; -- illustration_is_not_a_referenced_graphics_rule

ENTITY external_content
ABSTRACT SUPERTYPE OF(ONEOF(
	translated_external_content,
	not_translated_external_content,
	not_translatable_external_content));
	consists_of: LIST[1:?] OF language_specific_content;
INVERSE
	content_of: external_item FOR content;
END_ENTITY; -- external_content

ENTITY translated_external_content
SUBTYPE OF(external_content);
	languages: present_translations;
WHERE
	WR1: SIZEOF(SELF\external_content.consists_of)
		= SIZEOF(SELF.languages.language_codes);
END_ENTITY; -- translated_external_content

ENTITY not_translated_external_content
SUBTYPE OF(external_content);
WHERE
	WR1: SIZEOF(SELF\external_content.consists_of) = 1;
END_ENTITY; -- not_translated_external_content

ENTITY not_translatable_external_content
SUBTYPE OF(external_content);
WHERE
	WR1: SIZEOF(SELF\external_content.consists_of) = 1;
END_ENTITY; -- not_translatable_external_content

ENTITY language_specific_content;
	content_files: SET [1:?] OF external_file_unit;
	main_file: OPTIONAL external_file_unit;
	character_encoding: OPTIONAL character_set_type;
INVERSE
	content_of: external_content FOR consists_of;
WHERE
	WR1: NOT EXISTS(main_file) OR (main_file IN content_files);
	WR2: EXISTS(main_file) XOR
		('ISO13584_EXTERNAL_FILE_SCHEMA.PROGRAM_LIBRARY_CONTENT'
		IN TYPEOF(SELF.content_of.content_of));
	WR3: EXISTS(character_encoding) OR NOT
		('ISO13584_EXTERNAL_FILE_SCHEMA.HTTP_PROTOCOL'
		IN TYPEOF(SELF.content_of.content_of.used_protocol));
END_ENTITY; -- language_specific_content

ENTITY external_file_unit
SUPERTYPE OF(http_file);
	file: external_file_address;
	content_encoding: OPTIONAL content_encoding_type;
INVERSE
	unit_of: language_specific_content FOR content_files;
WHERE
	WR1: (('ISO13584_EXTERNAL_FILE_SCHEMA.HTTP_PROTOCOL'
		IN TYPEOF(SELF.unit_of.content_of.content_of.used_protocol))
		AND ('ISO13584_EXTERNAL_FILE_SCHEMA.HTTP_FILE' 
		IN TYPEOF(SELF)))
		XOR NOT
		(('ISO13584_EXTERNAL_FILE_SCHEMA.HTTP_PROTOCOL'
		IN TYPEOF(SELF.unit_of.content_of.content_of.used_protocol))
		OR ('ISO13584_EXTERNAL_FILE_SCHEMA.HTTP_FILE'
		IN TYPEOF(SELF)));
END_ENTITY; -- external_file_unit

ENTITY http_file
SUBTYPE OF(external_file_unit);
	mime: MIME_type;
	exchange_format: MIME_subtype;
	format_RFC: OPTIONAL IAB_RFC;
	http_file_name: http_file_name_type;
	http_directory: OPTIONAL http_class_directory;
	remote_access: OPTIONAL absolute_URL_type;
UNIQUE
	UR1: http_file_name, http_directory;
WHERE
	WR1: EXISTS(http_directory) XOR
		('ISO13584_EXTERNAL_FILE_SCHEMA.SUPPLIER_BSU_RELATED_CONTENT'
		IN TYPEOF(SELF.unit_of.content_of.content_of));
	WR1: NOT EXISTS(http_directory) XOR
	('ISO13584_EXTERNAL_FILE_SCHEMA.CLASS_EXTENSION_EXTERNAL_ITEM'
		IN TYPEOF(SELF.unit_of.content_of.content_of));
END_ENTITY; -- http_file

ENTITY http_class_directory;
	name: http_directory_name_type;
	class: class_BSU;
UNIQUE
	UR1: class;
END_ENTITY; -- http_class_directory

FUNCTION supplier_associated_http_files(sup_BSU: supplier_BSU):
	SET OF http_file;

LOCAL
	sup: supplier_element;
	files: SET OF http_file := [];
END_LOCAL;

IF SIZEOF(sup_BSU.definition) > 0
	THEN sup := sup_BSU.definition[1];
ELSE
	RETURN(files);
END_IF;

REPEAT i := 1 TO SIZEOF(sup.associated_items);
-- supplier_BSU_relationship
	REPEAT j := 1 TO SIZEOF(sup.associated_items[i].related_tokens);
	--supplier_related_BSU
		REPEAT k := 1 TO SIZEOF(sup.associated_items[i]
				.related_tokens[j].referenced_by); --content_item

			IF ('ISO13584_EXTERNAL_FILE_SCHEMA.EXTERNAL_ITEM'IN
				TYPEOF(sup.associated_items[i]
				.related_tokens[j].referenced_by[k]))
			THEN
				REPEAT l := 1 TO SIZEOF(sup.associated_items[i]
					.related_tokens[j].referenced_by[k]
					\external_item.content.consists_of);
					--language_specific_content

					REPEAT m := 1 TO SIZEOF(
						sup.associated_items[i]
						.related_tokens[j].referenced_by[k]
						\external_item.content
						.consists_of[l].content_files);
						-- external_file_unit
						IF
						('ISO13584_EXTERNAL_FILE_SCHEMA.HTTP_FILE'
							IN TYPEOF(sup.associated_items[i]
							.related_tokens[j].referenced_by[k]
							\external_item.content
							.consists_of[l].content_files[m]))
						THEN
							files := files +
							sup.associated_items[i]
							.related_tokens[j].referenced_by[k]
							\external_item.content
							.consists_of[l].content_files[m];
						END_IF; -- http_file
					END_REPEAT; -- m
				END_REPEAT; -- l
			END_IF; -- external_item
		END_REPEAT; -- k
	END_REPEAT; -- j
END_REPEAT; -- i

RETURN(files);

END_FUNCTION; -- supplier_associated_http_files

FUNCTION control_compiler_version_format(the_compiler_version: STRING): 
	BOOLEAN;
LOCAL
	result: BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 TO LENGTH(the_compiler_version);
	IF (NOT((the_compiler_version[i] LIKE '#')
		OR (the_compiler_version[i] LIKE '.')
		OR (the_compiler_version[i] LIKE '_')))
	THEN
		result := FALSE;
	END_IF;
END_REPEAT;
	RETURN(result);
END_FUNCTION; -- control_compiler_version_format

END_SCHEMA; -- ISO13584_external_file_schema

SCHEMA ISO13584_method_schema;

REFERENCE FROM ISO13584_IEC61360_dictionary_schema
	(all_class_descriptions_reachable,
	class_BSU,
	content_item,
	definition_available_implies,
	list_to_set,
	property_BSU);

REFERENCE FROM ISO13584_library_expressions_schema
	(class_instance_constructor,
	class_instance_expression,
	collects_assigned_properties,
	collects_referenced_library_expressions,
	compatible_variable_and_library_expression,
	library_expression,
	library_variable,
	property_assignment);

REFERENCE FROM ISO13584_variable_semantics_schema
	(property_semantics,
	property_semantics_or_path,
	self_property_value_semantics);

REFERENCE FROM ISO13584_domain_resource_schema
	(collects_variables,
	functional_domain_restriction,
	used_variables_in_domain);

REFERENCE FROM ISO13584_extended_dictionary_schema
	(abstract_functional_model_class,
	applicable_properties,
	applicable_tables,
	data_type_class_of,
	data_type_typeof,
	data_type_type_name,
	functional_model_class,
	functional_view_class,
	functional_view_v_c_v,
	view_control_variable_range);

REFERENCE FROM ISO13584_generic_expressions_schema
	(generic_variable,
	used_variables);

REFERENCE FROM ISO13584_expressions_schema
	(boolean_expression,
	numeric_expression,
	string_expression);

REFERENCE FROM ISO13584_library_content_schema
	(exists_super,
	functional_model_class_extension,
	method_variables,
	model_class_extension,
	provided_properties_list,
	provided_properties_or_method_variables,
	super);

REFERENCE FROM ISO13584_external_file_schema
	(external_file_protocol);


TYPE accessible_variable_for_method = library_variable;
WHERE
	WR1:(('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_VARIABLE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'OPEN_VIEW_VARIABLE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_TABLE_RESOURCE_SCHEMA.'
		+'COLUMN_TRAVERSAL_VARIABLE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics));
END_TYPE; -- accessible_variable_for_method

TYPE assignment_allowed_variable = library_variable;
WHERE
	WR1:(('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_PROPERTY_VALUE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'OPEN_VIEW_PROPERTY_VALUE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics));
END_TYPE; -- assignment_allowed_variable

TYPE control_allowed_variable = library_variable;
WHERE
	WR1: (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_PROPERTY_VALUE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'OPEN_VIEW_PROPERTY_VALUE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_PROPERTY_CODE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_PROPERTY_VERSION_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_PROPERTY_CLASS_CODE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_PROPERTY_CLASS_VERSION_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_PROPERTY_CLASS_SUPPLIER_CODE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_CLASS_CODE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_CLASS_VERSION_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics))
		OR (('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+'SELF_CLASS_SUPPLIER_CODE_SEMANTICS')
		IN TYPEOF(SELF\generic_variable.interpretation
		.semantics));
END_TYPE; -- control_allowed_variable

ENTITY method;
	specification: method_specif;
	body: method_body;
	representation_interface: OPTIONAL external_file_protocol;
INVERSE
	its_class: functional_model_class_extension
		FOR provided_methods;
WHERE
	WR1: (EXISTS(SELF.representation_interface))
		AND (SELF.representation_interface
		IN SELF.its_class\model_class_extension.used_protocols)
		OR (NOT(EXISTS(SELF.representation_interface)));
END_ENTITY; -- method

ENTITY method_specif;
	created_view: class_BSU;
	v_c_v_range: SET [0:?] OF view_control_variable_range;
	model_needed_properties: SET [0:?] OF property_BSU;
	referred_subobject_models: SET [0:?] OF class_BSU;
INVERSE
	specifies: method FOR specification;
WHERE
	WR1: NOT all_class_descriptions_reachable(
		SELF.specifies.its_class.dictionary_definition)
		OR (SELF.model_needed_properties
		<= list_to_set(provided_properties_list(
		SELF.specifies.its_class.dictionary_definition)));
	WR2: same_view_model_method(SELF);
	WR3: SIZEOF(QUERY(models <* SELF.referred_subobject_models |
		definition_available_implies(models,
		('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS'
		IN TYPEOF(models.definition[1])) OR (
		('ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+ '.FUNCTIONAL_MODEL_CLASS' IN TYPEOF(models.definition[1])))
		))) = SIZEOF(SELF.referred_subobject_models);
END_ENTITY; -- method_specif

ENTITY method_body;
	declaration: SET [1:?] OF accessible_variable_for_method;
	view_generation: LIST [1:?] OF method_statement;
INVERSE
	describes: method FOR body;
WHERE
	WR1: QUERY(prop <*
		SELF.describes.specification.model_needed_properties |
		SIZEOF(QUERY(v <* SELF.declaration |
		('ISO13584_VARIABLE_SEMANTICS_SCHEMA.PROPERTY_SEMANTICS'
		IN TYPEOF(v\generic_variable.interpretation.semantics))
		AND (v\generic_variable.interpretation.semantics\
		property_semantics.the_property :=: prop))) <> 1) = [];
	WR2: QUERY(v <* SELF.declaration | 
		('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+ 'SELF_PROPERTY_SEMANTICS' IN TYPEOF (
		v\generic_variable.interpretation.semantics)) AND
		NOT(v\generic_variable.interpretation
		.semantics\property_semantics.the_property
		IN provided_properties_or_method_variables (
		SELF.describes.its_class.dictionary_definition)))
		= [];
	WR3: QUERY(v <* SELF.declaration | 
		('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+ 'OPEN_VIEW_PROPERTY_SEMANTICS' IN TYPEOF(
		v\generic_variable.interpretation.semantics))
		AND NOT applicable_properties(
		SELF.describes.specification.created_view,
		[v\generic_variable.interpretation.semantics\
		property_semantics.the_property])) = [];
	WR4: QUERY(v <* SELF.declaration |
		('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+ 'SELF_PROPERTY_SEMANTICS' IN TYPEOF 
		(v\generic_variable.interpretation.semantics))
		AND NOT checks_applicable_properties_in_path(
		v\generic_variable.interpretation.semantics)) = [];
	WR5: QUERY(v <* SELF.declaration |
		('ISO13584_VARIABLE_SEMANTICS_SCHEMA.'
		+ 'SELF_PROPERTY_SEMANTICS' IN TYPEOF 
		(v\generic_variable.interpretation.semantics))
		AND NOT checks_classes_in_path(v\generic_variable
		.interpretation.semantics,
		SELF.describes.specification.referred_subobject_models))
		= [];
END_ENTITY; -- method_body

ENTITY method_statement;
	statements: LIST [1:?] OF guarded_statement;
INVERSE
	defines: method_body FOR view_generation;
END_ENTITY; -- method_statement

ENTITY guarded_statement;
	guard: boolean_expression;
	statement: simple_statement;
INVERSE
	item_of: method_statement FOR statements;
WHERE
	WR1: QUERY(elt <* used_variables(SELF.guard) |
		NOT('ISO13584_METHOD_SCHEMA.CONTROL_ALLOWED_VARIABLE' IN
		TYPEOF(elt))) = [];
	WR2: QUERY(elt <* used_variables(SELF.guard) |
		NOT(elt IN SELF.item_of.defines.declaration)) = [];
END_ENTITY; -- guarded_statement

ENTITY simple_statement
ABSTRACT SUPERTYPE OF(ONEOF(
	null_statement, 
	modelling_statement, 
	predefined_representation_call_statement, 
	assignment_statement,
	sub_object_view_statement));
INVERSE
	referenced_by: guarded_statement FOR statement;
END_ENTITY; -- simple_statement

ENTITY null_statement
SUBTYPE OF(simple_statement);
END_ENTITY; -- null_statement

ENTITY modelling_statement
ABSTRACT SUPERTYPE OF(ONEOF(
	set_reference_lcs,
	begin_set, 
	close_set, 
	set_2d_relative_view_level))
SUBTYPE OF(simple_statement);
END_ENTITY; -- modelling_statement

ENTITY set_reference_lcs
SUBTYPE OF(modelling_statement);
	x_rotation: numeric_expression;
	y_rotation: numeric_expression;
	z_rotation: numeric_expression;
	x_translation: numeric_expression;
	y_translation: numeric_expression;
	z_translation: numeric_expression;
WHERE
	WR1: QUERY(elt <* used_variables(SELF.y_rotation) |
		NOT('ISO13584_METHOD_SCHEMA.CONTROL_ALLOWED_VARIABLE'
		IN TYPEOF(elt))) +
		QUERY(elt <* used_variables(SELF.z_rotation) |
		NOT('ISO13584_METHOD_SCHEMA.CONTROL_ALLOWED_VARIABLE'
		IN TYPEOF(elt))) +
		QUERY(elt <* used_variables(SELF.x_translation) |
		NOT('ISO13584_METHOD_SCHEMA.CONTROL_ALLOWED_VARIABLE'
		IN TYPEOF(elt))) +
		QUERY(elt <* used_variables(SELF.y_translation) |
		NOT('ISO13584_METHOD_SCHEMA.CONTROL_ALLOWED_VARIABLE'
		IN TYPEOF(elt))) +
		QUERY(elt <* used_variables(SELF.z_translation) |
		NOT('ISO13584_METHOD_SCHEMA.CONTROL_ALLOWED_VARIABLE'
		IN TYPEOF(elt))) +
		QUERY(elt <* used_variables(SELF.x_rotation) |
		NOT('ISO13584_METHOD_SCHEMA.CONTROL_ALLOWED_VARIABLE'
		IN TYPEOF(elt)))
		= [];
	WR2: QUERY(elt <* used_variables(SELF.x_rotation) |
		NOT(elt IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) +
		QUERY(elt <* used_variables(SELF.y_rotation) |
		NOT(elt IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) +
		QUERY(elt <* used_variables(SELF.z_rotation) |
		NOT(elt IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) +
		QUERY(elt <* used_variables(SELF.x_translation) |
		NOT(elt IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) +
		QUERY(elt <* used_variables(SELF.y_translation) |
		NOT(elt IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) +
		QUERY(elt <* used_variables(SELF.z_translation) |
		NOT(elt IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration))
		= [];
END_ENTITY; -- set_reference_lcs

ENTITY begin_set
SUBTYPE OF(modelling_statement);
	set_name: string_expression;
WHERE
	WR1: QUERY(elt <* used_variables(SELF.set_name)
		| NOT(elt IN SELF\simple_statement.referenced_by.item_of
		.defines.declaration)) = [];
END_ENTITY; -- begin_set

ENTITY close_set
SUBTYPE OF(modelling_statement);
	set_name: string_expression;
WHERE
	WR1: QUERY(elt <* used_variables(SELF.set_name) |
		NOT(elt IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) = [];
END_ENTITY; -- close_set

ENTITY set_2d_relative_view_level
SUBTYPE OF(modelling_statement);
	offset: numeric_expression;
WHERE
	WR1: QUERY(elt <* used_variables(SELF.offset) |
		NOT('ISO13584_METHOD_SCHEMA.CONTROL_ALLOWED_VARIABLE'
		IN TYPEOF(elt))) = [];
	WR2: QUERY(elt <* used_variables(SELF.offset) |
		NOT(elt IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) = [];
END_ENTITY; -- set_2d_relative_view_level

ENTITY predefined_representation_call_statement
ABSTRACT SUPERTYPE OF(ONEOF(
	send_representation_statement,
	send_representation_reference_statement,
	call_program_statement))
SUBTYPE OF(simple_statement);
END_ENTITY; -- predefined_representation_call_statement

ENTITY send_representation_statement
SUBTYPE OF(predefined_representation_call_statement);
	corresponding_method_variable: assignment_allowed_variable;
	representation_to_be_processed: functional_domain_restriction;
WHERE
	WR1: SELF.representation_to_be_processed.defines
		= [SELF.corresponding_method_variable\generic_variable.
		interpretation.semantics];
	WR2: SELF.corresponding_method_variable
		IN SELF.referenced_by.item_of.defines.declaration;
	WR3: collects_variables(SELF.representation_to_be_processed
		.assumes) <= SELF.referenced_by.item_of.defines.declaration;
	WR4: definition_available_implies(
		SELF.corresponding_method_variable\generic_variable
		.interpretation.semantics\property_semantics.the_property,
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN data_type_typeof(SELF.corresponding_method_variable
		\generic_variable.interpretation.semantics
		\property_semantics.the_property))
		AND ('REPRESENTATION_SCHEMA.REPRESENTATION' IN
		data_type_type_name(
		SELF.corresponding_method_variable\generic_variable
		.interpretation.semantics\property_semantics.the_property)))
		OR (data_type_typeof(SELF.corresponding_method_variable
		\generic_variable.interpretation.semantics\property_semantics
		.the_property) = []));
	WR5: NOT all_class_descriptions_reachable
		(SELF.referenced_by.item_of.defines.describes.its_class
		.dictionary_definition) OR
		((SELF.corresponding_method_variable\generic_variable
		.interpretation.semantics\property_semantics.the_property) IN
		method_variables(SELF.referenced_by.item_of.defines
		.describes.its_class.dictionary_definition));
	WR6: applicable_tables(SELF.referenced_by.item_of
		.defines.describes.its_class.dictionary_definition,
		SELF.representation_to_be_processed.base_tables);
	WR7: used_variables_in_domain(
		SELF.representation_to_be_processed) <=
		SELF.referenced_by.item_of.defines.declaration;
END_ENTITY; -- send_representation_statement

ENTITY send_representation_reference_statement
SUBTYPE OF(predefined_representation_call_statement);
	corresponding_method_variable: assignment_allowed_variable;
	representation_reference_to_be_processed:
		functional_domain_restriction;
WHERE
	WR1: SELF.representation_reference_to_be_processed.defines
		= [SELF.corresponding_method_variable\generic_variable
		.interpretation.semantics];
	WR2: SELF.corresponding_method_variable
		IN SELF.referenced_by.item_of.defines.declaration;
	WR3: collects_variables(
		SELF.representation_reference_to_be_processed.assumes)
		<= SELF.referenced_by.item_of.defines.declaration;
	WR4: definition_available_implies(
		SELF.corresponding_method_variable\generic_variable
		.interpretation.semantics\property_semantics.the_property,
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN data_type_typeof(SELF.corresponding_method_variable
		\generic_variable.interpretation.semantics
		\property_semantics.the_property))
		AND ('ISO13584_EXTERNAL_FILE_SCHEMA.REPRESENTATION_REFERENCE' 		IN data_type_type_name(SELF.corresponding_method_variable
		\generic_variable.interpretation.semantics
		\property_semantics.the_property))) OR
		(data_type_typeof(SELF.corresponding_method_variable
		\generic_variable.interpretation.semantics
		\property_semantics.the_property) = []));
	WR5: NOT all_class_descriptions_reachable
		(SELF.referenced_by.item_of.defines.describes.its_class
		.dictionary_definition) OR
		((SELF.corresponding_method_variable\generic_variable
		.interpretation.semantics\property_semantics.the_property) IN
		method_variables(SELF.referenced_by.item_of.defines
		.describes.its_class.dictionary_definition));
	WR6: applicable_tables(SELF.referenced_by.item_of
		.defines.describes.its_class.dictionary_definition,
		SELF.representation_reference_to_be_processed.base_tables);
	WR7: used_variables_in_domain(
		SELF.representation_reference_to_be_processed) <=
		SELF.referenced_by.item_of.defines.declaration;
END_ENTITY; -- send_representation_reference_statement

ENTITY call_program_statement
SUBTYPE OF(predefined_representation_call_statement);
	corresponding_method_variable: assignment_allowed_variable;
	program_reference_to_be_processed:
		functional_domain_restriction;
	input_parameters: LIST [0:?] OF library_expression;
	output_parameters: LIST [0:?] OF assignment_allowed_variable;
	inout_parameters: LIST [0:?] OF assignment_allowed_variable;
WHERE
	WR1: SELF.program_reference_to_be_processed.defines
		= [SELF.corresponding_method_variable\generic_variable
		.interpretation.semantics];
	WR2: SELF.corresponding_method_variable
		IN SELF.referenced_by.item_of.defines.declaration;
	WR3: collects_variables(
		SELF.program_reference_to_be_processed.assumes)
		<= SELF.referenced_by.item_of.defines.declaration;
	WR4: definition_available_implies(
		SELF.corresponding_method_variable\generic_variable
		.interpretation.semantics\property_semantics.the_property,
		(('ISO13584_IEC61360_DICTIONARY_SCHEMA.ENTITY_INSTANCE_TYPE'
		IN data_type_typeof(SELF.corresponding_method_variable
		\generic_variable.interpretation.semantics
		\property_semantics.the_property))
		AND ('ISO13584_EXTERNAL_FILE_SCHEMA.PROGRAM_REFERENCE' IN
		data_type_type_name(SELF.corresponding_method_variable
		\generic_variable.interpretation.semantics
		\property_semantics.the_property)))
		OR (data_type_typeof(SELF.corresponding_method_variable
		\generic_variable.interpretation.semantics
		\property_semantics.the_property) = []));
	WR5: NOT all_class_descriptions_reachable
		(SELF.referenced_by.item_of.defines.describes.its_class
		.dictionary_definition) OR
		((SELF.corresponding_method_variable\generic_variable
		.interpretation.semantics\property_semantics.the_property) IN
		method_variables(SELF.referenced_by.item_of.defines
		.describes.its_class.dictionary_definition));
	WR6: applicable_tables(SELF.referenced_by.item_of
		.defines.describes.its_class.dictionary_definition,
		SELF.program_reference_to_be_processed.base_tables);
	WR7: QUERY(expr <* SELF.input_parameters
		| QUERY(v <* used_variables(expr)
		| NOT(v IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) <> []) = [];
	WR8: QUERY(v <* SELF.output_parameters
		| NOT(v IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) = [];
	WR9: QUERY(v <* SELF.inout_parameters
		| NOT(v IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) = [];
	WR10: used_variables_in_domain(
		SELF.program_reference_to_be_processed)
		<= SELF.referenced_by.item_of.defines.declaration;
END_ENTITY; -- call_program_statement

ENTITY assignment_statement
SUBTYPE OF(simple_statement);
	assigned_variable: assignment_allowed_variable;
	assigned_value: library_expression;
WHERE
	WR1: SELF.assigned_variable IN
		SELF\simple_statement.referenced_by.item_of.defines
		.declaration;
	WR2: compatible_variable_and_library_expression(
		SELF.assigned_variable, SELF.assigned_value);
	WR3: QUERY(v <* used_variables(
		SELF\assignment_statement.assigned_value)
		| NOT(v IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) = [];
	WR4: NOT(SELF.assigned_variable\generic_variable
		.interpretation.semantics\property_semantics.the_property
		IN provided_properties_list(
		SELF\simple_statement.referenced_by.item_of.defines
		.describes.its_class.dictionary_definition));
END_ENTITY; -- assignment_statement

ENTITY sub_object_view_statement
ABSTRACT SUPERTYPE OF(ONEOF(referenced_sub_item_view_statement,
	constructed_sub_model_view_statement))
SUBTYPE OF(simple_statement);
	created_view: class_BSU;
	v_c_v_values: SET [0:?] OF property_assignment;
WHERE
	WR1: definition_available_implies(SELF.created_view,
		'ISO13584_EXTENDED_DICTIONARY_SCHEMA.FUNCTIONAL_VIEW_CLASS'
		IN TYPEOF(SELF.created_view.definition[1]));
	WR2: QUERY(e <* collects_referenced_library_expressions(
		SELF.v_c_v_values) | QUERY(v <* used_variables(e)
		| NOT(v IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) <> []) = [];
END_ENTITY; -- sub_object_view_statement

ENTITY referenced_sub_item_view_statement
SUBTYPE OF(sub_object_view_statement);
	sub_object: self_property_value_semantics;
WHERE
	WR1: definition_available_implies(SELF.sub_object
		\property_semantics.the_property,
		(data_type_typeof(SELF.sub_object
		\property_semantics.the_property) = [])
		OR ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE'
		IN data_type_typeof(SELF.sub_object
		\property_semantics.the_property)));
	WR2: self_property_value_semantics_is_item_class(SELF);
	WR3: definition_available_implies(SELF.sub_object
		\property_semantics.the_property,
		(data_type_class_of(SELF.sub_object
		\property_semantics.the_property) = []))
		OR definition_available_implies(data_type_class_of(
		SELF.sub_object\property_semantics.the_property)[1], 
		data_type_class_of(
		SELF.sub_object\property_semantics.the_property)[1] IN
		SELF\simple_statement.referenced_by.item_of.defines
		.describes.specification.referred_subobject_models);
END_ENTITY; -- referenced_sub_item_view_statement

ENTITY constructed_sub_model_view_statement
SUBTYPE OF(sub_object_view_statement);
	sub_model: class_instance_constructor;
WHERE
	WR1: SELF.sub_model\class_instance_expression.expr_type IN
		SELF\simple_statement.referenced_by.item_of.defines
		.describes.specification.referred_subobject_models;
	WR2: definition_available_implies(
		SELF.sub_model\class_instance_expression.expr_type,
		'ISO13584_EXTENDED_DICTIONARY_SCHEMA'
		+'.FUNCTIONAL_MODEL_CLASS' IN
		TYPEOF(SELF.sub_model\class_instance_expression.expr_type
		.definition[1]));
	WR3: definition_available_implies(
		SELF.sub_model\class_instance_expression.expr_type,
		SIZEOF(SELF.sub_model\class_instance_expression.expr_type
		.referenced_by) = 1);
	WR4: definition_available_implies(
		SELF.sub_model\class_instance_expression.expr_type,
		SELF.sub_model\class_instance_expression.expr_type
		= SELF\sub_object_view_statement.created_view);
	WR5: QUERY(v <* used_variables(SELF.sub_model)
		| NOT(v IN SELF\simple_statement.referenced_by
		.item_of.defines.declaration)) = [];
END_ENTITY; -- constructed_sub_model_view_statement

RULE created_view_v_c_v_rule FOR(method_specif,
	functional_view_class);
WHERE
	WR1: QUERY(meth <* method_specif |
		all_class_descriptions_reachable(meth.created_view)
		AND (QUERY(temp <* meth.v_c_v_range | NOT(
		temp.parameter_type IN functional_view_v_c_v(
		meth.created_view))) <> [])) = [];
END_RULE; -- created_view_v_c_v_rule

RULE v_c_v_values_set_and_created_view_v_c_v_set_equality_rule FOR(
	sub_object_view_statement, functional_view_class);
WHERE
	WR1: QUERY(sub <* sub_object_view_statement |
		all_class_descriptions_reachable(sub.created_view)
		AND
		(collects_assigned_properties(sub.v_c_v_values) <>
		functional_view_v_c_v(sub.created_view))) = [];
END_RULE; -- v_c_v_values_set_and_created_view_v_c_v_set_equality_rule

RULE no_v_c_v_in_assigned_variables_set_rule FOR(
	assignment_statement, functional_view_class);
WHERE
	WR1: QUERY(ass <* assignment_statement |
		all_class_descriptions_reachable(ass\simple_statement.
		referenced_by.item_of.defines.describes
		.specification.created_view)
		AND
		(ass.assigned_variable\generic_variable
		.interpretation.semantics\property_semantics.the_property IN
		functional_view_v_c_v(ass\simple_statement.referenced_by
		.item_of.defines.describes.specification.created_view)))
		= [];
END_RULE; -- no_v_c_v_in_assigned_variables_set_rule

FUNCTION checks_classes_in_path(v: property_semantics_or_path;
		cl: SET OF class_BSU): LOGICAL;

LOCAL
	prop: property_BSU;
	temp: SET [0:1] OF class_BSU;
END_LOCAL;

prop := v.the_property;

IF data_type_typeof(prop) = []
THEN -- domain is unknown
	RETURN(UNKNOWN);
ELSE -- domain is known
	IF('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE' IN
		data_type_typeof(prop))
	THEN
		temp := data_type_class_of(prop);
		IF NOT(temp[1] IN cl)
		THEN
			RETURN(FALSE);
		ELSE -- domain in cl, check forward
			IF EXISTS(v.its_own_property)
			THEN
				RETURN(checks_classes_in_path(
					v.its_own_property, cl));
			ELSE
				RETURN(TRUE); -- all path checked
			END_IF;
		END_IF;
	ELSE
		RETURN(TRUE); -- domain is not a class
	END_IF;
END_IF;

END_FUNCTION; -- checks_classes_in_path

FUNCTION checks_applicable_properties_in_path(
	v: property_semantics_or_path): LOGICAL;

LOCAL
	prop: property_BSU;
	temp: SET[0:1] OF class_BSU;
END_LOCAL;

prop := v.the_property;

IF data_type_typeof(prop) = []
THEN --domain is unknown
	RETURN(UNKNOWN);
ELSE --domain is known
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CLASS_INSTANCE_TYPE' IN
		data_type_typeof(prop))
	THEN
		IF EXISTS(v.its_own_property)
		THEN
			temp := data_type_class_of(prop);
			RETURN(applicable_properties(
				temp[1], [v.its_own_property
				.the_property]) AND
				checks_applicable_properties_in_path(
				v.its_own_property));
		ELSE
			RETURN(TRUE); --all paths checked
		END_IF;
	ELSE
		RETURN(TRUE); -- no sub_property
	END_IF;
END_IF;

END_FUNCTION; --checks_applicable_properties_in_path

FUNCTION same_view_model_method(meth: method_specif): LOGICAL;

IF SIZEOF(meth.specifies.its_class
	\content_item.dictionary_definition.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

RETURN(
	meth.specifies.its_class
	\content_item.dictionary_definition.definition[1]
	\abstract_functional_model_class.created_view :=:
	meth.created_view);

END_FUNCTION; -- same_view_model_method

FUNCTION self_property_value_semantics_is_item_class(
	it: referenced_sub_item_view_statement): LOGICAL;

IF SIZEOF(it.sub_object
	\property_semantics.the_property.definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

IF (data_type_class_of(it.sub_object
	\property_semantics.the_property) = [])
THEN
	RETURN(UNKNOWN);
END_IF;

IF SIZEOF(data_type_class_of(it.sub_object
	\property_semantics.the_property)[1].definition) = 0
THEN
	RETURN(UNKNOWN);
END_IF;

RETURN(('ISO13584_IEC61360_DICTIONARY_SCHEMA.ITEM_CLASS' IN
	TYPEOF(data_type_class_of(it.sub_object
	\property_semantics.the_property)[1].definition[1])));

END_FUNCTION; -- self_property_value_semantics_is_item_class

END_SCHEMA; -- ISO13584_method_schema

SCHEMA ISO13584_g_m_iim_schema;

USE FROM ISO13584_generic_expressions_schema
	(environment);

USE FROM ISO13584_expressions_schema
	(abs_function,
	acos_function,
	and_expression,
	asin_function,
	atan_function,
	boolean_literal,
	boolean_variable,
	comparison_equal,
	comparison_greater,
	comparison_greater_equal,
	comparison_less,
	comparison_less_equal,
	comparison_not_equal,
	concat_expression,
	cos_function,
	div_expression,
	equals_expression,
	exp_function,
	format_function,
	index_expression,
	interval_expression,
	int_literal,
	int_numeric_variable,
	int_value_function,
	length_function,
	like_expression,
	log_function,
	log2_function,
	log10_function,
	maximum_function,
	minimum_function,
	minus_expression,
	minus_function,
	mod_expression,
	mult_expression,
	not_expression,
	odd_function,
	or_expression,
	plus_expression,
	power_expression,
	real_literal,
	real_numeric_variable,
	sin_function,
	slash_expression,
	square_root_function,
	string_literal,
	string_variable,
	substring_expression,
	tan_function,
	value_function,
	xor_expression);

USE FROM ISO13584_IEC61360_dictionary_schema
	(axis1_placement_type,
	axis2_placement_2d_type,
	axis2_placement_3d_type,
	basic_semantic_unit,
	boolean_type,
	class_BSU,
	class_instance_type,
	class_value_assignment,
	component_class,
	condition_DET,
	data_type_BSU,
	data_type_element,
	dates,
	dependent_P_DET,
	dic_unit,
	dic_value,
	entity_instance_type,
	identified_document,
	integer_type,
	int_currency_type,
	int_measure_type,
	int_type,
	item_class,
	item_names,
	label_with_language,
	level_type,
	material_class,
	mathematical_string,
	named_type,
	non_dependent_P_DET,
	non_quantitative_code_type,
	non_quantitative_int_type,
	non_si_unit,
	number_type,
	placement_type,
	property_BSU,
	real_currency_type,
	real_measure_type,
	real_type,
	string_type,
	supplier_BSU,
	supplier_element,
	value_code_type,
	value_domain);

USE FROM ISO13584_IEC61360_language_resource_schema
	(global_language_assignment,
	present_translations,
	translated_label,
	translated_text);

USE FROM ISO13584_instance_resource_schema
	(Null_value,
	Primitive_value,
	Null_or_primitive_value,
	Simple_value,
	Null_or_simple_value,
	Number_value,
	Null_or_number_value,
	Integer_value,
	Null_or_integer_value,
	Real_value,
	Null_or_real_value,
	Boolean_value,
	Null_or_boolean_value,
	Translatable_string_value,
	Translated_string_value,
	String_value,
	Null_or_translatable_string_value,
	Complex_value,
	Null_or_complex_value,
	Entity_instance_value,
	Null_or_entity_instance_value,
	Defined_entity_instance_value,
	Controlled_entity_instance_value,
	STEP_entity_instance_value,
	PLIB_entity_instance_value,
	Property_or_data_type_BSU,
	Level_spec_value,
	Null_or_level_spec_value,
	Int_level_spec_value,
	Null_or_int_level_spec_value,
	Real_level_spec_value,
	Null_or_real_level_spec_value,
	Property_value,
	Context_dependent_property_value,
	dic_class_instance,
	null_or_dic_class_instance,
	dic_component_instance,
	dic_feature_instance,
	dic_material_instance,
	lib_component_instance,
	lib_feature_instance,
	lib_material_instance);
	
USE FROM ISO13584_library_expressions_schema
	(binary_class_instance_constructor,
	class_instance_literal,
	class_instance_variable,
	entity_instance_literal,
	entity_instance_variable,
	exists_value,
	instance_comparison_equal,
	int_level_spec_literal,
	int_level_spec_variable,
	multiple_arity_class_instance_constructor,
	property_assignment,
	real_level_spec_literal,
	real_level_spec_variable,
	unary_class_instance_constructor);

USE FROM ISO13584_table_resource_schema
	(boolean_column,
	class_instance_column,
	column_traversal_variable_semantics,
	difference_table_expression,
	entity_instance_column,
	integer_column,
	intersect_table_expression,
	int_level_spec_column,
	in_RDB_table_boolean_expression,
	multiple_arity_cartesian_product,
	natural_join_expression,
	projection_expression,
	RDB_table_extension,
	RDB_table_specification,
	RDB_table_variable,
	real_column,
	real_level_spec_column,
	select_expression,
	string_column,
	table_extension,
	table_literal,
	table_specification,
	table_variable,
	union_table_expression);

USE FROM ISO13584_variable_semantics_schema
	(property_semantics_or_path,
	self_class_code_semantics,
	self_class_preferred_name_semantics,
	self_class_short_name_semantics,
	self_class_supplier_code_semantics,
	self_class_version_semantics,
	self_property_class_code_semantics,
	self_property_class_version_semantics,
	self_property_code_semantics,
	self_property_preferred_name_semantics,
	self_property_short_name_semantics,
	self_property_value_semantics,
	self_property_version_semantics,
	sub_property_path);

USE FROM ISO13584_domain_resource_schema
	(constant_range_defined_domain,
	domain_restriction,
	functional_domain_restriction,
	guarded_functional_domain,
	guarded_simple_domain,
	library_expression_defined_value,
	null_defined_value,
	others,
	predicate_defined_domain,
	subclass_defined_domain,
	table_defined_domain,
	table_defined_value,
	type_defined_domain,
	variable_range_defined_domain);

USE FROM ISO13584_extended_dictionary_schema
	(a_posteriori_case_of,
	class_document_relationship,
	class_table_relationship,
	component_class_case_of,
	dictionary_identification,
	dictionary,
	dictionary_in_standard_format,
	document_BSU,
	document_element,
	feature_class,
	feature_class_case_of,
	geometric_representation_context_type,
	item_class_case_of,
	library_iim_identification,
	material_class_case_of,
	RDB_table_content,
	RDB_table_element,
	representation_type,
	table_BSU,
	table_content,
	table_element,
	view_exchange_protocol_identification);

USE FROM ISO13584_library_content_schema
	(explicit_item_class_extension,
	item_class_extension,
	library,
	library_in_standard_format,
	opt_or_mand_property_BSU);

USE FROM ISO13584_external_file_schema
	(A6_illustration,
	A9_illustration,
	document_content,
	external_file_unit,
	http_class_directory,
	http_directory_name_type,
	http_file,
	http_protocol,
	illustration,
	language_specific_content,
	message,
	non_standard_data_protocol,
	not_translatable_external_content,
	not_translated_external_content,
	standard_data_protocol,
	translated_external_content,
	property_value_external_item);

USE FROM measure_schema
	(amount_of_substance_measure,
	amount_of_substance_unit,
	area_measure,
	area_unit,
	context_dependent_measure,
	context_dependent_unit,
	conversion_based_unit,
	count_measure,
	derived_unit,
	derived_unit_element,
	descriptive_measure,
	dimensional_exponents,
	electric_current_measure,
	electric_current_unit,
	global_unit_assigned_context,
	length_measure,
	length_measure_with_unit,
	length_unit,
	luminous_intensity_measure,
	luminous_intensity_unit,
	mass_measure,
	mass_unit,
	measure_value,
	measure_with_unit,
	named_unit,
	numeric_measure,
	parameter_value,
	plane_angle_measure,
	plane_angle_unit,
	positive_length_measure,
	positive_plane_angle_measure,
	positive_ratio_measure,
	ratio_measure,
	ratio_unit,
	si_unit,
	solid_angle_measure,
	solid_angle_unit,
	thermodynamic_temperature_measure,
	thermodynamic_temperature_unit,
	time_measure,
	time_unit,
	volume_measure,
	volume_unit);

USE FROM person_organization_schema
	(address,
	organization,
	person,
	person_and_organization,
	personal_address,
	organizational_address );

USE FROM date_time_schema
	(date,
	date_and_time,
	local_time,
	calendar_date,
	ordinal_date,
	week_of_year_and_day_date);

USE FROM application_context_schema
	(application_context,
	application_context_element,
	application_protocol_definition);


RULE at_most_one_dictionary_rule FOR(dictionary);
WHERE
	WR1: SIZEOF(dictionary) <= 1;
END_RULE; -- at_most_one_library_rule

RULE class_associated_items_rule FOR(class);
WHERE
	WR1: QUERY(temp <* class | (SIZEOF(temp.associated_items) > 2)
		OR ((SIZEOF(temp.associated_items) = 1)
		AND NOT(('ISO13584_G_M_IIM_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP' IN 
		TYPEOF(temp.associated_items[1]))
		OR ('ISO13584_G_M_IIM_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))
		OR ((SIZEOF(temp.associated_items) = 2)
		AND NOT((('ISO13584_G_M_IIM_SCHEMA'
		+ '.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))
		AND ('ISO13584_G_M_IIM_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2])))
		OR (('ISO13584_G_M_IIM_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2]))
		AND ('ISO13584_G_M_IIM_SCHEMA'
		+ '.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))))
		= [];
END_RULE; -- class_associated_items_rule

END_SCHEMA; -- ISO13584_g_m_iim_schema

SCHEMA ISO13584_f_m_iim_schema;

USE FROM ISO13584_generic_expressions_schema
	(environment);

USE FROM ISO13584_expressions_schema
	(abs_function,
	acos_function,
	and_expression,
	asin_function,
	atan_function,
	boolean_literal,
	boolean_variable,
	comparison_equal,
	comparison_greater,
	comparison_greater_equal,
	comparison_less,
	comparison_less_equal,
	comparison_not_equal,
	concat_expression,
	cos_function,
	div_expression,
	equals_expression,
	exp_function,
	format_function,
	index_expression,
	interval_expression,
	int_literal,
	int_numeric_variable,
	int_value_function,
	length_function,
	like_expression,
	log_function,
	log2_function,
	log10_function,
	maximum_function,
	minimum_function,
	minus_expression,
	minus_function,
	mod_expression,
	mult_expression,
	not_expression,
	odd_function,
	or_expression,
	plus_expression,
	power_expression,
	real_literal,
	real_numeric_variable,
	sin_function,
	slash_expression,
	square_root_function,
	string_literal,
	string_variable,
	substring_expression,
	tan_function,
	value_function,
	xor_expression);

USE FROM ISO13584_IEC61360_dictionary_schema
	(axis1_placement_type,
	axis2_placement_2d_type,
	axis2_placement_3d_type,
	basic_semantic_unit,
	boolean_type,
	class_BSU,
	class_instance_type,
	data_type_BSU,
	data_type_element,
	dates,
	dic_unit,
	dic_value,
	entity_instance_type,
	identified_document,
	integer_type,
	int_currency_type,
	int_measure_type,
	int_type,
	item_names,
	label_with_language,
	level_type,
	mathematical_string,
	named_type,
	non_quantitative_code_type,
	non_quantitative_int_type,
	non_si_unit,
	number_type,
	placement_type,
	property_BSU,
	real_currency_type,
	real_measure_type,
	real_type,
	string_type,
	supplier_BSU,
	supplier_element,
	value_code_type,
	value_domain);

USE FROM ISO13584_IEC61360_language_resource_schema
	(global_language_assignment,
	present_translations,
	translated_label,
	translated_text);

USE FROM ISO13584_instance_resource_schema
	(Null_value,
	Primitive_value,
	Null_or_primitive_value,
	Simple_value,
	Null_or_simple_value,
	Number_value,
	Null_or_number_value,
	Integer_value,
	Null_or_integer_value,
	Real_value,
	Null_or_real_value,
	Boolean_value,
	Null_or_boolean_value,
	Translatable_string_value,
	Translated_string_value,
	String_value,
	Null_or_translatable_string_value,
	Complex_value,
	Null_or_complex_value,
	Entity_instance_value,
	Null_or_entity_instance_value,
	Defined_entity_instance_value,
	Controlled_entity_instance_value,
	STEP_entity_instance_value,
	PLIB_entity_instance_value,
	Property_or_data_type_BSU,
	Level_spec_value,
	Null_or_level_spec_value,
	Int_level_spec_value,
	Null_or_int_level_spec_value,
	Real_level_spec_value,
	Null_or_real_level_spec_value,
	Property_value,
	Context_dependent_property_value,
	dic_class_instance,
	null_or_dic_class_instance,
	dic_f_model_instance,
	lib_f_model_instance);

USE FROM ISO13584_library_expressions_schema
	(binary_class_instance_constructor,
	class_instance_literal,
	class_instance_variable,
	entity_instance_literal,
	entity_instance_variable,
	exists_value,
	instance_comparison_equal,
	int_level_spec_literal,
	int_level_spec_variable,
	multiple_arity_class_instance_constructor,
	property_assignment,
	real_level_spec_literal,
	real_level_spec_variable,
	unary_class_instance_constructor);

USE FROM ISO13584_table_resource_schema
	(boolean_column,
	class_instance_column,
	column_traversal_variable_semantics,
	difference_table_expression,
	entity_instance_column,
	integer_column,
	intersect_table_expression,
	int_level_spec_column,
	in_RDB_table_boolean_expression,
	multiple_arity_cartesian_product,
	natural_join_expression,
	projection_expression,
	RDB_table_extension,
	RDB_table_specification,
	RDB_table_variable,
	real_column,
	real_level_spec_column,
	select_expression,
	string_column,
	table_extension,
	table_literal,
	table_specification,
	table_variable,
	union_table_expression);

USE FROM ISO13584_variable_semantics_schema
	(open_view_property_value_semantics,
	self_class_code_semantics,
	self_class_preferred_name_semantics,
	self_class_short_name_semantics,
	self_class_supplier_code_semantics,
	self_class_version_semantics,
	self_property_class_code_semantics,
	self_property_class_version_semantics,
	self_property_code_semantics,
	self_property_preferred_name_semantics,
	self_property_short_name_semantics,
	self_property_value_semantics,
	self_property_version_semantics,
	sub_property_path);

USE FROM ISO13584_domain_resource_schema
	(constant_range_defined_domain,
	domain_restriction,
	functional_domain_restriction,
	library_expression_defined_value,
	guarded_functional_domain,
	guarded_simple_domain,
	null_defined_value,
	others,
	predicate_defined_domain,
	subclass_defined_domain,
	table_defined_domain,
	table_defined_value,
	type_defined_domain,
	variable_range_defined_domain);

USE FROM ISO13584_extended_dictionary_schema
	(a_posteriori_view_of,
	class_document_relationship,
	class_table_relationship,
	dictionary_identification,
	dictionary,
	dictionary_in_standard_format,
	document_BSU,
	document_element,
	fm_class_view_of,
	functional_model_class,
	geometric_representation_context_type,
	library_iim_identification,
	program_library_BSU,
	program_library_element,
	program_reference_type,
	RDB_table_content,
	RDB_table_element,
	representation_P_DET,
	representation_type,
	representation_reference_type,
	supplier_program_library_relationship,
	table_BSU,
	table_content,
	table_element,
	view_control_variable_range,
	view_exchange_protocol_identification);

USE FROM ISO13584_library_content_schema
	(explicit_functional_model_class_extension,
	functional_model_class_extension,
	library,
	library_in_standard_format,
	opt_or_mand_property_BSU);

USE FROM ISO13584_external_file_schema
	(A6_illustration,
	A9_illustration,
	document_content,
	external_file_unit,
	http_class_directory,
	http_file,
	http_protocol,
	IAB_RFC,
	illustration,
	language_specific_content,
	linked_interface_program_protocol,
	message,
	non_standard_data_protocol,
	non_standard_simple_program_protocol,
	not_translatable_external_content,
	not_translated_external_content,
	program_library_content,
	program_reference,
	representation_reference,
	standard_data_protocol,
	standard_simple_program_protocol,
	translated_external_content,
	property_value_external_item);

USE FROM ISO13584_method_schema
	(assignment_statement,
	begin_set,
	call_program_statement,
	close_set,
	constructed_sub_model_view_statement,
	guarded_statement,
	method,
	method_body,
	method_specif,
	method_statement,
	null_statement,
	referenced_sub_item_view_statement,
	send_representation_statement,
	send_representation_reference_statement,
	set_2d_relative_view_level,
	set_reference_lcs);

USE FROM measure_schema
	(amount_of_substance_measure,
	amount_of_substance_unit,
	area_measure,
	area_unit,
	context_dependent_measure,
	context_dependent_unit,
	conversion_based_unit,
	count_measure,
	derived_unit,
	derived_unit_element,
	descriptive_measure,
	dimensional_exponents,
	electric_current_measure,
	electric_current_unit,
	global_unit_assigned_context,
	length_measure,
	length_measure_with_unit,
	length_unit,
	luminous_intensity_measure,
	luminous_intensity_unit,
	mass_measure,
	mass_unit,
	measure_value,
	measure_with_unit,
	named_unit,
	numeric_measure,
	parameter_value,
	plane_angle_measure,
	plane_angle_unit,
	positive_length_measure,
	positive_plane_angle_measure,
	positive_ratio_measure,
	ratio_measure,
	ratio_unit,
	si_unit,
	solid_angle_measure,
	solid_angle_unit,
	thermodynamic_temperature_measure,
	thermodynamic_temperature_unit,
	time_measure,
	time_unit,
	volume_measure,
	volume_unit);

USE FROM person_organization_schema
	(address,
	organization,
	person,
	person_and_organization,
	personal_address,
	organizational_address );

USE FROM date_time_schema
	(date,
	date_and_time,
	local_time,
	calendar_date,
	ordinal_date,
	week_of_year_and_day_date);


USE FROM geometry_schema
	(axis1_placement,
	axis2_placement_2D,
	axis2_placement_3D,
	geometric_representation_context,
	placement);

USE FROM representation_schema
	(representation,
	representation_item,
	representation_context);


USE FROM application_context_schema
	(application_context,
	application_context_element,
	application_protocol_definition);



RULE exactly_one_dictionary_rule FOR(dictionary);
WHERE
	WR1: SIZEOF(dictionary) = 1;
END_RULE; -- exactly_one_library_rule

RULE class_associated_items_rule FOR(class);
WHERE
	WR1: QUERY(temp <* class | (SIZEOF(temp.associated_items) > 2)
		OR ((SIZEOF(temp.associated_items) = 1)
		AND NOT(('ISO13584_F_M_IIM_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP' IN 
		TYPEOF(temp.associated_items[1]))
		OR ('ISO13584_F_M_IIM_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))
		OR ((SIZEOF(temp.associated_items) = 2)
		AND NOT((('ISO13584_F_M_IIM_SCHEMA'
		+ '.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))
		AND ('ISO13584_F_M_IIM_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2])))
		OR (('ISO13584_F_M_IIM_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2]))
		AND ('ISO13584_F_M_IIM_SCHEMA'
		+ '.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))))
		= [];
END_RULE; -- class_associated_items_rule

RULE supplier_associated_items_rule FOR(supplier_element);
WHERE
	WR1: QUERY(temp <* supplier_element
		| (SIZEOF(temp.associated_items) > 1)
		OR ((SIZEOF(temp.associated_items) = 1)
		AND NOT('ISO13584_F_M_IIM_SCHEMA'
		+ '.SUPPLIER_PROGRAM_LIBRARY_RELATIONSHIP'
		IN TYPEOF(temp.associated_items)))) = [];
END_RULE; -- supplier_associated_items_rule


END_SCHEMA; -- ISO13584_f_m_iim_schema


SCHEMA ISO13584_f_v_iim_schema;

USE FROM ISO13584_IEC61360_dictionary_schema
	(axis1_placement_type,
	axis2_placement_2d_type,
	axis2_placement_3d_type,
	boolean_type,
	class_BSU,
	class_instance_type,
	data_type_BSU,
	data_type_element,
	dates,
	dic_unit,
	dic_value,
	entity_instance_type,
	identified_document,
	integer_type,
	int_currency_type,
	int_measure_type,
	int_type,
	item_names,
	level_type,
	label_with_language,
	mathematical_string,
	named_type,
	non_quantitative_code_type,
	non_quantitative_int_type,
	non_si_unit,
	number_type,
	placement_type,
	property_BSU,
	real_currency_type,
	real_measure_type,
	real_type,
	string_type,
	supplier_BSU,
	supplier_element,
	value_code_type,
	value_domain);

USE FROM ISO13584_IEC61360_language_resource_schema
	(global_language_assignment,
	present_translations,
	translated_label,
	translated_text);

USE FROM ISO13584_extended_dictionary_schema
	(table_BSU,
	class_document_relationship,
	dictionary_identification,
	dictionary,
	dictionary_in_standard_format,
	document_BSU,
	document_element,
	functional_view_class,
	geometric_representation_context_type,
	library_iim_identification,
	non_instantiable_functional_view_class,
	representation_P_DET,
	representation_type,
	view_exchange_protocol_identification);

USE FROM ISO13584_external_file_schema
	(document_content,
	external_file_unit,
	http_protocol,
	http_file,
	http_class_directory,
	language_specific_content,
	non_standard_protocol,
	not_translatable_external_content,
	not_translated_external_content,
	standard_data_protocol,
	translated_external_content);

USE FROM measure_schema
	(amount_of_substance_measure,
	amount_of_substance_unit,
	area_measure,
	area_unit,
	context_dependent_measure,
	context_dependent_unit,
	conversion_based_unit,
	count_measure,
	derived_unit,
	derived_unit_element,
	descriptive_measure,
	dimensional_exponents,
	electric_current_measure,
	electric_current_unit,
	length_measure,
	length_measure_with_unit,
	length_unit,
	luminous_intensity_measure,
	luminous_intensity_unit,
	mass_measure,
	mass_unit,
	measure_value,
	measure_with_unit,
	named_unit,
	numeric_measure,
	parameter_value,
	plane_angle_measure,
	plane_angle_unit,
	positive_length_measure,
	positive_plane_angle_measure,
	positive_ratio_measure,
	ratio_measure,
	ratio_unit,
	si_unit,
	solid_angle_measure,
	solid_angle_unit,
	thermodynamic_temperature_measure,
	thermodynamic_temperature_unit,
	time_measure,
	time_unit,
	volume_measure,
	volume_unit);

USE FROM person_organization_schema
	(address,
	organization,
	person,
	person_and_organization,
	personal_address,
	organizational_address );

USE FROM date_time_schema
	(date,
	date_and_time,
	local_time,
	calendar_date,
	ordinal_date,
	week_of_year_and_day_date);


USE FROM application_context_schema
	(application_context,
	application_context_element,
	application_protocol_definition);

USE FROM representation_schema
	(representation,
	representation_context,
	representation_item);


RULE exactly_one_dictionary_rule FOR(dictionary);
WHERE
	WR1: SIZEOF(dictionary) = 1;
END_RULE; -- exactly_one_library_rule

RULE class_associated_items_rule FOR(class);
WHERE
	WR1: QUERY(temp <* class | (SIZEOF(temp.associated_items) > 2)
		OR ((SIZEOF(temp.associated_items) = 1)
		AND NOT(('ISO13584_F_V_IIM_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP' IN 
		TYPEOF(temp.associated_items[1]))
		OR ('ISO13584_F_V_IIM_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))
		OR ((SIZEOF(temp.associated_items) = 2)
		AND NOT((('ISO13584_F_V_IIM_SCHEMA'
		+ '.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))
		AND ('ISO13584_F_V_IIM_SCHEMA'
		+'.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2])))
		OR (('ISO13584_F_V_IIM_SCHEMA'
		+'.CLASS_TABLE_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[2]))
		AND ('ISO13584_F_V_IIM_SCHEMA'
		+ '.CLASS_DOCUMENT_RELATIONSHIP'
		IN TYPEOF(temp.associated_items[1]))))))
		= [];
END_RULE; -- class_associated_items_rule


END_SCHEMA; -- ISO13584_f_v_iim_schema

SCHEMA ISO13584_g_m_iim_conformance_schema;

USE FROM ISO13584_IEC61360_dictionary_schema(
	item_names);

USE FROM ISO13584_IEC61360_language_resource_schema(
	translated_label);

USE FROM person_organization_schema(
	organization);

USE FROM support_resource_schema(
	label);

USE FROM ISO13584_extended_dictionary_schema(
	data_exchange_specification_identification,
	library_iim_identification);

USE FROM ISO13584_external_file_schema(
	http_protocol,
	standard_data_protocol,
	external_file_protocol);

RULE allowed_reference_to_LIIM_24_1_rule FOR(
	library_iim_identification);
WHERE
	WR1: QUERY(liim_id <* library_iim_identification |
		((liim_id\data_exchange_specification_identification
				.status = 'WD')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'CD')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'DIS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'FDIS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'IS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'TS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'PAS')
			OR
		(liim_id\data_exchange_specification_identification
				.status = 'ITA')
		)
		AND
		(liim_id\data_exchange_specification_identification.name
		= 'ISO_13584_24_1')
		AND
		is_correct_liim_24_1_application_value(liim_id)
		AND
		(QUERY(efp <*
		liim_id\data_exchange_specification_identification
		.external_file_protocols
		| NOT(is_extended_liim_24_1_application_value(liim_id))
		AND
		NOT(conformant_external_file_protocol_24_1([efp]))
		) = []))
		= QUERY(liim_id <* library_iim_identification |
		(liim_id\data_exchange_specification_identification
		.name = 'ISO_13584_24_1'));
END_RULE; -- allowed_reference_to_LIIM_24_1_rule

FUNCTION conformant_http_protocol_24_1(
	ef: external_file_protocol): BOOLEAN;

LOCAL
	ok: BOOLEAN := TRUE;
END_LOCAL;

IF (('ISO13584_EXTERNAL_FILE_SCHEMA'
	+ '.HTTP_PROTOCOL' IN TYPEOF(ef)) AND
	(ef.organisation.id = 'IAB') AND
	(ef.organisation.name = 'Internet Architecture Board') AND
	((ef.protocol_name = 'HTTP') 
		OR (ef.protocol_name = 'HTTPS'))AND
	(ef.designation.preferred_name = 'Hypertext Transfer Protocol'))
THEN
	IF ('ISO13584_IEC61360_DICTIONARY_SCHEMA.TRANSLATED_LABEL'
		IN TYPEOF(ef.designation.short_name))
	THEN
		REPEAT i := 1 TO SIZEOF(ef.designation.short_name.labels);
			IF (ef.designation.short_name.labels[i]
				LIKE 'RFC####&')
			THEN
				ok := ok AND TRUE;
			ELSE
				ok := ok AND FALSE;
			END_IF;
		END_REPEAT;
		RETURN(OK);
	ELSE
		IF ef.designation.short_name
			LIKE 'RFC####&'
		THEN
			RETURN(TRUE);
		ELSE
			RETURN(FALSE);
		END_IF;
	END_IF;
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- conformant_http_protocol_24_1

FUNCTION conformant_8859_1_protocol_24_1(
	ef: external_file_protocol): BOOLEAN;

IF (('ISO13584_EXTERNAL_FILE_SCHEMA'
	+ '.STANDARD_DATA_PROTOCOL' IN TYPEOF(ef)) AND
	(ef.organisation.id = 'ISO') AND
	(ef.organisation.name
		= 'International Organisation for Standardisation') AND
	(ef.protocol_name = 'ISO_8859_1') AND
	(ef.designation.preferred_name = 'Latin alphabet No 1') AND
	(ef.designation.short_name = 'ISO 8859-1'))
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- conformant_8859_1_protocol_24_1

FUNCTION conformant_external_file_protocol_24_1(
	s: SET [0:?] OF external_file_protocol): BOOLEAN;

REPEAT i := 1 TO SIZEOF(s);
	IF NOT(conformant_8859_1_protocol_24_1(s[i])
		OR conformant_http_protocol_24_1(s[i]))
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- conformant_external_file_protocol_24_1

FUNCTION is_correct_liim_24_1_application_value(
	liim_id: library_iim_identification): BOOLEAN;

IF EXISTS(liim_id\data_exchange_specification_identification.
	application)
	AND
	((liim_id\data_exchange_specification_identification.
		application[1] = '1')
	OR
	(liim_id\data_exchange_specification_identification.
		application[1] = '2')
	OR
	(liim_id\data_exchange_specification_identification.
		application[1] = '3')
	OR
	(liim_id\data_exchange_specification_identification.
		application[1] = '4')
	OR
	(liim_id\data_exchange_specification_identification.
		application[1] = '5')
	OR
	(liim_id\data_exchange_specification_identification.
		application[1] = '6'))
	AND
	((liim_id\data_exchange_specification_identification.
		application LIKE '#')
	OR
	(liim_id\data_exchange_specification_identification.
		Application LIKE '#E'))
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- is_correct_liim_24_1_application_value

FUNCTION is_extended_liim_24_1_application_value(
	liim_id: library_iim_identification): BOOLEAN;

IF EXISTS(liim_id\data_exchange_specification_identification.
		application) AND
	(liim_id\data_exchange_specification_identification.
		application LIKE '#E')
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- is_extended_liim_24_1_application_value

END_SCHEMA; -- ISO13584_g_m_iim_conformance_schema


SCHEMA ISO13584_f_m_iim_conformance_schema;

USE FROM ISO13584_IEC61360_dictionary_schema(
	item_names);

USE FROM ISO13584_IEC61360_language_resource_schema(
	translated_label);

USE FROM support_resource_schema(
	label);

USE FROM person_organization_schema(
	organization);

USE FROM ISO13584_extended_dictionary_schema(
	data_exchange_specification_identification,
	library_iim_identification);

USE FROM ISO13584_external_file_schema(
	http_protocol,
	standard_data_protocol,
	external_file_protocol);

RULE allowed_reference_to_LIIM_24_2_rule FOR(
	library_iim_identification);
WHERE
	WR1: QUERY(liim_id <* library_iim_identification |
		((liim_id\data_exchange_specification_identification
			.status = 'WD')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'CD')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'DIS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'FDIS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'IS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'TS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'PAS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'ITA'))
		AND
		(liim_id\data_exchange_specification_identification.
			Name = 'ISO_13584_24_2')
		AND
		is_correct_liim_24_2_application_value(liim_id)
		AND
		(QUERY(efp <*
		liim_id\data_exchange_specification_identification
		.external_file_protocols
		| NOT(is_extended_liim_24_2_application_value(liim_id))
		AND
		NOT(conformant_external_file_protocol_24_2([efp]))
		) = []))
	= QUERY(liim_id <* library_iim_identification |
		(liim_id\data_exchange_specification_identification
		.name = 'ISO_13584_24_2'));
END_RULE; -- allowed_reference_to_LIIM_24_2_rule

FUNCTION conformant_http_protocol_24_2(
	ef: external_file_protocol): BOOLEAN;

LOCAL
	ok: BOOLEAN := TRUE;
END_LOCAL;

IF (('ISO13584_EXTERNAL_FILE_SCHEMA.HTTP_PROTOCOL' IN TYPEOF(ef)) AND
	(ef.organisation.id = 'IAB') AND
	(ef.organisation.name = 'Internet Architecture Board') AND
	((ef.protocol_name = 'HTTP') 
		OR (ef.protocol_name = 'HTTPS'))AND
	(ef.designation.preferred_name = 'Hypertext Transfer Protocol'))
THEN
	IF 'ISO13584_IEC61360_DICTIONARY_SCHEMA.TRANSLATED_LABEL'
		IN TYPEOF(ef.designation.short_name)
	THEN
		REPEAT i := 1 TO SIZEOF(ef.designation.short_name.labels);
			IF ef.designation.short_name.labels[i] LIKE 'RFC####&'
			THEN
				ok := ok AND TRUE;
			ELSE
				ok := ok AND FALSE;
			END_IF;
		END_REPEAT;
		RETURN(OK);
	ELSE
		IF ef.designation.short_name
			LIKE 'RFC####&'
		THEN
			RETURN(TRUE);
		ELSE
			RETURN(FALSE);
		END_IF;
	END_IF;
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- conformant_http_protocol_24_2

FUNCTION conformant_8859_1_protocol_24_2(
	ef: external_file_protocol): BOOLEAN;

IF (('ISO13584_EXTERNAL_FILE_SCHEMA'
	+ '.STANDARD_DATA_PROTOCOL' IN TYPEOF(ef)) AND
	(ef.organisation.id = 'ISO') AND
	(ef.organisation.name
	= 'International Organisation for Standardisation') AND
	(ef.protocol_name = 'ISO_8859_1') AND
	(ef.designation.preferred_name
	= 'Latin alphabet No 1') AND
	(ef.designation.short_name = 'ISO 8859-1')
	)
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;
END_FUNCTION; -- conformant_8859_1_protocol_24_2

FUNCTION conformant_external_file_protocol_24_2(
	s: SET [0:?] OF external_file_protocol): BOOLEAN;

REPEAT i := 1 TO SIZEOF(s);
	IF NOT(conformant_8859_1_protocol_24_2(s[i])
		OR conformant_http_protocol_24_2(s[i]))
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- conformant_external_file_protocol_24_2

FUNCTION is_correct_liim_24_2_application_value(
	liim_id: library_iim_identification): BOOLEAN;

IF EXISTS(liim_id\data_exchange_specification_identification
	.application)
	AND
	((liim_id\data_exchange_specification_identification
		.application[1] = '1')
		OR
	(liim_id\data_exchange_specification_identification
		.application[1] = '2')
		OR
	(liim_id\data_exchange_specification_identification
		.application[1] = '3')
		OR
	(liim_id\data_exchange_specification_identification
		.application[1] = '4')
		OR
	(liim_id\data_exchange_specification_identification
		.application[1] = '5')
		OR
	(liim_id\data_exchange_specification_identification
		.application[1] = '6'))
	AND
	((liim_id\data_exchange_specification_identification
		.application LIKE '#')
		OR
	(liim_id\data_exchange_specification_identification
		.application LIKE '#E'))
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;
END_FUNCTION; -- is_correct_liim_24_2_application_value

FUNCTION is_extended_liim_24_2_application_value(
	liim_id: library_iim_identification): BOOLEAN;
IF EXISTS(liim_id\data_exchange_specification_identification
	.application)
	AND
	(liim_id\data_exchange_specification_identification
		.application LIKE '#E')
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;
END_FUNCTION; -- is_extended_liim_24_2_application_value


END_SCHEMA; -- ISO13584_f_m_iim_conformance_schema


SCHEMA ISO13584_f_v_iim_conformance_schema;

USE FROM ISO13584_IEC61360_dictionary_schema(
	item_names);

USE FROM ISO13584_IEC61360_language_resource_schema(
	translated_label);

USE FROM person_organization_schema(
	organization);

USE FROM support_resource_schema(
	label);

USE FROM ISO13584_extended_dictionary_schema(	data_exchange_specification_identification,
	library_iim_identification);

USE FROM ISO13584_external_file_schema(
	http_protocol,
	standard_data_protocol,
	external_file_protocol);

RULE allowed_reference_to_LIIM_24_3_rule FOR(
	library_iim_identification);
WHERE
	WR1: QUERY(liim_id <* library_iim_identification |
		((liim_id\data_exchange_specification_identification
			.status = 'WD')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'CD')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'DIS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'FDIS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'IS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'TS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'PAS')
			OR
		(liim_id\data_exchange_specification_identification
			.status = 'ITA'))
		AND
		(liim_id\data_exchange_specification_identification.name
		= 'ISO_13584_24_3')
		AND
		is_correct_liim_24_3_application_value(liim_id)
		AND
		(QUERY(efp <*
		liim_id\data_exchange_specification_identification
		.external_file_protocols
		| NOT(is_extended_liim_24_3_application_value(liim_id))
		AND
		NOT(conformant_external_file_protocol_24_3([efp]))
		) = []))
	= QUERY(liim_id <* library_iim_identification |
		(liim_id\data_exchange_specification_identification
		.name = 'ISO_13584_24_3'));
END_RULE; -- allowed_reference_to_LIIM_24_3_rule

FUNCTION conformant_http_protocol_24_3(
	ef: external_file_protocol): BOOLEAN;

LOCAL
	OK: BOOLEAN := TRUE;
END_LOCAL;

IF (('ISO13584_EXTERNAL_FILE_SCHEMA'
	+ '.HTTP_PROTOCOL' IN TYPEOF(ef)) AND
	(ef.organisation.id = 'IAB') AND
	(ef.organisation.name = 'Internet Architecture Board') AND
	((ef.protocol_name = 'HTTP')
		OR (ef.protocol_name = 'HTTPS')) AND
	(ef.designation.preferred_name = 'Hypertext Transfer Protocol'))
THEN
	IF 'ISO13584_IEC61360_DICTIONARY_SCHEMA.TRANSLATED_LABEL'
		IN TYPEOF(ef.designation.short_name)
	THEN
		REPEAT i := 1 TO SIZEOF(ef.designation.short_name.labels);
		
			IF ef.designation.short_name.labels[i]
				LIKE 'RFC####&'
			THEN
				ok := ok AND TRUE;
			ELSE
				ok := ok AND FALSE;
			END_IF;
		END_REPEAT;
		RETURN(OK);
	ELSE
		IF ef.designation.short_name
			LIKE 'RFC####&'
		THEN
			RETURN(TRUE);
		ELSE
			RETURN(FALSE);
		END_IF;
	END_IF;
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- conformant_http_protocol_24_3

FUNCTION conformant_8859_1_protocol_24_3(
	ef: external_file_protocol): BOOLEAN;

IF (('ISO13584_EXTERNAL_FILE_SCHEMA'
	+ '.STANDARD_DATA_PROTOCOL' IN TYPEOF(ef)) AND
	(ef.organisation.id = 'ISO') AND
	(ef.organisation.name
		= 'International Organisation for Standardisation') AND
	(ef.protocol_name = 'ISO_8859_1') AND
	(ef.designation.preferred_name
		= 'Latin alphabet No 1') AND
	(ef.designation.short_name = 'ISO 8859-1'))
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;
END_FUNCTION; -- conformant_8859_1_protocol_24_3

FUNCTION conformant_external_file_protocol_24_3(
	s: SET [0:?] OF external_file_protocol): BOOLEAN;

REPEAT i := 1 TO SIZEOF(s);
	IF NOT(conformant_8859_1_protocol_24_3(s[i])
		OR conformant_http_protocol_24_3(s[i]))
	THEN
		RETURN(FALSE);
	END_IF;
END_REPEAT;

RETURN(TRUE);

END_FUNCTION; -- conformant_external_file_protocol_24_3

FUNCTION is_correct_liim_24_3_application_value(
	liim_id: library_iim_identification): BOOLEAN;

IF EXISTS(liim_id\data_exchange_specification_identification.
	application)
	AND
	((liim_id\data_exchange_specification_identification.
		application[1] = '1')
			OR
	(liim_id\data_exchange_specification_identification.
		application[1] = '2'))
	AND
	((liim_id\data_exchange_specification_identification.application
		LIKE '#')
			OR
	(liim_id\data_exchange_specification_identification.application
		LIKE '#E'))
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;

END_FUNCTION; -- is_correct_liim_24_3_application_value

FUNCTION is_extended_liim_24_3_application_value(
	liim_id: library_iim_identification): BOOLEAN;

IF EXISTS(liim_id\data_exchange_specification_identification.
	application)
	AND
	(liim_id\data_exchange_specification_identification.
		application LIKE '#E')
THEN
	RETURN(TRUE);
ELSE
	RETURN(FALSE);
END_IF;
END_FUNCTION; -- is_extended_liim_24_3_application_value


END_SCHEMA; -- ISO13584_f_v_iim_conformance_schema
