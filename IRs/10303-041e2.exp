(*

	WG12 N525 								2000-05-30

	EXPRESS Declarations for ISO 10303-41: 2nd Edition
*)

SCHEMA application_context_schema;
REFERENCE FROM basic_attribute_schema                   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   id_attribute);
REFERENCE FROM date_time_schema                         -- ISO 10303-41
  (year_number);
REFERENCE FROM support_resource_schema                  -- ISO 10303-41
  (identifier,
   label,
   text);

ENTITY application_context;
  application      : label;
DERIVE
  description      : text := get_description_value (SELF);
  id               : identifier := get_id_value (SELF);
INVERSE
  context_elements : SET [1:?] OF application_context_element
                               FOR frame_of_reference;
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- application_context

ENTITY application_context_element
  SUPERTYPE OF (ONEOF (library_context,
                       product_concept_context,
                       product_context,
                       product_definition_context));
  name               : label;
  frame_of_reference : application_context;
END_ENTITY; -- application_context_element

ENTITY application_context_relationship;
  name             : label;
  description      : OPTIONAL text;
  relating_context : application_context;
  related_context  : application_context;
END_ENTITY; -- application_context_relationship;

ENTITY application_protocol_definition;
  status                                    : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year                 : year_number;
  application                               : application_context;
END_ENTITY; -- application_protocol_definition;

ENTITY library_context
  SUBTYPE OF (application_context_element);
  library_reference : label;
END_ENTITY; -- library_context

ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY; -- product_concept_context

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY; -- product_context

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY; -- product_definition_context

END_SCHEMA; -- application_context_schema

SCHEMA product_definition_schema;
REFERENCE FROM application_context_schema              -- ISO 10303-41
  (product_context,
   product_definition_context);
REFERENCE FROM basic_attribute_schema                  -- ISO 10303-41
  (get_id_value,
   get_name_value,
   name_attribute);
REFERENCE FROM document_schema                         -- ISO 10303-41
  (document);
REFERENCE FROM effectivity_schema                      -- ISO 10303-41
  (effectivity);
REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE source = ENUMERATION OF
  (made,
   bought,
   not_known);
END_TYPE; -- source

ENTITY product;
  id                 : identifier;
  name               : label;
  description        : OPTIONAL text;
  frame_of_reference : SET [1:?] OF product_context;
END_ENTITY; -- product

ENTITY product_category;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- product_category

ENTITY product_category_relationship;
  name          : label;
  description   : OPTIONAL text;
  category      : product_category;
  sub_category  : product_category;
WHERE
  WR1: acyclic_product_category_relationship
      (SELF, [SELF.sub_category]);
END_ENTITY; -- product_category_relationship

ENTITY product_definition;
  id                 : identifier;
  description        : OPTIONAL text;
  formation          : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name               : label := get_name_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- product_definition

ENTITY product_definition_context_association;
  definition         : product_definition;
  frame_of_reference : product_definition_context;
  role               : product_definition_context_role;
END_ENTITY; -- product_definition_context_association

ENTITY product_definition_context_role;
 name        : label;
 description : OPTIONAL text ;
END_ENTITY; -- product_definition_context_role

ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' +
               'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
END_ENTITY; -- product_definition_effectivity

ENTITY product_definition_formation;
  id          : identifier;
  description : OPTIONAL text;
  of_product  : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY; -- product_definition_formation

ENTITY product_definition_formation_relationship;
  id                                    : identifier;
  name                                  : label;
  description                           : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation  : product_definition_formation;
END_ENTITY; -- product_definition_formation_relationship

ENTITY product_definition_formation_with_specified_source
  SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY; -- product_definition_formation_with_specified_source

ENTITY product_definition_relationship;
  id                          : identifier;
  name                        : label;
  description                 : OPTIONAL text;
  relating_product_definition : product_definition;
  related_product_definition  : product_definition;
END_ENTITY; -- product_definition_relationship

ENTITY product_definition_substitute;
  description           : OPTIONAL text;
  context_relationship  : product_definition_relationship;
  substitute_definition : product_definition;
DERIVE
  name                  : label := get_name_value (SELF);
WHERE
  WR1 : context_relationship.related_product_definition :<>:
        substitute_definition;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- product_definition_substitute

ENTITY product_definition_with_associated_documents
  SUBTYPE OF(product_definition);
  documentation_ids : SET[1:?] OF document;
END_ENTITY; -- product_definition_with_associated_documents

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET [1:?] OF product;
END_ENTITY; -- product_related_product_category

ENTITY product_relationship;
  id               : identifier;
  name             : label;
  description      : OPTIONAL text;
  relating_product : product;
  related_product  : product;
END_ENTITY; -- product_relationship

FUNCTION acyclic_product_category_relationship
  (relation : product_category_relationship;
   children : SET of product_category): BOOLEAN;
  LOCAL 
    x              : SET OF product_category_relationship;
    local_children : SET OF product_category;
  END_LOCAL;
  REPEAT i := 1 to HIINDEX(children);
    IF relation.category :=: children [i] THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  x := bag_to_set(USEDIN (relation.category,
                          'PRODUCT_DEFINITION_SCHEMA.' + 
                          'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
  local_children := children + relation.category;
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 to HIINDEX(x);
      IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_product_category_relationship

FUNCTION acyclic_product_definition_formation_relationship
  (relation          : product_definition_formation_relationship;
   relatives         : SET [1:?] OF product_definition_formation;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF product_definition_formation_relationship;
  END_LOCAL;
  IF relation.relating_product_definition_formation IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (pdf <* bag_to_set 
             (USEDIN (relation.relating_product_definition_formation,
             'PRODUCT_DEFINITION_SCHEMA.' + 
             'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' +
             'RELATED_PRODUCT_DEFINITION_FORMATION')) |
              specific_relation IN TYPEOF (pdf));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_formation_relationship
      (x[i], 
       relatives + relation.relating_product_definition_formation, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_product_definition_formation_relationship

FUNCTION acyclic_product_definition_relationship
  (relation          : product_definition_relationship;
   relatives         : SET [1:?] OF product_definition;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF product_definition_relationship;
  END_LOCAL;
  IF relation.relating_product_definition IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (pd <* bag_to_set 
             (USEDIN (relation.relating_product_definition,
             'PRODUCT_DEFINITION_SCHEMA.' + 
             'PRODUCT_DEFINITION_RELATIONSHIP.' +
             'RELATED_PRODUCT_DEFINITION')) |
              specific_relation IN TYPEOF (pd));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_relationship
      (x[i], 
       relatives + relation.relating_product_definition, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_product_definition_relationship

FUNCTION acyclic_product_relationship
  (relation          : product_relationship;
   relatives         : SET [1:?] OF product;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF product_relationship;
  END_LOCAL;
  IF relation.relating_product IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (prod <* bag_to_set 
             (USEDIN (relation.relating_product,
             'PRODUCT_DEFINITION_SCHEMA.' + 
             'PRODUCT_RELATIONSHIP.' +
             'RELATED_PRODUCT')) |
              specific_relation IN TYPEOF (prod));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_relationship
      (x[i], 
       relatives + relation.relating_product, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_product_relationship

FUNCTION get_product_definitions 
      ( c_def_instance : product ) : SET OF product_definition;
      
      LOCAL
      pd_set : SET OF product_definition_formation := [];
      pdr_set : SET OF product_definition := [];
      END_LOCAL;
      
 pd_set := bag_to_set (USEDIN (c_def_instance,
  'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
 IF (SIZEOF (pd_set) < 1 ) THEN RETURN (pdr_set);
 END_IF;

 REPEAT i:= 1 to HIINDEX (pd_set);
    pdr_set := pdr_set + bag_to_set (USEDIN (pd_set[i],
    'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
 END_REPEAT;
 RETURN (pdr_set);
END_FUNCTION;

END_SCHEMA; -- product_definition_schema

SCHEMA product_property_definition_schema;
REFERENCE FROM process_property_schema                   -- ISO 10303-49
  (action_property,
   resource_property);
REFERENCE FROM product_definition_schema                 -- ISO 10303-41
  (product_definition,
   product_definition_relationship);
REFERENCE FROM support_resource_schema                   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);
REFERENCE FROM basic_attribute_schema                    -- ISO 10303-41
       (get_id_value,
       id_attribute);

TYPE characterized_definition = SELECT
  (characterized_object,
   characterized_product_definition,
   shape_definition);
END_TYPE; -- characterized_definition

TYPE characterized_product_definition = SELECT
  (product_definition,
   product_definition_relationship);
END_TYPE; -- characterized_product_definition

TYPE derived_property_select = SELECT
  (property_definition,
   action_property,
   resource_property);
END_TYPE; -- derived_property_select

TYPE shape_definition = SELECT
  (product_definition_shape,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE; -- shape_definition

ENTITY characterized_object;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- characterized_object

ENTITY characterized_object_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_object : characterized_object;
  related_object  : characterized_object;
END_ENTITY; -- characterized_object_relationship

ENTITY general_property;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- general_property

ENTITY general_property_association;
  name               : label;
  description        : OPTIONAL text;
  base_definition    : general_property;
  derived_definition : derived_property_select;
 WHERE
  WR1: SIZEOF( USEDIN( derived_definition,
                       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 
                       'GENERAL_PROPERTY_ASSOCIATION.' + 
                       'DERIVED_DEFINITION')) = 1;
  WR2: derived_definition.name = base_definition.name;
END_ENTITY; -- general_property_association

ENTITY general_property_relationship; 
  name              : label;
  description       : OPTIONAL text;
  relating_property : general_property;
  related_property  : general_property;
END_ENTITY; -- general_property_relationship

ENTITY product_definition_shape
  SUBTYPE OF (property_definition);
UNIQUE
  UR1: SELF\property_definition.definition;
WHERE
     WR1: SIZEOF
     (['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION',  'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] *TYPEOF         (SELF\property_definition.definition))>0;
END_ENTITY; -- product_definition_shape

ENTITY property_definition;
  name        : label;
  description : OPTIONAL text;
  definition  : characterized_definition;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- property_definition

ENTITY shape_aspect;
  name                 : label;
  description          : OPTIONAL text;
  of_shape             : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- shape_aspect

ENTITY shape_aspect_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect  : shape_aspect;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- shape_aspect_relationship

FUNCTION acyclic_characterized_object_relationship
  (relation          : characterized_object_relationship;
   relatives         : SET [1:?] OF characterized_object;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF characterized_object_relationship;
  END_LOCAL;
  IF relation.relating_object IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (ca <* bag_to_set 
             (USEDIN (relation.relating_object,
             'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 
             'CHARACTERIZED_OBJECT_RELATIONSHIP.' +
             'RELATED_OBJECT')) |
              specific_relation IN TYPEOF (ca));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_characterized_object_relationship
      (x[i], 
       relatives + relation.relating_object, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_characterized_object_relationship

FUNCTION acyclic_general_property_relationship
  (relation          : general_property_relationship;
   relatives         : SET [1:?] OF general_property;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF general_property_relationship;
  END_LOCAL;
  IF relation.relating_property IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (genp <* bag_to_set 
             (USEDIN (relation.relating_property,
             'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 
             'GENERAL_PROPERTY_RELATIONSHIP.' +
             'RELATED_PROPERTY')) |
              specific_relation IN TYPEOF (genp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_general_property_relationship
      (x[i], 
       relatives + relation.relating_property, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_general_property_relationship

FUNCTION acyclic_shape_aspect_relationship
  (relation          : shape_aspect_relationship;
   relatives         : SET [1:?] OF shape_aspect;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF shape_aspect_relationship;
  END_LOCAL;
  IF relation.relating_shape_aspect IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (sa <* bag_to_set 
             (USEDIN (relation.relating_shape_aspect,
             'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 
             'SHAPE_ASPECT_RELATIONSHIP.' +
             'RELATED_SHAPE_ASPECT')) |
              specific_relation IN TYPEOF (sa));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_shape_aspect_relationship
      (x[i], 
       relatives + relation.relating_shape_aspect, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_shape_aspect_relationship

FUNCTION get_shape_aspects 
      ( c_def_instance : characterized_definition ) : SET OF shape_aspect;
      
      LOCAL
      pd_set : SET OF product_definition_shape := [];
      pdr_set : SET OF shape_aspect := [];
      END_LOCAL;
  pd_set := bag_to_set (QUERY(pd <* USEDIN (c_def_instance,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
      | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF(pd)));
 IF (SIZEOF (pd_set) < 1 ) THEN RETURN (pdr_set);
 END_IF;

 REPEAT i:= 1 to HIINDEX (pd_set);
    pdr_set := pdr_set + bag_to_set (USEDIN (pd_set[i],
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
 END_REPEAT;
 RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA; -- product_property_definition_schema

SCHEMA product_property_representation_schema;
REFERENCE FROM basic_attribute_schema                    -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_name_value,
   name_attribute);
REFERENCE FROM material_property_definition_schema       -- ISO 10303-45
  (property_definition_relationship);
REFERENCE FROM product_definition_schema                 -- ISO 10303-41
  (product_definition,
   product_definition_relationship);
REFERENCE FROM product_property_definition_schema        -- ISO 10303-41
  (characterized_definition,
   general_property,
   product_definition_shape,
   property_definition,
   shape_aspect,
   shape_aspect_relationship);
REFERENCE FROM representation_schema                     -- ISO 10303-43
  (representation,
   representation_item,
   representation_relationship,
   using_representations);
REFERENCE FROM support_resource_schema                   -- ISO 10303-41
  (bag_to_set,
   label,
   text);

TYPE represented_definition = SELECT
  (general_property,
   property_definition,
   property_definition_relationship,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE; -- represented_definition

ENTITY context_dependent_shape_representation;
  representation_relation      : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description                  : text := get_description_value (SELF);
  name                         : label := get_name_value (SELF);
WHERE
  WR1 : 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP'
         IN TYPEOF (SELF.represented_product_relation.definition);
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR3 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- context_dependent_shape_representation

ENTITY item_identified_representation_usage;
  name                : label;
  description         : OPTIONAL text;
  definition          : represented_definition;  
  used_representation : representation;    
  identified_item     : representation_item;
WHERE
  WR1: SELF.used_representation IN 
       using_representations(SELF.identified_item);
END_ENTITY; -- item_identified_representation_usage

ENTITY property_definition_representation;
  definition          : represented_definition;
  used_representation : representation;
DERIVE
  description         : text := get_description_value (SELF);
  name                : label := get_name_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- property_definition_representation

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
       TYPEOF (SELF.definition))
       OR
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN
       TYPEOF (SELF.definition.definition));
  WR2: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN
       TYPEOF(SELF.used_representation);
END_ENTITY; -- shape_definition_representation

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY; -- shape_representation

ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN
       (TYPEOF(SELF\representation_relationship.rep_1) +
        TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY; -- shape_representation_relationship

FUNCTION relatives_of_product_definitions
  (definition_set   : SET OF product_definition;
   relation_subtype : STRING) : SET OF product_definition;
  FUNCTION local_relatives_of_product_definitions
    (definition_set    : SET OF product_definition;
     total_definitions : SET OF product_definition;
     relation_subtype  : STRING) : SET OF product_definition;
  LOCAL
    local_def   : SET OF product_definition := [];
    local_pdr   : SET OF product_definition_relationship := [];
    local_total : SET OF product_definition := [];
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(definition_set);
    local_pdr := local_pdr +
                 bag_to_set(USEDIN
                   (definition_set[i],
                    relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(local_pdr);
    local_def := local_def + local_pdr[i].related_product_definition;
  END_REPEAT;
  IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
    RETURN (local_def);
  ELSE
    local_total := total_definitions + local_def;
    RETURN(local_def +
          (local_relatives_of_product_definitions
          (local_def - total_definitions, local_total, relation_subtype)));
  END_IF;
  END_FUNCTION; -- local_relatives_of_product_definitions
RETURN (local_relatives_of_product_definitions
       (definition_set, definition_set, relation_subtype));
END_FUNCTION; -- relatives_of_product_definitions

FUNCTION relatives_of_shape_representations
   (shape_representation_set : SET OF shape_representation) :
    SET OF shape_representation;
  FUNCTION local_relatives_of_shape_representations
     (shape_representation_set : SET OF shape_representation;
      total_reps    : SET OF shape_representation) : SET OF
      shape_representation;
    LOCAL
      local_shape_rep : SET OF shape_representation := [];
      local_srr       : SET OF shape_representation_relationship := [];
      local_total     : SET OF shape_representation := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(shape_representation_set);
      local_srr := local_srr + QUERY (rr <* bag_to_set
      (USEDIN(shape_representation_set[i],
       'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1'))|
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP'
      IN TYPEOF (rr));
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(local_srr);
      IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+
                  'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i])
      THEN
         local_shape_rep := local_shape_rep + local_srr[i].rep_2;
      END_IF;
    END_REPEAT;
    IF SIZEOF (local_shape_rep - total_reps) = 0 THEN
      RETURN (shape_representation_set);
    ELSE
      local_total := total_reps + local_shape_rep;
      RETURN(local_shape_rep + (local_relatives_of_shape_representations
                               (local_shape_rep - total_reps, local_total)));
    END_IF;
  END_FUNCTION;
  RETURN (local_relatives_of_shape_representations
          (shape_representation_set, shape_representation_set));
END_FUNCTION; -- relatives_of_shape_representations

FUNCTION get_property_definition_representations 
      ( c_def_instance : characterized_definition ) : SET OF property_definition_representation;
      
      LOCAL
      pd_set : SET OF property_definition := [];
      pdr_set : SET OF property_definition_representation := [];
      END_LOCAL;
      
 pd_set := bag_to_set (USEDIN (c_def_instance,
      'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
 IF (SIZEOF (pd_set) < 1 ) THEN RETURN (pdr_set);
 END_IF;

 REPEAT i:= 1 to HIINDEX (pd_set);
    pdr_set := pdr_set + bag_to_set (USEDIN (pd_set[i],
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
 END_REPEAT;
 RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA; -- product_property_representation_schema

SCHEMA management_resources_schema;
REFERENCE FROM action_schema;                      -- ISO 10303-41
REFERENCE FROM application_context_schema          -- ISO 10303-41
  (library_context);
REFERENCE FROM approval_schema;                    -- ISO 10303-41
REFERENCE FROM basic_attribute_schema              -- ISO 10303-41
  (get_role,
  object_role,
  role_association);
REFERENCE FROM certification_schema;               -- ISO 10303-41
REFERENCE FROM contract_schema;                    -- ISO 10303-41
REFERENCE FROM date_time_schema;                   -- ISO 10303-41
REFERENCE FROM document_schema;                    -- ISO 10303-41
REFERENCE FROM effectivity_schema;                 -- ISO 10303-41
REFERENCE FROM external_reference_schema           -- ISO 10303-41
  (external_source);
REFERENCE FROM group_schema;                       -- ISO 10303-41
REFERENCE FROM person_organization_schema;         -- ISO 10303-41
REFERENCE FROM security_classification_schema;     -- ISO 10303-41
REFERENCE FROM support_resource_schema;            -- ISO 10303-41

TYPE attribute_type = SELECT
  (label,
   text);
END_TYPE; -- attribute_type

ENTITY action_assignment
  ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role            : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- action_assignment

ENTITY action_method_assignment
  ABSTRACT SUPERTYPE;
  assigned_action_method : action_method;
  role                   : action_method_role;
END_ENTITY; -- action_method_assignment

ENTITY action_method_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- action_method_role

ENTITY action_request_assignment
  ABSTRACT SUPERTYPE;
  assigned_action_request : versioned_action_request;
DERIVE
  role                    : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- action_request_assignment

ENTITY approval_assignment
  ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role              : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- approval_assignment

ENTITY attribute_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class          : group;
  attribute_name          : label;
  role                    : classification_role;
END_ENTITY; -- attribute_classification_assignment

ENTITY attribute_value_assignment
  ABSTRACT SUPERTYPE;
  attribute_name  : label;
  attribute_value : attribute_type;
  role            : attribute_value_role;
END_ENTITY; -- attribute_value_assignment

ENTITY attribute_value_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- attribute_value_role

ENTITY certification_assignment
  ABSTRACT SUPERTYPE;
  assigned_certification : certification;
DERIVE
  role                   : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- certification_assignment

ENTITY classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class          : group;
  role                    : classification_role;
END_ENTITY; -- classification_assignment

ENTITY classification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- classification_role

ENTITY contract_assignment
  ABSTRACT SUPERTYPE;
  assigned_contract : contract;
DERIVE
  role              : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; --  contract_assignment

ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role                   : date_time_role;
END_ENTITY; -- date_and_time_assignment

ENTITY date_assignment
  ABSTRACT SUPERTYPE;
  assigned_date : date;
  role          : date_role;
END_ENTITY; -- date_assignment

ENTITY document_reference
  ABSTRACT SUPERTYPE;
  assigned_document : document;
  source            : label;
DERIVE
  role              : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- document_reference

ENTITY document_usage_constraint_assignment
  ABSTRACT SUPERTYPE;
  assigned_document_usage : document_usage_constraint;
  role                    : document_usage_role;
END_ENTITY; -- document_usage_constraint_assignment

ENTITY document_usage_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- document_usage_role

ENTITY effectivity_assignment
  ABSTRACT SUPERTYPE;
  assigned_effectivity : effectivity;
DERIVE
  role                 : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- effectivity_assignment

ENTITY effectivity_context_assignment
  ABSTRACT SUPERTYPE;
  assigned_effectivity_assignment : effectivity_assignment;
  role                            : effectivity_context_role;
END_ENTITY; -- effectivity_context_assignment

ENTITY effectivity_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- effectivity_context_role

ENTITY event_occurrence_assignment
  ABSTRACT SUPERTYPE;
  assigned_event_occurrence : event_occurrence;
  role                      : event_occurrence_role;
END_ENTITY; -- event_occurrence_assignment

ENTITY event_occurrence_context_assignment
  ABSTRACT SUPERTYPE;
  assigned_event_occurrence_assignment : event_occurrence_assignment;
  role                                 : event_occurrence_context_role;
END_ENTITY; -- event_occurrence_context_assignment

ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY; -- external_identification_assignment

ENTITY external_referent_assignment
  ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role          : object_role := get_role (SELF);
UNIQUE
  UR1 : assigned_name;
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- external_referent_assignment

ENTITY group_assignment
  ABSTRACT SUPERTYPE;
  assigned_group : group;
DERIVE
  role           : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- group_assignment

ENTITY identification_assignment
  ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role        : identification_role;
END_ENTITY; -- identification_assignment

ENTITY identification_assignment_relationship;
  name                               : label;
  description                        : OPTIONAL text;
  relating_identification_assignment : identification_assignment;
  related_identification_assignment  : identification_assignment;
END_ENTITY; -- identification_assignment_relationship

ENTITY identification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- identification_role

ENTITY library_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (external_referent_assignment);
  frame_of_reference : library_context;
UNIQUE
  UR1: frame_of_reference;
END_ENTITY; -- library_assignment

ENTITY name_assignment
  ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role          : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- name_assignment

ENTITY organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role                  : organization_role;
END_ENTITY; -- organization_assignment

ENTITY organizational_project_assignment
ABSTRACT SUPERTYPE;
  assigned_organizational_project : organizational_project;
  role                            : organizational_project_role;
END_ENTITY; -- organizational_project_assignment

ENTITY organizational_project_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- organizational_project_role

ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role                             : person_and_organization_role;
END_ENTITY; -- person_and_organization_assignment

ENTITY person_assignment
  ABSTRACT SUPERTYPE;
  assigned_person : person;
  role            : person_role;
END_ENTITY; -- person_assignment

ENTITY security_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
DERIVE
  role                             : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- security_classification_assignment

ENTITY time_assignment
  ABSTRACT SUPERTYPE;
  assigned_time : local_time;
  role          : time_role;
END_ENTITY; -- time_assignment

ENTITY time_interval_assignment
  ABSTRACT SUPERTYPE;
  assigned_time_interval : time_interval;
  role                   : time_interval_role;
END_ENTITY; -- time_interval_assignment

FUNCTION acyclic_identification_assignment_relationship
  (relation          : identification_assignment_relationship;
   relatives         : SET [1:?] OF identification_assignment;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF identification_assignment_relationship;
  END_LOCAL;
  IF relation.relating_identification_assignment IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (ia <* bag_to_set 
             (USEDIN (relation.relating_identification_assignment,
             'MANAGEMENT_RESOURCES_SCHEMA.' + 
             'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' +
             'RELATED_IDENTIFICATION_ASSIGNMENT')) |
              specific_relation IN TYPEOF (ia));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_identification_assignment_relationship
      (x[i], 
       relatives + relation.relating_identification_assignment, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_identification_assignment_relationship

END_SCHEMA; -- management_resources_schema

SCHEMA document_schema;
REFERENCE FROM product_definition_schema           -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation);
REFERENCE FROM support_resource_schema             -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE product_or_formation_or_definition = SELECT
  (product,
   product_definition_formation,
   product_definition);
END_TYPE; -- product_or_formation_or_definition

ENTITY document;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  kind                : document_type;
INVERSE
  representation_types : SET[0:?] OF document_representation_type
                          FOR represented_document; 
END_ENTITY; -- document

ENTITY document_product_association;
  name              : label;
  description       : OPTIONAL text;
  relating_document : document;
  related_product   : product_or_formation_or_definition;
END_ENTITY; -- document_product_association

ENTITY document_relationship;
  name                : label;
  description         : OPTIONAL text;
  relating_document   : document;
  related_document    : document;
END_ENTITY; -- document_relationship

ENTITY document_representation_type;
  name                 : label;
  represented_document : document;
END_ENTITY; -- document_representation_type

ENTITY document_type;
  product_data_type : label;
END_ENTITY; -- document_type

ENTITY document_usage_constraint;
  source                : document;
  subject_element       : label;
  subject_element_value : text;
END_ENTITY; -- document_usage_constraint

ENTITY document_with_class
  SUBTYPE OF (document);
  class : identifier;
END_ENTITY; -- document_with_class

FUNCTION acyclic_document_relationship
  (relation          : document_relationship;
   relatives         : SET [1:?] OF document;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF document_relationship;
  END_LOCAL;
  IF relation.relating_document IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (doc <* bag_to_set 
             (USEDIN (relation.relating_document,
             'DOCUMENT_SCHEMA.' + 
             'DOCUMENT_RELATIONSHIP.' +
             'RELATED_DOCUMENT')) |
              specific_relation IN TYPEOF (doc));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_document_relationship
      (x[i], 
       relatives + relation.relating_document, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_document_relationship

END_SCHEMA; -- document_schema

SCHEMA action_schema;
REFERENCE FROM basic_attribute_schema                  -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   get_name_value,
   id_attribute,
   name_attribute);
REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE supported_item = SELECT
  (action_directive,
   action,
   action_method);
END_TYPE; -- supported_item

ENTITY action;
  name          : label;
  description   : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- action

ENTITY action_directive;
  name        : label;
  description : OPTIONAL text;
  analysis    : text;
  comment     : text;
  requests    : SET[1:?] OF versioned_action_request;
END_ENTITY; -- action_directive

ENTITY action_method;
  name        : label;
  description : OPTIONAL text;
  consequence : text;
  purpose     : text;
END_ENTITY; -- action_method

ENTITY action_method_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_method : action_method;
  related_method  : action_method;
END_ENTITY; -- action_method_relationship

ENTITY action_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_action : action;
  related_action  : action;
END_ENTITY; -- action_relationship

ENTITY action_request_solution;
  method      : action_method;
  request     : versioned_action_request;
DERIVE
  description : text := get_description_value (SELF);
  name        : label := get_name_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- action_request_solution

ENTITY action_request_status;
  status           : label;
  assigned_request : versioned_action_request;
END_ENTITY; -- action_request_status

ENTITY action_resource;
  name        : label;
  description : OPTIONAL text;
  usage       : SET [1:?] OF supported_item;
  kind        : action_resource_type;
END_ENTITY; -- action_resource

ENTITY action_resource_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_resource : action_resource;
  related_resource  : action_resource;
END_ENTITY; -- action_resource_relationship

ENTITY action_resource_type;
  name : label;
END_ENTITY; -- action_resource_type

ENTITY action_status;
  status          : label;
  assigned_action : executed_action;
END_ENTITY; -- action_status

ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY; -- directed_action

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY; -- executed_action

ENTITY versioned_action_request;
  id          : identifier;
  version     : label;
  purpose     : text;
  description : OPTIONAL text;
END_ENTITY; -- versioned_action_request

FUNCTION acyclic_action_method_relationship
  (relation          : action_method_relationship;
   relatives         : SET [1:?] OF action_method;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF action_method_relationship;
  END_LOCAL;
  IF relation.relating_method IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (am <* bag_to_set 
             (USEDIN (relation.relating_method,
             'ACTION_SCHEMA.' + 
             'ACTION_METHOD_RELATIONSHIP.' +
             'RELATED_METHOD')) |
              specific_relation IN TYPEOF (am));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_method_relationship
      (x[i], 
       relatives + relation.relating_method, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_action_method_relationship

FUNCTION acyclic_action_relationship
  (relation          : action_relationship;
   relatives         : SET [1:?] OF action;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF action_relationship;
  END_LOCAL;
  IF relation.relating_action IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (actn <* bag_to_set 
             (USEDIN (relation.relating_action,
             'ACTION_SCHEMA.' + 
             'ACTION_RELATIONSHIP.' +
             'RELATED_ACTION')) |
              specific_relation IN TYPEOF (actn));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_relationship
      (x[i], 
       relatives + relation.relating_action, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_action_relationship

FUNCTION acyclic_action_resource_relationship
  (relation          : action_resource_relationship;
   relatives         : SET [1:?] OF action_resource;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF action_resource_relationship;
  END_LOCAL;
  IF relation.relating_resource IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (ar <* bag_to_set 
             (USEDIN (relation.relating_resource,
             'ACTION_SCHEMA.' + 
             'ACTION_RESOURCE_RELATIONSHIP.' +
             'RELATED_RESOURCE')) |
              specific_relation IN TYPEOF (ar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_resource_relationship
      (x[i], 
       relatives + relation.relating_resource, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_action_resource_relationship

END_SCHEMA; -- action_schema

SCHEMA certification_schema;
REFERENCE FROM support_resource_schema
  (label,
   text);

ENTITY certification;
  name    : label;
  purpose : text;
  kind    : certification_type;
END_ENTITY; -- certification

ENTITY certification_type;
  description : label;
END_ENTITY; -- certification_type

END_SCHEMA; -- certification_schema

SCHEMA approval_schema;
REFERENCE FROM basic_attribute_schema                -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_role,
   object_role,
   role_association);
REFERENCE FROM date_time_schema                      -- ISO 10303-41
  (date_time_select);
REFERENCE FROM person_organization_schema            -- ISO 10303-41
  (person_organization_select);
REFERENCE FROM support_resource_schema               -- ISO 10303-41
  (bag_to_set,
   label,
   text);

ENTITY approval;
  status : approval_status;
  level  : label;
END_ENTITY; -- approval

ENTITY approval_date_time;
  date_time      : date_time_select;
  dated_approval : approval;
DERIVE
  role           : object_role := get_role (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY; -- approval_date_time

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role                : approval_role;
END_ENTITY; -- approval_person_organization

ENTITY approval_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_approval : approval;
  related_approval  : approval;
END_ENTITY; -- approval_relationship

ENTITY approval_role;
  role        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- approval_role

ENTITY approval_status;
  name : label;
END_ENTITY; -- approval_status

FUNCTION acyclic_approval_relationship
  (relation          : approval_relationship;
   relatives         : SET [1:?] OF approval;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF approval_relationship;
  END_LOCAL;
  IF relation.relating_approval IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (app <* bag_to_set 
             (USEDIN (relation.relating_approval,
             'APPROVAL_SCHEMA.' + 
             'APPROVAL_RELATIONSHIP.' +
             'RELATED_APPROVAL')) |
              specific_relation IN TYPEOF (app));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_approval_relationship
      (x[i], 
       relatives + relation.relating_approval, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_approval_relationship

END_SCHEMA; -- approval_schema

SCHEMA contract_schema;
REFERENCE FROM support_resource_schema              -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

ENTITY contract;
  name    : label;
  purpose : text;
  kind    : contract_type;
END_ENTITY; -- contract

ENTITY contract_relationship;
  id                : identifier;
  name              : label;
  description       : OPTIONAL text;
  relating_contract : contract;
  related_contract  : contract;
END_ENTITY; -- contract_relationship

ENTITY contract_type;
  description : label;
END_ENTITY; -- contract_type

FUNCTION acyclic_contract_relationship
  (relation          : contract_relationship;
   relatives         : SET [1:?] OF contract;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF contract_relationship;
  END_LOCAL;
  IF relation.relating_contract IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (cont <* bag_to_set 
             (USEDIN (relation.relating_contract,
             'CONTRACT_SCHEMA.' + 
             'CONTRACT_RELATIONSHIP.' +
             'RELATED_CONTRACT')) |
              specific_relation IN TYPEOF (cont));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_contract_relationship
      (x[i], 
       relatives + relation.relating_contract, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_contract_relationship

END_SCHEMA; -- contract_schema

SCHEMA security_classification_schema;
REFERENCE FROM support_resource_schema
    (label,
     text);

ENTITY security_classification;
  name           : label;
  purpose        : text;
  security_level : security_classification_level;
END_ENTITY; -- security_classification

ENTITY security_classification_level;
  name : label;
END_ENTITY; -- security_classification_level

END_SCHEMA; -- security_classification_schema

SCHEMA person_organization_schema;
REFERENCE FROM basic_attribute_schema                  -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   get_name_value,
   get_role,
   id_attribute,
   name_attribute,
   object_role,
   role_association);
REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE person_organization_select = SELECT
  (person,
   organization,
   person_and_organization);
END_TYPE; -- person_organization_select

ENTITY address;
  internal_location       : OPTIONAL label;
  street_number           : OPTIONAL label;
  street                  : OPTIONAL label;
  postal_box              : OPTIONAL label;
  town                    : OPTIONAL label;
  region                  : OPTIONAL label;
  postal_code             : OPTIONAL label;
  country                 : OPTIONAL label;
  facsimile_number        : OPTIONAL label;
  telephone_number        : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number            : OPTIONAL label;
DERIVE
  name          : label := get_name_value (SELF);
  url           : identifier := get_id_value (SELF);
WHERE
  WR1: EXISTS(internal_location)       OR
       EXISTS(street_number)           OR
       EXISTS(street)                  OR
       EXISTS(postal_box)              OR
       EXISTS(town)                    OR
       EXISTS(region)                  OR
       EXISTS(postal_code)             OR
       EXISTS(country)                 OR
       EXISTS(facsimile_number)        OR
       EXISTS(telephone_number)        OR
       EXISTS(electronic_mail_address) OR
       EXISTS(telex_number);
END_ENTITY; -- address

ENTITY organization;
  id          : OPTIONAL identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- organization

ENTITY organization_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_organization : organization;
  related_organization  : organization;
END_ENTITY; -- organization_relationship

ENTITY organization_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- organization_role

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET [1:?] OF organization;
  description   : OPTIONAL text;
END_ENTITY; -- organizational_address

ENTITY organizational_project;
  name                      : label;
  description               : OPTIONAL text;
  responsible_organizations : SET[1:?] OF organization;
DERIVE
  id                        : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- organizational_project

ENTITY organizational_project_relationship;
  name                            : label;
  description                     : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project  : organizational_project;
END_ENTITY; -- organizational_project_relationship

ENTITY person;
  id            : identifier;
  last_name     : OPTIONAL label;
  first_name    : OPTIONAL label;
  middle_names  : OPTIONAL LIST [1:?] OF label;
  prefix_titles : OPTIONAL LIST [1:?] OF label;
  suffix_titles : OPTIONAL LIST [1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY; -- person

ENTITY person_and_organization;
  the_person       : person;
  the_organization : organization;
DERIVE
  name             : label := get_name_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- person_and_organization

ENTITY person_and_organization_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- person_and_organization_role

ENTITY person_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- person_role

ENTITY personal_address
  SUBTYPE OF (address);
  people      : SET [1:?] OF person;
  description : OPTIONAL text;
END_ENTITY; -- personal_address

FUNCTION acyclic_organization_relationship
  (relation          : organization_relationship;
   relatives         : SET [1:?] OF organization;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF organization_relationship;
  END_LOCAL;
  IF relation.relating_organization IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY (org <* bag_to_set
             (USEDIN (relation.relating_organization,
             'PERSON_ORGANIZATION_SCHEMA.' +
             'ORGANIZATION_RELATIONSHIP.' +
             'RELATED_ORGANIZATION')) |
              specific_relation IN TYPEOF (org));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_organization_relationship
      (x[i], 
       relatives + relation.relating_organization, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_organization_relationship

FUNCTION acyclic_organizational_project_relationship
  (relation          : organizational_project_relationship;
   relatives         : SET [1:?] OF organizational_project;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF organizational_project_relationship;
  END_LOCAL;
  IF relation.relating_organizational_project IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (op <* bag_to_set 
             (USEDIN (relation.relating_organizational_project,
             'PERSON_ORGANIZATION_SCHEMA.' + 
             'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' +
             'RELATED_ORGANIZATIONAL_PROJECT')) |
              specific_relation IN TYPEOF (op));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_organizational_project_relationship
      (x[i], 
       relatives + relation.relating_organizational_project, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_organizational_project_relationship

END_SCHEMA; -- person_organization_schema

SCHEMA date_time_schema;
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
  (description_attribute,
   get_description_value);
  
REFERENCE FROM measure_schema                   -- ISO 10303-41
  (time_measure_with_unit);
REFERENCE FROM support_resource_schema          -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

TYPE ahead_or_behind = ENUMERATION OF
  (ahead,
   exact,
   behind);
END_TYPE; -- ahead_or_behind

TYPE date_time_or_event_occurrence = SELECT 
  (date_time_select,
   event_occurrence);
END_TYPE; -- date_time_or_event_occurrence

TYPE date_time_select = SELECT
  (date,
   local_time,
   date_and_time);
END_TYPE; -- date_time_select

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE; -- day_in_month_number

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 7 };
END_TYPE; -- day_in_week_number

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE; -- day_in_year_number

TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE; -- hour_in_day

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE; -- minute_in_hour 

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE; -- month_in_year_number

TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF <= 60.0 };
END_TYPE; -- second_in_minute 

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 53 };
END_TYPE; -- week_in_year_number

TYPE year_number = INTEGER;
END_TYPE; -- year_number

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component   : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY; -- calendar_date

ENTITY coordinated_universal_time_offset;
hour_offset : INTEGER;
minute_offset : OPTIONAL INTEGER;
sense : ahead_or_behind; 
DERIVE 
actual_minute_offset: INTEGER := NVL(minute_offset,0);
WHERE
WR1: { 0 <= hour_offset < 24 };
WR2: { 0 <= actual_minute_offset <= 59 };
WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY; -- coordinated_universal_time_offset


ENTITY date
  SUPERTYPE OF (ONEOF (calendar_date,
                       ordinal_date,
                       week_of_year_and_day_date));
  year_component : year_number;
END_ENTITY; -- date

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY; -- date_and_time

ENTITY date_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- date_role

ENTITY date_time_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- date_time_role

ENTITY event_occurrence;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- event_occurrence

ENTITY event_occurrence_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- event_occurrence_context_role

ENTITY event_occurrence_relationship;
  name           : label;
  description    : OPTIONAL text;
  relating_event : event_occurrence;
  related_event  : event_occurrence;
END_ENTITY; -- event_occurrence_relationship

ENTITY event_occurrence_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- event_occurrence_role

ENTITY local_time;
  hour_component   : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone             : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY; -- local_time

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 })
       OR
       (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
END_ENTITY; -- ordinal_date

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset     : time_measure_with_unit;
END_ENTITY; -- relative_event_occurrence

ENTITY time_interval;
  id              : identifier;
  name            : label;
  description     : OPTIONAL text;
END_ENTITY; -- time_interval

ENTITY time_interval_relationship;
  name                   : label;
  description            : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval  : time_interval;
END_ENTITY; -- time_interval_relationship

ENTITY time_interval_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- time_interval_role

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound   : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration        : OPTIONAL time_measure_with_unit;
WHERE
  WR1: NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  WR2: EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY; -- time_interval_with_bounds

ENTITY time_role;
  name        : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- time_role

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component  : OPTIONAL day_in_week_number;
END_ENTITY; -- week_of_year_and_day_date

FUNCTION acyclic_event_occurrence_relationship
  (relation          : event_occurrence_relationship;
   relatives         : SET [1:?] OF event_occurrence;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF event_occurrence_relationship;
  END_LOCAL;
  IF relation.relating_event IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (evnt <* bag_to_set 
             (USEDIN (relation.relating_event,
             'DATE_TIME_SCHEMA.' + 
             'EVENT_OCCURRENCE_RELATIONSHIP.' +
             'RELATED_EVENT')) |
              specific_relation IN TYPEOF (evnt));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_event_occurrence_relationship
      (x[i], 
       relatives + relation.relating_event, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_event_occurrence_relationship

FUNCTION acyclic_time_interval_relationship
  (relation          : time_interval_relationship;
   relatives         : SET [1:?] OF time_interval;
   specific_relation : STRING) : BOOLEAN;
  LOCAL    x                : SET OF time_interval_relationship;
  END_LOCAL;
  IF relation.relating_time_interval IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (ti <* bag_to_set 
             (USEDIN (relation.relating_time_interval,
             'DATE_TIME_SCHEMA.' + 
             'TIME_INTERVAL_RELATIONSHIP.' +
             'RELATED_TIME_INTERVAL')) |
              specific_relation IN TYPEOF (ti));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_time_interval_relationship
      (x[i], 
       relatives + relation.relating_time_interval, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_time_interval_relationship

FUNCTION leap_year (year : year_number) : BOOLEAN;
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR
       ((year MOD 400) = 0)) THEN
    RETURN(TRUE);
  ELSE
    RETURN(FALSE);
  END_IF;
END_FUNCTION; -- leap_year

FUNCTION valid_calendar_date (date : calendar_date) : LOGICAL;
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
       RETURN (FALSE);
END_FUNCTION; -- valid_calendar_date

FUNCTION valid_time (time: local_time) : BOOLEAN;
  IF EXISTS (time.second_component) THEN
    RETURN (EXISTS (time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION; -- valid_time

END_SCHEMA; -- date_time_schema

SCHEMA group_schema;
REFERENCE FROM support_resource_schema           -- ISO 10303-41
    (label,
     bag_to_set,
     identifier,
     text);
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
    (get_id_value,
     id_attribute);

ENTITY group;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id            : identifier := get_id_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY; -- group

ENTITY group_relationship;
  name           : label;
  description    : OPTIONAL text;
  relating_group : group;
  related_group  : group;
END_ENTITY; -- group_relationship

FUNCTION acyclic_group_relationship
  (relation          : group_relationship;
   relatives         : SET [1:?] OF group;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF group_relationship;
  END_LOCAL;
  IF relation.relating_group IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (grp <* bag_to_set 
             (USEDIN (relation.relating_group,
             'GROUP_SCHEMA.' + 
             'GROUP_RELATIONSHIP.' +
             'RELATED_GROUP')) |
              specific_relation IN TYPEOF (grp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_group_relationship
      (x[i], 
       relatives + relation.relating_group, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_group_relationship

END_SCHEMA; -- group_schema

SCHEMA effectivity_schema;
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_name_value,
   name_attribute);
REFERENCE FROM date_time_schema                 -- ISO 10303-41
  (date_time_or_event_occurrence,
   time_interval);
REFERENCE FROM measure_schema                   -- ISO 10303-41
  (measure_with_unit);
                                            REFERENCE FROM support_resource_schema      -- ISO 10303-41
 (bag_to_set,
  identifier,
  label,
  text);

ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_end_date   : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY; -- dated_effectivity

ENTITY effectivity
  SUPERTYPE OF (ONEOF (serial_numbered_effectivity,
                       dated_effectivity,
                       lot_effectivity,
                       time_interval_based_effectivity));
  id          : identifier;
DERIVE
  name        : label := get_name_value (SELF);
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- effectivity

ENTITY effectivity_relationship;
  name                 : label;
  description          : OPTIONAL text;
  related_effectivity  : effectivity;
  relating_effectivity : effectivity;
END_ENTITY; -- effectivity_relationship

ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id    : identifier;
  effectivity_lot_size  : measure_with_unit;
END_ENTITY; -- lot_effectivity

ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id :  identifier;
  effectivity_end_id   :  OPTIONAL identifier;
END_ENTITY; -- serial_numbered_effectivity

ENTITY time_interval_based_effectivity
  SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY; -- time_interval_based_effectivity

FUNCTION acyclic_effectivity_relationship
  (relation          : effectivity_relationship;
   relatives         : SET [1:?] OF effectivity;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF effectivity_relationship;
  END_LOCAL;
  IF relation.relating_effectivity IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (eff <* bag_to_set 
             (USEDIN (relation.relating_effectivity,
             'EFFECTIVITY_SCHEMA.' + 
             'EFFECTIVITY_RELATIONSHIP.' +
             'RELATED_EFFECTIVITY')) |
              specific_relation IN TYPEOF (eff));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_effectivity_relationship
      (x[i], 
       relatives + relation.relating_effectivity, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_effectivity_relationship

END_SCHEMA; -- effectivity_schema

SCHEMA external_reference_schema;
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
  (description_attribute,
   get_description_value);
REFERENCE FROM support_resource_schema          -- ISO 10303-41
  (label,
   text,
   identifier,
   bag_to_set);

TYPE message = STRING;
END_TYPE; -- message

TYPE source_item = SELECT 
  (identifier, 
   message);
END_TYPE; -- source_item

ENTITY external_source;
  source_id   : source_item;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY; -- external_source

ENTITY external_source_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_source : external_source;
  related_source  : external_source;
END_ENTITY; -- external_source_relationship

ENTITY externally_defined_item;
  item_id : source_item;
  source  : external_source;
END_ENTITY; -- externally_defined_item

ENTITY externally_defined_item_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_item   : externally_defined_item;
  related_item    : externally_defined_item;
END_ENTITY; -- externally_defined_item_relationship

ENTITY pre_defined_item;
  name : label;
END_ENTITY; -- pre_defined_item

FUNCTION acyclic_external_source_relationship
  (relation          : external_source_relationship;
   relatives         : SET [1:?] OF external_source;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF external_source_relationship;
  END_LOCAL;
  IF relation.relating_source IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (es <* bag_to_set 
             (USEDIN (relation.relating_source,
             'EXTERNAL_REFERENCE_SCHEMA.' + 
             'EXTERNAL_SOURCE_RELATIONSHIP.' +
             'RELATED_SOURCE')) |
              specific_relation IN TYPEOF (es));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_external_source_relationship
      (x[i], 
       relatives + relation.relating_source, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_external_source_relationship

FUNCTION acyclic_externally_defined_item_relationship
  (relation          : externally_defined_item_relationship;
   relatives         : SET [1:?] OF externally_defined_item;
   specific_relation : STRING) : BOOLEAN;
  LOCAL
    x                : SET OF externally_defined_item_relationship;
  END_LOCAL;
  IF relation.relating_item IN relatives THEN 
    RETURN (FALSE);
  END_IF;
  x := QUERY (edi <* bag_to_set 
             (USEDIN (relation.relating_item,
             'EXTERNAL_REFERENCE_SCHEMA.' + 
             'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' +
             'RELATED_ITEM')) |
              specific_relation IN TYPEOF (edi));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_externally_defined_item_relationship
      (x[i], 
       relatives + relation.relating_item, 
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION; -- acyclic_externally_defined_item_relationship

END_SCHEMA; -- external_reference_schema

SCHEMA support_resource_schema;

TYPE identifier = STRING;
END_TYPE; -- identifier

TYPE label = STRING;
END_TYPE; -- label

TYPE text = STRING;
END_TYPE; -- text

FUNCTION bag_to_set 
  (the_bag : BAG OF GENERIC : intype) : SET OF GENERIC : intype;
  LOCAL
    the_set: SET OF GENERIC : intype := [];
  END_LOCAL;
  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 to HIINDEX (the_bag);
      the_set := the_set + the_bag [i];
    END_REPEAT;
  END_IF;
  RETURN (the_set);
END_FUNCTION; -- bag_to_set

FUNCTION  type_check_function 
      ( the_type : GENERIC; 
        sub_names: SET OF STRING;
        criterion: INTEGER ): LOGICAL;

--first, check the correctness of function arguments
IF (( NOT EXISTS ( the_type ) ) OR (NOT ({0<= criterion <=3})) OR
(SIZEOF ( sub_names ) = 0 ) ) THEN RETURN (UNKNOWN);
ELSE
  CASE criterion OF
       0: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) > 0);
       1: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 0);
       2: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 1);
       3: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) <= 1);
  END_CASE;
END_IF;
END_FUNCTION;

END_SCHEMA; -- support_resource_schema

SCHEMA measure_schema;
REFERENCE FROM basic_attribute_schema           -- ISO 10303-41
  (name_attribute,
   get_name_value);
REFERENCE FROM representation_schema            -- ISO 10303-43
  (representation_context);
REFERENCE FROM support_resource_schema;         -- ISO 10303-41

TYPE amount_of_substance_measure = REAL;
END_TYPE; -- amount_of_substance_measure

TYPE area_measure = REAL;
END_TYPE; -- area_measure

TYPE celsius_temperature_measure = REAL;
END_TYPE; -- celsius_temperature_measure

TYPE context_dependent_measure = REAL;
END_TYPE; -- context_dependent_measure

TYPE count_measure = NUMBER;
END_TYPE; -- count_measure

TYPE descriptive_measure= STRING;
END_TYPE; -- descriptive_measure

TYPE electric_current_measure= REAL;
END_TYPE; -- electric_current_measure

TYPE length_measure = REAL;
END_TYPE; -- length_measure

TYPE luminous_intensity_measure = REAL;
END_TYPE; -- luminous_intensity_measure

TYPE mass_measure = REAL;
END_TYPE; -- mass_measure

TYPE measure_value = SELECT
  (length_measure,
   mass_measure,
   time_measure,
   electric_current_measure,
   thermodynamic_temperature_measure,
   celsius_temperature_measure,
   amount_of_substance_measure,
   luminous_intensity_measure,
   plane_angle_measure,
   solid_angle_measure,
   area_measure,
   volume_measure,
   ratio_measure,
   parameter_value,
   numeric_measure,
   context_dependent_measure,
   descriptive_measure,
   positive_length_measure,
   positive_plane_angle_measure,
   positive_ratio_measure,
   count_measure);
END_TYPE; -- measure_value

TYPE numeric_measure = NUMBER;
END_TYPE; -- numeric_measure

TYPE parameter_value = REAL;
END_TYPE; -- parameter_value

TYPE plane_angle_measure = REAL;
END_TYPE; -- plane_angle_measure

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; -- positive_length_measure

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; -- positive_plane_angle_measure

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; -- positive_ratio_measure

TYPE ratio_measure = REAL;
END_TYPE; -- ratio_measure

TYPE si_prefix = ENUMERATION OF
  (exa,
   peta,
   tera,
   giga,
   mega,
   kilo,
   hecto,
   deca,
   deci,
   centi,
   milli,
   micro,
   nano,
   pico,
   femto,
   atto);
END_TYPE; -- si_prefix

TYPE si_unit_name = ENUMERATION OF
  (metre,
   gram,
   second,
   ampere,
   kelvin,
   mole,
   candela,
   radian,
   steradian,
   hertz,
   newton,
   pascal,
   joule,
   watt,
   coulomb,
   volt,
   farad,
   ohm,
   siemens,
   weber,
   tesla,
   henry,
   degree_Celsius,
   lumen,
   lux,
   becquerel,
   gray,
   sievert);
END_TYPE; -- si_unit_name

TYPE solid_angle_measure = REAL;
END_TYPE; -- solid_angle_measure 

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE; -- thermodynamic_temperature_measure

TYPE time_measure = REAL;
END_TYPE; -- time_measure

TYPE unit = SELECT
  (named_unit,
   derived_unit);
END_TYPE; -- unit

TYPE volume_measure = REAL;
END_TYPE; -- volume_measure

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- amount_of_substance_measure_with_unit

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- amount_of_substance_unit

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- area_measure_with_unit

ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 2.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- area_unit

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- celsius_temperature_measure_with_unit

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY; -- context_dependent_unit

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name              : label;
  conversion_factor : measure_with_unit;
END_ENTITY; -- conversion_based_unit

ENTITY derived_unit;
  elements : SET [1:?] OF derived_unit_element;
DERIVE
  name     : label := get_name_value (SELF);
WHERE
  WR1 : (SIZEOF (elements) > 1) OR
        ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY; -- derived_unit

ENTITY derived_unit_element;
  unit     : named_unit;
  exponent : REAL;
END_ENTITY; -- derived_unit_element

ENTITY dimensional_exponents;
  length_exponent                    : REAL;
  mass_exponent                      : REAL;
  time_exponent                      : REAL;
  electric_current_exponent          : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent       : REAL;
  luminous_intensity_exponent        : REAL;
END_ENTITY; -- dimensional_exponents

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF 
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- electric_current_measure_with_unit

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- electric_current_unit

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET [1:?] OF unit;
END_ENTITY; -- global_unit_assigned_context

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF 
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- length_measure_with_unit

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 1.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- length_unit

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- luminous_intensity_measure_with_unit

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY; -- luminous_intensity_unit

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF 
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- mass_measure_with_unit

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 1.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- mass_unit

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (length_measure_with_unit,
                      mass_measure_with_unit,
                      time_measure_with_unit,
                      electric_current_measure_with_unit,
                      thermodynamic_temperature_measure_with_unit,
                      celsius_temperature_measure_with_unit,
                      amount_of_substance_measure_with_unit,
                      luminous_intensity_measure_with_unit,
                      plane_angle_measure_with_unit,
                      solid_angle_measure_with_unit,
                      area_measure_with_unit,
                      volume_measure_with_unit,
                      ratio_measure_with_unit ));
  value_component : measure_value;
  unit_component  : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY; -- measure_with_unit

ENTITY named_unit
  SUPERTYPE OF (ONEOF (si_unit,
                       conversion_based_unit,
                       context_dependent_unit)
               ANDOR
               ONEOF  (length_unit,
                       mass_unit,
                       time_unit,
                       electric_current_unit,
                       thermodynamic_temperature_unit,
                       amount_of_substance_unit,
                       luminous_intensity_unit,
                       plane_angle_unit,
                       solid_angle_unit,
                       area_unit,
                       volume_unit,
                       ratio_unit ));
  dimensions : dimensional_exponents;
END_ENTITY; -- named_unit

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- plane_angle_measure_with_unit

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- plane_angle_unit

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF
           (SELF\measure_with_unit.unit_component);
END_ENTITY; -- ratio_measure_with_unit

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- ratio_unit

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix     : OPTIONAL si_prefix;
  name       : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents
                            := dimensions_for_si_unit (name);
END_ENTITY; -- si_unit

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF 
          (SELF\measure_with_unit.unit_component);
END_ENTITY; -- solid_angle_measure_with_unit

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- solid_angle_unit

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF 
         (SELF\measure_with_unit.unit_component);
END_ENTITY; -- thermodynamic_temperature_measure_with_unit

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- thermodynamic_temperature_unit

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1:'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF
        (SELF\measure_with_unit.unit_component);
END_ENTITY; -- time_measure_with_unit

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 0.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 1.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
     (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- time_unit

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF
           (SELF\measure_with_unit.unit_component);
END_ENTITY; -- volume_measure_with_unit

ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1:(SELF\named_unit.dimensions.length_exponent = 3.0) AND
   (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
   (SELF\named_unit.dimensions.time_exponent = 0.0) AND
   (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
   (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
   (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- volume_unit

FUNCTION derive_dimensional_exponents (x : unit) : dimensional_exponents;
  LOCAL
    result : dimensional_exponents :=
            dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;
  IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN -- x is a derived unit
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent                   :=
        result.length_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent                     :=
        result.mass_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.mass_exponent);
     result.time_exponent :=
        result.time_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent         :=
        result.electric_current_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent :=
        result.thermodynamic_temperature_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent       :=
        result.amount_of_substance_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent        :=
        result.luminous_intensity_exponent +
        (x.elements[i].exponent *
         x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE -- x is a unitless or a named unit
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION; -- derive_dimensional_exponents 

FUNCTION dimensions_for_si_unit (n : si_unit_name) : dimensional_exponents;
  CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;
END_FUNCTION; -- dimensions_for_si_unit

FUNCTION valid_units ( m : measure_with_unit ) : BOOLEAN ;
  IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION; -- valid_units

END_SCHEMA; -- measure_schema

SCHEMA basic_attribute_schema;
REFERENCE FROM action_schema                         -- ISO 10303-41
  (action,
   action_request_solution);
REFERENCE FROM application_context_schema            -- ISO 10303-41
  (application_context);
REFERENCE FROM approval_schema                       -- ISO 10303-41
  (approval_date_time,
   approval_role);
REFERENCE FROM configuration_management_schema       -- ISO 10303-44
  (configuration_design);
REFERENCE FROM date_time_schema                      -- ISO 10303-41
  (date_role,
   date_time_role,
   time_role);
REFERENCE FROM effectivity_schema                    -- ISO 10303-41
  (effectivity);
REFERENCE FROM external_reference_schema             -- ISO 10303-41
  (external_source);
REFERENCE FROM management_resources_schema           -- ISO 10303-41
  (action_assignment,
   action_request_assignment,
   approval_assignment,
   certification_assignment,
   contract_assignment,
   document_reference,
   effectivity_assignment,
   external_referent_assignment,
   group_assignment,
   name_assignment,
   security_classification_assignment);
REFERENCE FROM measure_schema                         -- ISO 10303-41
  (derived_unit);
REFERENCE FROM person_organization_schema             -- ISO 10303-41
  (address,
   person_and_organization_role,
   person_and_organization,
   person_role,
   organization_role,
   organizational_project);
REFERENCE FROM product_definition_schema              -- ISO 10303-41
  (product_category,
   product_definition,
   product_definition_substitute);
REFERENCE FROM product_property_definition_schema       -- ISO 10303-41
  (property_definition,
   shape_aspect,
   shape_aspect_relationship);
REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (context_dependent_shape_representation,
   property_definition_representation);
REFERENCE FROM group_schema                             -- ISO 10303-41
  (group);
REFERENCE FROM representation_schema                    -- ISO 10303-43
  (representation);
REFERENCE FROM support_resource_schema                  -- ISO 10303-41
  (identifier,
   label,
   text);

TYPE description_attribute_select = SELECT
  (action_request_solution,
   application_context,
   approval_role,
   configuration_design,
   date_role,
   date_time_role,
   context_dependent_shape_representation,
   effectivity,
   external_source,
   organization_role,
   person_and_organization_role,
   person_and_organization,
   person_role,
   property_definition_representation,
   representation,
   time_role);
END_TYPE; -- description_attribute_select

TYPE id_attribute_select = SELECT
  (action,
   address,
   product_category,
   property_definition,
   shape_aspect,
   shape_aspect_relationship,
   application_context,
   group,
   organizational_project,
   representation);
END_TYPE; -- id_attribute_select

TYPE name_attribute_select = SELECT
  (action_request_solution,
   address,
   configuration_design,
   context_dependent_shape_representation,
   derived_unit,
   effectivity,
   person_and_organization,
   product_definition,
   product_definition_substitute,
   property_definition_representation);
END_TYPE; -- name_attribute_select

TYPE role_select = SELECT
  (action_assignment,
   action_request_assignment,
   approval_assignment,
   approval_date_time,
   certification_assignment,
   contract_assignment,
   document_reference,
   effectivity_assignment,
   external_referent_assignment,
   group_assignment,
   name_assignment,
   security_classification_assignment);
END_TYPE; -- role_select

ENTITY description_attribute;
  attribute_value : text;
  described_item  : description_attribute_select;
END_ENTITY; -- description_attribute

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY; -- id_attribute

ENTITY name_attribute;
  attribute_value : label;
  named_item      : name_attribute_select;
END_ENTITY; -- name_attribute

ENTITY object_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- object_role

ENTITY role_association;
  role           : object_role;
  item_with_role : role_select;
END_ENTITY; -- role_association

FUNCTION get_description_value 
  (obj : description_attribute_select) : text;
  LOCAL
    description_bag : BAG OF description_attribute := 
                      (USEDIN (obj,
                      'BASIC_ATTRIBUTE_SCHEMA.' +
                      'DESCRIPTION_ATTRIBUTE.' +
                      'DESCRIBED_ITEM'));
  END_LOCAL;
  IF SIZEOF (description_bag) = 1 
    THEN RETURN (description_bag[1].attribute_value);
    ELSE RETURN (?);
  END_IF;
END_FUNCTION; -- get_description_value

FUNCTION get_id_value 
  (obj : id_attribute_select) : identifier;
  LOCAL
    id_bag : BAG OF id_attribute :=
             (USEDIN (obj,
             'BASIC_ATTRIBUTE_SCHEMA.' +
             'ID_ATTRIBUTE.' +
             'IDENTIFIED_ITEM'));
  END_LOCAL;
  IF SIZEOF (id_bag) = 1
    THEN RETURN (id_bag[1].attribute_value);
    ELSE RETURN (?);
  END_IF;
END_FUNCTION; -- get_id_value

FUNCTION get_name_value 
  (obj : name_attribute_select) : label;
  LOCAL
    name_bag : BAG OF name_attribute :=
               (USEDIN (obj,
               'BASIC_ATTRIBUTE_SCHEMA.' +
               'NAME_ATTRIBUTE.' +
               'NAMED_ITEM'));
  END_LOCAL;
  IF SIZEOF (name_bag) = 1
    THEN RETURN (name_bag[1].attribute_value);
    ELSE RETURN (?);
  END_IF;
END_FUNCTION; -- get_name_value

FUNCTION get_role
  (obj : role_select) : object_role;
  LOCAL
  role_bag : BAG OF role_association:=
             (USEDIN (obj,
             'BASIC_ATTRIBUTE_SCHEMA.' +
             'ROLE_ASSOCIATION.' +
             'ITEM_WITH_ROLE'));
  END_LOCAL;
  IF SIZEOF (role_bag) = 1
    THEN RETURN (role_bag[1].role);
    ELSE RETURN (?);
  END_IF;
END_FUNCTION; -- get_role

END_SCHEMA; -- basic_attribute_schema






